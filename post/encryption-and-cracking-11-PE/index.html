<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon1.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"directoree.github.io","root":"/","scheme":"Mist","version":"8.0.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="ʕ •ᴥ•ʔ  ɔ:">
<meta property="og:type" content="article">
<meta property="og:title" content="加密与解密（第四版）PE文件格式">
<meta property="og:url" content="https://directoree.github.io/post/encryption-and-cracking-11-PE/index.html">
<meta property="og:site_name" content="Catecat">
<meta property="og:description" content="ʕ •ᴥ•ʔ  ɔ:">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/04/06/gW6n8yKmMTUDHlY.png">
<meta property="og:image" content="https://i.loli.net/2021/04/06/yx76vb8uKQsDJAz.png">
<meta property="og:image" content="https://i.loli.net/2021/04/06/a7YSPuRwJN2mCXb.jpg">
<meta property="og:image" content="https://i.loli.net/2021/04/12/foc72VEZpnivKHF.png">
<meta property="og:image" content="https://i.loli.net/2021/04/12/XG9BlAzqIMJDpod.png">
<meta property="og:image" content="https://i.loli.net/2021/04/12/6OhAoRtgVeG9FsC.png">
<meta property="og:image" content="https://i.loli.net/2021/04/13/pN1FTJ4kthGwDU5.png">
<meta property="og:image" content="https://i.loli.net/2021/04/13/NilGw4fPn36g5c8.png">
<meta property="og:image" content="https://i.loli.net/2021/04/13/a1SbHkumvYpWh9X.png">
<meta property="og:image" content="https://i.loli.net/2021/04/13/DkMS2tlqpchIG1Q.png">
<meta property="og:image" content="https://i.loli.net/2021/04/13/NilGw4fPn36g5c8.png">
<meta property="og:image" content="https://i.loli.net/2021/04/16/PBC5TmNopiJRMLj.png">
<meta property="og:image" content="https://i.loli.net/2021/04/26/XawfrVtlxNS6yHc.png">
<meta property="og:image" content="https://i.loli.net/2021/04/20/64KCR3xsa7EQqmw.png">
<meta property="og:image" content="https://i.loli.net/2021/04/20/jPIEsbFz2WhD4ky.png">
<meta property="og:image" content="https://i.loli.net/2021/04/23/LR1jrzuNdtBmDMK.png">
<meta property="og:image" content="https://i.loli.net/2021/04/23/kpdzR81nqivoBxP.png">
<meta property="og:image" content="https://i.loli.net/2021/04/23/TXbimPz963nxUrZ.png">
<meta property="og:image" content="https://i.loli.net/2021/04/23/2TvYDpwzFX8ch1W.png">
<meta property="og:image" content="https://i.loli.net/2021/04/26/NlXRc4OMIexfVKs.png">
<meta property="og:image" content="https://i.loli.net/2021/04/26/OFsglcfM93YnLuP.png">
<meta property="og:image" content="https://i.loli.net/2021/04/27/Wsy4h6O1jFCKxJG.png">
<meta property="og:image" content="https://i.loli.net/2021/04/27/l2ftZeTVI5PJCnx.png">
<meta property="og:image" content="https://i.loli.net/2021/04/27/pRuyg5NXlJKFfwI.png">
<meta property="og:image" content="https://i.loli.net/2021/04/27/kcjFHzt3IlnLwY5.png">
<meta property="article:published_time" content="2021-04-06T01:38:19.000Z">
<meta property="article:modified_time" content="2021-09-20T04:29:44.204Z">
<meta property="article:author" content="Catecat">
<meta property="article:tag" content="逆向">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/04/06/gW6n8yKmMTUDHlY.png">


<link rel="canonical" href="https://directoree.github.io/post/encryption-and-cracking-11-PE/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>加密与解密（第四版）PE文件格式 | Catecat</title><meta name="robots" content="noindex">
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b832a9ae9a43377003fd975ca4e525ea";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Catecat</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">爱你所爱，行你所行，听从你心，无问西东。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-更新日志">

    <a href="/changelog" rel="section"><i class="fa fa-heartbeat fa-fw"></i>更新日志</a>

  </li>
        <li class="menu-item menu-item-空调房">

    <a href="/tips" rel="section"><i class="fa fa-wifi fa-fw"></i>空调房</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%9F%BA%E5%9C%B0%E5%9D%80"><span class="nav-text">1  基地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-MS-DOS%E5%A4%B4%E9%83%A8"><span class="nav-text">2 MS-DOS头部</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-PE%E6%96%87%E4%BB%B6%E5%A4%B4"><span class="nav-text">3 PE文件头</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-Signature-%E5%AD%97%E6%AE%B5"><span class="nav-text">3.1 Signature 字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-IMAGE-FILE-HEADER-%E7%BB%93%E6%9E%84"><span class="nav-text">3.2 IMAGE_FILE_HEADER 结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-IMAGE-OPTIONAL-HEADER-%E7%BB%93%E6%9E%84"><span class="nav-text">3.3 IMAGE_OPTIONAL_HEADER 结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%8C%BA%E5%9D%97"><span class="nav-text">4 区块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E5%8C%BA%E5%9D%97%E8%A1%A8"><span class="nav-text">4.1 区块表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E5%8C%BA%E5%9D%97%E5%90%88%E5%B9%B6"><span class="nav-text">4.2 区块合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E5%8C%BA%E5%9D%97%E7%9A%84%E5%AF%B9%E9%BD%90"><span class="nav-text">4.3 区块的对齐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E6%96%87%E4%BB%B6%E5%81%8F%E7%A7%BB%E4%B8%8E%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-text">4.4 文件偏移与虚拟地址的转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E8%BE%93%E5%85%A5%E8%A1%A8"><span class="nav-text">5 输入表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E8%BE%93%E5%85%A5%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8"><span class="nav-text">5.1 输入函数的调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E8%BE%93%E5%85%A5%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-text">5.2 输入表的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E7%BB%91%E5%AE%9A%E8%BE%93%E5%85%A5"><span class="nav-text">5.3 绑定输入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E8%BE%93%E5%87%BA%E8%A1%A8"><span class="nav-text">6 输出表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E8%BE%93%E5%87%BA%E8%A1%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">6.1 输出表的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E8%BE%93%E5%87%BA%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-text">6.2 输出表的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-%E6%9F%A5%E6%89%BE%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%A5%E5%8F%A3%E5%9C%B0%E5%9D%80"><span class="nav-text">6.3 查找输出函数的入口地址</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E5%9F%BA%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="nav-text">7 基址重定位</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E5%9F%BA%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">7.1 基址重定位的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-%E5%9F%BA%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-text">7.2 基址重定位表的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-%E5%9F%BA%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90"><span class="nav-text">7.3 基址重定位表的实例分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-text"></span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Catecat"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Catecat</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">109</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">43</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">58</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Directoree" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Directoree" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhao_yilong@aliyun.com" title="E-Mail → mailto:zhao_yilong@aliyun.com" rel="noopener" target="_blank"><i class="fas fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://sighttp.qq.com/msgrd?v=1&uin=1003432683" title="QQ → http:&#x2F;&#x2F;sighttp.qq.com&#x2F;msgrd?v&#x3D;1&amp;uin&#x3D;1003432683" rel="noopener" target="_blank"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://treecatee.github.io/" title="https:&#x2F;&#x2F;treecatee.github.io" rel="noopener" target="_blank">Treecatee</a>
        </li>
    </ul>
  </div>

      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://directoree.github.io/post/encryption-and-cracking-11-PE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Catecat">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Catecat">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          加密与解密（第四版）PE文件格式
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-06 09:38:19" itemprop="dateCreated datePublished" datetime="2021-04-06T09:38:19+08:00">2021-04-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-09-20 12:29:44" itemprop="dateModified" datetime="2021-09-20T12:29:44+08:00">2021-09-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AC%94%E8%AE%B0/%E9%80%86%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">逆向</span></a>
        </span>
    </span>

  
    <span id="/post/encryption-and-cracking-11-PE/" class="post-meta-item leancloud_visitors" data-flag-title="加密与解密（第四版）PE文件格式" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/post/encryption-and-cracking-11-PE/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/post/encryption-and-cracking-11-PE/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>34k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>31 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>ʕ •ᴥ•ʔ  ɔ: </p>
<a id="more"></a>



<p>在Win16平台上（例如Windows 3.x），可执行文件格式是NE。在Win32平台上（包括Windows 9x&#x2F;NT&#x2F;2000&#x2F;XP&#x2F;Server 2003&#x2F;Vista&#x2F;CE&#x2F;7&#x2F;10），可执行文件格式是PE。“PE” 是“Portable Executable File Format” （可移植的执行体）的缩写。PE格式是目前Windows平台上的主流可执行文件格式。</p>
<div class="note warning"><p><mark class="label success">Win32平台</mark><mark class="label danger">32&#x2F;64位系统</mark></p>
<p>不管是32位的Windows还是64位的，都是运行在NT内核之上的Win32子系统。<strong>Win32既包括32位的Windows又包括64位的Windows。</strong></p>
<ul>
<li>32位的Windows，叫Win32-i386。i386架构也可叫做i686或者x86或者IA-32。</li>
<li>64位的Windows，叫Win32-x86_64，x86_64架构也可叫做AMD64或者x64。虽然名字里有AMD，但是Intel的64位CPU也是这个指令集。</li>
</ul>
<p>此外，还有一些基本上宣告失败的64位架构，比如Intel的IA-64。Windows 2000的64位版就是运行在IA-64架构而不是AMD64架构之上的。</p>
<ul>
<li>32指令集的Windows操作系统：Win9x，NT，Win2K，WinXP，2003，Vista，2008，Win7；</li>
<li>64指令集的Windows操作系统：Win7，Win10。</li>
</ul>
</div>



<p>EXE文件和DLL文件的区别完全是语义上的。它们使用完全相同的PE格式，<mark class="label warning">唯一的区别就是用一个字段标识出这个文件是EXE还是DLL</mark>。还有许多DLL的扩展。例如，OCX控件和控制面板程序（<code>.CPL</code>文件）等都是DLL，它们拥有一样的实体。</p>
<p>PE文件中的数据结构一般都有32位和64位之分，例如<code>IMAGE NT_HEADERS32</code>、<code>IMAGE NT_HEADER64</code>等。除了在64位版本中的一些扩展域以外，这些结构几乎是一样的，在<code>winnt.h</code>中都有<code>#defines</code>，它可以选择适当的32位或64位结构，并给它们起一个与大小无关的别名。结构的选择依赖于用户正在编译的模式（尤其是<code>_WIN64</code>是否被定义）。</p>
<p><img data-src="https://i.loli.net/2021/04/06/gW6n8yKmMTUDHlY.png" alt="1.png"></p>
<h2 id="1-基地址"><a href="#1-基地址" class="headerlink" title="1  基地址"></a>1  基地址</h2><p>PE文件使用的是一个平面地址空间， 所有代码和数据都合并在一起，组成了个很大的结构。文件的内容被分割为不同的<strong>区块</strong>（Section又称<strong>区段</strong>、<strong>节</strong>等，在本章中不区分“区块”与“块”）区块中包含代码或数据，各个区块按页边界对齐。<mark class="label success">区块没有大小限制，是个连续结构</mark>。 每个块都有它自己在内存中的一套属性，例如这个块是否包含代码、是否只读或可读&#x2F;写等。</p>
<p>认识到PE文件不是作为单一内存映射文件被载入内存是很重要的。Windows 加载器（又称PE 装载器）遍历PE文件并决定文件的哪一部分被映射， 这种映射方式是将文件较高的偏移位置映射到较高的内存地址中。<mark class="label default">磁盘文件一旦被载入内存，磁盘上的数据结构布局和内存中的数据结构布局就是一致的</mark>。这样，如果在磁盘的数据结构中寻找一些内容，那么几乎都能在被载入的内存映射文件中找到相同的信息，但数据之间的相对位置可能会改变，某项的偏移地址可能区别于原始的偏移位置。不管怎样，对所有表现出来的信息，都允许进行从磁盘文件偏移到内存偏移的转换，如图11.2所示。</p>
<p><img data-src="https://i.loli.net/2021/04/06/yx76vb8uKQsDJAz.png" alt="2.png"></p>
<p>当PE文件通过Windows加载器载入内存后，内存中的版本称为<mark class="label danger">模块</mark>（Module）。内存中映射文件的起始地址称为<mark class="label danger">模块句柄</mark>（hModule ），可以通过模块句柄访问内存中的其他数据结构。这个初始内存地址也称为基地址（ImageBase）。准确地说，对于Windows CE（精简的Windows 95），这是不成立的，一个模块句柄在WindowsCE下并不等同于安装的起始地址。</p>
<p>【<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012861978/article/details/53048077?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&dist_request_id=1328767.69973.16176901373279367&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">虚拟内存与物理内存的区别</a>】【<a target="_blank" rel="noopener" href="https://www.codenong.com/cs106179422">面试网易游戏面试题目整理及答案（1）</a>】</p>
<p><img data-src="https://i.loli.net/2021/04/06/a7YSPuRwJN2mCXb.jpg" alt="20161105222328096.jpeg"></p>
<p>内存中的模块代表进程将这个可执行文件所需要的代码、数据、资源、输入表、输出表及其他有用的数据结构所使用的内存都放在一个连续的内存块中， 程序员只要知道装载程序文件映像到内存后的<strong>基地址</strong>即可。PE文件的剩余部分可以被读入，但可能无法被映射。例如，在将调试信息放到文件尾部时，PE的一个字段会告诉系统把文件映射到内存时需要使用多少内存，不能被映射的数据将被放置在文件尾部。</p>
<div class="note info"><p>在32位Windows系统中可以直接调用GetModuleHandle以取得指向DLL的指针，通过指针访问该DLL Module的内容，示例如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HMODULE <span class="title">GetModuleHandle</span> <span class="params">(LPCTSTR lpModuleName)</span></span>;</span><br></pre></td></tr></table></figure>

<p>调用该函数时会传递一个可执行文件或DLL文件名字符串（参数），如果系统找到文件，则返回该可执行文件或DLL文件映像所<mark class="label success">加载的基地址</mark>。也可以调用GetModuleHandle来传递NULL参数，此时将返回调用的可执行文件的基地址。</p>
<p><mark class="label warning">基地址的值是由PE文件本身设定的。</mark>按照默认设置，用Visual C++建立的EXE文件的基地址是<mark class="label danger">400000h</mark>、DLL文件的基地址是<mark class="label danger">1000000h</mark>，可以在创建应用程序的EXE文件时改变这个地址，方法是在链接应用时使用链接程序的/BASE选项，或者在链接后通过REBASE应用程序进行设置。</p>
</div>

<h2 id="2-MS-DOS头部"><a href="#2-MS-DOS头部" class="headerlink" title="2 MS-DOS头部"></a>2 MS-DOS头部</h2><p>每个PE文件都是以一个DOS程序开始的，有了它，一且程序在DOS下执行，DOS就能识别出这是一个有效的执行体，然后运行紧随MZ header的DOS stub（DOS块）。DOS stub实际上是一个有效的EXE，在不支持PE文件格式的操作系统中它将简单地显示一个错误提示， 类似于字符串”This program cannot be run in MS-DOS mode”。程序员也可以根据自己的意图实现完整的DOS代码。用户通常对DOS stub不太感兴趣，因为在大多数情况下它是由汇编器&#x2F;编译器自动生成的。我们通常把 DOS MZ头与DOS stub合称为DOS文件头。</p>
<mark class="label default">MS-DOS</mark>头部，又称作<mark class="label default">IMAGE_DOS_HEADER</mark>，其结构如下（<mark class="label info">左边的数字是到文件头的偏移量</mark>）。

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_DOS_HEADER_STRUCT&#123; </span><br><span class="line">  +<span class="number">0</span>h     e_magic       WORD ?        <span class="comment">//DOS可执行文件标记&quot;MZ&quot;，IMAGE_DOS_SIGNATURE</span></span><br><span class="line">  +<span class="number">2</span>h     e_cblp        WORD ?</span><br><span class="line">  +<span class="number">4</span>h     e_cp          WORD ?</span><br><span class="line">  +<span class="number">6</span>h     e_crlc        WORD ? </span><br><span class="line">  +<span class="number">8</span>h     e_cparhdr     WORD ?</span><br><span class="line">  +<span class="number">0</span>ah    e_minalloc    WORD ? </span><br><span class="line">  +<span class="number">0</span>ch    e maxalloc    WORD ?</span><br><span class="line">  +<span class="number">0</span>eh    e_ss          WORD ? </span><br><span class="line">  +<span class="number">10</span>h    e_sp          WORD ?</span><br><span class="line">  +<span class="number">12</span>h    e_csum        WORD ?</span><br><span class="line">  +<span class="number">14</span>h    e_ip          WORD ?        <span class="comment">//DOS代码入口IP</span></span><br><span class="line">  +<span class="number">16</span>h    e_cs          WORD ?        <span class="comment">//DOS代码入口CS</span></span><br><span class="line">  +<span class="number">18</span>h    e_lfarlc      WORD ?</span><br><span class="line">  +<span class="number">1</span>ah    e_ovno        WORD ? </span><br><span class="line">  +<span class="number">1</span>ch    e_res         WORD <span class="number">4</span> dup(?) </span><br><span class="line">  +<span class="number">24</span>h    e_oemid       WORD ?</span><br><span class="line">  +<span class="number">26</span>h    e_oeminfo     WORD ?</span><br><span class="line">  +<span class="number">28</span>h    e_res2        WORD <span class="number">10</span> dup (?) </span><br><span class="line">  +<span class="number">3</span>ch    e_lfanew      DWORD ?       <span class="comment">//指向PE文件头&quot;PE&quot;,0,0 </span></span><br><span class="line">&#125;IMAGE_DOS_HEADER_ENDS    </span><br></pre></td></tr></table></figure>

<div class="note info"><p>其中有两个字段比较重要，分别是<code>e_magic</code>和<code>e_lfanew</code>。</p>
<ul>
<li><code>e_magic</code>字段（2个字节大小）的值被设置为<mark class="label success">5A4Dh</mark>，这个值有一个<code>#define</code>名为<mark class="label success">IMAGE_DOS_SIGNATURE</mark>，在ASCI表示法里它的ASCII值为“MZ”，是MS-DOS的创建者之一Mark Zbikowski 名字的缩写。</li>
<li><code>e_lfanew</code>字段（4个字节大小）是真正的PE文件头的相对偏移（RVA），指出真正的PE头的文件偏移位置，位于从文件开始偏移<mark class="label success">3Ch</mark>字节处。</li>
</ul>
</div>

<h2 id="3-PE文件头"><a href="#3-PE文件头" class="headerlink" title="3 PE文件头"></a>3 PE文件头</h2><div class="note warning"><p>PE头是PE相关结构NT映像头的简称，即<mark class="label primary">IMAGE_NT_HEADER</mark>，其中包含许多PE装载器能用到的重要字段。</p>
<p>当执行体在支持PE文件结构的操作系统中执行时，PE装载器将从IMAGE_DOS_HEADER结构的<code>e_lfanew</code>字段里找到PE Header的起始偏移量，用其加上基址，得到PE文件头的指针。</p>
<p>$$PNTHeader &#x3D; ImageBase + dosHeader -&gt;e\_lfanew $$</p>
<p>实际上有两个版本的IMAGE_NT_HEADER结构，一个是为PE32 （32位版本）可执行文件准备的，另一个是PE32+（64位版本）。因为它们几乎没有区别，所以在以后的讨论中将不作区分。</p>
</div>

<p> IMAGE_NT_HEADER是由3个字段（左边的数字是到PE文件头的偏移量）组成的，示例如下。</p>
<p>PE32 （32位版本）:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_NT_HEADERS STRUCT&#123;</span><br><span class="line">  +Oh       Signature         DWORD                    ?      <span class="comment">//PE文件标识，IMAGE_NT_SIGNATURE</span></span><br><span class="line">  +<span class="number">4</span>h       FileHeader        IMAGE_FILE_HEADER        &lt;&gt; </span><br><span class="line">  +<span class="number">18</span>h      OptionalHeader    IMAGE OPTIONAL_HEADER32  &lt;&gt;</span><br><span class="line">&#125;IMAGE NT_HEADERS ENDS   </span><br></pre></td></tr></table></figure>

<p>PE32+（64位版本）:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_NT_HEADERS STRUCT&#123;</span><br><span class="line">  +Oh       Signature         DWORD                    ?      <span class="comment">//PE文件标识，IMAGE_NT_SIGNATURE</span></span><br><span class="line">  +<span class="number">4</span>h       FileHeader        IMAGE_FILE_HEADER        &lt;&gt; </span><br><span class="line">  +<span class="number">18</span>h      OptionalHeader    IMAGE OPTIONAL_HEADER32  &lt;&gt;</span><br><span class="line">&#125;IMAGE NT_HEADERS64 ENDS   </span><br></pre></td></tr></table></figure>

<h3 id="3-1-Signature-字段"><a href="#3-1-Signature-字段" class="headerlink" title="3.1 Signature 字段"></a>3.1 Signature 字段</h3><p>在一个有效的PE文件里，Signature字段被设置为<code>0x00004550</code>， ASCII 码字符是<mark class="label danger">PE00</mark>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_NT_SIGNATURE 0x00004550</span></span><br></pre></td></tr></table></figure>

<p>Signature字段的值<mark class="label danger">PE00</mark>是PE文件头的开始，MS-DOS头部的<code>e-lfanew</code>字段正是指向<mark class="label danger">PE00</mark>的。</p>
<h3 id="3-2-IMAGE-FILE-HEADER-结构"><a href="#3-2-IMAGE-FILE-HEADER-结构" class="headerlink" title="3.2 IMAGE_FILE_HEADER 结构"></a>3.2 IMAGE_FILE_HEADER 结构</h3><div class="note default"><ul>
<li><code>IMAGE_FILE_HEADER</code>（映像文件头）结构包含PE文件的一些基本信息，最重要的是，其中<mark class="label info">SizeOfOptionalHeader</mark>域指出<code>IMAGE_OPTIONAL_HEADER</code>的大小。</li>
<li><code>IMAGE_FILE_HEADER</code>这个结构也能在COFF格式的OBJ文件的开始处找到，因此也称其为“COFF File Header”。注释中的偏移量是基于PE文件头（<code>IMAGE_NT_HEADERS</code>）的。</li>
</ul>
</div>

<p>其结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">  +<span class="number">04</span>h   WORD    Machine;               <span class="comment">// 运行平台</span></span><br><span class="line">  +<span class="number">06</span>h   WORD    NumberOfSections;      <span class="comment">// 文件的区块数目</span></span><br><span class="line">  +<span class="number">08</span>h   DWORD   TimeDateStamp;         <span class="comment">// 文件创建日期和时间</span></span><br><span class="line">  +<span class="number">0</span>Ch   DWORD   PointerToSymbolTable;  <span class="comment">// 指向符号表(主要用于调试)</span></span><br><span class="line">  +<span class="number">10</span>h   DWORD   NumberOfSymbols;       <span class="comment">// 符号表中符号个数(用于调试)</span></span><br><span class="line">  +<span class="number">14</span>h   WORD    SizeOfOptionalHeader;  <span class="comment">// IMAGE_OPTIONAL_HEADER32 结构大小</span></span><br><span class="line">  +<span class="number">16</span>h   WORD    Characteristics;       <span class="comment">// 文件属性</span></span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://i.loli.net/2021/04/12/foc72VEZpnivKHF.png" alt="屏幕快照 2021-04-12 下午6.44.40.png"></p>
<div class="note success"><ol>
<li><p><strong>Machine</strong>：是可执行文件的目标CPU类型，其中典型的机器类标志如下</p>
<table>
<thead>
<tr>
<th align="center">机器类型</th>
<th align="center">标志</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Intel i386</td>
<td align="center">14Ch</td>
</tr>
<tr>
<td align="center">MIPS R3000</td>
<td align="center">162H</td>
</tr>
<tr>
<td align="center">MIPS R4000</td>
<td align="center">166H</td>
</tr>
<tr>
<td align="center">Alpha AXP</td>
<td align="center">184H</td>
</tr>
<tr>
<td align="center">Power PC</td>
<td align="center">1F0H</td>
</tr>
<tr>
<td align="center">MIPS R10000</td>
<td align="center">0x0168</td>
</tr>
<tr>
<td align="center">AMD64</td>
<td align="center">0x8664</td>
</tr>
<tr>
<td align="center">ALPHA64</td>
<td align="center">0x0284</td>
</tr>
<tr>
<td align="center">IA64</td>
<td align="center">0x0200</td>
</tr>
</tbody></table>
</li>
<li><p><strong>NumberOfSections</strong>：是文件的区块数目；</p>
</li>
<li><p><strong>TimeDateStamp</strong>：文件创建的时间，这个值是从1970年1月1日以来用格林尼治时间计算的秒数；</p>
</li>
<li><p><strong>PointerToSymbolTable</strong>：COFF符号表的偏移地址，主要用于调试，若不存在，这一项可设置为0；</p>
</li>
<li><p><strong>NumberOfSymbols</strong>：符号表的符号个数。</p>
</li>
<li><p><strong>SizeOfOptionalHeader</strong>：表示<code>IMAGE_OPTIONAL_HEADER32</code>数据结构大小，其最小值对于PE32结构是<code>00E0H</code>，对于PE32+是<code>00F0H</code>。</p>
</li>
<li><p><strong>Characteristics</strong>：文件属性，通过几个值运算得到。这些值定义与<code>winnt.h</code>的<code>IMAGE_FILE_XXX</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_RELOCS_STRIPPED           0x0001  <span class="comment">// 重定位信息被移除，文件必须加载先前的基地址</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  <span class="comment">// 文件可执行</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  <span class="comment">// 行号被移除</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  <span class="comment">// 符号被移除</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_AGGRESIVE_WS_TRIM         0x0010  <span class="comment">// Agressively trim working set</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_LARGE_ADDRESS_AWARE       0x0020  <span class="comment">// 程序能处理大于2G的地址</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_BYTES_REVERSED_LO         0x0080  <span class="comment">// Bytes of machine word are reversed.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_32BIT_MACHINE             0x0100  <span class="comment">// 32位机器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_DEBUG_STRIPPED            0x0200  <span class="comment">// .dbg文件的调试信息被移除</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP   0x0400  <span class="comment">// 如果在移动介质中,拷到交换文件中运行</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_NET_RUN_FROM_SWAP         0x0800  <span class="comment">// 如果在网络中,拷到交换文件中运行</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_SYSTEM                    0x1000  <span class="comment">// 系统文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_DLL                       0x2000  <span class="comment">// 文件是一个dll</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_UP_SYSTEM_ONLY            0x4000  <span class="comment">// 文件只能运行在单处理器上</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_BYTES_REVERSED_HI         0x8000  <span class="comment">// 处理机的高位字节是相反的</span></span></span><br></pre></td></tr></table></figure>

<p><mark class="label success">其值是通过上述的值或运算得到，上述定义的值都是2^n，所以运算后对于二进制就是不同的位的一。</mark></p>
</li>
</ol>
</div>

<p><img data-src="https://i.loli.net/2021/04/12/XG9BlAzqIMJDpod.png" alt="5.png"></p>
<h3 id="3-3-IMAGE-OPTIONAL-HEADER-结构"><a href="#3-3-IMAGE-OPTIONAL-HEADER-结构" class="headerlink" title="3.3 IMAGE_OPTIONAL_HEADER 结构"></a>3.3 IMAGE_OPTIONAL_HEADER 结构</h3><p>尽管<code>IMAGE_OPTIONAL_HEADER</code>是一个可选结构，但是<code>IMAGE_FILE_HEADER</code>不足以包含所有的属性，完全不考虑两个结构的区别，将两者连起来就是一个完整的“PE文件头结构”，其结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// Standard fields.  </span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">  +<span class="number">18</span>h    WORD    Magic;                        <span class="comment">// 标志字, ROM 映像（0107h）,普通可执行文件（010Bh）</span></span><br><span class="line">  +<span class="number">1</span>Ah    BYTE    MajorLinkerVersion;           <span class="comment">// 链接程序的主版本号</span></span><br><span class="line">  +<span class="number">1B</span>h    BYTE    MinorLinkerVersion;           <span class="comment">// 链接程序的次版本号</span></span><br><span class="line">  +<span class="number">1</span>Ch    DWORD   SizeOfCode;                   <span class="comment">// 所有含代码的节的总大小</span></span><br><span class="line">  +<span class="number">20</span>h    DWORD   SizeOfInitializedData;        <span class="comment">// 所有含已初始化数据的节的总大小</span></span><br><span class="line">  +<span class="number">24</span>h    DWORD   SizeOfUninitializedData;      <span class="comment">// 所有含未初始化数据的节的大小</span></span><br><span class="line">  +<span class="number">28</span>h    DWORD   AddressOfEntryPoint;          <span class="comment">// 程序执行入口RVA</span></span><br><span class="line">  +<span class="number">2</span>Ch    DWORD   BaseOfCode;                   <span class="comment">// 代码的区块的起始RVA</span></span><br><span class="line">  +<span class="number">30</span>h    DWORD   BaseOfData;                   <span class="comment">// 数据的区块的起始RVA</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// NT additional fields.    以下是属于NT结构增加的领域。</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">  +<span class="number">34</span>h    DWORD   ImageBase;                    <span class="comment">// 程序默认的装载基址</span></span><br><span class="line">  +<span class="number">38</span>h    DWORD   SectionAlignment;             <span class="comment">// 内存中的区块的对齐大小</span></span><br><span class="line">  +<span class="number">3</span>Ch    DWORD   FileAlignment;                <span class="comment">// 文件中的区块的对齐大小</span></span><br><span class="line">  +<span class="number">40</span>h    WORD    MajorOperatingSystemVersion;  <span class="comment">// 要求操作系统最低版本号的主版本号</span></span><br><span class="line">  +<span class="number">42</span>h    WORD    MinorOperatingSystemVersion;  <span class="comment">// 要求操作系统最低版本号的副版本号</span></span><br><span class="line">  +<span class="number">44</span>h    WORD    MajorImageVersion;            <span class="comment">// 可运行于操作系统的主版本号</span></span><br><span class="line">  +<span class="number">46</span>h    WORD    MinorImageVersion;            <span class="comment">// 可运行于操作系统的次版本号</span></span><br><span class="line">  +<span class="number">48</span>h    WORD    MajorSubsystemVersion;        <span class="comment">// 要求最低子系统版本的主版本号</span></span><br><span class="line">  +<span class="number">4</span>Ah    WORD    MinorSubsystemVersion;        <span class="comment">// 要求最低子系统版本的次版本号</span></span><br><span class="line">  +<span class="number">4</span>Ch    DWORD   Win32VersionValue;            <span class="comment">// 莫须有字段，不被病毒利用的话一般为0</span></span><br><span class="line">  +<span class="number">50</span>h    DWORD   SizeOfImage;                  <span class="comment">// 映像装入内存后的总尺寸</span></span><br><span class="line">  +<span class="number">54</span>h    DWORD   SizeOfHeaders;                <span class="comment">// 所有头 + 区块表的尺寸大小</span></span><br><span class="line">  +<span class="number">58</span>h    DWORD   CheckSum;                     <span class="comment">// 映像的校检和</span></span><br><span class="line">  +<span class="number">5</span>Ch    WORD    Subsystem;                    <span class="comment">// 可执行文件期望的子系统</span></span><br><span class="line">  +<span class="number">5</span>Eh    WORD    DllCharacteristics;           <span class="comment">// DllMain()函数何时被调用，默认为 0</span></span><br><span class="line">  +<span class="number">60</span>h    DWORD   SizeOfStackReserve;           <span class="comment">// 初始化时的栈大小</span></span><br><span class="line">  +<span class="number">64</span>h    DWORD   SizeOfStackCommit;            <span class="comment">// 初始化时实际提交的栈大小</span></span><br><span class="line">  +<span class="number">68</span>h    DWORD   SizeOfHeapReserve;            <span class="comment">// 初始化时保留的堆大小</span></span><br><span class="line">  +<span class="number">6</span>Ch    DWORD   SizeOfHeapCommit;             <span class="comment">// 初始化时实际提交的堆大小</span></span><br><span class="line">  +<span class="number">70</span>h    DWORD   LoaderFlags;                  <span class="comment">// 与调试有关，默认为 0 </span></span><br><span class="line">  +<span class="number">74</span>h    DWORD   NumberOfRvaAndSizes;          <span class="comment">// 下边数据目录的项数，这个字段自Windows NT 发布以来一直是16</span></span><br><span class="line">  +<span class="number">78</span>h    DataDirectory IMAGE_DATA_DIRECTORY <span class="number">16</span> DUP (&lt;<span class="number">0</span>&gt;);   <span class="comment">// 数据目录表</span></span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure>

<p>PE32与PE32+的可选文件头的主要区别为：<strong>BaseData域不存在于PE32+中</strong>，PE32+中的Magic值为<strong>020Bh</strong>，PE32中的Magic值为<strong>010Bh</strong>。</p>
<p><img data-src="https://i.loli.net/2021/04/12/6OhAoRtgVeG9FsC.png" alt="6.png"></p>
<div class="note danger"><ol>
<li><p><strong>Magic</strong>：是一个标记字，用于标记文件是ROM映像（<code>0107h</code>）还是可执行文件的映像（<code>010Bh</code>），一般是<code>010Bh</code>，如果是PE32+，则是<code>020Bh</code>。</p>
</li>
<li><p><strong>MajorLinkerVersion</strong>：连接程序的主版本号 如vc6.0的为06h。</p>
</li>
<li><p><strong>MinorLinkerVersion</strong>：连接程序的次版本号 如vc6.0的为00h。</p>
</li>
<li><p><strong>SizeOfCode</strong>：是<code>IMAGE_SCN_CNT_CODE</code>属性区块的总大小，即<strong>代码段的大小</strong>。多数文件只有一个Code块，所以这个字段和<code>.text</code>块的大小相匹配。<mark class="label danger">一般对齐的是一个磁盘区字节数（200h）的整数倍</mark>。</p>
</li>
<li><p><strong>SizeOfInitializedData</strong>：所有含<strong>已初始化数据的块的大小</strong>，即在编译时所构成块的大小（不包含代码段），一般在<code>.data</code>段中，但这个数据不太准确。</p>
</li>
<li><p><strong>SizeOfUninitializedData</strong>：所有含<strong>未初始化数据的块的大小</strong>，装载程序要在虚拟地址控件中给这些数据约定空间，这些块在磁盘中并不占地方，在程序开始时并没有指定值，一般在<code>.bss</code>段中。</p>
</li>
<li><p><strong>AddressOfEntryPoint</strong>：指出文件被执行时的入口地址（OEP），这是一个RVA地址。</p>
<ul>
<li><p>对于dll，这个入口点在进程初始化和关闭时及线程创建和毁灭时调用。在多数可执行文件中，这个值并不指向Main、WinMain或DllMain函数，而是指向运行需要的库代码并由其调用上述函数；对于dll文件，这里是libMain()的地址。</p>
</li>
<li><p>对于exe文件,这里是启动代码。</p>
<p><mark class="label danger">如果在一个可执行文件上附加了一段代码并想让这段代码首先被执行，那么只需要将这个入口地址指向附加的代码就可以了。</mark></p>
</li>
</ul>
</li>
<li><p><strong>BaseOfCode</strong>：代码段基地址，代码段通常在PE头和数据段之间，<mark class="label success">微软的连接程序生成的程序一般把这个值置为<code>1000h</code></mark>。</p>
</li>
<li><p><strong>BaseOfData</strong>：数据段基地址，<strong>数据段一般出现在内存的末尾，这个字段在PE32+结构是没有的</strong>。</p>
</li>
<li><p><strong>ImageBase</strong>：PE文件默认的装入地址，这是一个理想地址，如果有可能的话（即地址当前没有被占用且是一个合法地址），加载器会试图在这个地址载入PE文件。当文件被装载进这个地址中时，将不进行重定位操作，否则会进行过重定位，速度会慢一点。</p>
<ul>
<li>对于EXE文件来说，由于每个文件总是使用独立的虚拟地址空间，<strong>优先装入地址不可能被其他模块占据</strong>，所以EXE总是能够按照这个地址装入，<strong>这也意味着EXE文件不再需要重定位信息</strong>。</li>
<li>对于DLL文件来说，由于多个DLL文件全部使用宿主EXE文件的地址空间，不能保证优先装入地址没有被其他的DLL使用，所以DLL文件中必须包含重定位信息以防万一，因此，在前面介绍的<code>IMAGE_FILE_HEADER</code>结构的<code>Characteristics</code>字段中，DLL 文件对应的<code>IMAGE_FILE_RELOCS_STRIPPED</code>位总是为0，而EXE文件的这个标志位总是为1。</li>
<li>Windows9x中EXE文件默认为<code>400000h</code>，DLL文件为<code>10000000h</code>。</li>
</ul>
</li>
<li><p><strong>SectionAlignment</strong>：区块被装入内存后的对齐大小（单位）。也就是说，每个区块被装入的地址必定是本字段指定数值的整数倍。对运行在Windows 9x、Me下的用户模式可执行文件，最小的对其尺寸是每页1000h（4kb），在IA-64上，这个字段按8kb排列。</p>
</li>
<li><p><strong>FileAlignment</strong>：区块存储在磁盘文件中时的对齐单位，<strong>对于x86可执行文件，这个值通常是200h或1000h，这是为了保证块总是从磁盘的扇区开始，使用不同版本的Microsoft连接器，这个值会被改变，但必须是2的幂，最小为200h。而且如果SectionAlignment小于CPU的页尺寸，这个值就必须与SectionAlignment匹配。</strong><mark class="label default">由于在磁盘中的页大小和在内存中的页大小不同，所以文件在被装载进内存中与在磁盘中不是完全一样的，中间的差距用0填充。</mark></p>
</li>
<li><p><strong>MajorOperatingSystemVersion：</strong>指运行这个PE文件所需的操作系统的最低主版本号。</p>
</li>
<li><p><strong>MinorOperatingSystemVersion</strong>：指运行这个PE文件所需的操作系统的最低次版本号。</p>
</li>
<li><p><strong>MajorImageVersion：</strong>指用户自定义的PE文件的主版本号，可以通过连接程序来设置。</p>
</li>
<li><p><strong>MinorImageVersion</strong>：指用户自定义的PE文件的次版本号，可以通过连接程序来设置。</p>
</li>
<li><p><strong>MajorSubsystemVersion：</strong>要求最低子系统版本的主版本号，通常被设置为04h。</p>
</li>
<li><p><strong>MinorSubsystemVersion</strong>要求最低子系统版本的次版本号。</p>
</li>
<li><p><strong>Win32VersionValue</strong> ：从来不用的字段，总是设置为0。</p>
</li>
<li><p><strong>SizeOfImage</strong>：PE文件装入内存后映像的总大小，从<code>ImageBase</code>到最后一个块的总大小，最后一块向上取整到文件对齐值的倍数。如果<code>SectionAlignment</code>域和<code>FileAlignment</code>域相等，那么这个值也是PE文件在硬盘上的大小。</p>
</li>
<li><p><strong>SizeOfHeader</strong>：是MS-DOS头、PE头和区块表的总尺寸，在PE文件代码块或数据块之前，四舍五入到文件对齐值的倍数。</p>
</li>
<li><p><strong>CheckSum</strong>：PE文件的CRC校验和，<code>IMAGEHLP.DLL</code>中的<code>CheckSumMappedFile</code>函数可以计算该值，一般的EXE文件该值可以为<code>0h</code>，但一些内核模式的驱动程序和系统DLL必须有一个校验和。</p>
</li>
<li><p><strong>Subsystem</strong>：PE文件的用户界面使用的子系统（UI）类型，这个值只对EXE重要。如果将子系统指定为Windows CUI，那么系统会自动为程序建立一个控制台窗口，而指定为Windows GUI的话，窗口必须由程序自己建立。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>子系统</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>未知</td>
</tr>
<tr>
<td>1</td>
<td>不需要子系统（例如驱动程序）</td>
</tr>
<tr>
<td>2</td>
<td>图形接口子系统（GUI）</td>
</tr>
<tr>
<td>3</td>
<td>字符子系统（CUI）</td>
</tr>
<tr>
<td>5</td>
<td>OS&#x2F;2字符子系统</td>
</tr>
<tr>
<td>7</td>
<td>POSIX字符子系统</td>
</tr>
<tr>
<td>8</td>
<td>保留</td>
</tr>
<tr>
<td>9</td>
<td>WinCE图形界面</td>
</tr>
</tbody></table>
</li>
<li><p><strong>DllCharacteristics</strong>：Dll文件特性（表示DllMain()函数何时被调用，通常设置为0），与Characteristics相类似，采用相同的计算方式，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//      IMAGE_LIBRARY_PROCESS_INIT            0x0001     // 保留</span></span><br><span class="line"><span class="comment">//      IMAGE_LIBRARY_PROCESS_TERM            0x0002     // 保留</span></span><br><span class="line"><span class="comment">//      IMAGE_LIBRARY_THREAD_INIT             0x0004     // 保留</span></span><br><span class="line"><span class="comment">//      IMAGE_LIBRARY_THREAD_TERM             0x0008     // 保留</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA 0x0020 <span class="comment">//Image can handle a high entropy 64-bit virtual address space.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE     0x0040           <span class="comment">// DLL 可重定位。</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY  0x0080           <span class="comment">// Code Integrity Image</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_NX_COMPAT        0x0100           <span class="comment">// 该映像与 NX 兼容。</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_NO_ISOLATION     0x0200           <span class="comment">// 该映像理解隔离，但不需要隔离。</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_NO_SEH           0x0400           <span class="comment">// 该映像不使用 SEH。 该映像中不能有任何 SE 处理程序。</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_NO_BIND          0x0800           <span class="comment">// 请勿绑定此映像。</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_APPCONTAINER     0x1000           <span class="comment">// 映像必须在 AppContainer 中运行。</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_WDM_DRIVER       0x2000           <span class="comment">// 驱动程序使用 WDM 模型。</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_GUARD_CF         0x4000           <span class="comment">// Image supports Control Flow Guard.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE     0x8000    <span class="comment">//该映像支持终端服务器感知。</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>SizeOfStackReserve</strong>：为线程的栈初始保留的虚拟内存的大小，默认为1MB，即<code>00100000h</code>。如果在调用<code>CreateThread</code>函数时指定堆栈的大小为0，被创建的线程的堆栈的初始大小就与这个值相同。</p>
</li>
<li><p><strong>SizeOfStackCommit</strong>：<mark class="label info">在EXE文件里，一开始默认给栈分配的虚拟内存大小，微软的连接程序把这个值置为4KB，即<code>1000h</code>。</mark></p>
</li>
<li><p><strong>SizeOfHeapReserve</strong>：在EXE文件里，为进程的堆保留的虚拟内存的大小，默认值为默认为1MB，即<code>00100000h</code>。</p>
</li>
<li><p><strong>SizeOfHeapCommit</strong>：在EXE文件里，一开始默认给程序的进程分配的堆的大小，微软的连接程序把这个值置为4KB，即<code>1000h</code>。</p>
</li>
<li><p><strong>LoadFlags</strong>：与调试有关，默认为0。</p>
</li>
<li><p><strong>NumberOfRvaAndSizes</strong>：数据目录结构数组的项数，即下面数据目录的项数，自Windows NT发布以来该值总为<code>00000010h</code>。</p>
</li>
<li><p><strong>DataDirectory</strong>[16]：数据目录表，是一个数组，由16个相同的<code>IMAGE_DATA_DIRECTORY</code>结构组成，每一个<code>IMAGE_DATA_DIRECTORY</code>的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;  <span class="comment">//数据起始RVA，是所指向的数据块RVA。</span></span><br><span class="line">    DWORD   Size;            <span class="comment">//数据块长度，所指向的数据块的大小。</span></span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">序号</th>
<th>成员</th>
<th>结构</th>
<th>偏移量（PE&#x2F;PE32+）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td>Export Table（导出表）</td>
<td>IMAGE_DIRECTORY_ENTRY_EXPORT</td>
<td>78h&#x2F;88h</td>
</tr>
<tr>
<td align="center">1</td>
<td>Import Table（导入表）</td>
<td>IMAGE_DIRECTORY_ENTRY_IMPORT</td>
<td>90h&#x2F;90h</td>
</tr>
<tr>
<td align="center">2</td>
<td>Resources Table（资源）</td>
<td>IMAGE_DIRECTORY_ENTRY_RESOURCE</td>
<td>88h&#x2F;98h</td>
</tr>
<tr>
<td align="center">3</td>
<td>Exception Table（异常）</td>
<td>IMAGE_DIRECTORY_ENTRY_EXCEPTION</td>
<td>90h&#x2F;A0h</td>
</tr>
<tr>
<td align="center">4</td>
<td>Security Table（安全）</td>
<td>IMAGE_DIRECTORY_ENTRY_SECURITY</td>
<td>98h&#x2F;A8h</td>
</tr>
<tr>
<td align="center">5</td>
<td>Base relocation Table（重定位表）</td>
<td>IMAGE_DIRECTORY_ENTRY_BASERELOC</td>
<td>A0h&#x2F;B0h</td>
</tr>
<tr>
<td align="center">6</td>
<td>Debug（调试信息）</td>
<td>IMAGE_DIRECTORY_ENTRY_DEBUG</td>
<td>A8h&#x2F;B8h</td>
</tr>
<tr>
<td align="center">7</td>
<td>Copyright（版权信息）</td>
<td>IMAGE_DIRECTORY_ENTRY_ARCHITECTURE</td>
<td>B0h&#x2F;C0h</td>
</tr>
<tr>
<td align="center">8</td>
<td>Global Ptr（RVA of GP）</td>
<td>IMAGE_DIRECTORY_ENTRY_GLOBALPTR</td>
<td>B8h&#x2F;C8h</td>
</tr>
<tr>
<td align="center">9</td>
<td>Thread local storage（TLS）</td>
<td>IMAGE_DIRECTORY_ENTRY_TLS</td>
<td>C0h&#x2F;D0h</td>
</tr>
<tr>
<td align="center">10</td>
<td>Load Configuration</td>
<td>IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG</td>
<td>C8h&#x2F;D8h</td>
</tr>
<tr>
<td align="center">11</td>
<td>Bound Import Directory in headers</td>
<td>IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT</td>
<td>D0h&#x2F;E0h</td>
</tr>
<tr>
<td align="center">12</td>
<td>Import Address Table（IAT导入函数地址表）</td>
<td>IMAGE_DIRECTORY_ENTRY_IAT</td>
<td>D8h&#x2F;E8h</td>
</tr>
<tr>
<td align="center">13</td>
<td>Delay Import（Delay Load Import Descriptors）</td>
<td>IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT</td>
<td>E0h&#x2F;F0h</td>
</tr>
<tr>
<td align="center">14</td>
<td>COM descriptor（COM Runtime descriptor）</td>
<td>IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR</td>
<td>E8h&#x2F;F8h</td>
</tr>
<tr>
<td align="center">15</td>
<td>保留，必须为0</td>
<td></td>
<td>F0h&#x2F;100h</td>
</tr>
</tbody></table>
</li>
</ol>
</div>

<h2 id="4-区块"><a href="#4-区块" class="headerlink" title="4 区块"></a>4 区块</h2><h3 id="4-1-区块表"><a href="#4-1-区块表" class="headerlink" title="4.1 区块表"></a>4.1 区块表</h3><p>区块表是一个<code>IMAGE_SECTION_HEADER</code>结构数组，数组中的每个结构包含了其所关联的区块的信息。区块的数目由<code>IMAGE_NT_HEADER.FileHeader.NumberOfSections</code>字段给出。其结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        Name[IMAGE_SIZEOF_SHORT_NAME]  <span class="function">BYTE8 <span class="title">DUP</span><span class="params">(?)</span> </span>;   <span class="comment">// 8字节长度的区块名称,如“.text”</span></span><br><span class="line">                                                        <span class="comment">//IMAGE_SIZEOF_SHORT_NAME=8</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span>                                           //区块尺寸</span></span><br><span class="line"><span class="class">         &#123;</span></span><br><span class="line">             PhysicalAddress           DWORD ?          <span class="comment">// 物理地址</span></span><br><span class="line">             VirtualSize;              DWORD ?          <span class="comment">// 真实长度，这两个值是一个联合结构，可以使用其中的任何一个，一般是取后一个</span></span><br><span class="line">         &#125; Misc;</span><br><span class="line">        VirtualAddress                 DWORD ?          <span class="comment">// 区块的 RVA 地址</span></span><br><span class="line">        SizeOfRawData                  DWORD ?          <span class="comment">// 在文件中对齐后的尺寸</span></span><br><span class="line">        PointerToRawData               DWORD ?          <span class="comment">// 在文件中的偏移量</span></span><br><span class="line">        PointerToRelocations           DWORD ?          <span class="comment">// 在OBJ文件中使用，重定位的偏移</span></span><br><span class="line">        PointerToLinenumbers           DWORD ?          <span class="comment">// 行号表的偏移（供调试使用地）</span></span><br><span class="line">        NumberOfRelocations            WORD  ?          <span class="comment">// 在OBJ文件中使用，重定位项数目</span></span><br><span class="line">        NumberOfLinenumbers            WORD  ?          <span class="comment">// 行号表中行号的数目</span></span><br><span class="line">        Characteristics                DWORD ?          <span class="comment">// 节属性如可读，可写，可执行等</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure>



<p>如下图对应于PE文件中的某一个区块，<mark class="label success">每个区块对应于一个IMAGE_SECTION_HEADER结构</mark>。</p>
<p><img data-src="https://i.loli.net/2021/04/13/pN1FTJ4kthGwDU5.png" alt="7.png"></p>
<div class="note warning"><ol>
<li><p><strong>Name</strong>：区块名。这是一个由8位的ASCII 码名（不是Unicode内码），用来定义区块的名称。多数区块名都习惯性以一个<code>.</code>作为开头（例如：<code>.text</code>），这个<code>.</code>实际上是不是必须的。如果区块名超过 8 个字节，则没有最后的终止标志<code>NULL</code> 字节。<mark class="label default">并且前边带有一个<code>$</code> 的区块名字会在载入的时候被合并，在合并之后的区块中，他们是按照<code>$</code> 后边的字符的字母顺序进行合并的</mark>。</p>
<p>区块名称是唯一的，在一个PE文件中不可重复，而且区块名称仅仅是一个标记，和区块内容没有任何关系，这也就意味着在把代码块命名成.data也是合法的，所以判断区块内容可以结合<code>IMAGE_OPTIONAL_HEADER32</code>结构中的字段结合判断。</p>
</li>
<li><p><strong>Virtual Size</strong>：实际被区块所使用的大小，这是区块的数据在<strong>对齐处理前</strong>的实际大小。如果这个字段的值大于<code>SizeOfRawData</code>的值，那么相差的字节用<code>0</code>填充。</p>
</li>
<li><p><strong>Virtual Address</strong>：该区块装载到内存中的RVA 地址。这个地址是按照内存页来对齐的，因此它的数值总是可选文件头中<code>SectionAlignment</code>（区块被装入内存后的对齐大小）的值的整数倍。在Microsoft 工具中，第一个块的默认 RVA 总为<code>1000h</code>。在OBJ 中，该字段没有意义地，并被设为<code>0</code>。</p>
</li>
<li><p><strong>SizeOfRawData</strong>：该区块在磁盘中所占的大小。在可执行文件中，该字段是已经被<code>FileAlignment</code>（区块存储在磁盘文件中时的对齐单位）处理过的长度。例如，<code>FileAlignment</code>为200字节，<code>Virtual Size</code>中指定的长度为<code>192h</code>字节，该块应保存为<code>200h</code>字节。</p>
</li>
<li><p><strong>PointerToRawData</strong>：<mark class="label warning">该区块在磁盘中的偏移，指出原始数据在文件中的偏移</mark>。这个数值是从文件头开始算起的偏移量。如果是自装载PE文件或者COFF文件，则必须使用完全线性的方式装载文件，而不是Virtual Address字段中的RVA地址。</p>
</li>
<li><p><strong>PointerToRelocations</strong>：这个字段在EXE中没有任何意义，在OBJ 文件中，表示本区块重定位信息的偏移值。（在OBJ 文件中如果不是零，它会指向一个<code>IMAGE_RELOCATION</code>结构的数组）</p>
</li>
<li><p><strong>PointerToLinenumbers</strong>：行号表在文件中的偏移值，是文件的调试信息。</p>
</li>
<li><p><strong>NumberOfRelocations</strong>：在EXE文件中没有意义，在OBJ 文件中，是本区块在重定位表中的重定位数目。</p>
</li>
<li><p><strong>NumberOfLinenumbers</strong>：该区块在行号表中的行号数目。</p>
</li>
<li><p><strong>Characteristics</strong>：块属性，是一组指出块属性（如代码&#x2F;数据，可读&#x2F;可写）的标志，与之前介绍过的文件属性字段相类似：</p>
<table>
<thead>
<tr>
<th>字段值</th>
<th>地址</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>IMAGE_SCN_CNT_CODE</td>
<td>0x00000020</td>
<td>包含代码，常与 0x10000000一起设置。</td>
</tr>
<tr>
<td>IMAGE_SCN_CNT_INITIALIZED_DATA</td>
<td>0x00000040</td>
<td>该区块包含以初始化的数据。</td>
</tr>
<tr>
<td>IMAGE_SCN_CNT_UNINITIALIZED_DATA</td>
<td>0x00000080</td>
<td>该区块包含未初始化的数据。</td>
</tr>
<tr>
<td>IMAGE_SCN_MEM_DISCARDABLE</td>
<td>0x02000000</td>
<td>该区块可被丢弃，因为当它一旦被装入后，进程就不在需要它了，典型的如重定位区块（如.reloc）。</td>
</tr>
<tr>
<td>IMAGE_SCN_MEM_SHARED</td>
<td>0x10000000</td>
<td>该区块为共享区块。</td>
</tr>
<tr>
<td>IMAGE_SCN_MEM_EXECUTE</td>
<td>0x20000000</td>
<td>该区块可以执行。通常当0x00000020被设置时候，该标志也被设置。</td>
</tr>
<tr>
<td>IMAGE_SCN_MEM_READ</td>
<td>0x40000000</td>
<td>该区块可读，可执行文件中的区块总是设置该标志。</td>
</tr>
<tr>
<td>IMAGE_SCN_MEM_WRITE</td>
<td>0x80000000</td>
<td>该区块可写。该标志没有设置，装载程序就会将内存映像也标记为可读或可执行。</td>
</tr>
</tbody></table>
<p>区块属性通过<mark class="label danger">与运算</mark>得到，如$E0000020h&#x3D;20000000h|40000000h|80000000h|00000020h$，表示该块可执行、可读、可写且包含代码。</p>
</li>
</ol>
</div>

<p>如下图是通过LordPE查看到的区块表。</p>
<p><img data-src="https://i.loli.net/2021/04/13/NilGw4fPn36g5c8.png" alt="8.png"></p>
<ul>
<li><strong>Name</strong>：区块名称。</li>
<li><strong>VOffset</strong>：区块在内存中的相对虚拟地址RVA，对应于<code>IMAGE_SECTION_HEADER</code>结构的<code>Virtual Address</code>字段。</li>
<li><strong>VSize</strong>：区块在内存中对齐前的实际区块大小。</li>
<li><strong>ROffset</strong>：区块在磁盘中的文件偏移量，对应于<code>IMAGE_SECTION_HEADER</code>结构的<code>PointerToRawData</code>字段。</li>
<li><strong>RSize</strong>：区块在磁盘空间中的大小。</li>
<li><strong>Flags</strong>：区块属性。</li>
</ul>
<h3 id="4-2-区块合并"><a href="#4-2-区块合并" class="headerlink" title="4.2 区块合并"></a>4.2 区块合并</h3><p>一般来说，一个PE文件会包含至少代码块（Borland链接器使用的是“code”而非微软的“text”）和数据块两个区块，诶个区块都有特定的名字用于区别区块的用途，<strong>区块在映像中是按照RVA排列的</strong>。EXE和OBJ文件一些常见的区块表如下图：</p>
<p><img data-src="https://i.loli.net/2021/04/13/a1SbHkumvYpWh9X.png" alt="9.png"></p>
<p><img data-src="https://i.loli.net/2021/04/13/DkMS2tlqpchIG1Q.png" alt="10.png"></p>
<div class="note warning"><p><mark class="label info">区块事实上就是相同属性数据的组合，</mark><mark class="label danger">当区块载入到（虚拟）内存中的时候，相同一个块表对应的内存页都将被赋予相同的页属性，</mark><mark class="label success">事实上Windows 系统对内存属性的设置是以页为单位的进行的，块表在内存的对齐的单位必须是一个页的大小或者是一个页的正整数倍。</mark></p>
<p>区块在磁盘中没有这个设置属性的限制，因为磁盘中排放的是以空间为主导，在磁盘只是存放，不是使用，所以不用设置那么详细的属性。</p>
<p>链接器能够合并区块，如果两个区块有相似或者一致的属性，那么他们在链接时就能够合并为一个区块。 但不应该将.<code>rsrc</code>、<code>.reloc</code>、<code>.pdata</code>合并到其他区块。</p>
</div>

<h3 id="4-3-区块的对齐"><a href="#4-3-区块的对齐" class="headerlink" title="4.3 区块的对齐"></a>4.3 区块的对齐</h3><p>区块的大小是需要对齐的，有两种对齐值，PE文件头的<code>FileAlignment</code>、<code>SectionAlignment</code>指出了这两个值。</p>
<ul>
<li>在磁盘内对齐，即文件对齐；</li>
<li>在内存中对齐。</li>
</ul>
<p><strong>一、在磁盘中对齐</strong></p>
<p>在PE文件头里，<code>FileAlignment</code>定义磁盘区块的对齐值，<mark class="label danger">每一个区块从对齐值的倍数的偏移位置开始存放</mark>。而区块的实际代码或数据的大小不一定刚好是这么多，所以在多余的地方一般以<code>00h </code>来填充，这就是区块间的间隙。在PE文件中，一个典型的对齐值是<code>200h</code>，这样每个区块从<mark class="label default">200h的倍数</mark>的文件偏移位置开始。<mark class="label default">一个物理扇区的大小作为对齐粒度，512字节， 即200h</mark></p>
<p>假设区块的第1个节在<code>400h</code>处，长度为<code>90h</code>，那么<code>400h~490h</code>为这 一区块的内容， 而文件对齐值是<code>200h</code>为了使这一节的长度为<code>FleAlignment</code>的整数倍，<code>490h~600h</code>会被<code>0</code>填充，这段空间称为区块间隙，下一个区块的开始地址为<code>600h</code>。</p>
<p><strong>二、在内存中对齐</strong></p>
<p>在PE文件头里，<code>Sctionlignment</code>定义了内存中区块的对齐值。<mark class="label danger">当PE文件被映射到内存中时，区块总是至少从一个页边界处开始</mark>。也就是说，当一个PE文件被央射到内存中时，每个区块的第1个字节对应于某个内存页。</p>
<ul>
<li>在x86系列CPU中，内存页是按4KB （<code>1000h</code>）排列的,所以，在x86系统中，PE文件区块的内存对齐值般为<code>1000h</code>，每个区块从<code>1000h</code>的倍数的内存偏移位置开始。</li>
<li>在x64中， 内存页是按8KB（<code>2000h</code>）排列的。</li>
</ul>
<div class="note warning"><p>内存页有两种对齐方式：</p>
<ol>
<li>除非使用<code>/OPT:NOWIN98</code>或<code>/ALIGN</code>开关，否则<mark class="label info"><code>Visual Studio 6.0</code></mark>中的默认值都是<mark class="label success">4KB</mark>。</li>
<li>而<mark class="label info"><code>Visual Studio .NET</code></mark>链接器依然使用默认的<code>/OPT:WIN98</code>开关，<code>.NET</code>文件的内存对齐值为<mark class="label success">8KB</mark>，而不是普通x86平台上的4KB，这样就保证了在x86平台上编译的程序可以在x64平台上运行。如果内存对齐值为4KB，那么x64加载器就不能载入这个程序了，因为64位Windows中的内存页大小是8KB。但如果文件大小<strong>小于</strong>特定值，就会以<code>200h</code>为对齐值。</li>
</ol>
<p>8kb对齐的内存页对于4kb对齐的32位系统来说也能够对齐，但是对于4kb对齐的内存页，8kb不一定能对齐。比如<code>Visual Studio 6.0</code> 编译的某程序的某个区块长度为12kb，在32位系统的4kb对齐方式中可以使用，但是移植到64位系统中无法运行。</p>
<p>可以建立一个区块在文件中的偏移与在内存中的偏移相同的PE文件。虽然这样做会使可执行文件变大，但是可以提高载入速度。<code>Visual Studio 6.0</code>的默认选项<code>/OPT:WIN98</code>将使PE文件（文件对齐为<code>8kb</code>）按照这种方式来创建。在<code>Visual Studio .NET</code>中，链接器可以不使用<code>/0PT:NOWIN98</code>开关，这取决于文件是否足够小。</p>
</div>

<p><strong>区块的尺寸</strong></p>
<p>主要有2个方面：</p>
<ul>
<li>磁盘映像和内存映像中块表对齐存储单位的不同而导致了长度不同</li>
<li>对于包含为初始化数据的块表处理问题，既然是没有初始化，那么没有必要为其在磁盘中浪费空间资源，但是在内存中不同，程序一旦运行，之前没有初始化的数据便有可能要被赋值初始化，那么就必须为他们留下空间。</li>
</ul>
<p><strong>不进行映射的块表</strong></p>
<p>有些块表并不需要映射到内存中，例如<code>.reloc</code>块表，重定位数据对于文件的执行代码是透明的，它只是提供Windows装载器使用执行代码根本不会去访问他们，所以没有必要将他们映射到物理内存中。</p>
<p>【<a target="_blank" rel="noopener" href="https://blog.csdn.net/lj94093/article/details/50504061">PE文件详解（二）–节表和节</a>】</p>
<h3 id="4-4-文件偏移与虚拟地址的转换"><a href="#4-4-文件偏移与虚拟地址的转换" class="headerlink" title="4.4 文件偏移与虚拟地址的转换"></a>4.4 文件偏移与虚拟地址的转换</h3><p>如下图是通过LordPE查看到的区块表。</p>
<p><img data-src="https://i.loli.net/2021/04/13/NilGw4fPn36g5c8.png" alt="8.png"></p>
<ul>
<li><strong>Name</strong>：区块名称。</li>
<li><strong>VOffset</strong>：区块在内存中的相对虚拟地址RVA，对应于<code>IMAGE_SECTION_HEADER</code>结构的<code>Virtual Address</code>字段。</li>
<li><strong>VSize</strong>：区块在内存中对齐前的实际区块大小。</li>
<li><strong>ROffset</strong>：区块在磁盘中的文件偏移量，对应于<code>IMAGE_SECTION_HEADER</code>结构的<code>PointerToRawData</code>字段。</li>
<li><strong>RSize</strong>：区块在磁盘空间中的大小。</li>
<li><strong>Flags</strong>：区块属性。</li>
</ul>
<div class="note primary"><p><strong>文件偏移与虚拟地址是否需要转换？</strong></p>
<ol>
<li>若PE文件的磁盘对齐值与内存对齐值相同，同一数据在PE文件与内存中的偏移量相同，则不需要转换；</li>
<li>若PE文件的磁盘对齐值与内存对齐值不同，如磁盘对齐值为<code>200h</code>，内存对齐值<code>1000h</code>，则需要进行转换。<ul>
<li><mark class="label primary">虚拟地址和虚拟大小是指该区块在内存中的地址和大小。</mark></li>
<li><mark class="label primary">物理地址和物理大小是指该区块在磁盘文件中的地址和大小。</mark></li>
</ul>
</li>
</ol>
</div>

<ul>
<li><mark class="label success">区块事实上就是相同属性数据的组合。当区块被装入到内存中的时候，相同一个节所对应的内存页都将被赋予相同的页属性。</mark></li>
<li><mark class="label danger">事实上，Windows 系统对内存属性的设置是以页为单位进行的，所以一个区块在内存中对齐单位必须至少是一个页的大小。</mark></li>
</ul>
<p><img data-src="https://i.loli.net/2021/04/16/PBC5TmNopiJRMLj.png" alt="11.png"></p>
<div class="note info"><p><strong>文件偏移与虚拟地址转换规则：</strong></p>
<p>文件被映射到内存中时，<mark class="label success">MS_DOS头部</mark><mark class="label warning">PE文件头</mark><mark class="label info">和块表</mark>的偏移位置与大小均没有变化，而当各他区块被映射到内存中后，其偏移位置就发生了变化。</p>
<p>例如，磁盘文件中<code>.text</code>块起始端与文件头的偏移量为add1，映射到内存后，<code>.text</code>块起始端与文件头（基地址）的偏移量为add2。同时，<code>.text</code>块与块表之间形成了一大段空隙，这部分数据全是以<code>0</code>填充的。</p>
<p>在这里，add1的值就是文件偏移地址（File Offset），add2的值就是相对虚拟地址( RVA )。假设它们的差值为$\Delta{k}$（填充量的长度），则文件偏移地址与虚拟地址的关系如下。</p>
<p>$$File\ Offset&#x3D; RVA - \Delta{k}$$</p>
<p>$$File\ Offset&#x3D; VA - ImageBase - \Delta{k}$$</p>
<ul>
<li>在同一区块中，各地址的偏移量是相等的，可用上面的公式对此区块中的任意<code>File Offset</code>与<code>VA</code>进行转换。</li>
<li>但请不要错误地认为在整个文件里<code>File Offset</code>与<code>VA</code>的差值是$\Delta{k}$，因为不同的区块填充的<code>0</code>的个数不一样占的页也不一样，各区块在内存中是以一个页边界开始的，从第1个区块的结束到第2个区块的开始( 1000h对齐处)全以数据0填充，所以不同区块在磁盘与内存中的差值不同。</li>
</ul>
</div>

<p><strong>方法二：RVA --&gt; FOA</strong>（File Offset，目标在PE文件的地址）</p>
<ol>
<li>步骤一：定位目标RVA属于哪一个区块。循环扫描区块表得出每个区块在内存中的起始 RVA（根据IMAGE_SECTION_HEADER 中的VirtualAddress 字段），并根据区块的大小（根据IMAGE_SECTION_HEADER 中的SizeOfRawData 字段）算出区块的结束 RVA（两者相加即可），最后判断目标 RVA 是否落在该区块内。</li>
<li>步骤二：通过步骤一定位了目标 RVA 处于具体的某个区块中后，那么用目标 RVA 减去该区块的起始 RVA ，这样就能得到目标 RVA 相对于起始地址的偏移量 $RVA_2$。</li>
<li>步骤三：在区块表中获取该区块在文件中所处的偏移地址，即文件偏移（根据IMAGE_SECTION_HEADER 中的PointerToRawData 字段）, 将这个文件偏移值加上步骤二得到的 $RVA_2$ 值，就得到了转换后的文件偏移地址。</li>
</ol>
<p>这是因为填充都是在最后进行填充。</p>
<h2 id="5-输入表"><a href="#5-输入表" class="headerlink" title="5 输入表"></a>5 输入表</h2><ol>
<li>可执行文件使用来自其他DLL的代码或数据的动作称为输入。当PE文件被载入内存时，Windows加载器的工作之一就是定位所有被输入的函数和数据，并让正在载入的文件可以使用那些地址。这个过程是通过PE文件的输入表（ImportTable，简称“IT”，也称导入表）完成的。输入表中保存的是<mark class="label info">函数名</mark>和其驻留的<mark class="label info">DLL名</mark>等动态链接所需的信息。</li>
<li>导入表是PE数据组织中的一个很重要的组成部分，<mark class="label warning">它是为实现代码重用而设置的</mark>。通过分析导入表数据，可以获得诸如PE文件的指令中调用了多少外来的函数，以及这些外来函数都存在于哪些动态链接库里等信息。Windows 加载器在运行PE时会将导入表中声明的动态链接库一并加载到进程的地址空间，并修正指令代码中调用的函数地址。</li>
<li>输入函数，表示被程序调用但是它的代码不在调用者程序代码中的，而在dll中的函数。对于这些函数，<mark class="label default">磁盘上的可执行文件只是保留相关的函数信息，如函数名，dll文件名等</mark>，故调用者程序中只保留相关的函数信息，例如函数名、DLL文件名等。在程序运行前，程序是没有保存这些函数在内存中的地址。当程序运行起来时，<mark class="label danger">Windows加载器会把相关的dll装入内存</mark>，并且将输入函数的指令与函数真在内存中正的地址联系起来。<strong>输入表（导入表）就是用来保存这些函数的信息的</strong>。</li>
</ol>
<p><strong>如何定位到输入表：</strong></p>
<ol>
<li>由DOS头定位到PE头。</li>
<li>由PE头定位到PE头中的中的可选头<code>IMAGE_OPTIONAL_HEADER32</code>结构中取出数据目录表，并从第二个数据目录中得到导入表的RVA。</li>
</ol>
<h3 id="5-1-输入函数的调用"><a href="#5-1-输入函数的调用" class="headerlink" title="5.1 输入函数的调用"></a>5.1 输入函数的调用</h3><div class="note primary"><ol>
<li><p>调用DLL文件的函数原理？</p>
<p>程序在调用DLL文件里函数的时候，<mark class="label warning">并不是把函数编译到当前程序中，而是把函数的地址保存到了当前文件中</mark>，在文件当中，对应的函数地址部分存放的是函数名称。</p>
</li>
<li><p>一个进程空间的EXE、DLL文件如何被加载到内存？</p>
<ul>
<li>用<code>LoadLibraryA</code>显示加载DLL文件，操作系统把EXE调用到内存中后，根据EXE中需要调用的DLL文件，再把DLL调用进内存中。</li>
<li><code>HMOULE</code>等于的是DLL文件的<code>IMAGEBASE</code>，也就是首地址。</li>
<li><code>GetProcessAddr(HMOUDLE,fun1); </code>就拿到DLL中对应的函数地址。</li>
</ul>
</li>
<li><p>EXE文件调用的动态链接库在内存和在硬盘中的区别？</p>
<p>函数地址的不同，加载到内存中是一个具体的函数地址，而在硬盘中是一个函数名称，通过函数名称加载得到函数地址。</p>
</li>
</ol>
</div>

<div class="note info"><p>在汇编代码层输入函数函数的高效与低效调用：</p>
<ul>
<li><p>高效调用：<code>call DWORD PTR [00402010] </code></p>
</li>
<li><p>低效调用：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call <span class="number">00401164</span></span><br><span class="line">:<span class="number">00401164</span></span><br><span class="line">  JMP DWORD <span class="keyword">PTR</span> [<span class="number">00402010</span>] </span><br></pre></td></tr></table></figure></li>
</ul>
<p>默认情况下，对被输入函数的调用将使用低效的形式。</p>
</div>

<h3 id="5-2-输入表的结构"><a href="#5-2-输入表的结构" class="headerlink" title="5.2 输入表的结构"></a>5.2 输入表的结构</h3><div class="note danger"><p>DLL显示链接与隐式链接：</p>
<ul>
<li>显示链接：程序运行期间由<code>LoadLibraryA</code>函数显示加载，用<code>FreeLibrary()</code>来释放。</li>
<li>隐式链接：程序运行前由Windows加载器完成。</li>
</ul>
</div>

<p>【<a target="_blank" rel="noopener" href="https://blog.csdn.net/u010154760/article/details/45691541?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&spm=1001.2101.3001.4242">dll中的隐式链接和显式链接的区别</a>】</p>
<p>在<code>IMAGE_OPTIONAL_HEADER.DataDirectory[1].IMAGE_IMPORT_DESCRIPTOR</code>为输入表的结构。</p>
<p>输入表的结构为<code>IMAGE_IMPORT_DESCRIPTOR</code>（IID），<mark class="label success">且输入表是一个数组</mark>，在这个数组中，没有字段指出该结构数组的项数，但它的最后一个单元是 <code>NULL</code>，由此可以计算出该数组的项数。例如，某个PE文件从两个DLL文件中引入函数，因此该PE文件存在两个IID结构来描述这些DLL。</p>
<div class="note danger"><ul>
<li>每个被PE文件隐式链接的DLL都有一个IID，PE文件导入<code>N</code>个DLL文件，就有<code>N</code>个导入表，就有<code>N+1</code>个IID，最后一个是<code>NULL</code>。</li>
<li>显示链接的DLL是在载入内存后动态加载的，无输入表。</li>
</ul>
</div>

<p>输入表结构体<code>IMAGE_IMPORT_DESCRIPTOR</code>（IID）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">	_ANONYMOUS_UNION <span class="class"><span class="keyword">union</span> &#123;</span>              <span class="comment">//00h</span></span><br><span class="line">		DWORD Characteristics;</span><br><span class="line">		DWORD OriginalFirstThunk;           <span class="comment">//桥1</span></span><br><span class="line">	&#125; DUMMYUNIONNAME;</span><br><span class="line">	DWORD TimeDateStamp;                  <span class="comment">//04h</span></span><br><span class="line">	DWORD ForwarderChain;                 <span class="comment">//08h</span></span><br><span class="line">	DWORD Name;                           <span class="comment">//0Ch</span></span><br><span class="line">	DWORD FirstThunk;                     <span class="comment">//10h，桥2</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR,*PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<div class="note default"><ol>
<li><strong>OriginalFirstThunk（Characteristics）</strong>：双字，是一个RVA，指向输入名称表（Import Name Table，INT）  INT是一个    <code>IMAGE_THUNK_DATA</code>结构数组，数组每一个成员都指向<code>IMAGE_IMPORT_BY_NAME</code>结构数组的成员。这些数组都以<code>0</code>数组成员结尾简称桥1。</li>
<li><strong>TimeDateStamp</strong>：双字，是一个时间戳，但是如果该字段为0，也就是IAT和INT执行的是一个表。</li>
<li><strong>ForwarderChain</strong>：双字，链表的前一个结构，当程序引用一个DLL中的API，而这个API又引用别的DLL的API时使用，这种情况很少出现。</li>
<li><strong>Name</strong>：双字，是一个指针，指向该结构所对应的DLL文件名称（该名称以<code>\0</code>结束），即为DLL文件名称的RVA，（译注：相对一个用<code>null</code>作为结束符的ASCII字符串的一个RVA，该字符串是该导入DLL文件的名称，如：<code>KERNEL32.DLL</code>）。</li>
<li><strong>FirstThunk</strong>：双字，它指向输入地址表（简称IAT），IAT是一个<code>IMAGE_THUNK_DATA</code>结构的数组。它指向的链表定义了针对<code>Name</code>这个动态链接库引入的所有输入函数，简称桥2。</li>
</ol>
</div>

<p>IID数组如下：</p>
<p><img data-src="https://i.loli.net/2021/04/26/XawfrVtlxNS6yHc.png" alt="18.png"></p>
<div class="note warning"><p><mark class="label success">OriginalFirstThunk</mark><mark class="label danger">FirstThunk</mark><mark class="label info">INT</mark><mark class="label default">IAT</mark><mark class="label warning">IMAGE_THUNK_DATA</mark></p>
<ol>
<li><code>OriginalFirstThunk</code> --&gt; INT，<code>FirstThunk</code> --&gt; IAT；</li>
<li>INT与IAT都是<code>IMAGE_THUNK_DATA</code>结构的数组；</li>
<li>每一个<code>IAMGE_THUNK_DATA</code>元素对应于一个输入的函数，两个数组的结束都是有一个值为0的结构；</li>
<li><code>IAMGE_THUNK_DATA</code>结构不同时刻有不同的含义，每一个成员都指向<code>IMAGE_IMPORT_BY_NAME</code>结构。</li>
</ol>
</div>

<p><code>IMAGE_THUNK_DATA</code>的双字结构为（<mark class="label primary">也就是一个数组只能取下面联合体中的一种状态</mark>）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_THUNK_DATA32</span> &#123;</span> </span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span> </span><br><span class="line">    DWORD ForwarderString;      <span class="comment">// 指向一个转向者字符串的RVA </span></span><br><span class="line">    DWORD Function;             <span class="comment">// 被输入的函数的内存地址 </span></span><br><span class="line">    DWORD Ordinal;              <span class="comment">// 被输入的API的序列值 </span></span><br><span class="line">    DWORD AddressOfData;        <span class="comment">// 指向 PIMAGE_IMPORT_BY_NAME </span></span><br><span class="line">  &#125; u1; </span><br><span class="line">&#125; IMAGE_THUNK_DATA32,*PIMAGE_THUNK_DATA32;</span><br></pre></td></tr></table></figure>

<div class="note primary"><ul>
<li>每个<code>IMAGE_THUNK_DATA</code>元素对应于一个从可执行文件输入的函数。</li>
<li>当<code>IMAGE_THUNK_DATA</code>值的最高位为<mark class="label warning">1</mark>时，表示函数以序号的方式进行输入，这时候低31位（或一个64位可执行文件的低63位）的值就表示函数的序号；</li>
<li>当该类型的最高位为<mark class="label warning">0</mark>时，表示函数以字符串类型的函数名方式输入（这里的函数名指的是<code>IMAGE_IMPORT_BY_NAME</code>的<code>Name</code>），这时候值就表示一个<mark class="label primary">指向<code>IMAGE_IMPORT_BY_NAME</code>结构的RVA</mark>。</li>
</ul>
</div>

<p><code>IMAGE_IMPORT_BY_NAME</code>结构（1个字大小）如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class="line">    WORD    Hint;</span><br><span class="line">    CHAR   Name[<span class="number">1</span>];</span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure>

<p><strong>Hint</strong>：表示函数在其原始DLL文件的输出表中的序号。该域被PE装载器用来在DLL的输出表里快速查询函数。该值不是必须的。<br><strong>Name</strong>：含有输入函数的函数名。以<code>NULL</code>字符结尾。这是一个可变的大小。</p>
<p><img data-src="https://i.loli.net/2021/04/20/64KCR3xsa7EQqmw.png" alt="12.png"></p>
<div class="note success"><p><mark class="label info">INT</mark><mark class="label danger">IAT</mark></p>
<ol>
<li><mark class="label info">INT</mark>不可以改写，<mark class="label danger">IAT</mark>可以改写，由PE装载器重写。 </li>
<li>当PE文件被加载时，PE加载器会遍历INT结构中的数组项，通过其指向的<code>IMAGE_IMPORT_BY_NAME</code>结构来找到函数的名字，PE加载器可以通过函数的名字找到函数的地址，随后把得到的函数地址填充到IAT结构中。所以当PE文件装载内存后准备执行时，所有函数入口地址被排列在一起，此时输入表中其他就不重要的，依靠IAT提供地址就可以正常运行。即<mark class="label default">IAT为函数入口地址</mark>。</li>
</ol>
</div>

<p>当PE文件装载内存后准备执行时，上图将转换为下图的形式，此时输入表的其他结构已经不重要，程序依靠IAT提供的函数地址就可以正常运行。</p>
<p><img data-src="https://i.loli.net/2021/04/20/jPIEsbFz2WhD4ky.png" alt="13.png"></p>
<div class="note danger"><p><strong>PE装载器把导入函数输入至IAT的顺序</strong>：</p>
<ol>
<li>读取IID的Name成员，获取库名称字符串（如<code>Kernel32.dll”</code>）；</li>
<li>装载相应库，如<code>LoadLibrary(&quot;Kernel32.dll&quot;)</code>；</li>
<li>读取IID的OriginalFirstThunk成员，获取INT地址；</li>
<li>读取INT数组中的值，获取相应IMAGE_IMPORT_BY_NAME地址（RVA）；</li>
<li>使用IMAGE_IMPORT_BY_NAME的Hint或Name项，获取相应函数（若是Name则使用GetProcAddress函数）的起始地址；</li>
<li>读取IID的FirstThunk（IAT）成员，获得IAT的地址（方便步骤7写操作）；</li>
<li>将上面获得的函数地址入口地址（步骤5）输入相应的IAT数组值；</li>
<li>重复4-7步骤，直到INT结束（遇到NULL时）。</li>
</ol>
<p><strong>IID的FirstThunk指向IAT数组，FirstThunk的值（是个RVA）–&gt; IAT（IMAGE_THUNK_DATA）数组，IAT数组每个元素存的值对应一个函数入口地址（是个VA）。</strong></p>
</div>

<h3 id="5-3-绑定输入"><a href="#5-3-绑定输入" class="headerlink" title="5.3 绑定输入"></a>5.3 绑定输入</h3><p>双桥结构的导入表中，桥2是指向IAT的，Windows 加载程序负责IAT中地址的修正工作。 </p>
<p>如果一个PE中导入的函数比较多，那么这部分工作就会占用一些时间，PE加载速度就会变慢。绑定导入的目的就是把由Windows加载程序负责的<strong>IAT地址修正工作提前到加载前进行</strong>，要么由用户手工完成，要么由专门的程序来完成；然后，通过在PE文件中声明绑定导入数据，以便告诉操作系统加载器说这部分工作不需要你做了。</p>
<p>在磁盘中可执行文件的IAT里（文件载入内存前），有的文件IAT存放的是与DLL输出函数相关的实际内存地址（不是RVA），这样做可以使应用程序更快递进行初始化，并且使用较少的存储器。<mark class="label success">但是由Borland（TLINK）生成的文件是不能被绑定的。</mark></p>
<div class="note success"><p>那么为什么说它只是辅助性的工作呢？不同的操作系统中，动态链接库的函数地址通常是不一样的。比如<code>kernel32.dll</code>在Windows 2000中其加载到进程空间的基地址为<code>0x77e60000</code>，而在Windws XP SP3中其加载地址则是<code>0x7c800000</code>，同动态链接库加载后处于不同的基地址，直接导致了同一个导入的函数在不同操作系统中其导入地址VA是不一样的。 所以，经过绑定导人的个PE程序可能在Windows 2000里运行得很好，但到了Windows XP中却因地址出现错误而造成无法运行。</p>
</div>

<p>在为PE加入绑定导入机制的时候，微软就已经考虑到了这个问题，所以假定PE加载前对IAT的修正都是正确的。那么PE的加载速度是加快的，即使绑定以后的EXE程序在其他的兼容系统中运行时，其地址出现错误，PE加载也有检测错误的机制。<mark class="label warning">如果地址检测出错误，PE加载器会重新接管这项工作，加载时对IAT进行修正。</mark></p>
<p>微软提供了一个绑定工具<mark class="label primary">bind.exe</mark>程序，该程序可以把导入表中IAT表项<code>IMAGE_THUNK_DATA32</code>的内容都静态替换成虚拟内存地址，<mark class="label warning">然后在数据目录表的第12项指定的位置声明这些更改</mark>。Windows在加载目标PE相关的动态链接库时，会首先检查这些地址是否正确合法，这些检查包括当前系统的DLL版本是否符合绑定导入结构中描述的版本号，如果不符合或者DLL需要被重新定位，加载器就会去遍历<code>OriginalFirstThunk</code>指向的数组（也就是INT）计算新的地址。如果导入表是单桥结构，此时的遍历会失效，所以说单桥结构无法实施静态绑定操作。</p>
<div class="note info"><ol>
<li>若可执行文件无绑定输入，PE文件在装载入内存前的IAT无输入函数的实际内存地址（VA）。</li>
<li>若可执行文件有绑定输入，PE文件在装载入内存前，在磁盘中的IAT表里面就已经写入了输入函数在内存的实际地址（VA），并且会将输入表结构<code>IMAGE_IMPORT_DESCRIPTOR.TimeDateStamp</code>字段设置为<mark class="label success">-1</mark>。尽管有绑定输入，当IAT表中的函数地址发生错误或平台不兼容时，Windows加载器仍然会先通过INT表得到函数名然后找到函数地址，最后改的IAT表。</li>
</ol>
</div>

<div class="note danger"><p><strong>如何判断和定位一个可执行文件的绑定输入？</strong></p>
<ol>
<li>通过看输入表结构的TimeDataStamp字段，即若<code>IMAGE_IMPORT_DESCRIPTOR.TimeDateStamp</code>字段为<mark class="label success">0</mark>，则该DLL没有绑定输入，若为<mark class="label success">-1</mark>，则表示该DLL有绑定输入。</li>
<li>通过看数据目录表的第12个元素结构（<code>IMAGE_OPTIONAL_HEADER.DataDirectory[11] </code>即 <code>IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT</code>），该元素指向绑定输入。</li>
<li>由于数据目录表的每一个元素都包含两个属性，第一个属性是所指向数据块的RVA，第二个属性是所指向的数据块的大小。即<code>IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT</code>指向绑定输入表结构。</li>
<li>绑定输入表结构为<code>IMAGE_BOUND_IMPORT_DESCRIPTOR</code>，<mark class="label info">每一个这样的结构对应一个输入的动态链接库</mark>，它用来描述输入的DLL的版本信息以及依赖的DLL个数。</li>
</ol>
</div>

<p>参考【<a target="_blank" rel="noopener" href="https://www.cnblogs.com/iBinary/p/9745417.html">PE知识复习之PE的绑定导入表</a>】、【《Windows PE 权威指南》】</p>
<p><code>IMAGE_BOUND_IMPORT_DESCRIPTOR</code>的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_BOUND_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    DWORD   TimeDateStamp;　　　　　　　　　　　　　　　　<span class="comment">//真正的时间戳,</span></span><br><span class="line">    WORD    OffsetModuleName;　　　　　　　　　　　　　　<span class="comment">//DLL的名字. PE的文件名</span></span><br><span class="line">    WORD    NumberOfModuleForwarderRefs;　　　　　　　 <span class="comment">//依赖的另外的DLL有几个</span></span><br><span class="line"><span class="comment">// Array of zero or more IMAGE_BOUND_FORWARDER_REF follows</span></span><br><span class="line">&#125; IMAGE_BOUND_IMPORT_DESCRIPTOR,  *PIMAGE_BOUND_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>TimeDateStamp</strong>：<code>+0000h</code>，双字。该字段的值必须与要引用的DLL的文件头<code>IMAGE_FILE_HEADER.TimeDateStamp</code>字段值相吻合，否则就会促使加载器去重新计算新IAT，这种情况一般发生在DLL版本不同时或者DLL映像被重定位时。</li>
<li><strong>OffsetModuleName</strong>：<code>+0004h</code>，单字。该字段包含了以第一个<code>IMAGE_BOUND_IMPORT_DESCRIPTOR</code>作为基址，是一个指针，表示<strong>DLL名称字符串（ASCII且以<code>\0</code>结束）的偏移</strong>。注意该偏移地址是一个特殊地址，它即不是RVA，也不是FOA，而是基于上述的基地址。</li>
<li><strong>NumberOfModuleForwarderRefs</strong>：<code>+0006h</code>，单字。用来描述该结构对应的DLL所依赖的DLL的个数，并将所依赖的DLL相关信息描述紧跟在该结构的后面。所依赖的DLL结构用<code>IMAGE_BOUND_FORWARDER_REF</code>数组结构来描述。依赖几个DLL就有几个该结构的元素。也就是说，它将引入函数所涉及的所有动态链接库都列举出来。</li>
</ol>
<p>以下是结构<code>IMAGE_BOUND_FORWARDER_REF</code>的定义:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_BOUND_FORWARDER_REF</span> &#123;</span></span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    WORD    OffsetModuleName;</span><br><span class="line">    WORD    Reserved;</span><br><span class="line">&#125; IMAGE_BOUND_FORWARDER_REF, *PIMAGE_BOUND_FORWARDER_REF;</span><br></pre></td></tr></table></figure>

<p>结构与<code>IMAGE_BOUND_IMPORT_DESCRIPTOR</code>结构类似：除了最后一个属性<code>Reserved</code>被保留外，其他属性同IBID（<code>IMAGE_BOUND_IMPORT_DESCRIPTOR</code>）结构。其绑定倒入数据的组织方式如下图：</p>
<p><img data-src="https://i.loli.net/2021/04/23/LR1jrzuNdtBmDMK.png" alt="14.png"></p>
<h2 id="6-输出表"><a href="#6-输出表" class="headerlink" title="6 输出表"></a>6 输出表</h2><h3 id="6-1-输出表的作用"><a href="#6-1-输出表的作用" class="headerlink" title="6.1 输出表的作用"></a>6.1 输出表的作用</h3><p>导入表描述的是其所在PE文件中的指令调用了其他动态链接库函数的情况。输出表描述的是导出表所在PE文件向其他程序提供的可供调用的函数的情况。</p>
<p>代码重用机制提供了重用代码的动态链接库，它会向调用者说明库里的哪些函数是可以被别人使用的，<strong>这些用来说明的信息便组成了导出表。</strong></p>
<p>EXE文件中很少有导出表，大部分的DLL文件中都有导出表。所以一提到导出表，大家总是首先想到动态链接库。不能简单地认为EXE中没有导出表，例如<code>WinWord.exe</code>文件里就有；也不能简单地认为所有的DLL中都有导出表，例如一些专门存放资源文件的DLL里就没有导出表。</p>
<div class="note default"><p>Windows装载器在进行PE装载时，会将导入表中登记的所有DLL一并装入，然后根据DLL的导出表中对导入函数的描述修正导入表的IAT值。通过导出表，DLL文件向调用它的程序或系统提供导出<strong>函数的</strong><mark class="label info">名称</mark><mark class="label warning">序号</mark><mark class="label success">入口地址</mark>等信息。</p>
<p>综上所述，导出表的作用有两个:</p>
<ol>
<li>可以通过导出表分析不认识的动态链接库文件所能提供的功能（根据输出表的函数分析）。</li>
<li>向调用者提供输出函数指令在模块中的起始地址。</li>
</ol>
</div>

<div class="note success"><p><strong>输入表和输出表的关系</strong>：</p>
<ol>
<li><mark class="label info">输入表可以通过输入函数的函数名或在输出表中的序号来获取输入函数在内存的VA；</mark></li>
<li><mark class="label danger">输出表中提供了输出函数的函数名或输出表中的序号索引来供其他可执行文件进行输入调用；</mark></li>
<li>假设可执行文件A导入动态链接库B中的某个函数F。当A加载入内存后，之后Windows加载器将与此进程相关的DLL（B）加载到虛拟地址空间，会根据A的导入表中登记的与该动态链接库（A）相关的由INT指向的名称或编号来遍历DLL（B）所在虚拟地址空间，通过函数名或编号查找B的导出表结构，从而确定该导出函数F在虚拟地址空间中的起始地址VA，并将该VA覆盖A的导入表的IAT相关项。</li>
<li>在覆盖IAT的过程中，B的导出表起到了参照和指引的作用。如果一个动态链接库没有定义导出表，其内部包含的所有函数都无法被其他程序透明地调用。这里所说的透明，是指公开调用。</li>
</ol>
</div>

<h3 id="6-2-输出表的结构"><a href="#6-2-输出表的结构" class="headerlink" title="6.2 输出表的结构"></a>6.2 输出表的结构</h3><p>在一个PE文件中导入表的<code>IMAGE_IMPORT_DESCRIPTOR</code>个数与调用的动态链接库个数相等，而导出 表的<code>IMAGE_EXPORT_DIRECTORY</code>只有一个。</p>
<p>输出表的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span></span><br><span class="line">  DWORD Characteristics;       <span class="comment">//0000h，保留，恒为0x00000000</span></span><br><span class="line">  DWORD TimeDateStamp;         <span class="comment">//0004h，时间戳，导出表创建的时间（GMT时间）</span></span><br><span class="line">  WORD  MajorVersion;          <span class="comment">//0008h，导出表的主版本号，未用，一般为0</span></span><br><span class="line">  WORD  MinorVersion;          <span class="comment">//000ah，导出表的子版本号，未用，一般为0</span></span><br><span class="line">  DWORD Name;                  <span class="comment">//000ch，指向该导出表所在文件名称（模块名）的RVA，名称是ASCII字符</span></span><br><span class="line">  DWORD Base;                  <span class="comment">//0010h，导出函数序号的起始值，基数</span></span><br><span class="line">  DWORD NumberOfFunctions;     <span class="comment">//0014h，导出函数的个数</span></span><br><span class="line">  DWORD NumberOfNames;         <span class="comment">//0018h，以函数名导出的函数的个数</span></span><br><span class="line">  DWORD AddressOfFunctions;    <span class="comment">//001ch，一个RVA 值，指向导出函数入口地址表</span></span><br><span class="line">  DWORD AddressOfNames;        <span class="comment">//0020h，一个RVA 值，指向导出函数名称地址表</span></span><br><span class="line">  DWORD AddressOfNameOrdinals; <span class="comment">//0024h，函数序号地址表</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure>
<div class="note danger"><ol>
<li><p><strong>Characteristics</strong>：输出表的属性，现在没有用到，一般为0。</p>
</li>
<li><p><strong>TimeDateStamp</strong>：输出表创建的时间（GMT时间）。</p>
</li>
<li><p><strong>MajorVersion</strong>：输出表的主版本号，未用，设置为0。</p>
</li>
<li><p><strong>MinorVersion</strong>：输出表的次版本号，未用，设置为0。</p>
</li>
<li><p><strong>Name</strong>：双字，是一个指针，指向一个以<code>\0</code>结尾ASCII字符串，该字符串是输出函数所在的本文件最初的文件名。</p>
</li>
<li><p><strong>Base</strong>：DLL中第一个输出函数并不是从0开始的，该值一般设置为1，但是当通过序数来查询一个输出函数时使用到这个值（不一定为1），表示导出函数序号的起始值，导出函数序号 &#x3D; 函数入口地址数组下标索引值（<strong>AddressOfNameOrdinals</strong>指向的索引值） + 起始值。假如Base 字段的值为x，那么入口地址表指定的第1个导出函数的序号就是x+0；第2个导出函数的序号就是x＋1。其结果作为进入输出地址表（EAT）的索引。</p>
</li>
<li><p><strong>NumberOfFunctions</strong>：该PE文件导出函数的个数，也就是EAT的条目数目。</p>
</li>
<li><p><strong>NumberOfNames</strong>：以函数名输出的函数的个数，即输出函数名称表（ENT）里条目的数量。</p>
</li>
<li><p><strong>AddressOfFunctions</strong>：EAT的RVA，该指针指向全部导出函数的起始入口地址。EAT数组中每一个非0的RVA值指针都对应于一个被输出的函数。</p>
</li>
<li><p><strong>AddressOfNames</strong>：ENT的RVA，ENT是一个指向输出函数名ASCII字符串的RVA的数组。每一个ASCII字符串对应于一个通过函数名输出的函数。这个表需要对ASCII字符串进行排序，这允许加载器可以通过二进制查找方式查找输出函数名。</p>
</li>
<li><p><strong>AddressOfNameOrdinals</strong>：双字大小的指针，输出序数表（索引值）的RVA。这个数组表的每个元素是字大小的，即索引值是一个字大小，<mark class="label danger">他将ENT的数组索引映射到相应的输出地址表条目里</mark> 。索引值&#x3D;函数的编号-<strong>Base</strong>。</p>
<p>导出序号<code>AddressOfNameOrdinals</code>指向的也是到处序号列表地址，其中的每个序号与导出函数名称一一对应，代表了这个函数名称对应的函数在导出函数列表里序号。</p>
</li>
</ol>
</div>

<p>设计输出表是为了<mark class="label default">方便PE装载器工作</mark>。首先，模块必须保存所有输出函数的地址，供PE装载器查询。模块将这些信息保存在<code>AdressOfFunctions</code>域所指向的数组中，而数组元素数目存放在<code>NumberOfFunctions</code>域中。如果模块引出了40个函数，那么在<code>AdressOfFunctions</code>指向的数组中必定有40个元素，<code>NumberOfFunctions</code>的值为40。如果有些函数是通过名字引出的，那么模块必定也在 文件中保留了这些信息。这些名字的RVA值存放在一个数组中，供PE装载器查询。该数组由<code>AddressOfNames</code>指向，<code>NumberOfNames</code>中包含名字数目。PE装载器知道函数名，并想以此获取这些函数的地址。<mark class="label default">目前已有两个模块，分别是名字数组和地址数组，但两者之间还没有联系的纽带，需要一些联系函数名及其地址为它们建立联系。PE文档指出，可以使用指向地址数组的索引作为连接，因此PE装载器在名字数组中找到匹配名字的同时，也获取了指向地址表中对应元素的索引。这些索引保存在由AddressOfNameOrdinals域所指向的另一个数组中</mark>。由于该数组起联系名 字和地址的作用，其元素数目一定与名字数组相同。 例如，每个名字有且仅有1个相关地址，反过 来则不一定（一个地址可有好几个名字来对应）。因此，需要给同一个地址取“别名”。 为了发挥连接作用，名字数组和索引数组必须并行成对使用，例如索引数组的第1个元素必定含有第1个名字的索引，依此类推。</p>
<p>即现在有函数名称表<code>AddressOfNames</code>和函数地址表<code>AdressOfFunctions</code>，想要通过函数名称得到函数的入口地址，中间通过一个索引值（<code>AddressOfNameOrdinals</code>数组的值）来进行连接。因为<code>AddressOfNames</code>的值与<code>AddressOfNameOrdinals</code>的值一一对应，也就是一个函数名称对应一个索引值，同时<code>AdressOfFunctions</code>记录了某个函数对应的入口地址和其地址索引值，最后通过<code>AddressOfNameOrdinals</code>的索引值与<code>AdressOfFunctions</code>的索引值得到函数入口地址。</p>
<div class="note warning"><p>输入表中<code>IMAGE_IMPORT_BY_NAME.Hint</code>的值为输出表中<code>IMAGE_EXPORT_DIRECTORY.AddressOfNameOrdinals</code>的索引值。</p>
</div>

<p>PE输出表的结构如下：</p>
<p><img data-src="https://i.loli.net/2021/04/23/kpdzR81nqivoBxP.png" alt="17.png"></p>
<p><img data-src="https://i.loli.net/2021/04/23/TXbimPz963nxUrZ.png" alt="15.png"></p>
<p><img data-src="https://i.loli.net/2021/04/23/2TvYDpwzFX8ch1W.png" alt="16.png"></p>
<h3 id="6-3-查找输出函数的入口地址"><a href="#6-3-查找输出函数的入口地址" class="headerlink" title="6.3 查找输出函数的入口地址"></a>6.3 查找输出函数的入口地址</h3><div class="note info"><p><strong>注意</strong>：<code>AddressOfNames</code>的索引等于<code>AddressOfNamesOrdinals</code>的索引，但是不等于地址索引，目的就是要通过<code>AddressOfNames</code>的索引得到地址索引，最后得到到处函数的入口地址。</p>
<p><code>AddressOfNames</code>和<code>AddressOfNameOrdinals</code>：</p>
<ul>
<li>均为RVA 值。</li>
<li>前者指向函数名字符串地址表。这个地址表是一个双字数组，<mark class="label warning">数组中的每一项指向一个函数名称字符串的RVA</mark>。数组的项数等<code>NumberOfNames</code>字段的值，所有有名称的导出函数的名称字符串都定义在这个表中。</li>
<li>后者指向另一个word类型的数组（注意不是双字数组）。数组项目与文件名地址表中的项目一一对应，数组项目值代表函数入口地址表的索引，这样函数名称与函数入口地址关联起来。</li>
</ul>
<p>举个例子，假如函数名称字符串地址表的第n项指向一个字符串“MyFunction”，那么可以去查找<code>AddressOfNameOrdinals</code>指向的数组的第n项，假如第n项中存放的值是x，则表示<code>AddressOfFunctions</code>字段描述的地址表中的第x项函数入口地址对应的名称就是“MyFunction”。</p>
</div>

<p><strong>一、按函数名称导出</strong></p>
<ol>
<li>由DOS头定位到PE头。</li>
<li>由PE头定位到PE头中的中的可选头<code>IMAGE_OPTIONAL_HEADER32</code>结构中取出数据目录表，并从第一个数据目录中得到导出表的RVA并转换为FOA。</li>
<li>从导出表的<code>NumberOfNames</code>字段得到已命名函数的总数，并以这个数字作为循环的次数来构造一个循环。</li>
<li>从<code>AddressOfNames</code>字段指向得到的函数名称地址表的第一项开始，在循环中将每一项定义的函数名与要查找的函数名相比较，如果没有任何一个函数名是符合的，表示文件中没有指定名称的函数，否则执行下一步骤。</li>
<li>如果某一项定义的函数名与要查找的函数名符合，那么记下这个函数名在字符串地址表中的索引值（数组下标），然后通过索引号再去检索<code>AddressOfNamesOrdinals</code>指向的数组，从同样索引的位置找到函数的地址索引。我们这里假设这个值是x。</li>
<li>最后，以 x 值作为索引值，在<code>AddressOfFunctions</code>字段指向的函数入口地址表中获取的 RVA ，这个RVA 值加上模块实际装入的基地址，就得到了函数真正的入口地址。</li>
</ol>
<p><strong>二、按函数索引导出</strong></p>
<ol>
<li>由DOS头定位到PE头。</li>
<li>由PE头定位到PE头中的中的可选头<code>IMAGE_OPTIONAL_HEADER32</code>结构中取出数据目录表，并从第一个数据目录中得到导出表的RVA并转换为FOA。</li>
<li>从导出表的 Base 字段得到起始序号。</li>
<li>将需要查找的导出序号减去起始序号，得到函数在入口地址表中的索引。</li>
<li>检测索引值是否大于导出表的<code>NumberOfFunctions</code>字段的值，如果大于后者的话，说明输入的序号是无效的。</li>
<li>用这个索引值在<code>AddressOfFunctions</code>字段指向的导出函数入口地址表中取出相应的项目，这就是函数入口地址的RVA 值，当函数被装入内存的时候，这个RVA 值加上模块实际装入的基地址，就得到了函数真正的入口地址。</li>
</ol>
<div class="note warning"><p>以上的1、2步骤具体操作如下：</p>
<p>1、先使用PE工具定位到PE文件数据目录表（Directory）的初始地址，然后定位到数据目录项的第一项（输出表为前8个字节），因为数据目录表的描述结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;  <span class="comment">//数据起始RVA，是所指向的数据块RVA。</span></span><br><span class="line">    DWORD   Size;            <span class="comment">//数据块长度，所指向的数据块的大小。</span></span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>每8个字节为这样一个结构，每个这样的结构描述一个Directory[15]数组元素，以一个元素来举例，如Directory[0]为输出表，其对应的8个字节（双字）为<code>40 21 00 00 8F 00 00 00</code>，则表示：</p>
<ul>
<li>输出表所在的地址为RVA&#x3D;<code>0x00002140</code>，输出表的大小为<code>0000008F</code>个字节。</li>
<li>然后将RVA转换为FOA（文件偏移地址）。</li>
<li>用PE工具查看PE文件每一个块对应的RVA和FOA，然后使用以上第二步的FOA值定位到其所处的区块（辅助，不一定非要此步骤）。</li>
<li>在PE文件中从已经定位到的FOA地址开始，然后对照着输出表的结构，去查看每一个<code>IMAGE_EXPORT_DIRECTORY</code>成员对应的字节码是什么即可。</li>
</ul>
</div>

<h2 id="7-基址重定位"><a href="#7-基址重定位" class="headerlink" title="7 基址重定位"></a>7 基址重定位</h2><p>程序被装入内存时，其基址是由字段<code>IMAGE_OPTIONAL_HEADER32.ImageBase</code>决定的。当链器生成一个PE文件时， 会假设这个文件在执行时被装载到默认的基地址处（ImageBase在编译链接时写入PE文件），并把code和data的相关地址都写入PE文件。如果载入时将默认的值作为基地址载人，则不需要重定位。但是，如果当装载时该位置已经被别的程序使用，链接器登记的那个地址就是错误的，那么操作系统就有权重新选择一个基地址。这时候就需要对所有的重定位信息进行修正，而修正的依据就是PE中的重定位表。在PE文件中，重定位表往往单独作为一块，用<code>.reloc</code>表示。</p>
<div class="note primary"><p><mark class="label danger">系统的DLL</mark>实际不会发生重定位，因为同一系统的kernel32.dll、user32.dll等会被加载到自身固有的ImageBase。</p>
</div>

<h3 id="7-1-基址重定位的概念"><a href="#7-1-基址重定位的概念" class="headerlink" title="7.1 基址重定位的概念"></a>7.1 基址重定位的概念</h3><p>PE格式不参考外部DLL或模块中的其他区块，<mark class="label default">而是把文件中所有可能需要修改的地址放在一一个数组里</mark>。如果PE文件不在首选的地址载入，那么文件中的每一个定位（如全局变量地址）都需要被修正。对加载器来说，它不需要知道关于地址使用的任何细节，只要知道有一系列的数据需要以某种致的方式来修正就可以了。</p>
<div class="note warning"><ul>
<li>对EXE文件来说，每个文件总是使用独立的虚拟地址空间，所以EXE总是能够按照这个地址载入，这意味着EXE文件不再需要重定位信息。</li>
<li>对DLL来说，因为多个DLL文件使用宿主EXE文件的地址空间，不能保证载入地址没有被其他DLL使用，所以DLL文件中必须包含重定位信息， 除非用一个<code>/FIXED</code>开关来忽略它们。</li>
<li>在Visual Studio .NET中，链接器会为Debug和Release模式的EXE文件省路基址重定位，因此，在不同系统中跟踪同一个DLL文件时，其虚拟地址是不同的。</li>
</ul>
</div>

<blockquote>
<p>假设test.exe可执行程序需要三个动态链接库dll（a.dll，b.dll，c.dll），由于一个dll中的需要修正的地址不止一两个，可能有很多，所以用一张表记录那些“写死”的地址，将来加载进内存时，可能需要一一修正，这张表称作为重定位表，一般每一个PE文件都有一个重定位表。当加载器加载程序时，如果加载器为某PE（.exe、.dll）分配的基址与其自身默认记录的ImageBase不相同，那么该程序文件加载完毕后就需要修正重定位表中的所有需要修正的地址。如果加载器分配的基址和该程序文件中记录默认的ImageBase相同，则不需要修正，重定位表对于该dll也是没有效用的。比如test.exe和a.dll的重定位表都是不起作用的（由于一般情况.exe运行时被第一个加载，所以exe文件一般没有重定位表，但是不代表所有exe都没有重定位表）。同理如果先加载b.dll后加载a.dll、c.dll，那么b.dll的重定位表就不起作用了。</p>
</blockquote>
<h3 id="7-2-基址重定位表的结构"><a href="#7-2-基址重定位表的结构" class="headerlink" title="7.2 基址重定位表的结构"></a>7.2 基址重定位表的结构</h3><p>基址重定位表的结构用一个<code>IMAGE_BASE_RELOCATION</code>数组来描述，基址重定位表位于数据目录表的的第<mark class="label primary">6</mark>个数据目录项中，即<code>Directore[5].IMAGE_BASE_RELOCATION</code>。基址重定位数据组织方法采用类似按页分割的方法，其许多重定位块串接在成的，每个块存放4KB（1000h）大小的重定位信息，每个重定位数据块的大小必须以DWORD（4字节）对齐，他们以<code>IMAGE_BASE_RELOCATION</code>结构开始，格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_BASE_RELOCATION</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;   <span class="comment">//重定位数据开始RVA地址</span></span><br><span class="line">    DWORD   SizeOfBlock;      <span class="comment">//重定位块的长度</span></span><br><span class="line">    WORD    TypeOffset;       <span class="comment">//重定项位数组</span></span><br><span class="line">&#125; IMAGE_BASE_RELOCATION;</span><br></pre></td></tr></table></figure>

<div class="note info"><ol>
<li><p><strong>VirtualAddress</strong>：这是一组重定位数据的开始RVA地址，各重定位项的地址加上这个值才是重定位项完整的RVA地址。</p>
</li>
<li><p><strong>SizeOfBlock</strong>：是当前重定位结构的大小，因为<code>VirtualAddress</code>和<code>SizeOfBlock</code>大小都是固定的4个字节，因此这个项减去8字节，则是<code>TypeOffset</code>大小。</p>
</li>
<li><p><strong>TypeOffset</strong>：是一个数组。数组每项大小为<mark class="label success">2</mark>个字节，共16位，它又分为高4位与低12位，<mark class="label warning">高4位代表重定位类型</mark>，<mark class="label warning">低12位是重定位的地址</mark>，低12位与<code>VirtualAddress</code>相加即是指向PE映像中需要修改地址数据的指针RVA。</p>
<p><mark class="label danger">高4位的和的值</mark>代表所指定的Type：</p>
<ul>
<li>PE文件中常见的值为<mark class="label success">3h</mark> --&gt; <code>IMAGE_REL_BASED_HIGHLOW</code>。</li>
<li>64位的PE文件中常见值为<mark class="label success">Ah</mark> --&gt; <code>IMAGE_REL_BASED_DIR64</code>。</li>
</ul>
</li>
</ol>
</div>

<p>常见的重定位类型如下图所示。虽然有多种重定位类型，但对x86可执行文件来说，所有的基址重定位类型都是<code>IMAGE_REL_BASED HIGHLOW</code>。在一组重定位结束的地方会出现一个类型是<code>IMAGE_REL_BASED_ABSOLUTE</code>的重定位，这些重定位什么都不做，只用于填充，以便下一一个<code>IMAGE_BASE_RELOCATION</code>按4字节分界线对齐。所有重定位块以一个<code>VirtualAddress</code>字段为<mark class="label success">0</mark> 的<code>IMAGE_BASE_RELOCATION</code>结构结束。</p>
<p><img data-src="https://i.loli.net/2021/04/26/NlXRc4OMIexfVKs.png" alt="19.png"></p>
<p>重定位表的结构如图11.23所示，它由数个<code>IMACE_BASE_RELOCATION</code>结构组成，每个结构由VirtualAddress、SizeOfBlock和TypeOffset 3部分组成。</p>
<p><img data-src="https://i.loli.net/2021/04/26/OFsglcfM93YnLuP.png" alt="20.png"></p>
<div class="note danger"><p>对于IA-64可执行文件，重定位类型似乎总是<code>IMAGE_REL_BASED_DIR64</code>。就像x86重定位， 也用<code>IMAGE_REL_BASED_ ABSOLUTE</code>重定位类型进行填充。有趣的是，<mark class="label info">尽管IA-64的EXE页大小是8KB，但基址重定位仍是4KB的块</mark>。</p>
</div>

<h3 id="7-3-基址重定位表的实例分析"><a href="#7-3-基址重定位表的实例分析" class="headerlink" title="7.3 基址重定位表的实例分析"></a>7.3 基址重定位表的实例分析</h3><p>以DllDemo.dll为例，数据目录表中的第6个元素指向的重定位表指针为<code>0x00005000h</code>，转换为文件偏移为<code>0x00000E00h</code>，在PE文件中取到的<code>IMAGE_BASE_RELOCATION</code>结构内容如图11.24。</p>
<p><img data-src="https://i.loli.net/2021/04/27/Wsy4h6O1jFCKxJG.png" alt="21.png"></p>
<p><img data-src="https://i.loli.net/2021/04/27/l2ftZeTVI5PJCnx.png" alt="22.png"></p>
<p>如此，得到需要修改的地址RVA后，加上PE文件装载内存的基地址，即可得到需要被重定位的地址。有两种方式查看该地址载入内存后被重定位后的地址：</p>
<ol>
<li>根据上述的图计算得到发生被重定位的地址的RVA，然后加上PE文件载入内存基址，即可得到发生被重定位的VA，最后可以使用OD去查看该地址处对应的内容，可能是全局变量发生地址重定位。</li>
<li>使用工具PEView：<ul>
<li>根据上述的图计算得到$RVA$。</li>
<li>$RVA+ImageBase&#x3D;VA_1$。（文件发生重定位前的地址，因为ImageBase是在编译器生成可执行文件时写死的，不是PE文件载入内存后的才写入的）。使用PE工具查看$VA_1$地址内的内容，如下图图1中$VA_1$的值为<code>0x01001420</code>，地址里面的数据为<code>0x010010C4</code>。</li>
<li>$0x010010C4-ImageBase(0x01000000)&#x3D;VA_2(0x000010C4)$。</li>
<li>加上装载基地址：$0x000010C4+0x00270000&#x3D;0x002710C4$，该地址（$VA_2$）即为重定位后的地址，如下图2。</li>
</ul>
</li>
</ol>
<p><img data-src="https://i.loli.net/2021/04/27/pRuyg5NXlJKFfwI.png" alt="23.png"></p>
<p><img data-src="https://i.loli.net/2021/04/27/kcjFHzt3IlnLwY5.png" alt="24.png"></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><!-- flag of hidden posts -->
    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>Buy me a coffee</div>
  <button onclick="document.querySelector('.post-reward').classList.toggle('active');">
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechat.jpg" alt="Catecat 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpg" alt="Catecat 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Catecat
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://directoree.github.io/post/encryption-and-cracking-11-PE/" title="加密与解密（第四版）PE文件格式">https://directoree.github.io/post/encryption-and-cracking-11-PE/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E9%80%86%E5%90%91/" rel="tag"># 逆向</a>
          </div>

        

    </footer>
  </article>
</div>






      
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Catecat</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">899k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">13:37</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1.15.0/dist/lozad.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/local-search.js"></script>








<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  const url = element.dataset.target;
  const pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  const pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  const fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script>
if (document.querySelectorAll('.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8.7.0/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>








  

  
      <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//cdn.jsdelivr.net/npm/mathjax@3.1.0/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
NexT.utils.loadComments('#valine-comments', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    new Valine(Object.assign({"enable":true,"appId":"7zujCcS8pYH88CJXfdBlLyS8-gzGzoHsz","appKey":"lWGr7OPoNHo4v1YmVV5yr3E9","serverURLs":"https://7zujccs8.lc-cn-n1-shared.com","placeholder":"快来勾搭我呀🐶","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"lang":null,"visitor":true,"comment_count":true,"bg":"/images/comment_bg.png","recordIP":false,"enableQQ":false,"requiredFields":["nick"]}, {
      el: '#valine-comments',
      path: "/post/encryption-and-cracking-11-PE/",
      serverURLs: "https://7zujccs8.lc-cn-n1-shared.com"
    }));
  }, window.Valine);
});
</script>

</body>
</html>
