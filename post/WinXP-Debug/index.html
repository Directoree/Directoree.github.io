<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon1.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"directoree.github.io","root":"/","scheme":"Mist","version":"8.0.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="ʕ •̀ o •́ ʔ">
<meta property="og:type" content="article">
<meta property="og:title" content="Windows XP 用户态调试（一）被调试进程">
<meta property="og:url" content="https://directoree.github.io/post/WinXP-Debug/index.html">
<meta property="og:site_name" content="Catecat">
<meta property="og:description" content="ʕ •̀ o •́ ʔ">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/08/26/uT4ybWXzsmcMZBi.png">
<meta property="og:image" content="https://s2.loli.net/2022/08/18/yDcb3HzVnmaG5qj.png">
<meta property="og:image" content="https://s2.loli.net/2022/08/18/WVlipAO9zuR6P3r.png">
<meta property="og:image" content="https://s2.loli.net/2022/08/21/FofyDWm92C4i7VB.png">
<meta property="og:image" content="https://s2.loli.net/2022/08/18/UiVgqFL1jTMAGxS.png">
<meta property="og:image" content="https://s2.loli.net/2022/08/21/FRVS3IvgJp4d6zq.png">
<meta property="og:image" content="https://s2.loli.net/2022/08/21/z9QAPpnXOk7letc.png">
<meta property="og:image" content="https://s2.loli.net/2022/08/22/z7I1vDhKFxrGds3.png">
<meta property="og:image" content="https://s2.loli.net/2022/08/21/e7b6DA8JPNuZcX3.png">
<meta property="og:image" content="https://s2.loli.net/2022/08/24/NAVQX5czDkiFa7T.png">
<meta property="article:published_time" content="2022-08-16T10:37:42.000Z">
<meta property="article:modified_time" content="2022-08-27T07:24:54.255Z">
<meta property="article:author" content="Catecat">
<meta property="article:tag" content="WinXP内核">
<meta property="article:tag" content="X86调试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/08/26/uT4ybWXzsmcMZBi.png">


<link rel="canonical" href="https://directoree.github.io/post/WinXP-Debug/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Windows XP 用户态调试（一）被调试进程 | Catecat</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b832a9ae9a43377003fd975ca4e525ea";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Catecat</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">爱你所爱，行你所行，听从你心，无问西东。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/newcategories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-更新日志">

    <a href="/changelog" rel="section"><i class="fa fa-heartbeat fa-fw"></i>更新日志</a>

  </li>
        <li class="menu-item menu-item-空调房">

    <a href="/tips" rel="section"><i class="fa fa-wifi fa-fw"></i>空调房</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%B0%83%E8%AF%95%E7%94%A8%E5%88%B0%E7%9A%84-API"><span class="nav-text">1 调试用到的 API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%B0%83%E8%AF%95%E5%99%A8%E4%B8%8E%E8%A2%AB%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F"><span class="nav-text">2 调试器与被调试程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E8%B0%83%E8%AF%95%E5%AF%B9%E8%B1%A1"><span class="nav-text">2.1 调试对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E8%B0%83%E8%AF%95%E5%85%B3%E7%B3%BB%E5%BB%BA%E7%AB%8B%E6%96%B9%E5%BC%8F"><span class="nav-text">2.2 调试关系建立方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-DebugActiveProcess"><span class="nav-text">2.3 DebugActiveProcess</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E8%B0%83%E8%AF%95%E5%99%A8TEB-DbgSsReserved"><span class="nav-text">2.4 调试器TEB.DbgSsReserved</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E8%A2%AB%E8%B0%83%E8%AF%95%E8%BF%9B%E7%A8%8BPEB-BeingDebugged"><span class="nav-text">2.5 被调试进程PEB.BeingDebugged</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-%E5%8F%8D%E8%B0%83%E8%AF%95"><span class="nav-text">2.6 反调试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-%E5%8F%8D%E5%8F%8D%E8%B0%83%E8%AF%95"><span class="nav-text">2.7 反反调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E8%B0%83%E8%AF%95%E6%B6%88%E6%81%AF%E7%9A%84%E9%87%87%E9%9B%86-0%E7%8E%AF"><span class="nav-text">3 调试消息的采集-0环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E8%B0%83%E8%AF%95%E6%B6%88%E6%81%AF%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">3.1 调试消息是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E8%B0%83%E8%AF%95%E6%B6%88%E6%81%AF%E7%A7%8D%E7%B1%BB"><span class="nav-text">3.2 调试消息种类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E8%B0%83%E8%AF%95%E6%B6%88%E6%81%AF%E7%BB%93%E6%9E%84"><span class="nav-text">3.3 调试消息结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E8%B0%83%E8%AF%95%E6%B6%88%E6%81%AF%E7%9A%84%E9%87%87%E9%9B%86"><span class="nav-text">3.4 调试消息的采集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-1-%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B"><span class="nav-text">3.4.1 创建进程、线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-2-%E9%80%80%E5%87%BA%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B"><span class="nav-text">3.4.2 退出进程、线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-3-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E3%80%81%E5%8D%B8%E8%BD%BD"><span class="nav-text">3.4.3 模块的加载、卸载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-4-%E5%BC%82%E5%B8%B8%E6%B6%88%E6%81%AF"><span class="nav-text">3.4.4 异常消息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E8%B0%83%E8%AF%95%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%91%E9%80%81"><span class="nav-text">3.5 调试消息的发送</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-1-DbgkpSendApiMessage"><span class="nav-text">3.5.1 DbgkpSendApiMessage</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-DbgkpQueueMessage"><span class="nav-text">3.5.2 DbgkpQueueMessage</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-3-DBGKM-DEBUG-EVENT"><span class="nav-text">3.5.3 _DBGKM_DEBUG_EVENT</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%9D%9C%E6%92%B0%E7%9A%84%E8%B0%83%E8%AF%95%E6%B6%88%E6%81%AF"><span class="nav-text">4 杜撰的调试消息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E6%B8%85%E9%99%A4%E8%B0%83%E8%AF%95%E5%AF%B9%E8%B1%A1"><span class="nav-text">5 清除调试对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E7%94%A8%E6%88%B7%E6%80%81%E8%B0%83%E8%AF%95%E5%85%A8%E6%99%AF"><span class="nav-text">6 用户态调试全景</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Catecat"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Catecat</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">146</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/newcategories/">
          
        <span class="site-state-item-count">65</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">83</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Directoree" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Directoree" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhao_yilong@aliyun.com" title="E-Mail → mailto:zhao_yilong@aliyun.com" rel="noopener" target="_blank"><i class="fas fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://sighttp.qq.com/msgrd?v=1&uin=1003432683" title="QQ → http:&#x2F;&#x2F;sighttp.qq.com&#x2F;msgrd?v&#x3D;1&amp;uin&#x3D;1003432683" rel="noopener" target="_blank"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://treecatee.github.io/" title="https:&#x2F;&#x2F;treecatee.github.io" rel="noopener" target="_blank">Treecatee</a>
        </li>
    </ul>
  </div>

      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://directoree.github.io/post/WinXP-Debug/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Catecat">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Catecat">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Windows XP 用户态调试（一）被调试进程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-16 18:37:42" itemprop="dateCreated datePublished" datetime="2022-08-16T18:37:42+08:00">2022-08-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-08-27 15:24:54" itemprop="dateModified" datetime="2022-08-27T15:24:54+08:00">2022-08-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/X86%E8%B0%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">X86调试</span></a>
        </span>
    </span>

  
    <span id="/post/WinXP-Debug/" class="post-meta-item leancloud_visitors" data-flag-title="Windows XP 用户态调试（一）被调试进程" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/post/WinXP-Debug/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/post/WinXP-Debug/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>35k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>32 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><a target="_blank" rel="noopener" href="https://unicode-table.com/cn/kaomoji/">ʕ •̀ o •́ ʔ </a></p>
<span id="more"></span>

<h2 id="1-调试用到的-API"><a href="#1-调试用到的-API" class="headerlink" title="1 调试用到的 API"></a>1 调试用到的 API</h2><div class="note danger"><p>软件调试系列主要用到 <code>kernel32.dll</code>、<code>ntdll.dll</code>、<code>ntoskrnl.exe</code> 这几个文件。<br><code>kernel32.dll</code>：主要是用在调试器在调试 被调试程序 前的一些建立过程上。<br><code>ntdll.dll</code> 中的调试支持函数主要分为 3 类：</p>
<ol>
<li>以 <code>DbgUi</code> 开头的，供调试器使用；</li>
<li>以 <code>DbgSs</code> 开头的，这一部分在 Windows 2000 之后被移除；</li>
<li>以 <code>Dbg</code> 开头（非前两种）的，用于实现调试API，如 <code>DbgBreakpoint</code> 是 <code>DebugBreak</code> API的实现。</li>
</ol>
<p><code>ntoskrnl.exe</code>：该文件中的调试支持函数负责<strong>采集</strong>和<strong>传递</strong>调试事件，以及控制被调试进程。这些内核函数都是以 <code>Dbgk</code> 开头的。</p>
</div>

<p>调试子系统主要由 3 个部分：位于<code>ntdll.dll</code> 中的支持函数、位于内核文件中的 <code>Dbgk</code>支持函数，以及在内核的调试子系统服务器组成（实际上子系统是一类服务函数的集合，所以这里指的服务器就是为调试提供服务的函数）。</p>
<h2 id="2-调试器与被调试程序"><a href="#2-调试器与被调试程序" class="headerlink" title="2 调试器与被调试程序"></a>2 调试器与被调试程序</h2><h3 id="2-1-调试对象"><a href="#2-1-调试对象" class="headerlink" title="2.1 调试对象"></a>2.1 调试对象</h3><p>调试器是一个进程，被调试程序是一个进程，如何才能将两个进程联系到一起呢？就需要一个桥梁，在 Windows 中一般都是用一个<strong>对象</strong>来管理和连接许多事务，而调试用到的就是<strong>调试对象</strong><code>_DEBUG_OBJECT</code>（进程间是相互隔离的，但是高2G往往又是相同的，因此这个桥梁可以利用内核层来实现）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DEBUG_OBJECT</span> &#123;</span></span><br><span class="line">+<span class="number">0x00</span>    KEVENT EventsPresent;</span><br><span class="line">+<span class="number">0x10</span>    FAST_MUTEX Mutex;</span><br><span class="line">+<span class="number">0x30</span>    LIST_ENTRY EventList;</span><br><span class="line">+<span class="number">0x38</span>    ULONG Flags;</span><br><span class="line">&#125; DEBUG_OBJECT, *PDEBUG_OBJECT;</span><br><span class="line"></span><br><span class="line">kd&gt; dt _FAST_MUTEX -v</span><br><span class="line">nt!_FAST_MUTEX</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">FAST_MUTEX</span>, 5 <span class="title">elements</span>, 0<span class="title">x20</span> <span class="title">bytes</span></span></span><br><span class="line"><span class="class">   +0<span class="title">x000</span> <span class="title">Count</span>            :</span> Int4B</span><br><span class="line">   +<span class="number">0x004</span> Owner            : Ptr32 to <span class="class"><span class="keyword">struct</span> _<span class="title">KTHREAD</span>, 73 <span class="title">elements</span>, 0<span class="title">x1c0</span> <span class="title">bytes</span></span></span><br><span class="line"><span class="class">   +0<span class="title">x008</span> <span class="title">Contention</span>       :</span> Uint4B</span><br><span class="line">   +<span class="number">0x00c</span> Event            : <span class="class"><span class="keyword">struct</span> _<span class="title">KEVENT</span>, 1 <span class="title">elements</span>, 0<span class="title">x10</span> <span class="title">bytes</span></span></span><br><span class="line"><span class="class">   +0<span class="title">x01c</span> <span class="title">OldIrql</span>          :</span> Uint4B</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center"><strong>偏移</strong></th>
<th align="left"><strong>名称</strong></th>
<th align="center"><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x00</td>
<td align="left">EventsPresent</td>
<td align="center">用于指示调试事件发生的事件对象，用来同步调试器进程和被调试进程，<strong>调试子系统服务器通过设置此事件来通知调试器读取消息队列中的调试信息</strong>。调试器通过 <code>WaitForDebugEvent</code> 来等待此对象。</td>
</tr>
<tr>
<td align="center">0x10</td>
<td align="left">Mutex</td>
<td align="center">用于同步的互斥对象，用来锁定对 <code>StateEventListEntry</code> 的访问，以防止向链表写数据时调试器正在取数据造成数据读写错误。</td>
</tr>
<tr>
<td align="center">0x30</td>
<td align="left">StateEventListEntry</td>
<td align="center">保存调试事件的链表，被称为<strong>调试消息队列</strong>。</td>
</tr>
<tr>
<td align="center">0x38</td>
<td align="left">Flags</td>
<td align="center">包含多个标志位，比如，位1代表结束调试会话时是否终止被调试进程（<code>KillProcessOnExit</code>），位0代表调试对象是否被正在被删除。 <code>DebugSetProcessKillOnExit</code> 实际上设置的就是这个标志位。具体见3.5.2。</td>
</tr>
</tbody></table>
<p>调试对象通常是在调试器进程中创建的，将调试器进程与被调试进程建立连接的过程为：</p>
<ol>
<li>调试器进程调用函数创建调试对象，并将调试对象<strong>句柄</strong>保存到调试器当前线程 <code>TEB.DbgSsReserved[1]</code> 字段中。</li>
<li>然后进入 0 环，将调试<strong>对象地址</strong>保存在被调试进程 <code>EPROCESS.DebugPort</code>。</li>
</ol>
<h3 id="2-2-调试关系建立方式"><a href="#2-2-调试关系建立方式" class="headerlink" title="2.2 调试关系建立方式"></a>2.2 调试关系建立方式</h3><p>打开调试器，有两种与被调试程序建立联系的方式：</p>
<ul>
<li>在调试器中<mark class="label warning">打开</mark>未运行的可执行文件：通过 <code>kernel32!CreateProcess</code> 建立联系。</li>
<li>将一个正在运行的程序<mark class="label success">附加</mark>到调试器中：通过 <code>kernel32!DebugActiveProcess</code> 建立联系。</li>
</ul>
<p><strong>一、kernel32!CreateProcess</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">CreateProcessA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN LPCSTR lpApplicationName,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN LPSTR lpCommandLine,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN LPSECURITY_ATTRIBUTES lpProcessAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN BOOL bInheritHandles,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN DWORD dwCreationFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN LPVOID lpEnvironment,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN LPCSTR lpCurrentDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN LPSTARTUPINFOA lpStartupInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT LPPROCESS_INFORMATION lpProcessInformation</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中 <code>dwCreationFlags</code> 参数用于指定创建新进程的选项，可以是一系列标志位的组合。以下两个标志位是<strong>专门用于调试</strong>的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG_PROCESS                     0x00000001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG_ONLY_THIS_PROCESS           0x00000002</span></span><br></pre></td></tr></table></figure>

<p>系统在创建进程时，会检查创建标志中是否包含以上标志。如果包含，那么系统会把调用进程当作调试器（debugger）进程，把新创建的进程当作被调试（debuggee）进程，为二者建立起调试关系。</p>
<p><strong>二者主要区别</strong>：</p>
<ul>
<li><code>DEBUG_PROCESS</code> ：调试器会收到被调试进程及由被调试进程创建的所有子进程中发生的所有调试事件的信息，但一般来说没有必要这样做。<code>DEBUG_ONLY_THIS_PROCESS</code> 和 <code>DEBUG_PROCESS</code> 组合标志来禁止它。</li>
<li><code>DEBUG_ONLY_THIS_PROCESS</code>：调试器将只会收到被调试进程的调试事件，而对其子进程的调试事件不予理睬。</li>
</ul>
<p>因为操作系统将调试对象标记为在特殊模式下运行，所以可以使用 <code>IsDebuggerPresent</code> 函数查看进程是否在调试器下运行。《加密与解密第四版 9.3 P377》。</p>
<p>这种方式创建具体细节请看《软件调试第二版卷2 10.3 P201》、《<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-207429.htm">64位CreateProcess逆向</a>》、《<a target="_blank" rel="noopener" href="https://www.cnblogs.com/feizianquan/p/15995610.html">基于Win11的CreateProcess逆向分析-3环用户层逆向分析(一)</a>》。</p>
<p>两种建立联系的方式本质上区别并不大，只是第一种有一个创建进程的过程，多出一步，所以仅分析第二种通过 <code>kernel32!DebugActiveProcess</code> 建立联系的方式即可。</p>
<h3 id="2-3-DebugActiveProcess"><a href="#2-3-DebugActiveProcess" class="headerlink" title="2.3 DebugActiveProcess"></a>2.3 DebugActiveProcess</h3><p>函数 <code>kernel32!DebugActiveProcess</code>：该函数允许调试器<strong>附加</strong>一个处于活动状态的进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL __stdcall <span class="title">DebugActiveProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwProcessId	<span class="comment">//被调试进程的PID</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span>			<span class="comment">//返回值：TRUE-附加成功，FALSE-附加失败。使用GetLastError可获取错误码</span></span></span><br></pre></td></tr></table></figure>

<ol>
<li>该函数调用 <code>ntdll!DbgUiConnectToDbg</code> ，无需进入 0 环。先判断调试器当前线程 <mark class="label info">TEB+0xF24</mark> 即 <code>DbgSsReserved[1] == NULL</code>，如果不为空则直接使用该调试对象即可，如果为空会创建一个调试对象。最后<strong>将调试对象句柄值存入调试器当前线程</strong> <code>TEB+0xF24</code>，即可关联起来。</li>
<li>然后调用 <code>ntdll!DbgUiDebugActiveProcess</code> 带着被调试进程句柄、调试对象句柄进入 0 环后调用 <code>DbgkpSetProcessDebugObject</code>，然后将<strong>调试对象地址</strong>存入被调试进程 <mark class="label default">EPROCESS.DebugPort</mark>即可。</li>
</ol>
<p>由于TEB是用户层的数据结构，所以此时 <code>DbgSsReserved[1]</code> 中保存的其实是调试对象的句柄，而不是调试对象的地址。</p>
<ul>
<li><code>ntdll!DbgUiConnectToDbg</code>：关联调试器-调试对象。</li>
<li><code>ntdll!DbgUiDebugActiveProcess --&gt; DbgkpSetProcessDebugObject</code>：关联被调试进程-调试对象。</li>
</ul>
<p>当调试器与被调试进程的调试会话建立起来后，调试器进程就进入了调试事件循环，等待调试事件的发生，然后处理，然后等待，直到调试会话结束，调试器的调试事件循环如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(WaitForDebugEvent(&amp;DbgEvt, INFINITE))<span class="comment">// 等待事件</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 处理等待得到的事件</span></span><br><span class="line">  <span class="comment">// 处理后，恢复调试目标继续执行</span></span><br><span class="line">  ContinueDebugEvent(DbgEvt.dwProcessId, DbgEvt.dwThreadId, dwContinueStatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DbgkpSetProcessDebugObject</code> 函数内部除了将调试对象赋给 <code>EPROCESS</code> 结构的 <code>DebugPort</code>字段，还会调用 <code>DbgkpMarkProcessPeb</code> 函数设置进程环境块 <mark class="label success">PEB.BeingDebugged</mark> 字段（用于在用户态判断进程是否正在被调试）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">DbgkpMarkProcessPeb</span><span class="params">(PEPROCESS Process)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(ExAcquireRundownProtection (&amp;Process-&gt;RundownProtect))</span><br><span class="line">  &#123;</span><br><span class="line">    KeStackAttachProcess(&amp;Process-&gt;Pcb, &amp;ApcState);</span><br><span class="line">    ExAcquireFastMutex (&amp;DbgkpProcessDebugPortMutex);</span><br><span class="line">    </span><br><span class="line">    Process-&gt;Peb-&gt;BeingDebugged = (BOOLEAN)(Process-&gt;DebugPort != <span class="literal">NULL</span> ? TRUE : FALSE);</span><br><span class="line">    </span><br><span class="line">    ExReleaseFastMutex (&amp;DbgkpProcessDebugPortMutex);</span><br><span class="line">    KeUnstackDetachProcess(&amp;ApcState);</span><br><span class="line">  &#125;</span><br><span class="line">  ExReleaseRundownProtection (&amp;Process-&gt;RundownProtect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note danger"><p>将调试器进程附加到已处于运行的进程中，使用 <code>kernel32!DebugActiveProcess</code>，需要注意两点：</p>
<ol>
<li>在 NT内核中，当试图通过 <code>DebugActiveProcess</code> 函数将调试器捆绑到一个创建时带有<strong>安全描述符的进程</strong>上时，将被拒绝。《加密与解密第四版 P378》</li>
<li>在  <code>kernel32!DebugActiveProcess</code> 调用 <code>ProcessIdToHlandle</code> 函数，获得指定 ID 的进程句柄，这个函数内部会调用 <code>OpenProcess</code> 函数， 进而调用 <code>NtOpenProcess</code> 内核服务。在执行这一步时需要调用进程与目标进程有同样或更高的权限，否则这一步便会失败，调用 <code>GetLastError</code>（返回的错误码通常是 <code>0x5</code>，意思是 <code>Access is denied</code>，即访问被拒绝。如果调试器进程具有 <code>SE_DEBUG_NAME 权限</code>，那么它通常有权限调试系统内的<strong>任何进程</strong>。《软件调试第二版 卷2 P206》</li>
</ol>
</div>

<p><img data-src="https://s2.loli.net/2022/08/26/uT4ybWXzsmcMZBi.png" alt="DebugActiveProcess的副本.png"></p>
<h3 id="2-4-调试器TEB-DbgSsReserved"><a href="#2-4-调试器TEB-DbgSsReserved" class="headerlink" title="2.4 调试器TEB.DbgSsReserved"></a>2.4 调试器TEB.DbgSsReserved</h3><p><code>TEB</code> 结构的 <code>DbgSsReservedr[2]</code> 数组就是专门用来记录调试器工作线程与调试子系统之间通信用的同步对象和通信对象的。</p>
<ul>
<li><code>DbgSsReservear[0]</code>：是一个链表头，指向所有被调试线程。这个链表的每个节点是一个 <code>DBGSS_THREAD_DATA</code> 结构或 <code>TMPHANDLES</code> 结构（XP SP3使用），每个节点用来描述被调试进程中的一个线程。</li>
<li><code>DbgSsReservear[1]</code>：存放调试对象句柄。</li>
</ul>
<p>关于 <code>DBGSS_THREAD_DATA</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DBGSS_THREAD_DATA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DBGSS_THREAD_DATA</span> *<span class="title">Next</span>;</span>	<span class="comment">// 指向下一个节点</span></span><br><span class="line">    HANDLE ThreadHandle;		<span class="comment">// 线程句柄（被调试进程中）</span></span><br><span class="line">    HANDLE ProcessHandle;		<span class="comment">// 被调试进程的句柄</span></span><br><span class="line">    DWORD ProcessId;			<span class="comment">// 被调试进程的 ID</span></span><br><span class="line">    DWORD ThreadId;			<span class="comment">// 线程ID（被调试进程中）</span></span><br><span class="line">    BOOLEAN HandleMarked;		<span class="comment">// 退出标记，TRUE为退出进程/线程</span></span><br><span class="line">&#125; DBGSS_THREAD_DATA, *PDBGSS_THREAD_DATA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TMPHANDLES</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">TMPHANDLES</span> *<span class="title">Next</span>;</span>	<span class="comment">//指向下一个节点</span></span><br><span class="line">    HANDLE Thread;		<span class="comment">// 线程句柄（被调试进程中）</span></span><br><span class="line">    HANDLE Process;		<span class="comment">// 被调试进程的句柄</span></span><br><span class="line">    DWORD dwProcessId;		<span class="comment">// 被调试进程的 ID</span></span><br><span class="line">    DWORD dwThreadId;		<span class="comment">// 线程ID（被调试进程中）</span></span><br><span class="line">    BOOLEAN DeletePending;	<span class="comment">// 退出标记，TRUE为退出进程/线程</span></span><br><span class="line">&#125; TMPHANDLES, *PTMPHANDLES;</span><br></pre></td></tr></table></figure>



<p>调试时间处理的 <code>WaitForDebugEvent</code> 和 <code>ContinueDebugEvent</code> 函数会维护这个链表。</p>
<h3 id="2-5-被调试进程PEB-BeingDebugged"><a href="#2-5-被调试进程PEB-BeingDebugged" class="headerlink" title="2.5 被调试进程PEB.BeingDebugged"></a>2.5 被调试进程PEB.BeingDebugged</h3><p><code>DbgkpSetProcessDebugObject</code> 函数内部除了将调试对象赋给被调试进程 <code>EPROCESS</code> 结构的 <code>DebugPort</code>字段，还会调用 <code>DbgkpMarkProcessPeb</code> 函数设置被调试进程环境块<mark class="label primary">PEB.BeingDebugged</mark>字段（用于在用户态判断进程是否正在被调试）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">DbgkpMarkProcessPeb</span><span class="params">(PEPROCESS Process)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(ExAcquireRundownProtection (&amp;Process-&gt;RundownProtect))</span><br><span class="line">  &#123;</span><br><span class="line">    KeStackAttachProcess(&amp;Process-&gt;Pcb, &amp;ApcState);</span><br><span class="line">    ExAcquireFastMutex (&amp;DbgkpProcessDebugPortMutex);</span><br><span class="line">    </span><br><span class="line">    Process-&gt;Peb-&gt;BeingDebugged = (BOOLEAN)(Process-&gt;DebugPort != <span class="literal">NULL</span> ? TRUE : FALSE);</span><br><span class="line">    </span><br><span class="line">    ExReleaseFastMutex (&amp;DbgkpProcessDebugPortMutex);</span><br><span class="line">    KeUnstackDetachProcess(&amp;ApcState);</span><br><span class="line">  &#125;</span><br><span class="line">  ExReleaseRundownProtection (&amp;Process-&gt;RundownProtect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个进程不在被调试状态，那么其 PEB 结构的 <code>Being Debugged</code> 字段为 0；否则，为 1。<code>ISDebuggerPresent</code> API 就是通过判断 <code>BeingDebugged</code> 字段实现的。</p>
<h3 id="2-6-反调试"><a href="#2-6-反调试" class="headerlink" title="2.6 反调试"></a>2.6 反调试</h3><p>在掌握了调试原理后，自然也就可以总结出一些反调试的手段：</p>
<ol>
<li><strong>清零DebugPort</strong>，只要起一个线程不断的检查当前进程的DebugPort，一旦有值就退出程序或者将其清零，这样可以<strong>中断调试对象与被调试进程的联系</strong>，以达到反调试的目的。</li>
<li><strong>遍历所有进程TEB+0xF24处</strong>，看有没有值，若有值，一定就是调试器，则退出程序。</li>
<li><strong>Hook NtCreateDebugObject</strong>，不让它创建调试对象。</li>
</ol>
<h3 id="2-7-反反调试"><a href="#2-7-反反调试" class="headerlink" title="2.7 反反调试"></a>2.7 反反调试</h3><p>有反调试，自然就有反反调试，正所谓道高一尺魔高一丈，针对各类反调试手段，也会衍生出各类的反反调试，攻防领域永远都在交替上升：</p>
<ol>
<li>针对Hook NtCreateDebugObject的反调试方式，可以<strong>自己分配一个内存给_DEBUG_OBJECT</strong>，并为它的成员赋值。</li>
<li>针对清零DebugPort的反调试方式，可以不使用DebugPort的位置，<strong>在进程中另找一个区域存放_DEBUG_OBJECT的地址</strong>。把原先+0xbc的值都选为新的偏移处。</li>
<li><strong>重写整个DebugActiveProcess函数</strong>。</li>
</ol>
<ul>
<li><a target="_blank" rel="noopener" href="https://cataloc.gitee.io/blog/2020/09/11/%E8%B0%83%E8%AF%95%E5%AF%B9%E8%B1%A1/">调试对象</a></li>
<li><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-271021.htm#msg_header_h1_1">Windows内核学习笔记之调试（上）</a></li>
</ul>
<h2 id="3-调试消息的采集-0环"><a href="#3-调试消息的采集-0环" class="headerlink" title="3 调试消息的采集-0环"></a>3 调试消息的采集-0环</h2><h3 id="3-1-调试消息是什么"><a href="#3-1-调试消息是什么" class="headerlink" title="3.1 调试消息是什么"></a>3.1 调试消息是什么</h3><p>调试消息（事件）：<strong>调试器进程如何才能知道被调试进程发生甚么事了</strong>？于是就有了调试消息这么一个概念，<strong>用来描述被调试进程的某些行为</strong>，当被调试进程做出了一些行为后，如果属于调试事件中的一类，就会借助调试对象告知调试器。参考下图：</p>
<p><img data-src="https://s2.loli.net/2022/08/18/yDcb3HzVnmaG5qj.png" alt="1.png"></p>
<div class="note danger"><p>调试事件的采集是<strong>在内核</strong>进行的，使用以 <code>Dbgk</code> 开头的函数来进行采集。</p>
<p>创建&#x2F;退出进程、线程时，进行消息采集的线程由<strong>被调试进程</strong>来提供。</p>
</div>

<p>在内核中，调试事件有时也称为调试消息，并使用一个名为 <code>DBGKM_APIMSG</code> 的结构来描述。实际上在 0 环侧一般叫调试消息。</p>
<p>调试事件是在 3 环的叫法，调试消息是在 0 环的叫法。</p>
<p>对于在3 环的调试器，调试 API 使用的是一个名为 <code>DEBUG_EVENT</code> 的结构。因为这两个结构是不同的，所以需要一个转化过程，这个工作是由调试子系统服务器和 <code>ntdll.dll</code> 中的用户态函数来完成的。简单来说，子系统服务器会将自己使用的结构转化为 <code>ntdll.dll</code> 使用的<code>DBGULWAIT_STATE_CHANGE</code>， <code>ntdll.dll</code> 再将这个结构转化为调试器使用的 <code>DEBUG_EVENT</code> 结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DEBUG_OBJECT</span> &#123;</span></span><br><span class="line">     KEVENT EventsPresent;		<span class="comment">//+0x00,用于指示有调试事件发生的事件对象</span></span><br><span class="line">     FAST_MUTEX Mutex;			<span class="comment">//+0x10,用于同步读取消息的互斥对象</span></span><br><span class="line">     LIST_ENTRY EventList;		<span class="comment">//+0x30,保存调试消息的链表</span></span><br><span class="line">     ULONG Flags;			<span class="comment">//+0x38,标志位,调试消息是否已读取</span></span><br><span class="line">&#125; DEBUG_OBJECT, *PDEBUG_OBJECT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3环使用</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DEBUG_EVENT</span> &#123;</span></span><br><span class="line">    DWORD dwDebugEventCode;		<span class="comment">//事件类型，对应消息类型</span></span><br><span class="line">    DWORD dwProcessId;			<span class="comment">//被调试进程PID</span></span><br><span class="line">    DWORD dwThreadId;			<span class="comment">//被调试线程TID</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span>				<span class="comment">//根据不同的事件类型，对应于不同的结构</span></span><br><span class="line">        EXCEPTION_DEBUG_INFO Exception;</span><br><span class="line">        CREATE_THREAD_DEBUG_INFO CreateThread;</span><br><span class="line">        CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;</span><br><span class="line">        EXIT_THREAD_DEBUG_INFO ExitThread;</span><br><span class="line">        EXIT_PROCESS_DEBUG_INFO ExitProcess;</span><br><span class="line">        LOAD_DLL_DEBUG_INFO LoadDll;</span><br><span class="line">        UNLOAD_DLL_DEBUG_INFO UnloadDll;</span><br><span class="line">        OUTPUT_DEBUG_STRING_INFO DebugString;</span><br><span class="line">        RIP_INFO RipInfo;</span><br><span class="line">    &#125; u;</span><br><span class="line">&#125; DEBUG_EVENT, *LPDEBUG_EVENT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0环使用</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DEBUG_EVENT</span> &#123;</span></span><br><span class="line">+<span class="number">0x00</span>    LIST_ENTRY EventList;	<span class="comment">// 与兄弟节点相互链接的节点结构，注意这不是调试消息队列</span></span><br><span class="line">+<span class="number">0x08</span>    KEVENT ContinueEvent;	<span class="comment">// 用于等待调试器回复的事件对象 </span></span><br><span class="line">+<span class="number">0x18</span>    CLIENT_ID ClientId;	<span class="comment">// 调试事件所属的线程 ID 和进程 ID</span></span><br><span class="line">+<span class="number">0x20</span>    PEPROCESS Process;	<span class="comment">// 被调试进程的 EPROCESS 结构地址</span></span><br><span class="line">+<span class="number">0x24</span>    PETHREAD Thread;	<span class="comment">// 被调试进程中触发调试事件的线程的 ETHREAD 地址</span></span><br><span class="line">+<span class="number">0x28</span>    NTSTATUS Status;	<span class="comment">// 对调试事件的处理结果</span></span><br><span class="line">+<span class="number">0x2C</span>    ULONG Flags;		<span class="comment">// 标志（调试消息是否已经被读取）</span></span><br><span class="line">+<span class="number">0x30</span>    PETHREAD BackoutThread;<span class="comment">// 产生杜撰消息（faked message）的线程</span></span><br><span class="line">+<span class="number">0x38</span>    DBGKM_APIMSG ApiMsg;	<span class="comment">// 调试消息的详细信息</span></span><br><span class="line">&#125; DEBUG_EVENT, *PDEBUG_EVENT;</span><br></pre></td></tr></table></figure>



<h3 id="3-2-调试消息种类"><a href="#3-2-调试消息种类" class="headerlink" title="3.2 调试消息种类"></a>3.2 调试消息种类</h3><p>不能说执行了什么代码（例如打印了某个字符，申请了一块内存），都产生一个调试事件（消息）发送给 <code>_DEBUG_OBJECT</code>，那样链表也就过于复杂了，所以<strong>调试事件设定了以下7种类型</strong>（对应的常量在 3 环使用）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">DBGKM_APINUMBER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DbgKmExceptionApi = <span class="number">0</span>,		<span class="comment">//异常(例：Int3断点，硬件断点)</span></span><br><span class="line">    DbgKmCreateThreadApi = <span class="number">1</span>,		<span class="comment">//创建线程</span></span><br><span class="line">    DbgKmCreateProcessApi = <span class="number">2</span>,		<span class="comment">//创建进程</span></span><br><span class="line">    DbgKmExitThreadApi = <span class="number">3</span>,		<span class="comment">//线程退出</span></span><br><span class="line">    DbgKmExitProcessApi = <span class="number">4</span>,		<span class="comment">//进程退出</span></span><br><span class="line">    DbgKmLoadDllApi = <span class="number">5</span>,		<span class="comment">//加载DLL</span></span><br><span class="line">    DbgKmUnloadDllApi = <span class="number">6</span>,		<span class="comment">//卸载DLL</span></span><br><span class="line">    DbgKmErrorReportApi = <span class="number">7</span>,		<span class="comment">//内部错误(已废弃)</span></span><br><span class="line">    DbgKmMaxApiNumber = <span class="number">8</span>,		<span class="comment">//最大值</span></span><br><span class="line">&#125; DBGKM_APINUMBER;</span><br></pre></td></tr></table></figure>



<p>当被调试进程做出任何一种上述类型的行为时，都会产生调试消息，并发送给 <code>_DEBUG_OBJECT.EventList</code>。</p>
<table>
<thead>
<tr>
<th align="center"><strong>消息类型</strong></th>
<th align="center"><strong>采集方式</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">进程和线程创建消息</td>
<td align="center">创建进程的时候，都需要创建主线程。而创建用户模式线程的时候，会执行PspUserThreadStartup例程，在该函数中会通过调用DbgkCreateThread来采集创建消息</td>
</tr>
<tr>
<td align="center">进程和线程退出消息</td>
<td align="center">进程的退出其实就是将其所有线程都退出，而线程退出的最终函数是PspExitThread。该函数会判断退出的线程是否是最后一个线程，如果不是则会调用DbgkExitThread来采集线程退出消除；如果是最后一个线程，就会通过调用DbgkExitProcess来采集进程退出消息</td>
</tr>
<tr>
<td align="center">DLL映射消息</td>
<td align="center">Windows内核使用NtMapViewOfSection来将一个模块对象映射到指定的进程空间中时，NtMapViewOfSection会调用DbgkMapViewOfSection来采集模块映射的消息</td>
</tr>
<tr>
<td align="center">DLL卸载消息</td>
<td align="center">NtUnMapViewOfSection则会在卸载模块的时候，调用DbgkUnMapViewOfSection来采集模块卸载消息</td>
</tr>
<tr>
<td align="center">异常消息</td>
<td align="center">当出现异常的时候，KiDispatchException会完成对异常的分发，而该函数会判断是否具有调试器，如果有调试器，则会通过调用DbgkForwardException函数来采集异常消息</td>
</tr>
</tbody></table>
<h3 id="3-3-调试消息结构"><a href="#3-3-调试消息结构" class="headerlink" title="3.3 调试消息结构"></a>3.3 调试消息结构</h3><p>为了让调试进程得知被调试进程的状态，内核会将被调试进程所有的调试消息都收集起来发送给调试子系统。</p>
<p>不同的 <code>Dbgk</code> 采集例程会根据当前进程的 <code>DebugPort</code> 字段来判断是否处于被调试状态。如果不是，便会忽略这次调用；如果处于调试状态，便会产生一个0环的 <code>DBGKM_APIMSG</code> <strong>消息结构</strong>，该结构的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DBGKM_APIMSG</span> &#123;</span></span><br><span class="line">+<span class="number">0x00</span>    PORT_MESSAGE h;				<span class="comment">// LPC端口消息结构，Windows XP之前使用，但是该成员一直在(0x18字节)</span></span><br><span class="line">+<span class="number">0x18</span>    DBGKM_APINUMBER ApiNumber;			<span class="comment">//消息类型</span></span><br><span class="line">+<span class="number">0x1C</span>    NTSTATUS ReturnedStatus;			<span class="comment">// 调试器的回复状态 </span></span><br><span class="line">+<span class="number">0x20</span>    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">+<span class="number">0x20</span>        DBGKM_EXCEPTION Exception;			<span class="comment">// 异常</span></span><br><span class="line">+<span class="number">0x20</span>        DBGKM_CREATE_THREAD CreateThread;		<span class="comment">// 创建线程</span></span><br><span class="line">+<span class="number">0x20</span>        DBGKM_CREATE_PROCESS CreateProcessInfo;	<span class="comment">// 创建进程</span></span><br><span class="line">+<span class="number">0x20</span>        DBGKM_EXIT_THREAD ExitThread;		<span class="comment">// 线程退出</span></span><br><span class="line">+<span class="number">0x20</span>        DBGKM_EXIT_PROCESS ExitProcess;		<span class="comment">// 进程退出	</span></span><br><span class="line">+<span class="number">0x20</span>        DBGKM_LOAD_DLL LoadDll;			<span class="comment">// 映射DLL</span></span><br><span class="line">+<span class="number">0x20</span>        DBGKM_UNLOAD_DLL UnloadDll;		<span class="comment">// 卸载DLL</span></span><br><span class="line">+<span class="number">0x20</span>    &#125; u;</span><br><span class="line">&#125; DBGKM_APIMSG, *PDBGKM_APIMSG;</span><br><span class="line"></span><br><span class="line">kd&gt; dt _PORT_MESSAGE -v</span><br><span class="line">nt!_PORT_MESSAGE</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">PORT_MESSAGE</span>, 7 <span class="title">elements</span>, 0<span class="title">x18</span> <span class="title">bytes</span></span></span><br><span class="line"><span class="class">   +0<span class="title">x000</span> <span class="title">u1</span>               :</span> <span class="class"><span class="keyword">union</span> __<span class="title">unnamed</span>, 2 <span class="title">elements</span>, 0<span class="title">x4</span> <span class="title">bytes</span></span></span><br><span class="line"><span class="class">   +0<span class="title">x004</span> <span class="title">u2</span>               :</span> <span class="class"><span class="keyword">union</span> __<span class="title">unnamed</span>, 2 <span class="title">elements</span>, 0<span class="title">x4</span> <span class="title">bytes</span></span></span><br><span class="line"><span class="class">   +0<span class="title">x008</span> <span class="title">ClientId</span>         :</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CLIENT_ID</span>, 2 <span class="title">elements</span>, 0<span class="title">x8</span> <span class="title">bytes</span></span></span><br><span class="line"><span class="class">   +0<span class="title">x008</span> <span class="title">DoNotUseThisField</span> :</span> Float</span><br><span class="line">   +<span class="number">0x010</span> MessageId        : Uint4B</span><br><span class="line">   +<span class="number">0x014</span> ClientViewSize   : Uint4B</span><br><span class="line">   +<span class="number">0x014</span> CallbackId       : Uint4B</span><br></pre></td></tr></table></figure>

<p>其中 <mark class="label danger">ApiNumber</mark> 的种类枚举值取自 <code>DBGKM_APINUMBER</code>，不同类型的消息将会封装成 <code>u</code> 中不同的结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DBGKM_CREATE_THREAD</span> &#123;</span></span><br><span class="line">    ULONG SubSystemKey;</span><br><span class="line">    PVOID StartAddress;</span><br><span class="line">&#125; DBGKM_CREATE_THREAD, *PDBGKM_CREATE_THREAD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DBGKM_CREATE_PROCESS</span> &#123;</span></span><br><span class="line">    ULONG SubSystemKey;</span><br><span class="line">    HANDLE FileHandle;</span><br><span class="line">    PVOID BaseOfImage;</span><br><span class="line">    ULONG DebugInfoFileOffset;</span><br><span class="line">    ULONG DebugInfoSize;</span><br><span class="line">    DBGKM_CREATE_THREAD InitialThread;</span><br><span class="line">&#125; DBGKM_CREATE_PROCESS, *PDBGKM_CREATE_PROCESS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DBGKM_EXIT_THREAD</span> &#123;</span></span><br><span class="line">    NTSTATUS ExitStatus;</span><br><span class="line">&#125; DBGKM_EXIT_THREAD, *PDBGKM_EXIT_THREAD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DBGKM_EXIT_PROCESS</span> &#123;</span></span><br><span class="line">    NTSTATUS ExitStatus;</span><br><span class="line">&#125; DBGKM_EXIT_PROCESS, *PDBGKM_EXIT_PROCESS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DBGKM_LOAD_DLL</span> &#123;</span></span><br><span class="line">    HANDLE FileHandle;</span><br><span class="line">    PVOID BaseOfDll;</span><br><span class="line">    ULONG DebugInfoFileOffset;</span><br><span class="line">    ULONG DebugInfoSize;</span><br><span class="line">&#125; DBGKM_LOAD_DLL, *PDBGKM_LOAD_DLL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DBGKM_UNLOAD_DLL</span> &#123;</span></span><br><span class="line">    PVOID BaseAddress;</span><br><span class="line">&#125; DBGKM_UNLOAD_DLL, *PDBGKM_UNLOAD_DLL;</span><br></pre></td></tr></table></figure>





<h3 id="3-4-调试消息的采集"><a href="#3-4-调试消息的采集" class="headerlink" title="3.4 调试消息的采集"></a>3.4 调试消息的采集</h3><p>对应 3.2 中的调试消息种类，Windows系统中提供了一些<strong>调试消息的采集函数</strong>，它们<strong>以 <code>Dbgk</code> 开头，用于生成不同调试事件对应的结构体</strong>，具体如下：</p>
<p><img data-src="https://s2.loli.net/2022/08/18/WVlipAO9zuR6P3r.png" alt="2.png"></p>
<p>针对不同类型的调试事件，均有对应的调试消息采集函数。图中：</p>
<ul>
<li><strong>黑色</strong>字体的为导致调试消息<strong>产生的函数</strong>；</li>
<li><mark class="label primary">紫色</mark>字体的为生成调试消息的_采集函数_；</li>
<li><mark class="label danger">红色</mark>字体的则为调试消息_写入函数_。</li>
</ul>
<p>并且<strong>调试消息采集函数均在导致调试事件发生的函数执行的必经之路上</strong>，从而捕获到被调试进程的行为。下面以前4类调试事件为例，分析调试事件采集函数的执行过程。</p>
<h4 id="3-4-1-创建进程、线程"><a href="#3-4-1-创建进程、线程" class="headerlink" title="3.4.1 创建进程、线程"></a>3.4.1 创建进程、线程</h4><p>从线程角度来说，创建进程就是创建第一个线程，可以参考《<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-207429.htm">64位CreateProcess逆向</a>》、《<a target="_blank" rel="noopener" href="https://www.cnblogs.com/feizianquan/p/15995610.html">基于Win11的CreateProcess逆向分析-3环用户层逆向分析(一)</a>》。</p>
<p>首先来看创建进程、线程的事件采集函数，<strong>创建进程的本质就是创建线程</strong>，其中第一次创建线程时为创建进程。<strong>因此底层调用的函数一样，均为PspUserThreadStartup</strong>，下面来分析它的执行流程：</p>
<ol>
<li><p>在 <code>PspUserThreadStartup</code> 中如果满足 <code>!DeadThread &amp;&amp; !HideFromDebugger </code> 就会调用 <code>DbgkCreateThread</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*VOID __stdcall PspUserThreadStartup(</span></span><br><span class="line"><span class="comment">    IN PKSTART_ROUTINE StartRoutine,	//忽略，并没有使用到（反汇编的代码直接将其忽略）</span></span><br><span class="line"><span class="comment">    IN PVOID StartContext		//线程开始执行的地址</span></span><br><span class="line"><span class="comment">    )</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">...</span><br><span class="line">PAGE:<span class="number">004F</span>8E52 loc_4F8E52:                             <span class="comment">// CODE XREF: PspUserThreadStartup(x,x)+44↑j</span></span><br><span class="line">PAGE:<span class="number">004F</span>8E52                 <span class="keyword">xor</span>     cl, cl          <span class="comment">// NewIrql</span></span><br><span class="line">PAGE:<span class="number">004F</span>8E54                 call    ds:__imp_@KfLowerIrql@<span class="number">4</span> <span class="comment">// KfLowerIrql(x)</span></span><br><span class="line">PAGE:<span class="number">004F</span>8E5A                 test    byte ptr [esi+_ETHREAD.CrossThreadFlags], <span class="number">6</span> <span class="comment">// DeadThread:2（创建失败）| </span></span><br><span class="line">  										<span class="comment">//HideFromDebugger:4（该线程对于调试器不可见）</span></span><br><span class="line">PAGE:<span class="number">004F</span>8E61                 jnz     <span class="keyword">short</span> loc_4F8E6B</span><br><span class="line">PAGE:<span class="number">004F</span>8E63                 push    [ebp+arg_4]</span><br><span class="line">PAGE:<span class="number">004F</span>8E66                 call    _DbgkCreateThread@<span class="number">4</span> <span class="comment">// DbgkCreateThread(x)</span></span><br><span class="line">PAGE:<span class="number">004F</span>8E6B loc_4F8E6B:                             <span class="comment">// CODE XREF: PspUserThreadStartup(x,x)+93↑j</span></span><br><span class="line">PAGE:<span class="number">004F</span>8E6B                 cmp     [ebp+var_19], <span class="number">0</span></span><br><span class="line">PAGE:<span class="number">004F</span>8E6F                 jz      <span class="keyword">short</span> loc_4F8E7E</span><br><span class="line">PAGE:<span class="number">004F</span>8E71                 push    <span class="number">0</span>C000004Bh      <span class="comment">// ExitStatus</span></span><br><span class="line">PAGE:<span class="number">004F</span>8E76                 push    esi             <span class="comment">// Object</span></span><br><span class="line">PAGE:<span class="number">004F</span>8E77                 call    _PspTerminateThreadByPointer@<span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>从代码分析来看，只要不是创建失败且不对调试器隐藏的线程，就一定会调用函数 <code>DbgkCreateThread</code>。如果一个线程不走 <code>DbgkCreateThread</code> 这条路线是不被 CPU 跑起来的，所以是必经之路。</p>
</li>
<li><p>进入 <code>DbgkCreateThread</code>，进来后，可以看到有一个判断，<strong>判断当前进程的 DebugPort 的值是否为空（ebx先前会被清零），这是每个 Dbgk 系列的函数都会做的判断；如果 DebugPort 的值不为空，说明当前进程正在被调试</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* VOID DbgkCreateThread(</span></span><br><span class="line"><span class="comment">    PVOID StartAddress	//Supplies the start address for the thread that is starting.</span></span><br><span class="line"><span class="comment">    )</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">PAGE:<span class="number">0056</span>C5A9 loc_56C5A9:                             <span class="comment">// CODE XREF: DbgkCreateThread(x)+26↑j</span></span><br><span class="line">PAGE:<span class="number">0056</span>C5A9                                         <span class="comment">// DbgkCreateThread(x)+2F↑j</span></span><br><span class="line">PAGE:<span class="number">0056</span>C5A9                 cmp     [esi+_EPROCESS.DebugPort], ebx</span><br><span class="line">PAGE:<span class="number">0056</span>C5AF                 jz      loc_56C815</span><br><span class="line">...</span><br><span class="line">PAGE:<span class="number">0056</span>C815 loc_56C815:                             <span class="comment">// CODE XREF: DbgkCreateThread(x)+12B↑j</span></span><br><span class="line">PAGE:<span class="number">0056</span>C815                                         <span class="comment">// DbgkCreateThread(x)+343↑j ...</span></span><br><span class="line">PAGE:<span class="number">0056</span>C815                 call    __SEH_epilog</span><br><span class="line">PAGE:<span class="number">0056</span>C81A                 retn    <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>在判断 <code>DebugPort == 0?</code> 前线程已经调用 <code> PsCallImageNotifyRoutines</code>。如果正在被调试则做两件事：第一件事，通过判断创建的线程是不是第一个线程来判断此时属于创建进程还是创建线程（<code>DbgKmCreateThreadApi/DbgKmCreateProcessApi</code>），第二件事，<strong>针对该调试事件将其打包成一个结构体</strong>。最终调用 <code>DbgkpSendApiMessage</code>，它的第一个参数，就是刚刚打包的调试事件结构体。可参考《软件调试第二版卷2 9.2.2》</p>
</li>
</ol>
<p><strong>小结</strong>：一个线程、进程被创建时，执行到 <code>PspUserThreadStartup</code> ，只要线程创建成功，且该线程不对调试设置隐藏就一定会调用 <code>DbgkCreateThread</code>，以便让调试子系统得到处理机会。在 <code>DbgkCreateThread</code> 中只要 <code>DebugPort != 0</code> 就一定会调用函数 <code>DbgkpSendApiMessage</code>。</p>
<p><img data-src="https://s2.loli.net/2022/08/21/FofyDWm92C4i7VB.png" alt="用户态调试.png"></p>
<h4 id="3-4-2-退出进程、线程"><a href="#3-4-2-退出进程、线程" class="headerlink" title="3.4.2 退出进程、线程"></a>3.4.2 退出进程、线程</h4><p>在《<a target="_blank" rel="noopener" href="https://catecat.github.io/post/ThreadFuction-Analysis/">Terminate&#x2F;Suspend&#x2F;ResumeThread函数分析</a>》中已经分析过结束一个线程的执行路径了，线程自杀，也就是退出进程时会调用 <code>PspExitThread</code>。他杀是通过插入APC实现的。</p>
<ol>
<li><p>如下，当 <code>EPROCESS.Flags = 0x8(ProcessDelete)</code> 即退出进程时，会设置变量 <code>var_19 = 1</code>， 这里的变量最后用来指示是退出线程还是退出进程（是否是最后一个线程）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VOID PspExitThread( IN NTSTATUS ExitStatus )</span></span><br><span class="line">...</span><br><span class="line">PAGE:<span class="number">004F</span>B180 loc_4FB180:                             <span class="comment">// CODE XREF: PspExitThread(x)+F1↑j</span></span><br><span class="line">PAGE:<span class="number">004F</span>B180                 dec     [edi+_EPROCESS.ActiveThreads]</span><br><span class="line">PAGE:<span class="number">004F</span>B186                 jnz     loc_4FB29E</span><br><span class="line">PAGE:<span class="number">004F</span>B18C                 push    <span class="number">8</span>		<span class="comment">//如果已经是最后一个线程</span></span><br><span class="line">PAGE:<span class="number">004F</span>B18E                 pop     eax</span><br><span class="line">PAGE:<span class="number">004F</span>B18F                 lea     ecx, [edi+_EPROCESS.Flags]</span><br><span class="line">PAGE:<span class="number">004F</span>B195                 lock <span class="keyword">or</span> [ecx], eax      <span class="comment">// Flags.ProcessDelete = 1</span></span><br><span class="line">PAGE:<span class="number">004F</span>B195                                         <span class="comment">//    +0x248 Flags            : Uint4B</span></span><br><span class="line">PAGE:<span class="number">004F</span>B195                                         <span class="comment">//    +0x248 CreateReported   : Pos 0, 1 Bit</span></span><br><span class="line">PAGE:<span class="number">004F</span>B195                                         <span class="comment">//    +0x248 NoDebugInherit   : Pos 1, 1 Bit</span></span><br><span class="line">PAGE:<span class="number">004F</span>B195                                         <span class="comment">//    +0x248 ProcessExiting   : Pos 2, 1 Bit</span></span><br><span class="line">PAGE:<span class="number">004F</span>B195                                         <span class="comment">//    +0x248 ProcessDelete    : Pos 3, 1 Bit</span></span><br><span class="line">PAGE:<span class="number">004F</span>B195                                         <span class="comment">//    +0x248 Wow64SplitPages  : Pos 4, 1 Bit</span></span><br><span class="line">PAGE:<span class="number">004F</span>B198                 mov     [ebp+var_19], <span class="number">1</span> <span class="comment">// if(Flags.ProcessDelete == 1) var_19 = 1;</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>如下图，只要对应的条件满足，一定会给内核调试器和用户调试器机会对即将退出的线程进行调试（这里就用到变量<code>var_19</code>）。</p>
<p><img data-src="https://s2.loli.net/2022/08/18/UiVgqFL1jTMAGxS.png" alt="3.png"></p>
</li>
<li><p>参考下面代码，无论是 <code>DbgkExitThread</code> 还是 <code>DbgkExitProcess</code>，内部都会调用 <code>DbgkpSendApiMessage</code>，当然在<strong>调用之前，这两个函数都会先生成一个该函数对应的调试事件结构体</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VOID DbgkExitProcess( NTSTATUS ExitStatus )</span></span><br><span class="line">PAGE:<span class="number">0056</span>C8ED                 push    <span class="number">0</span>		<span class="comment">//因为进程马上就要退出了，无需再进程挂起和恢复</span></span><br><span class="line">  						<span class="comment">//因为进程管理器已经对该线程做了删除标记</span></span><br><span class="line">PAGE:<span class="number">0056</span>C8EF                 lea     eax, [ebp+var_78]</span><br><span class="line">PAGE:<span class="number">0056</span>C8F2                 push    eax</span><br><span class="line">PAGE:<span class="number">0056</span>C8F3                 mov     [ebp+var_78], <span class="number">78000</span>Ch</span><br><span class="line">PAGE:<span class="number">0056</span>C8FA                 mov     [ebp+var_74], <span class="number">8</span></span><br><span class="line">PAGE:<span class="number">0056</span>C901                 mov     [ebp+var_60], <span class="number">4</span></span><br><span class="line">PAGE:<span class="number">0056</span>C908                 call    _DbgkpSendApiMessage@<span class="number">8</span> <span class="comment">// DbgkpSendApiMessage(x,x)</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// VOID DbgkExitThread( NTSTATUS ExitStatus )</span></span><br><span class="line">PAGE:<span class="number">0056</span>C877                 call    _DbgkpSuspendProcess@<span class="number">0</span> <span class="comment">// 先将进程挂起</span></span><br><span class="line">PAGE:<span class="number">0056</span>C87C                 mov     bl, al</span><br><span class="line">PAGE:<span class="number">0056</span>C87E                 push    <span class="number">0</span></span><br><span class="line">PAGE:<span class="number">0056</span>C880                 lea     eax, [ebp+var_78]</span><br><span class="line">PAGE:<span class="number">0056</span>C883                 push    eax</span><br><span class="line">PAGE:<span class="number">0056</span>C884                 call    _DbgkpSendApiMessage@<span class="number">8</span> <span class="comment">// DbgkpSendApiMessage(x,x)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>小结：</strong>在退出线程或进程的必经之路上会调用 <code>DbgkExitThread</code> 或者 <code>DbgkExitProcess</code> 生成相应的调试事件结构体，并最终调用 <code>DbgkpSendApiMessage</code>。其余的调试事件采集函数不再作分析，结论相同，可自行分析。</p>
<p><img data-src="https://s2.loli.net/2022/08/21/FRVS3IvgJp4d6zq.png" alt="消息采集_退出进程_线程的副本.png"></p>
<h4 id="3-4-3-模块的加载、卸载"><a href="#3-4-3-模块的加载、卸载" class="headerlink" title="3.4.3 模块的加载、卸载"></a>3.4.3 模块的加载、卸载</h4><h4 id="3-4-4-异常消息"><a href="#3-4-4-异常消息" class="headerlink" title="3.4.4 异常消息"></a>3.4.4 异常消息</h4><h3 id="3-5-调试消息的发送"><a href="#3-5-调试消息的发送" class="headerlink" title="3.5 调试消息的发送"></a>3.5 调试消息的发送</h3><p>在 3.4 中讲解了调试消息的采集，产生调试消息的被调试进程的线程调用相关 <code>Dbgk</code> 函数，将相应的调试消息封装成 <code>DBGKM_APIMSG</code> 结构，然后调用 <code>DbgkpSendApiMessage</code> 来传送该调试消息<strong>给调试器</strong>。</p>
<h4 id="3-5-1-DbgkpSendApiMessage"><a href="#3-5-1-DbgkpSendApiMessage" class="headerlink" title="3.5.1 DbgkpSendApiMessage"></a>3.5.1 DbgkpSendApiMessage</h4><p>函数 <code>DbgkpSendApiMessage</code> ：该函数将一条调试消息发送到调试子系统服务器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">DbgkpSendApiMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN OUT PDBGKM_APIMSG ApiMsg,	<span class="comment">// 要发送的消息</span></span></span></span><br><span class="line"><span class="function"><span class="params">    IN BOOLEAN SuspendProcess		<span class="comment">// 是否挂起当前进程</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center"><strong>参数</strong></th>
<th align="center"><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">ApiMsg</td>
<td align="center"><strong>消息结构</strong>，每种消息都有自己的消息结构，由不同的调试事件采集函数创建，共有7种类型。</td>
</tr>
<tr>
<td align="center">SuspendProcess</td>
<td align="center">如果 <code>SuspendProcess</code> 为 <code>TRUE</code>，那么这个函数会先调用 <code>DbgkpSuspendProcess</code> 函数挂起本进程内除了自己之外的其他所有线程，然后发送消息，消息发送后将当前线程也挂起。等收到消息回复后先唤醒消息处理的线程，然后再调用 <code>DbgkpResumeProcess</code> 函数唤醒当前进程的其他所有线程。</td>
</tr>
</tbody></table>
<p><img data-src="https://s2.loli.net/2022/08/21/z9QAPpnXOk7letc.png" alt="4.png"></p>
<p><code>KeFreezeAllThreads</code> ：当被调试进程中断到调试器中时，它当前线程的 <code>FreezeCount</code> 通常为0，其他线程的 <code>FreezeCount</code> 通常为1。因为 <code>KeFreezeAllThreads</code> 不会冻结当前线程，包括 WinDBG 在内的调试器在收到调试事件后，会对被调试进程中的所有线程依次调用 <code>SuspendThread</code>，这样所有线程的 <code>SuspendCount</code> 计数通常都为 <code>1</code>。</p>
<p><img data-src="https://s2.loli.net/2022/08/22/z7I1vDhKFxrGds3.png" alt="DbgkpSendApiMessage.png"></p>
<div class="note primary"><p>关于 <code>KTHREAD.FrezeeCount</code> 和 <code>KTHREAD.SuspendCount</code>：</p>
<ul>
<li><code>KTHREAD.FrezeeCount</code>：该字段由 <code>KeFreezeAllThreads</code>函数和 <code>KeThawAllThreads</code> 操作。当一个线程的进程被中断到调试器之后，当前线程<code>FreezeCount == 0</code>，其余线程<code>FreezeCount == 1</code>。即该字段为 <code>1</code> 时表示这个线程处于冻结状态。《软件调试第二版卷2 9.3.3 P175》</li>
<li><code>KTHREAD.SuspendCount</code>：当前线程被挂起的次数，次数小于1则会恢复执行线程。线程活动时该值为0。该字段加减次数由<code>SuspendThread</code> 和 <code>ResumeThread</code> （对应于 <code>NtSuspendThread</code> 内核服务<code>KeSuspendThread</code>）操作。</li>
</ul>
</div>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">PAGE:<span class="number">0056</span>C1F0 <span class="comment">// =============== S U B R O U T I N E =======================================</span></span><br><span class="line">PAGE:<span class="number">0056</span>C1F0</span><br><span class="line">PAGE:<span class="number">0056</span>C1F0 <span class="comment">// Attributes: bp-based frame</span></span><br><span class="line">PAGE:<span class="number">0056</span>C1F0</span><br><span class="line">PAGE:<span class="number">0056</span>C1F0 <span class="comment">// __stdcall DbgkpSendApiMessage(x, x)</span></span><br><span class="line">PAGE:<span class="number">0056</span>C1F0 _DbgkpSendApiMessage@<span class="number">8</span> proc near        <span class="comment">// CODE XREF: DbgkForwardException(x,x,x)+8A↓p</span></span><br><span class="line">PAGE:<span class="number">0056</span>C1F0                                         <span class="comment">// DbgkCreateThread(x)+218↓p ...</span></span><br><span class="line">PAGE:<span class="number">0056</span>C1F0</span><br><span class="line">PAGE:<span class="number">0056</span>C1F0 arg_ApiMsg      = dword ptr  <span class="number">8</span></span><br><span class="line">PAGE:<span class="number">0056</span>C1F0 arg_bSuspendProcess= byte ptr  <span class="number">0</span>Ch</span><br><span class="line">PAGE:<span class="number">0056</span>C1F0</span><br><span class="line">PAGE:<span class="number">0056</span>C1F0                 mov     edi, edi</span><br><span class="line">PAGE:<span class="number">0056</span>C1F2                 push    ebp</span><br><span class="line">PAGE:<span class="number">0056</span>C1F3                 mov     ebp, esp</span><br><span class="line">PAGE:<span class="number">0056</span>C1F5                 push    ebx</span><br><span class="line">PAGE:<span class="number">0056</span>C1F6                 <span class="keyword">xor</span>     ebx, ebx</span><br><span class="line">PAGE:<span class="number">0056</span>C1F8                 cmp     [ebp+arg_bSuspendProcess], bl</span><br><span class="line">PAGE:<span class="number">0056</span>C1FB                 push    esi</span><br><span class="line">PAGE:<span class="number">0056</span>C1FC                 jz      <span class="keyword">short</span> loc_56C206</span><br><span class="line">PAGE:<span class="number">0056</span>C1FE                 call    _DbgkpSuspendProcess@<span class="number">0</span> <span class="comment">// DbgkpSuspendProcess()</span></span><br><span class="line">PAGE:<span class="number">0056</span>C203                 mov     [ebp+arg_bSuspendProcess], al</span><br><span class="line">PAGE:<span class="number">0056</span>C206</span><br><span class="line">PAGE:<span class="number">0056</span>C206 loc_56C206:                             <span class="comment">// CODE XREF: DbgkpSendApiMessage(x,x)+C↑j</span></span><br><span class="line">PAGE:<span class="number">0056</span>C206                 mov     edx, [ebp+arg_ApiMsg]</span><br><span class="line">PAGE:<span class="number">0056</span>C209                 mov     dword ptr [edx+<span class="number">1</span>Ch], <span class="number">103</span>h <span class="comment">// DBGKM_APIMSG.ReturnedStatus, STATUS_PENDING</span></span><br><span class="line">PAGE:<span class="number">0056</span>C209                                         <span class="comment">// 表示调试器正在等待调试消息</span></span><br><span class="line">PAGE:<span class="number">0056</span>C210                 mov     eax, large fs:_KPCR.PrcbData.CurrentThread</span><br><span class="line">PAGE:<span class="number">0056</span>C216                 mov     ecx, [eax+_KTHREAD.ApcState.Process]</span><br><span class="line">PAGE:<span class="number">0056</span>C219                 <span class="keyword">xor</span>     eax, eax</span><br><span class="line">PAGE:<span class="number">0056</span>C21B                 inc     eax             <span class="comment">// PS_PROCESS_FLAGS_CREATE_REPORTED(Create process debug call has occurred)</span></span><br><span class="line">PAGE:<span class="number">0056</span>C21C                 lea     esi, [ecx+_EPROCESS.Flags]</span><br><span class="line">PAGE:<span class="number">0056</span>C222                 lock <span class="keyword">or</span> [esi], eax</span><br><span class="line">PAGE:<span class="number">0056</span>C225                 mov     eax, large fs:_KPCR.PrcbData.CurrentThread</span><br><span class="line">PAGE:<span class="number">0056</span>C22B                 push    ebx             <span class="comment">// PFAST_MUTEX</span></span><br><span class="line">PAGE:<span class="number">0056</span>C22C                 push    ebx             <span class="comment">// PRKEVENT</span></span><br><span class="line">PAGE:<span class="number">0056</span>C22D                 push    edx             <span class="comment">// &amp;ApiMsg</span></span><br><span class="line">PAGE:<span class="number">0056</span>C22E                 push    eax             <span class="comment">// &amp;CurrentThread</span></span><br><span class="line">PAGE:<span class="number">0056</span>C22F                 push    ecx             <span class="comment">// &amp;CurrentProcess</span></span><br><span class="line">PAGE:<span class="number">0056</span>C230                 call    _DbgkpQueueMessage@<span class="number">20</span> <span class="comment">// NTSTATUS DbgkpQueueMessage (</span></span><br><span class="line">PAGE:<span class="number">0056</span>C230                                         <span class="comment">//     IN PEPROCESS Process,</span></span><br><span class="line">PAGE:<span class="number">0056</span>C230                                         <span class="comment">//     IN PETHREAD Thread,</span></span><br><span class="line">PAGE:<span class="number">0056</span>C230                                         <span class="comment">//     IN OUT PDBGKM_APIMSG ApiMsg,</span></span><br><span class="line">PAGE:<span class="number">0056</span>C230                                         <span class="comment">//     IN ULONG Flags,</span></span><br><span class="line">PAGE:<span class="number">0056</span>C230                                         <span class="comment">//     IN PDEBUG_OBJECT TargetDebugObject</span></span><br><span class="line">PAGE:<span class="number">0056</span>C230                                         <span class="comment">//     )</span></span><br><span class="line">PAGE:<span class="number">0056</span>C235                 push    ebx             <span class="comment">// NumberOfBytesToFlush</span></span><br><span class="line">PAGE:<span class="number">0056</span>C236                 push    ebx             <span class="comment">// BaseAddress</span></span><br><span class="line">PAGE:<span class="number">0056</span>C237                 push    <span class="number">0F</span>FFFFFFFh      <span class="comment">// ProcessHandle</span></span><br><span class="line">PAGE:<span class="number">0056</span>C239                 mov     esi, eax</span><br><span class="line">PAGE:<span class="number">0056</span>C23B                 call    _ZwFlushInstructionCache@<span class="number">12</span> <span class="comment">// ZwFlushInstructionCache(x,x,x)</span></span><br><span class="line">PAGE:<span class="number">0056</span>C240                 cmp     [ebp+arg_bSuspendProcess], bl</span><br><span class="line">PAGE:<span class="number">0056</span>C243                 jz      <span class="keyword">short</span> loc_56C24A</span><br><span class="line">PAGE:<span class="number">0056</span>C245                 call    _DbgkpResumeProcess@<span class="number">0</span> <span class="comment">// DbgkpResumeProcess()</span></span><br><span class="line">PAGE:<span class="number">0056</span>C24A</span><br><span class="line">PAGE:<span class="number">0056</span>C24A loc_56C24A:                             <span class="comment">// CODE XREF: DbgkpSendApiMessage(x,x)+53↑j</span></span><br><span class="line">PAGE:<span class="number">0056</span>C24A                 mov     eax, esi</span><br><span class="line">PAGE:<span class="number">0056</span>C24C                 pop     esi</span><br><span class="line">PAGE:<span class="number">0056</span>C24D                 pop     ebx</span><br><span class="line">PAGE:<span class="number">0056</span>C24E                 pop     ebp</span><br><span class="line">PAGE:<span class="number">0056</span>C24F                 retn    <span class="number">8</span></span><br><span class="line">PAGE:<span class="number">0056</span>C24F _DbgkpSendApiMessage@<span class="number">8</span> endp</span><br></pre></td></tr></table></figure>



<h4 id="3-5-2-DbgkpQueueMessage"><a href="#3-5-2-DbgkpQueueMessage" class="headerlink" title="3.5.2 DbgkpQueueMessage"></a>3.5.2 DbgkpQueueMessage</h4><p>函数 <code>DbgkpQueueMessage</code> ：将<strong>扩展的</strong>调试消息 <code>Queue</code> 到调试对象 <code>DEBUG_OBJECT</code> 的消息队列 <code>EventList</code>，以便用户模式调试器获取消息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS __stdcall <span class="title">DbgkpQueueMessage</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PEPROCESS Process,		<span class="comment">//被调试进程对象地址</span></span></span></span><br><span class="line"><span class="function"><span class="params">    IN PETHREAD Thread,			<span class="comment">//被调试进程的线程对象地址</span></span></span></span><br><span class="line"><span class="function"><span class="params">    IN OUT PDBGKM_APIMSG ApiMsg,	<span class="comment">//要传送的调试消息</span></span></span></span><br><span class="line"><span class="function"><span class="params">    IN ULONG Flags,			<span class="comment">//NOWAIT 标志，Flags=0x2时是异步调试消息发送。Flags!=0x2时是同步消息发送，需要等待</span></span></span></span><br><span class="line"><span class="function"><span class="params">    IN PDEBUG_OBJECT TargetDebugObject	<span class="comment">//异步发送消息时有效，是一个调试对象</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span></span><br></pre></td></tr></table></figure>



<h4 id="3-5-3-DBGKM-DEBUG-EVENT"><a href="#3-5-3-DBGKM-DEBUG-EVENT" class="headerlink" title="3.5.3 _DBGKM_DEBUG_EVENT"></a>3.5.3 _DBGKM_DEBUG_EVENT</h4><div class="note danger"><p><strong>注意</strong>：<strong>调试对象的消息队列 <code>DEBUG_OBJECT.EventList</code> 串着的都是 <code>DEBUG_EVENT</code> 结构，该结构是对 <code>DBGKM_APIMSG</code> 的拓展，但是 0 环和 3 环该结构的定义不一样</strong>。</p>
<p>为了区分使用，所以本文借鉴《软件调试》中的命名方式，将 0 环使用的结构名称换为<mark class="label danger">_DBGKM_DEBUG_EVENT</mark>。</p>
</div>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0环使用, _DBGKM_DEBUG_EVENT</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DEBUG_EVENT</span> &#123;</span></span><br><span class="line">+<span class="number">0x00</span>    LIST_ENTRY EventList;	<span class="comment">// 与兄弟节点相互链接的节点结构，注意这不是调试消息队列</span></span><br><span class="line">+<span class="number">0x08</span>    KEVENT ContinueEvent;	<span class="comment">// 用于等待调试器回复的事件对象 </span></span><br><span class="line">+<span class="number">0x18</span>    CLIENT_ID ClientId;	<span class="comment">// 调试事件所属的线程 ID 和进程 ID</span></span><br><span class="line">+<span class="number">0x20</span>    PEPROCESS Process;	<span class="comment">// 被调试进程的 EPROCESS 结构地址</span></span><br><span class="line">+<span class="number">0x24</span>    PETHREAD Thread;	<span class="comment">// 被调试进程中触发调试事件的线程的 ETHREAD 地址</span></span><br><span class="line">+<span class="number">0x28</span>    NTSTATUS Status;	<span class="comment">// 对调试事件的处理结果</span></span><br><span class="line">+<span class="number">0x2C</span>    ULONG Flags;		<span class="comment">// 标志（调试消息是否已经被读取）</span></span><br><span class="line">+<span class="number">0x30</span>    PETHREAD BackoutThread;<span class="comment">// 产生杜撰消息（faked message）的线程</span></span><br><span class="line">+<span class="number">0x38</span>    DBGKM_APIMSG ApiMsg;	<span class="comment">// 调试消息的详细信息</span></span><br><span class="line">&#125; DEBUG_EVENT, *PDEBUG_EVENT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3环使用</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DEBUG_EVENT</span> &#123;</span></span><br><span class="line">    DWORD dwDebugEventCode;		<span class="comment">//事件类型，对应消息类型</span></span><br><span class="line">    DWORD dwProcessId;			<span class="comment">//被调试进程PID</span></span><br><span class="line">    DWORD dwThreadId;			<span class="comment">//被调试线程TID</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span>				<span class="comment">//根据不同的事件类型，对应于不同的结构</span></span><br><span class="line">        EXCEPTION_DEBUG_INFO Exception;</span><br><span class="line">        CREATE_THREAD_DEBUG_INFO CreateThread;</span><br><span class="line">        CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;</span><br><span class="line">        EXIT_THREAD_DEBUG_INFO ExitThread;</span><br><span class="line">        EXIT_PROCESS_DEBUG_INFO ExitProcess;</span><br><span class="line">        LOAD_DLL_DEBUG_INFO LoadDll;</span><br><span class="line">        UNLOAD_DLL_DEBUG_INFO UnloadDll;</span><br><span class="line">        OUTPUT_DEBUG_STRING_INFO DebugString;</span><br><span class="line">        RIP_INFO RipInfo;</span><br><span class="line">    &#125; u;</span><br><span class="line">&#125; DEBUG_EVENT, *LPDEBUG_EVENT;</span><br></pre></td></tr></table></figure>



<p>需要说明的是：</p>
<ul>
<li><p>在 0 环：</p>
<ul>
<li><p><code>DebugObject-&gt;EventsPresent</code>：该成员在 0 环将其信号设置为 1，通知 3 环的调试器来取调试消息。</p>
</li>
<li><p><code>DbgkmDebugEvent.ContinueEvent</code>：该成员在 0 环，用来等待调试器传来的信号。并且这里使用 <code>KeWaitForSingleObject</code> 将被调试进程的最后一个活动线程也挂起，当这个线程获得信号后返回到 <code>DbgkpSendApiMessage</code> 中调用 <code>DbgkpResumeProcess</code> 唤醒其他所有线程。</p>
</li>
<li><p>在 0 环的调用结构是这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KeSetEvent(&amp;DebugObject-&gt;EventsPresent, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">KeWaitForSingleObject(&amp;DbgkmDebugEvent-&gt;ContinueEvent, Executive, KernelMode, FALSE, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>我猜在 3 环的调用结构应该是这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KeWaitForSingleObject(&amp;DebugObject-&gt;EventsPresent, Executive, UserMode, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">KeSetEvent(&amp;DbgkmDebugEvent-&gt;ContinueEvent, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img data-src="https://s2.loli.net/2022/08/21/e7b6DA8JPNuZcX3.png" alt="DbgkpQueueMessage.png"></p>
<p>参考内容：<a target="_blank" rel="noopener" href="http://myblog.ac.cn/archives/windows-diao-shi-liu-cheng-fen-xi#0x6%3Adbgkpsendapimessage">《Windows调试流程分析-Win10 1511 Build:10586》</a>、<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-160595.htm">《科锐三阶段项目-跟踪调试框架》</a>、<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Ox9A82/p/5331387.html">《读书笔记|Windows 调试原理学习|持续更新》</a>、<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-260034.htm">《win7 x64内核调试函数逆向还原C代码，自建调试体系》</a>。</p>
<p>源代码分析如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line">PAGE:<span class="number">0056</span>AFDB <span class="comment">// ---------------------------------------------------------------------------</span></span><br><span class="line">PAGE:<span class="number">0056</span>AFDE                 db <span class="number">6</span> dup(<span class="number">0</span>CCh)</span><br><span class="line">PAGE:<span class="number">0056</span>AFE4</span><br><span class="line">PAGE:<span class="number">0056</span>AFE4 <span class="comment">// =============== S U B R O U T I N E =======================================</span></span><br><span class="line">PAGE:<span class="number">0056</span>AFE4</span><br><span class="line">PAGE:<span class="number">0056</span>AFE4 <span class="comment">// NTSTATUS DbgkpQueueMessage (</span></span><br><span class="line">PAGE:<span class="number">0056</span>AFE4 <span class="comment">//     IN PEPROCESS Process,</span></span><br><span class="line">PAGE:<span class="number">0056</span>AFE4 <span class="comment">//     IN PETHREAD Thread,</span></span><br><span class="line">PAGE:<span class="number">0056</span>AFE4 <span class="comment">//     IN OUT PDBGKM_APIMSG ApiMsg,</span></span><br><span class="line">PAGE:<span class="number">0056</span>AFE4 <span class="comment">//     IN ULONG Flags,</span></span><br><span class="line">PAGE:<span class="number">0056</span>AFE4 <span class="comment">//     IN PDEBUG_OBJECT TargetDebugObject</span></span><br><span class="line">PAGE:<span class="number">0056</span>AFE4 <span class="comment">//     )</span></span><br><span class="line">PAGE:<span class="number">0056</span>AFE4 <span class="comment">// Attributes: bp-based frame</span></span><br><span class="line">PAGE:<span class="number">0056</span>AFE4</span><br><span class="line">PAGE:<span class="number">0056</span>AFE4 <span class="comment">// int __stdcall DbgkpQueueMessage(PVOID, PVOID, int, PRKEVENT, PFAST_MUTEX)</span></span><br><span class="line">PAGE:<span class="number">0056</span>AFE4 _DbgkpQueueMessage@<span class="number">20</span> proc near         <span class="comment">// CODE XREF: DbgkpPostFakeThreadMessages(x,x,x,x,x)+150↓p</span></span><br><span class="line">PAGE:<span class="number">0056</span>AFE4                                         <span class="comment">// DbgkpPostFakeModuleMessages(x,x,x)+136↓p ...</span></span><br><span class="line">PAGE:<span class="number">0056</span>AFE4</span><br><span class="line">PAGE:<span class="number">0056</span>AFE4 var_B8          = byte ptr <span class="number">-0B</span>8h</span><br><span class="line">PAGE:<span class="number">0056</span>AFE4 var_8C          = dword ptr <span class="number">-8</span>Ch</span><br><span class="line">PAGE:<span class="number">0056</span>AFE4 var_DBGKM_DEBUG_EVENT.ApiMsg= dword ptr <span class="number">-8</span></span><br><span class="line">PAGE:<span class="number">0056</span>AFE4 var_Flags_NOWAIT= dword ptr <span class="number">-4</span></span><br><span class="line">PAGE:<span class="number">0056</span>AFE4 arg_Process     = dword ptr  <span class="number">8</span></span><br><span class="line">PAGE:<span class="number">0056</span>AFE4 arg_Thread      = dword ptr  <span class="number">0</span>Ch</span><br><span class="line">PAGE:<span class="number">0056</span>AFE4 arg_pApiMsg     = dword ptr  <span class="number">10</span>h</span><br><span class="line">PAGE:<span class="number">0056</span>AFE4 arg_Flags_0_DebugObj= dword ptr  <span class="number">14</span>h</span><br><span class="line">PAGE:<span class="number">0056</span>AFE4 arg_TargetDebugObject_0_DEBUG_OBJECT.Mutex= dword ptr  <span class="number">18</span>h</span><br><span class="line">PAGE:<span class="number">0056</span>AFE4</span><br><span class="line">PAGE:<span class="number">0056</span>AFE4                 mov     edi, edi</span><br><span class="line">PAGE:<span class="number">0056</span>AFE6                 push    ebp</span><br><span class="line">PAGE:<span class="number">0056</span>AFE7                 mov     ebp, esp</span><br><span class="line">PAGE:<span class="number">0056</span>AFE9                 sub     esp, <span class="number">0B</span>8h</span><br><span class="line">PAGE:<span class="number">0056</span>AFEF                 push    ebx</span><br><span class="line">PAGE:<span class="number">0056</span>AFF0                 push    esi</span><br><span class="line">PAGE:<span class="number">0056</span>AFF1                 mov     esi, [ebp+arg_Flags_0_DebugObj]</span><br><span class="line">PAGE:<span class="number">0056</span>AFF4                 mov     [ebp+var_Flags_NOWAIT], esi</span><br><span class="line">PAGE:<span class="number">0056</span>AFF7                 <span class="keyword">and</span>     [ebp+var_Flags_NOWAIT], <span class="number">2</span> <span class="comment">// var_4 == 0</span></span><br><span class="line">PAGE:<span class="number">0056</span>AFFB                 jz      <span class="keyword">short</span> loc_56B045</span><br><span class="line">PAGE:<span class="number">0056</span>AFFD                 push    <span class="number">45676244</span>h       <span class="comment">// Tag</span></span><br><span class="line">PAGE:<span class="number">0056B</span>002                 push    <span class="number">0B</span>0h            <span class="comment">// NumberOfBytes</span></span><br><span class="line">PAGE:<span class="number">0056B</span>007                 push    <span class="number">8</span>               <span class="comment">// PoolType</span></span><br><span class="line">PAGE:<span class="number">0056B</span>009                 call    _ExAllocatePoolWithQuotaTag@<span class="number">12</span> <span class="comment">// PVOID KsiAllocatePoolWithQuotaTag(</span></span><br><span class="line">PAGE:<span class="number">0056B</span>009                                         <span class="comment">//     IN POOL_TYPE PoolType,</span></span><br><span class="line">PAGE:<span class="number">0056B</span>009                                         <span class="comment">//     IN SIZE_T NumberOfBytes,</span></span><br><span class="line">PAGE:<span class="number">0056B</span>009                                         <span class="comment">//     IN ULONG Tag)</span></span><br><span class="line">PAGE:<span class="number">0056B</span>00E                 mov     ebx, eax</span><br><span class="line">PAGE:<span class="number">0056B</span>010                 test    ebx, ebx</span><br><span class="line">PAGE:<span class="number">0056B</span>012                 jnz     <span class="keyword">short</span> loc_56B01E</span><br><span class="line">PAGE:<span class="number">0056B</span>014                 mov     eax, <span class="number">0</span>C000009Ah</span><br><span class="line">PAGE:<span class="number">0056B</span>019                 jmp     loc_56B192</span><br><span class="line">PAGE:<span class="number">0056B</span>01E <span class="comment">// ---------------------------------------------------------------------------</span></span><br><span class="line">PAGE:<span class="number">0056B</span>01E</span><br><span class="line">PAGE:<span class="number">0056B</span>01E loc_56B01E:                             <span class="comment">// CODE XREF: DbgkpQueueMessage(x,x,x,x,x)+2E↑j</span></span><br><span class="line">PAGE:<span class="number">0056B</span>01E                 mov     ecx, [ebp+arg_Process] <span class="comment">// Object</span></span><br><span class="line">PAGE:<span class="number">0056B</span>021                 <span class="keyword">or</span>      esi, <span class="number">4</span></span><br><span class="line">PAGE:<span class="number">0056B</span>024                 mov     [ebx+DBGKM_DEBUG_EVENT.Flags], esi</span><br><span class="line">PAGE:<span class="number">0056B</span>027                 call    @ObfReferenceObject@<span class="number">4</span> <span class="comment">// ObfReferenceObject(x)</span></span><br><span class="line">PAGE:<span class="number">0056B</span>02C                 mov     ecx, [ebp+arg_Thread] <span class="comment">// Object</span></span><br><span class="line">PAGE:<span class="number">0056B</span>02F                 call    @ObfReferenceObject@<span class="number">4</span> <span class="comment">// ObfReferenceObject(x)</span></span><br><span class="line">PAGE:<span class="number">0056B</span>034                 mov     eax, large fs:<span class="number">124</span>h</span><br><span class="line">PAGE:<span class="number">0056B</span>03A                 mov     [ebx+DBGKM_DEBUG_EVENT.BackoutThread], eax</span><br><span class="line">PAGE:<span class="number">0056B</span>03D                 mov     eax, [ebp+arg_TargetDebugObject_0_DEBUG_OBJECT.Mutex]</span><br><span class="line">PAGE:<span class="number">0056B</span>040                 mov     [ebp+arg_Flags_0_DebugObj], eax</span><br><span class="line">PAGE:<span class="number">0056B</span>043                 jmp     <span class="keyword">short</span> loc_56B0A2 <span class="comment">// KeInitializeEvent()</span></span><br><span class="line">PAGE:<span class="number">0056B</span>045 <span class="comment">// ---------------------------------------------------------------------------</span></span><br><span class="line">PAGE:<span class="number">0056B</span>045</span><br><span class="line">PAGE:<span class="number">0056B</span>045 loc_56B045:                             <span class="comment">// CODE XREF: DbgkpQueueMessage(x,x,x,x,x)+17↑j</span></span><br><span class="line">PAGE:<span class="number">0056B</span>045                 mov     ecx, offset _DbgkpProcessDebugPortMutex <span class="comment">// FastMutex</span></span><br><span class="line">PAGE:<span class="number">0056B</span>04A                 lea     ebx, [ebp+var_B8]</span><br><span class="line">PAGE:<span class="number">0056B</span>050                 mov     [ebp+var_8C], esi <span class="comment">// esi == 0</span></span><br><span class="line">PAGE:<span class="number">0056B</span>056                 call    ds:__imp_@ExAcquireFastMutex@<span class="number">4</span> <span class="comment">// ExAcquireFastMutex(x)</span></span><br><span class="line">PAGE:<span class="number">0056B</span>05C                 mov     eax, [ebp+arg_Process]</span><br><span class="line">PAGE:<span class="number">0056B</span>05F                 mov     eax, [eax+_EPROCESS.DebugPort] <span class="comment">// 此时DebugPort是调试对象地址</span></span><br><span class="line">PAGE:<span class="number">0056B</span>065                 mov     [ebp+arg_Flags_0_DebugObj], eax</span><br><span class="line">PAGE:<span class="number">0056B</span>068                 mov     eax, [ebp+arg_pApiMsg]</span><br><span class="line">PAGE:<span class="number">0056B</span>06B                 mov     eax, [eax+<span class="number">18</span>h]  <span class="comment">// eax = DBGKM_APIMSG.ApiNumber</span></span><br><span class="line">PAGE:<span class="number">0056B</span>06E                 cmp     eax, <span class="number">1</span>          <span class="comment">// 1、对于DbgKmCreateThreadApi、DbgKmCreateProcessApi判断：</span></span><br><span class="line">PAGE:<span class="number">0056B</span>06E                                         <span class="comment">//    如果Thread-&gt;CrossThreadFlags==PS_CROSS_THREAD_FLAGS_SKIP_CREATION_MSG</span></span><br><span class="line">PAGE:<span class="number">0056B</span>06E                                         <span class="comment">//    则不向调试器发送创建消息。</span></span><br><span class="line">PAGE:<span class="number">0056B</span>06E                                         <span class="comment">// 2、对于DbgKmExitThreadApi、DbgKmExitProcessApi判断：</span></span><br><span class="line">PAGE:<span class="number">0056B</span>06E                                         <span class="comment">//    如果Thread-&gt;CrossThreadFlags==PS_CROSS_THREAD_FLAGS_SKIP_CREATION_MSG</span></span><br><span class="line">PAGE:<span class="number">0056B</span>06E                                         <span class="comment">//    则不向调试器发送终止消息。</span></span><br><span class="line">PAGE:<span class="number">0056B</span>071                 jz      <span class="keyword">short</span> loc_56B078 <span class="comment">// 直接跳到 0x56B0A2 即可</span></span><br><span class="line">PAGE:<span class="number">0056B</span>073                 cmp     eax, <span class="number">2</span></span><br><span class="line">PAGE:<span class="number">0056B</span>076                 jnz     <span class="keyword">short</span> loc_56B088</span><br><span class="line">PAGE:<span class="number">0056B</span>078</span><br><span class="line">PAGE:<span class="number">0056B</span>078 loc_56B078:                             <span class="comment">// CODE XREF: DbgkpQueueMessage(x,x,x,x,x)+8D↑j</span></span><br><span class="line">PAGE:<span class="number">0056B</span>078                 mov     ecx, [ebp+arg_Thread]</span><br><span class="line">PAGE:<span class="number">0056B</span>07B                 test    byte ptr [ecx+_ETHREAD.CrossThreadFlags], <span class="number">80</span>h</span><br><span class="line">PAGE:<span class="number">0056B</span>082                 jz      <span class="keyword">short</span> loc_56B088</span><br><span class="line">PAGE:<span class="number">0056B</span>084                 <span class="keyword">and</span>     [ebp+arg_Flags_0_DebugObj], <span class="number">0</span></span><br><span class="line">PAGE:<span class="number">0056B</span>088</span><br><span class="line">PAGE:<span class="number">0056B</span>088 loc_56B088:                             <span class="comment">// CODE XREF: DbgkpQueueMessage(x,x,x,x,x)+92↑j</span></span><br><span class="line">PAGE:<span class="number">0056B</span>088                                         <span class="comment">// DbgkpQueueMessage(x,x,x,x,x)+9E↑j</span></span><br><span class="line">PAGE:<span class="number">0056B</span>088                 cmp     eax, <span class="number">3</span></span><br><span class="line">PAGE:<span class="number">0056B</span>08B                 jz      <span class="keyword">short</span> loc_56B092</span><br><span class="line">PAGE:<span class="number">0056B</span>08D                 cmp     eax, <span class="number">4</span></span><br><span class="line">PAGE:<span class="number">0056B</span>090                 jnz     <span class="keyword">short</span> loc_56B0A2 <span class="comment">// KeInitializeEvent()</span></span><br><span class="line">PAGE:<span class="number">0056B</span>092</span><br><span class="line">PAGE:<span class="number">0056B</span>092 loc_56B092:                             <span class="comment">// CODE XREF: DbgkpQueueMessage(x,x,x,x,x)+A7↑j</span></span><br><span class="line">PAGE:<span class="number">0056B</span>092                 mov     eax, [ebp+arg_Thread]</span><br><span class="line">PAGE:<span class="number">0056B</span>095                 test    byte ptr [eax+<span class="number">249</span>h], <span class="number">1</span></span><br><span class="line">PAGE:<span class="number">0056B</span>09C                 jz      <span class="keyword">short</span> loc_56B0A2 <span class="comment">// KeInitializeEvent()</span></span><br><span class="line">PAGE:<span class="number">0056B</span>09E                 <span class="keyword">and</span>     [ebp+arg_Flags_0_DebugObj], <span class="number">0</span></span><br><span class="line">PAGE:<span class="number">0056B</span>0A2</span><br><span class="line">PAGE:<span class="number">0056B</span>0A2 loc_56B0A2:                             <span class="comment">// CODE XREF: DbgkpQueueMessage(x,x,x,x,x)+5F↑j</span></span><br><span class="line">PAGE:<span class="number">0056B</span>0A2                                         <span class="comment">// DbgkpQueueMessage(x,x,x,x,x)+AC↑j ...</span></span><br><span class="line">PAGE:<span class="number">0056B</span>0A2                 <span class="keyword">and</span>     [ebx+DBGKM_DEBUG_EVENT.ContinueEvent.DISPATCHER_HEADER.SignalState], <span class="number">0</span> <span class="comment">// KeInitializeEvent()</span></span><br><span class="line">PAGE:<span class="number">0056B</span>0A6                 mov     esi, [ebp+arg_pApiMsg]</span><br><span class="line">PAGE:<span class="number">0056B</span>0A9                 mov     [ebx+DBGKM_DEBUG_EVENT.ContinueEvent.Type], <span class="number">1</span> <span class="comment">// EventSynchronizationObject</span></span><br><span class="line">PAGE:<span class="number">0056B</span>0AD                 mov     [ebx+DBGKM_DEBUG_EVENT.ContinueEvent.Size], <span class="number">4</span></span><br><span class="line">PAGE:<span class="number">0056B</span>0B1                 lea     eax, [ebx+DBGKM_DEBUG_EVENT.ContinueEvent.WaitListHead]</span><br><span class="line">PAGE:<span class="number">0056B</span>0B4                 mov     [eax+_LIST_ENTRY.Blink], eax</span><br><span class="line">PAGE:<span class="number">0056B</span>0B7                 mov     [eax+_LIST_ENTRY.Flink], eax</span><br><span class="line">PAGE:<span class="number">0056B</span>0B9                 mov     eax, [ebp+arg_Process]</span><br><span class="line">PAGE:<span class="number">0056B</span>0BC                 push    edi</span><br><span class="line">PAGE:<span class="number">0056B</span>0BD                 mov     [ebx+DBGKM_DEBUG_EVENT.Process], eax</span><br><span class="line">PAGE:<span class="number">0056B</span>0C0                 mov     eax, [ebp+arg_Thread]</span><br><span class="line">PAGE:<span class="number">0056B</span>0C3                 lea     edi, [ebx+<span class="number">38</span>h]</span><br><span class="line">PAGE:<span class="number">0056B</span>0C6                 push    <span class="number">1</span>Eh</span><br><span class="line">PAGE:<span class="number">0056B</span>0C8                 mov     [ebx+DBGKM_DEBUG_EVENT.Thread], eax</span><br><span class="line">PAGE:<span class="number">0056B</span>0CB                 mov     [ebp<span class="number">-8</span>], edi    <span class="comment">// 局部变量2，&amp;_DBGKM_DEBUG_EVENT.ApiMsg</span></span><br><span class="line">PAGE:<span class="number">0056B</span>0CE                 pop     ecx</span><br><span class="line">PAGE:<span class="number">0056B</span>0CF                 rep movsd</span><br><span class="line">PAGE:<span class="number">0056B</span>0D1                 mov     ecx, [ebp+arg_Flags_0_DebugObj]</span><br><span class="line">PAGE:<span class="number">0056B</span>0D4                 mov     esi, eax</span><br><span class="line">PAGE:<span class="number">0056B</span>0D6                 mov     eax, [esi+_ETHREAD.Cid.UniqueProcess]</span><br><span class="line">PAGE:<span class="number">0056B</span>0DC                 mov     [ebx+DBGKM_DEBUG_EVENT.ClientId.UniqueProcess], eax</span><br><span class="line">PAGE:<span class="number">0056B</span>0DF                 mov     eax, [esi+_ETHREAD.Cid.UniqueThread]</span><br><span class="line">PAGE:<span class="number">0056B</span>0E5                 <span class="keyword">xor</span>     edi, edi</span><br><span class="line">PAGE:<span class="number">0056B</span>0E7                 cmp     ecx, edi        <span class="comment">// 判断 EPROCESS.DebugPort == 0 ？</span></span><br><span class="line">PAGE:<span class="number">0056B</span>0E9                 mov     [ebx+DBGKM_DEBUG_EVENT.ClientId.UniqueThread], eax</span><br><span class="line">PAGE:<span class="number">0056B</span>0EC                 jnz     <span class="keyword">short</span> loc_56B0F7 <span class="comment">// ecx == &amp;DEBUG_OBJECT.Mutex</span></span><br><span class="line">PAGE:<span class="number">0056B</span>0EE                 mov     [ebp+arg_Thread], <span class="number">0</span>C0000353h <span class="comment">// STATUS_PORT_NOT_SET</span></span><br><span class="line">PAGE:<span class="number">0056B</span>0F5                 jmp     <span class="keyword">short</span> loc_56B13E</span><br><span class="line">PAGE:<span class="number">0056B</span>0F7 <span class="comment">// ---------------------------------------------------------------------------</span></span><br><span class="line">PAGE:<span class="number">0056B</span>0F7</span><br><span class="line">PAGE:<span class="number">0056B</span>0F7 loc_56B0F7:                             <span class="comment">// CODE XREF: DbgkpQueueMessage(x,x,x,x,x)+108↑j</span></span><br><span class="line">PAGE:<span class="number">0056B</span>0F7                 add     ecx, <span class="number">10</span>h        <span class="comment">// ecx == &amp;DEBUG_OBJECT.Mutex</span></span><br><span class="line">PAGE:<span class="number">0056B</span>0FA                 mov     [ebp+arg_TargetDebugObject_0_DEBUG_OBJECT.Mutex], ecx</span><br><span class="line">PAGE:<span class="number">0056B</span>0FD                 call    ds:__imp_@ExAcquireFastMutex@<span class="number">4</span> <span class="comment">// ExAcquireFastMutex(x)</span></span><br><span class="line">PAGE:<span class="number">0056B</span>103                 mov     edx, [ebp+arg_Flags_0_DebugObj]</span><br><span class="line">PAGE:<span class="number">0056B</span>106                 test    byte ptr [edx+<span class="number">38</span>h], <span class="number">1</span> <span class="comment">// -----------------------------------</span></span><br><span class="line">PAGE:<span class="number">0056B</span>106                                         <span class="comment">// 如果此时 DEBUG_OBJECT.Flags == 2，代表结束调试会话时是否终止被调试进程</span></span><br><span class="line">PAGE:<span class="number">0056B</span>106                                         <span class="comment">// #define DEBUG_OBJECT_DELETE_PENDING (0x1) // 调试对象是否被正在被删除</span></span><br><span class="line">PAGE:<span class="number">0056B</span>106                                         <span class="comment">// #define DEBUG_OBJECT_KILL_ON_CLOSE  (0x2) // Kill all debugged processes on close</span></span><br><span class="line">PAGE:<span class="number">0056B</span>106                                         <span class="comment">// -----------------------------------</span></span><br><span class="line">PAGE:<span class="number">0056B</span>10A                 jnz     <span class="keyword">short</span> loc_56B12E <span class="comment">// STATUS_DEBUGGER_INACTIVE</span></span><br><span class="line">PAGE:<span class="number">0056B</span>10C                 cmp     [ebp+var_Flags_NOWAIT], edi <span class="comment">// var_4 == 0，edi == 0</span></span><br><span class="line">PAGE:<span class="number">0056B</span>10F                 lea     eax, [edx+<span class="number">30</span>h]  <span class="comment">// eax = &amp;DEBUG_OBJECT.EventList</span></span><br><span class="line">PAGE:<span class="number">0056B</span>112                 mov     ecx, [eax+DBGKM_DEBUG_EVENT.EventList.Blink] <span class="comment">// 将刚采集的 DBGKM_DEBUG_EVENT 插入到调试对象的 EventList链尾</span></span><br><span class="line">PAGE:<span class="number">0056B</span>115                 mov     [ebx+DBGKM_DEBUG_EVENT.EventList.Flink], eax</span><br><span class="line">PAGE:<span class="number">0056B</span>117                 mov     [ebx+DBGKM_DEBUG_EVENT.EventList.Blink], ecx</span><br><span class="line">PAGE:<span class="number">0056B</span>11A                 mov     [ecx], ebx</span><br><span class="line">PAGE:<span class="number">0056B</span>11C                 mov     [eax+<span class="number">4</span>], ebx</span><br><span class="line">PAGE:<span class="number">0056B</span>11F                 jnz     <span class="keyword">short</span> loc_56B129 <span class="comment">// KeSetEvent 使事件有信号，让调试器尽快处理调试事件（消息）</span></span><br><span class="line">PAGE:<span class="number">0056B</span>121                 push    edi             <span class="comment">// Wait</span></span><br><span class="line">PAGE:<span class="number">0056B</span>122                 push    edi             <span class="comment">// Increment</span></span><br><span class="line">PAGE:<span class="number">0056B</span>123                 push    edx             <span class="comment">// Event</span></span><br><span class="line">PAGE:<span class="number">0056B</span>124                 call    _KeSetEvent@<span class="number">12</span>  <span class="comment">// KeSetEvent(x,x,x)</span></span><br><span class="line">PAGE:<span class="number">0056B</span>129</span><br><span class="line">PAGE:<span class="number">0056B</span>129 loc_56B129:                             <span class="comment">// CODE XREF: DbgkpQueueMessage(x,x,x,x,x)+13B↑j</span></span><br><span class="line">PAGE:<span class="number">0056B</span>129                 mov     [ebp+arg_Thread], edi</span><br><span class="line">PAGE:<span class="number">0056B</span>12C                 jmp     <span class="keyword">short</span> loc_56B135</span><br><span class="line">PAGE:<span class="number">0056B</span>12E <span class="comment">// ---------------------------------------------------------------------------</span></span><br><span class="line">PAGE:<span class="number">0056B</span>12E</span><br><span class="line">PAGE:<span class="number">0056B</span>12E loc_56B12E:                             <span class="comment">// CODE XREF: DbgkpQueueMessage(x,x,x,x,x)+126↑j</span></span><br><span class="line">PAGE:<span class="number">0056B</span>12E                 mov     [ebp+arg_Thread], <span class="number">0</span>C0000354h <span class="comment">// STATUS_DEBUGGER_INACTIVE</span></span><br><span class="line">PAGE:<span class="number">0056B</span>135</span><br><span class="line">PAGE:<span class="number">0056B</span>135 loc_56B135:                             <span class="comment">// CODE XREF: DbgkpQueueMessage(x,x,x,x,x)+148↑j</span></span><br><span class="line">PAGE:<span class="number">0056B</span>135                 mov     ecx, [ebp+arg_TargetDebugObject_0_DEBUG_OBJECT.Mutex] <span class="comment">// FastMutex</span></span><br><span class="line">PAGE:<span class="number">0056B</span>138                 call    ds:__imp_@ExReleaseFastMutex@<span class="number">4</span> <span class="comment">// ExReleaseFastMutex(x)</span></span><br><span class="line">PAGE:<span class="number">0056B</span>13E</span><br><span class="line">PAGE:<span class="number">0056B</span>13E loc_56B13E:                             <span class="comment">// CODE XREF: DbgkpQueueMessage(x,x,x,x,x)+111↑j</span></span><br><span class="line">PAGE:<span class="number">0056B</span>13E                 cmp     [ebp+var_Flags_NOWAIT], edi</span><br><span class="line">PAGE:<span class="number">0056B</span>141                 jnz     <span class="keyword">short</span> loc_56B173</span><br><span class="line">PAGE:<span class="number">0056B</span>143                 mov     ecx, offset _DbgkpProcessDebugPortMutex <span class="comment">// FastMutex</span></span><br><span class="line">PAGE:<span class="number">0056B</span>148                 call    ds:__imp_@ExReleaseFastMutex@<span class="number">4</span> <span class="comment">// ExReleaseFastMutex(x)</span></span><br><span class="line">PAGE:<span class="number">0056B</span>14E                 cmp     [ebp+arg_Thread], edi</span><br><span class="line">PAGE:<span class="number">0056B</span>151                 jl      <span class="keyword">short</span> loc_56B18E</span><br><span class="line">PAGE:<span class="number">0056B</span>153                 push    edi             <span class="comment">// Timeout</span></span><br><span class="line">PAGE:<span class="number">0056B</span>154                 push    edi             <span class="comment">// Alertable</span></span><br><span class="line">PAGE:<span class="number">0056B</span>155                 push    edi             <span class="comment">// WaitMode</span></span><br><span class="line">PAGE:<span class="number">0056B</span>156                 push    edi             <span class="comment">// WaitReason</span></span><br><span class="line">PAGE:<span class="number">0056B</span>157                 lea     eax, [ebx+<span class="number">8</span>]</span><br><span class="line">PAGE:<span class="number">0056B</span>15A                 push    eax             <span class="comment">// Object</span></span><br><span class="line">PAGE:<span class="number">0056B</span>15B                 call    _KeWaitForSingleObject@<span class="number">20</span> <span class="comment">// KeWaitForSingleObject(x,x,x,x,x)</span></span><br><span class="line">PAGE:<span class="number">0056B</span>160                 mov     eax, [ebx+DBGKM_DEBUG_EVENT.Status] <span class="comment">// 这里将被调试进程的最后一个活动线程也挂起</span></span><br><span class="line">PAGE:<span class="number">0056B</span>163                 mov     esi, [ebp+var_DBGKM_DEBUG_EVENT.ApiMsg]</span><br><span class="line">PAGE:<span class="number">0056B</span>166                 mov     edi, [ebp+arg_pApiMsg]</span><br><span class="line">PAGE:<span class="number">0056B</span>169                 push    <span class="number">1</span>Eh</span><br><span class="line">PAGE:<span class="number">0056B</span>16B                 pop     ecx</span><br><span class="line">PAGE:<span class="number">0056B</span>16C                 mov     [ebp+arg_Thread], eax <span class="comment">// 接收从调试器传回来的消息</span></span><br><span class="line">PAGE:<span class="number">0056B</span>16C                                         <span class="comment">// Status = DebugEvent-&gt;Status//</span></span><br><span class="line">PAGE:<span class="number">0056B</span>16C                                         <span class="comment">// *ApiMsg = DebugEvent-&gt;ApiMsg//</span></span><br><span class="line">PAGE:<span class="number">0056B</span>16F                 rep movsd</span><br><span class="line">PAGE:<span class="number">0056B</span>171                 jmp     <span class="keyword">short</span> loc_56B18E</span><br><span class="line">PAGE:<span class="number">0056B</span>173 <span class="comment">// ---------------------------------------------------------------------------</span></span><br><span class="line">PAGE:<span class="number">0056B</span>173</span><br><span class="line">PAGE:<span class="number">0056B</span>173 loc_56B173:                             <span class="comment">// CODE XREF: DbgkpQueueMessage(x,x,x,x,x)+15D↑j</span></span><br><span class="line">PAGE:<span class="number">0056B</span>173                 cmp     [ebp+arg_Thread], edi</span><br><span class="line">PAGE:<span class="number">0056B</span>176                 jge     <span class="keyword">short</span> loc_56B18E</span><br><span class="line">PAGE:<span class="number">0056B</span>178                 mov     ecx, [ebp+arg_Process] <span class="comment">// Object</span></span><br><span class="line">PAGE:<span class="number">0056B</span>17B                 call    @ObfDereferenceObject@<span class="number">4</span> <span class="comment">// --</span></span><br><span class="line">PAGE:<span class="number">0056B</span>17B                                         <span class="comment">// 减少指定对象的对象引用计数，并在计数变为零时进行清理工作。</span></span><br><span class="line">PAGE:<span class="number">0056B</span>17B                                         <span class="comment">// 不同于句柄引用计数</span></span><br><span class="line">PAGE:<span class="number">0056B</span>17B                                         <span class="comment">// --</span></span><br><span class="line">PAGE:<span class="number">0056B</span>180                 mov     ecx, esi        <span class="comment">// Object</span></span><br><span class="line">PAGE:<span class="number">0056B</span>182                 call    @ObfDereferenceObject@<span class="number">4</span> <span class="comment">// --</span></span><br><span class="line">PAGE:<span class="number">0056B</span>182                                         <span class="comment">// 减少指定对象的对象引用计数，并在计数变为零时进行清理工作。</span></span><br><span class="line">PAGE:<span class="number">0056B</span>182                                         <span class="comment">// 不同于句柄引用计数</span></span><br><span class="line">PAGE:<span class="number">0056B</span>182                                         <span class="comment">// --</span></span><br><span class="line">PAGE:<span class="number">0056B</span>187                 push    edi             <span class="comment">// Tag</span></span><br><span class="line">PAGE:<span class="number">0056B</span>188                 push    ebx             <span class="comment">// P</span></span><br><span class="line">PAGE:<span class="number">0056B</span>189                 call    _ExFreePoolWithTag@<span class="number">8</span> <span class="comment">// ExFreePoolWithTag(x,x)</span></span><br><span class="line">PAGE:<span class="number">0056B</span>18E</span><br><span class="line">PAGE:<span class="number">0056B</span>18E loc_56B18E:                             <span class="comment">// CODE XREF: DbgkpQueueMessage(x,x,x,x,x)+16D↑j</span></span><br><span class="line">PAGE:<span class="number">0056B</span>18E                                         <span class="comment">// DbgkpQueueMessage(x,x,x,x,x)+18D↑j ...</span></span><br><span class="line">PAGE:<span class="number">0056B</span>18E                 mov     eax, [ebp+arg_Thread]</span><br><span class="line">PAGE:<span class="number">0056B</span>191                 pop     edi</span><br><span class="line">PAGE:<span class="number">0056B</span>192</span><br><span class="line">PAGE:<span class="number">0056B</span>192 loc_56B192:                             <span class="comment">// CODE XREF: DbgkpQueueMessage(x,x,x,x,x)+35↑j</span></span><br><span class="line">PAGE:<span class="number">0056B</span>192                 pop     esi</span><br><span class="line">PAGE:<span class="number">0056B</span>193                 pop     ebx</span><br><span class="line">PAGE:<span class="number">0056B</span>194                 leave</span><br><span class="line">PAGE:<span class="number">0056B</span>195                 retn    <span class="number">14</span>h</span><br><span class="line">PAGE:<span class="number">0056B</span>195 _DbgkpQueueMessage@<span class="number">20</span> endp</span><br></pre></td></tr></table></figure>



<h2 id="4-杜撰的调试消息"><a href="#4-杜撰的调试消息" class="headerlink" title="4 杜撰的调试消息"></a>4 杜撰的调试消息</h2><p>在 2.3 中讲了如何将调试器附加到一个已经处于运行状态的被调试进程，但是还有两个细节没有说（没有逆向分析）。本节是对 2.3 的补充，同时本节用来和 3.4.1 作对比。</p>
<div class="note default"><p>当使用<strong>附加</strong>的方式来调试一个进程时，调试子系统会“假装”此时正在创建一个新进程，模仿像创建进程那样给调试器发送杜撰的消息（faked debug message）。但是有一点区别：</p>
<ol>
<li>在被调试进程 <code>DbgkCreateThread</code> 中，当判断是创建进程时，会调用两次 <code>DbgkpSendApiMessage</code> 来分别发送 <code>DbgKmCreateProcessApi-DbgKmLoadDllApi</code> 或 <code>DbgKmCreateThreadApi</code> 消息。发送调试信息的线程属于被调试进程。可以挂起当前进程。消息发送是同步的。</li>
<li>在发送杜撰消息时，调试器的线程直接使用 <code>DbgkpQueueMessage</code> 来发送上面这三类消息。发送调试信息的线程属于调试器进程。不会挂起被调试进程，且消息发送是异步的（指定了 <code>NO_WAIT</code> ）。</li>
</ol>
</div>

<p>在 <code>nt!NtDebugActiveProcess</code> 中函数的主要调用顺序如下（由于该函数调用的子函数太多了，所以本节主要是参考源码和软件调试第二版卷2 9.4.5 来精简总结）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">NtDebugActiveProcess</span><span class="params">(IN HANDLE ProcessHandle, IN HADNLE DebugObjectHandle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  PDEBUG_OBJECT DebugObject;</span><br><span class="line">  PEPROCESS Process;</span><br><span class="line">  NTSTATUS Status;</span><br><span class="line">  </span><br><span class="line">  Status = ObReferenceObjectByHandle(ProcessHandle,PROCESS_SET_PORT,PsProcessType,PreviousMode,&amp;Process,<span class="literal">NULL</span>);</span><br><span class="line">  Status = ObReferenceObjectByHandle(DebugObjectHandle,DEBUG_PROCESS_ASSIGN,DbgkDebugObjectType,PreviousMode,</span><br><span class="line">                                     &amp;DebugObject,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">// 发送杜撰的进程/线程创建消息</span></span><br><span class="line">  Status = DbgkpPostFakeProcessCreateMessages(Process,DebugObject,&amp;LastThread);</span><br><span class="line">  </span><br><span class="line">  Status = DbgkpSetProcessDebugObject(Process,DebugObject,Status,LastThread);</span><br><span class="line">  <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数 <code>DbgkpSetProcessDebugObject</code> 用来将被调试进程和调试对象进行关联，但是在关联之前会调用 <code>DbgkpPostFakeProcessCreateMessages</code> 来发送上面提到的杜撰的消息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">DbgkpPostFakeProcessCreateMessages</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PEPROCESS Process,		<span class="comment">//被调试的进程对象</span></span></span></span><br><span class="line"><span class="function"><span class="params">    IN PDEBUG_OBJECT DebugObject,	<span class="comment">//调试对象</span></span></span></span><br><span class="line"><span class="function"><span class="params">    IN PETHREAD *pLastThread</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  NTSTATUS Status;</span><br><span class="line">  KAPC_STATE ApcState;</span><br><span class="line">  PETHREAD Thread;</span><br><span class="line">  PETHREAD LastThread;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将当前属于调试器的线程附加到被调试进程地址空间，CR3。</span></span><br><span class="line">  <span class="comment">// 调试会话建立的过程是由调试器发起的，所以当前线程属于调试器进程。</span></span><br><span class="line">  KeStackAttachProcess(&amp;Process-&gt;Pcb, &amp;ApcState);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发送 DbgKmCreateProcessApi/DbgKmCreateThreadApi 消息</span></span><br><span class="line">  Status = DbgkpPostFakeThreadMessages(Process, DebugObject, <span class="literal">NULL</span>, &amp;Thread, &amp;LastThread);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发送 DbgKmLoadDllApi 消息</span></span><br><span class="line">  <span class="keyword">if</span>(NT_SUCCESS(Status))</span><br><span class="line">  &#123;</span><br><span class="line">    Status = DbgkpPostFakeModuleMessages(Process, Thread, DebugObject);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DbgkpPostFakeProcessCreateMessages</code> 会先调用 <code>DbgkpPostFakeThreadMessages</code>，后者会遍历被调试进程的所有线程，以向调试对象的消息队列中投放杜撰的进程和线程来创建消息。而后 <code>DbgkpPostPakeProcessCreateMessages</code> 会调用<code>DbgkpPostFakeModuleMessages</code> 来投放杜撰的模块加载消息。</p>
<div class="note success"><p><code>DbgkpPostFakeThreadMessages</code> 和 <code>DbgkpPostFakeModuleMessages</code> 都是调用 <code>DbgkpQueueMessage</code> 来向消息队列添加调试消息的。</p>
<p>因为在<strong>参数中指定了不需等待的标志</strong>（<code>NOWAIT</code>，异步)，所以 <code>DbgkpQueueMessage</code> 将事件放人队列后便会返回，不会设置 <code>EventsPresent</code> 对象以避免它通知调试器来读取。</p>
</div>

<p><code>DbgkpSetProcessDebugObject</code> 函数内部除了将调试对象赋给被调试进程 <code>EPROCESS</code> 结构的 <code>DebugPort</code>字段，还会调用 <code>DbgkpMarkProcessPeb</code> 函数设置被调试进程环境块<mark class="label primary">PEB.BeingDebugged</mark>字段（用于在用户态判断进程是否正在被调试）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">DbgkpMarkProcessPeb</span><span class="params">(PEPROCESS Process)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(ExAcquireRundownProtection (&amp;Process-&gt;RundownProtect))</span><br><span class="line">  &#123;</span><br><span class="line">    KeStackAttachProcess(&amp;Process-&gt;Pcb, &amp;ApcState);</span><br><span class="line">    ExAcquireFastMutex (&amp;DbgkpProcessDebugPortMutex);</span><br><span class="line">    </span><br><span class="line">    Process-&gt;Peb-&gt;BeingDebugged = (BOOLEAN)(Process-&gt;DebugPort != <span class="literal">NULL</span> ? TRUE : FALSE);</span><br><span class="line">    </span><br><span class="line">    ExReleaseFastMutex (&amp;DbgkpProcessDebugPortMutex);</span><br><span class="line">    KeUnstackDetachProcess(&amp;ApcState);</span><br><span class="line">  &#125;</span><br><span class="line">  ExReleaseRundownProtection (&amp;Process-&gt;RundownProtect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个进程不在被调试状态，那么其 PEB 结构的 <code>Being Debugged</code> 字段为 0；否则，为 1。<code>ISDebuggerPresent</code> API 就是通过判断 <code>BeingDebugged</code> 字段实现的。</p>
<h2 id="5-清除调试对象"><a href="#5-清除调试对象" class="headerlink" title="5 清除调试对象"></a>5 清除调试对象</h2><p>当调试结束后需要撤销调试会话时，系统会调用 <code>DbgkClearProcessDebugObject</code> 将被调试进程的 <code>DebugPort</code> 字段恢复为 <code>NULL</code>。恢复时，这个函数会遍历调试对象的消息队列，将关于这个进程的调试事件清除。这个函数并不破坏调试对象，因为一个调试器可以同时调试多个被调试进程，这个调试对象可能还在被其他被调试进程所使用。</p>
<p>以前的 TP 保护就是起一个线程不断地扫描要保护的程序的 <code>DebugPort</code> 字段，来检测是否被调试，然后将 <code>DebugPort</code> 不断清零。后来逐渐演变，有的调试器在建立调试会话时，会将 <code>DebugPort</code> 移位到其他一些不常用的偏移处或保留位置（如 <code>ExitTime</code>）。也有的是将 <code>EPROCESS</code> 结构进行扩展，然后将相关调试结构移位到扩展的位置。</p>
<p>还有的检测手段就是，起一个线程，不断地遍历每一个线程 <code>TEB.DbgSsReserved</code> 出来判断其是否是调试器。</p>
<p>可以参考：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-260034.htm">win7 x64内核调试函数逆向还原C代码，自建调试体系</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1509729-1-1.html">现在流行debugport 移位, 重写调试框架啥的,我是这么实现的,一劳永逸</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/s/video/BV1nt411v75x"><strong>梦织未来论坛的调试与异常和过驱动保护</strong></a>（win7&#x2F;win8&#x2F;win10 64 过保护 驱动教程–郁金香外挂教程）</p>
</li>
</ul>
<h2 id="6-用户态调试全景"><a href="#6-用户态调试全景" class="headerlink" title="6 用户态调试全景"></a>6 用户态调试全景</h2><p><img data-src="https://s2.loli.net/2022/08/24/NAVQX5czDkiFa7T.png" alt="5.png"></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>Buy me a coffee</div>
  <button onclick="document.querySelector('.post-reward').classList.toggle('active');">
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechat.jpg" alt="Catecat 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpg" alt="Catecat 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Catecat
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://directoree.github.io/post/WinXP-Debug/" title="Windows XP 用户态调试（一）被调试进程">https://directoree.github.io/post/WinXP-Debug/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/WinXP%E5%86%85%E6%A0%B8/" rel="tag"><i class="fa fa-tag"></i> WinXP内核</a>
              <a href="/tags/X86%E8%B0%83%E8%AF%95/" rel="tag"><i class="fa fa-tag"></i> X86调试</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/Win32-EventMessage/" rel="prev" title="Win32开发（一）事件与消息">
                  <i class="fa fa-chevron-left"></i> Win32开发（一）事件与消息
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/WinXP-Debug2/" rel="next" title="Windows XP 用户态调试（二）调试器进程">
                  Windows XP 用户态调试（二）调试器进程 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Catecat</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">2.3m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">34:30</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1.15.0/dist/lozad.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/local-search.js"></script>








<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  const url = element.dataset.target;
  const pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  const pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  const fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script>
if (document.querySelectorAll('.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8.7.0/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>








  

  
      <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//cdn.jsdelivr.net/npm/mathjax@3.1.0/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
NexT.utils.loadComments('#valine-comments', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    new Valine(Object.assign({"enable":true,"appId":"7zujCcS8pYH88CJXfdBlLyS8-gzGzoHsz","appKey":"lWGr7OPoNHo4v1YmVV5yr3E9","serverURLs":"https://7zujccs8.lc-cn-n1-shared.com","placeholder":"快来勾搭我呀🐶","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"lang":null,"visitor":true,"comment_count":true,"bg":"/images/comment_bg.png","recordIP":false,"enableQQ":false,"requiredFields":["nick"]}, {
      el: '#valine-comments',
      path: "/post/WinXP-Debug/",
      serverURLs: "https://7zujccs8.lc-cn-n1-shared.com"
    }));
  }, window.Valine);
});
</script>

</body>
</html>
