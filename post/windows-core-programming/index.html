<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon1.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"directoree.github.io","root":"/","scheme":"Mist","version":"8.0.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="ʕ •ᴥ•ʔ  ɔ:">
<meta property="og:type" content="article">
<meta property="og:title" content="Windows核心编程（第五版）_1_错误处理_字符处理_内核对象">
<meta property="og:url" content="https://directoree.github.io/post/windows-core-programming/index.html">
<meta property="og:site_name" content="Catecat">
<meta property="og:description" content="ʕ •ᴥ•ʔ  ɔ:">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img.shields.io/badge/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E3%80%8AWindows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%EF%BC%88%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%89%E3%80%8B-1fd0f6.svg?colorA=ff69b4">
<meta property="og:image" content="https://i.loli.net/2021/11/04/5kmzEPThDyJ43bO.png">
<meta property="og:image" content="https://i.loli.net/2021/11/04/PMXndw8cJgW5673.png">
<meta property="og:image" content="https://i.loli.net/2021/11/08/RDKUTtOVds4i5wg.png">
<meta property="article:published_time" content="2021-11-03T07:28:58.000Z">
<meta property="article:modified_time" content="2021-11-10T08:52:12.398Z">
<meta property="article:author" content="Catecat">
<meta property="article:tag" content="Windows内核">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.shields.io/badge/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E3%80%8AWindows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%EF%BC%88%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%89%E3%80%8B-1fd0f6.svg?colorA=ff69b4">


<link rel="canonical" href="https://directoree.github.io/post/windows-core-programming/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Windows核心编程（第五版）_1_错误处理_字符处理_内核对象 | Catecat</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b832a9ae9a43377003fd975ca4e525ea";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Catecat</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">爱你所爱，行你所行，听从你心，无问西东。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/newcategories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-更新日志">

    <a href="/changelog" rel="section"><i class="fa fa-heartbeat fa-fw"></i>更新日志</a>

  </li>
        <li class="menu-item menu-item-空调房">

    <a href="/tips" rel="section"><i class="fa fa-wifi fa-fw"></i>空调房</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Windows-API%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-text">1 Windows API返回值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%87%BD%E6%95%B0%E7%9A%84%E9%94%99%E8%AF%AF%E7%A0%81"><span class="nav-text">1.1 函数的错误码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E7%A0%81"><span class="nav-text">1.2 自定义错误码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86"><span class="nav-text">2 字符和字符串处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="nav-text">2.1 字符集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-ANSI%E3%80%81Unicode%E5%AD%97%E7%AC%A6%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">2.2 ANSI、Unicode字符、字符串数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-Windows%E4%B8%AD%E7%9A%84ANSI%E5%92%8CUnicode%E5%87%BD%E6%95%B0"><span class="nav-text">2.3 Windows中的ANSI和Unicode函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-C%E8%BF%90%E8%A1%8C%E5%BA%93%E4%B8%AD%E7%9A%84ANSI%E5%92%8CUnicode%E5%87%BD%E6%95%B0"><span class="nav-text">2.4 C运行库中的ANSI和Unicode函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-C%E8%BF%90%E8%A1%8C%E5%BA%93%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="nav-text">2.5 C运行库中的安全字符串函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-Windows%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="nav-text">2.6 Windows字符串函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1"><span class="nav-text">3 内核对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">3.1 内核对象是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98-%E4%BD%BF%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="nav-text">3.2 内核对象成员-使用计数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98-%E5%AE%89%E5%85%A8%E5%B1%9E%E6%80%A7"><span class="nav-text">3.3 内核对象成员-安全属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E8%BF%9B%E7%A8%8B%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1%E5%8F%A5%E6%9F%84%E8%A1%A8"><span class="nav-text">3.4 进程内核对象句柄表</span></a></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Catecat"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Catecat</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">149</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/newcategories/">
          
        <span class="site-state-item-count">67</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">85</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Directoree" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Directoree" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhao_yilong@aliyun.com" title="E-Mail → mailto:zhao_yilong@aliyun.com" rel="noopener" target="_blank"><i class="fas fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://sighttp.qq.com/msgrd?v=1&uin=1003432683" title="QQ → http:&#x2F;&#x2F;sighttp.qq.com&#x2F;msgrd?v&#x3D;1&amp;uin&#x3D;1003432683" rel="noopener" target="_blank"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://treecatee.github.io/" title="https:&#x2F;&#x2F;treecatee.github.io" rel="noopener" target="_blank">Treecatee</a>
        </li>
    </ul>
  </div>

      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://directoree.github.io/post/windows-core-programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Catecat">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Catecat">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Windows核心编程（第五版）_1_错误处理_字符处理_内核对象
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-03 15:28:58" itemprop="dateCreated datePublished" datetime="2021-11-03T15:28:58+08:00">2021-11-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-11-10 16:52:12" itemprop="dateModified" datetime="2021-11-10T16:52:12+08:00">2021-11-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AC%94%E8%AE%B0/%E9%80%86%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">逆向</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AC%94%E8%AE%B0/%E9%80%86%E5%90%91/Windows%E5%86%85%E6%A0%B8/" itemprop="url" rel="index"><span itemprop="name">Windows内核</span></a>
        </span>
    </span>

  
    <span id="/post/windows-core-programming/" class="post-meta-item leancloud_visitors" data-flag-title="Windows核心编程（第五版）_1_错误处理_字符处理_内核对象" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/post/windows-core-programming/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/post/windows-core-programming/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>ʕ •ᴥ•ʔ  ɔ: </p>
<span id="more"></span>

<p><img data-src="https://img.shields.io/badge/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E3%80%8AWindows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%EF%BC%88%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%89%E3%80%8B-1fd0f6.svg?colorA=ff69b4"></p>
<h2 id="1-Windows-API返回值"><a href="#1-Windows-API返回值" class="headerlink" title="1 Windows API返回值"></a>1 Windows API返回值</h2><p>调用Windows函数时，它会先验证我们传给它的参数，然后再开始执行任务。如果传入的参数无效，或者由于其他原因导致操作无法执行，则函数的返回值将指出函数因为某些原因失败了。表1-1展示了大多数Windows函数使用的返回值的数据类型。</p>
<p><img data-src="https://i.loli.net/2021/11/04/5kmzEPThDyJ43bO.png" alt="1.png"></p>
<h3 id="1-1-函数的错误码"><a href="#1-1-函数的错误码" class="headerlink" title="1.1 函数的错误码"></a>1.1 函数的错误码</h3><p>通常情况下，如果 Windows函数能返回错误代码，将有助于我们理解函数调用为什么会失败。 Microsoft编辑了一个列表，其中列出了所有可能的错误代码，<mark class="label success">并为每个错误代码都分配了一个32位的编号</mark>。定义于<mark class="label danger">WinError.h</mark>头文件中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">GetlastError</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>此函数的作用很简单，就是返回由上一个函数调用设置的线程的32位错误代码。</p>
<p>在这个头文件中每个错误码（消息ID）都对应：一个消息ID（一个可在源代码中使用的宏，用于与<code>GetLastError</code>的返回值进行比较）、消息文本（描述错误的英文文本）和一个编号（应该避免使用此编号，尽量使用消息ID）。</p>
<div class="note primary"><p><strong>注意：</strong>Windows函数失败之后，应该马上调用<code>GetLastError</code>，因为假如又调用了另一个Windows函数，则此值很可能被改写。注意，成功调用的Windows函数可能用<code>ERROR_SUCCESS</code>改写此值。</p>
<p><mark class="label default">不管成功与否，使用<code>GetLastError</code>都可以知道函数调用的额外信息。</mark></p>
</div>

<h3 id="1-2-自定义错误码"><a href="#1-2-自定义错误码" class="headerlink" title="1.2 自定义错误码"></a>1.2 自定义错误码</h3><p>为了指出错误，只需<mark class="label warning">设置线程的上一个错误代码</mark>，然后令自己的函数返回<code>FALSE</code>，<code>INVALID_HANDLE_VALUE</code>、<code>NULL</code>或者其他合适的值。为了设置线程的上一个错误代码，只需调用以下函数，并传递我们认为合适的任何32位值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">SetlastError</span><span class="params">(DWORD dwErrCode)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该32位值的每一位含义如下：</p>
<p><img data-src="https://i.loli.net/2021/11/04/PMXndw8cJgW5673.png" alt="2.png"></p>
<p>Microsoft承诺，<strong>在它所生成的所有错误代码中，第29位将始终为0</strong>。但是，如果要创建我们自己的错误代码，就必须在此位放入一个1。通过这种方式，可以保证我们的错误代码绝不会与Microsoft现在和将来定义的错误代码冲突。注意，Facility字段非常大，足以容纳4096个可能的值。其中，前256个值是为Microsoft保留的，其余的值可由我们自己的应用程序来定义。</p>
<h2 id="2-字符和字符串处理"><a href="#2-字符和字符串处理" class="headerlink" title="2 字符和字符串处理"></a>2 字符和字符串处理</h2><h3 id="2-1-字符集"><a href="#2-1-字符集" class="headerlink" title="2.1 字符集"></a>2.1 字符集</h3><table>
<thead>
<tr>
<th>字符集</th>
<th>字节数</th>
<th>表示范围</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>标准ASCII</td>
<td><strong>1字节</strong>，使用低7位，最高位始终为0.</td>
<td>0～127</td>
<td>标准 ASCII 码使用 7 位二进制数来表示所有的大写和小写字母，数字 0 到 9、标点符号，以及在美式英语中使用的特殊控制字符。</td>
</tr>
<tr>
<td>扩展 ASCII 码（ANSI）</td>
<td><strong>1字节</strong>，使用8位，最高位为0时相当于标准ASCII.</td>
<td>0～255</td>
<td>扩展 ASCII 码允许将每个字符的第 8 位用于确定附加的 128 个特殊符号字符、外来语字母和图形符号。<br />ASCll码的字符集可以扩充了128个字符，即十进制数128～255，称为扩展ASCII码。扩展ASCII码所增加的字符包括加框文字、圆圈和其他图形符号。</td>
</tr>
<tr>
<td>GB2312</td>
<td><strong>2字节</strong>，高9位为0时，低7位含义同标准ASCII.</td>
<td>0～65535</td>
<td>一个小于127的字符的意义与原来相同，  但两个大于127的字符连在一起时，就表示一个汉字。不同的文字（国家语言）存于不同的序段。<br />虽然是双字节编码，但是编码完全不同于Unicode。</td>
</tr>
<tr>
<td>GBK</td>
<td><strong>2字节</strong>，属于扩展的GB2312.</td>
<td>0～65535</td>
<td>GB2312是简体汉字编码规范，GBK编码能够用来同时表示繁体字和简体字，而GB2312只能表示简体字，GBK是兼容GB2312编码的。</td>
</tr>
<tr>
<td>Unicode</td>
<td><strong>1～4字节</strong>，Windows使用UTF-16编码形式存储字符.</td>
<td>0x000000~0x0010FFFF</td>
<td>Unicode只规定了字符的二进制表示方式，并没有指出这些二进制数据如何在计算机中存储（规则）。并且不同国家的语言使用不同的区域，Unicode 只是字符集，UTF-8、UTF-16、UTF-32 才是真正的字符编码规则，常用的编码规则：<br /><strong>UTF-8：</strong>变长编码方式，使用1～4字节来编码不同字符，存储划算，常用于网络传输。<br /><strong>UTF-16：</strong>定长编码，使用2字节或者4字节。编码效率高，Windows、Java使用。<br /><strong>UTF-32：</strong>定长编码，使用4字节，存储非常不划算，更不用说网络传输了。所以这种实现用得极少。</td>
</tr>
</tbody></table>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.21ic.com/article/898541.html">Unicode、UTF-8、UTF-16，终于懂了</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/51202412">Unicode 编码及 UTF-32, UTF-16 和 UTF-8</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/crazylqy/p/10184291.html">彻底弄懂 Unicode 编码</a></li>
</ul>
<h3 id="2-2-ANSI、Unicode字符、字符串数据类型"><a href="#2-2-ANSI、Unicode字符、字符串数据类型" class="headerlink" title="2.2 ANSI、Unicode字符、字符串数据类型"></a>2.2 ANSI、Unicode字符、字符串数据类型</h3><p>C语言的<code>char</code>使用8位的ANSI字符。</p>
<p><code>wchar_t</code>数据类型使用16位（UTF-16）的Unicode。Microsoft的C&#x2F;C++编译器定义了这个内建的数据类型<code>wchar_t</code>。</p>
<p><strong>Unicode编码的数据类型</strong>：</p>
<ul>
<li>数据类型定义在Windows头文件<mark class="label danger">WinNT.h</mark>中；</li>
<li>使用<code>L&#39;&#39;</code>、<code>L&quot;&quot;</code>来表示字符和字符串，如<code>wchar_t wchar = L&#39;A&#39;;</code>；</li>
<li>使用通用字符数据类型<code>TEXT(&#39;&#39;)</code>和<code>TEXT(&quot;&quot;)</code>会在使用ANSI或Unicode的编译器中自动使用<code>char</code>或<code>wchar</code>数据类型。</li>
</ul>
<p>Windows常用数据类型、API、结构体可查看：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/debug/system-error-codes"><mark class="label primary">MSDN</mark></a><a target="_blank" rel="noopener" href="https://doxygen.reactos.org/d7/d69/typedefs_8h.html"><mark class="label default">ReactOS</mark></a><a target="_blank" rel="noopener" href="https://www.rpi.edu/dept/cis/software/g77-mingw32/include/"><mark class="label warning">Win32头文件</mark></a><a target="_blank" rel="noopener" href="http://yfvb.com/help/win32sdk/"><mark class="label info">Win32API参考手册</mark></a>等。</p>
<h3 id="2-3-Windows中的ANSI和Unicode函数"><a href="#2-3-Windows中的ANSI和Unicode函数" class="headerlink" title="2.3 Windows中的ANSI和Unicode函数"></a>2.3 Windows中的ANSI和Unicode函数</h3><p><strong>一、A版、W版Win32 API</strong></p>
<p>自Windows NT起，Windows的所有版本都完全用Unicode来构建。</p>
<p>调用Windows函数时，<strong>如果向它传入一个ANSI字符串（由单字节字符组成的一个字符串），那么函数首先会把字符串转换为Unicode</strong>，再把结果传给操作系统。如果希望函数返回ANSI字符串，那么操作系统会先把Unicode字符串转换为ANSI字符串，再把结果返回给我们的应用程序。所有这些转换都是在幕后进行的。</p>
<p>如果一个Windows函数的多数列表中有字符串，则该函数通常有两个版本，<mark class="label danger">A</mark>版、<mark class="label danger">W</mark>版。如：</p>
<ul>
<li><code>CreateWindowExA</code>：接受ANSI字符串；</li>
<li><code>CreateWindowExW</code>：接受Unicode字符串。</li>
</ul>
<div class="note primary"><p><strong>备注：</strong>使用时只需要用宏<code>CreateWindowEx</code>即可，因为编译器会自动使用<strong>A</strong>版或<strong>W</strong>版。这些类似的宏在<mark class="label danger">WinUser.h</mark>中定义。</p>
<p>ANSI版本只是分配内存，执行必要的字符串转换，然后调用该函数的Unicode版本与操作系统打交道。</p>
</div>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CreateWindowEx  CreateWindowExW</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CreateWindowEx  CreateWindowExA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !UNICODE</span></span></span><br></pre></td></tr></table></figure>



<p><strong>二、尽量使用新函数</strong></p>
<p>Windows API中的一些函数如：</p>
<p><code>WinExec</code>和<code>OpenFile</code>存在的唯一目的就是为了向后兼容16位Windows程序，因为后者只支持ANSI字符串。在开发的新程序中，应避免使用这些函数。应该用<code>CreateProcess</code>和<code>CreateFile</code>函数调用来代替。</p>
<p>在内部，老函数总是会调用新函数。但老函数的最大问题在于，它们不接受Unicode字符串，而且支持的功能一般都要少一些。调用这些函数的时候，必须向其传递ANSI字符串。</p>
<h3 id="2-4-C运行库中的ANSI和Unicode函数"><a href="#2-4-C运行库中的ANSI和Unicode函数" class="headerlink" title="2.4 C运行库中的ANSI和Unicode函数"></a>2.4 C运行库中的ANSI和Unicode函数</h3><p>和Windows函数一样，C运行库提供了一系列函数来处理ANSI字符和字符串，并提供了另一系列函数来处理Unicode字符与字符串。然而，与Windows不同的是，<mark class="label info">ANSI版本的函数是不会把字符串转换为Unicode形式，再从内部调用函数的Unicode版本</mark>。当然，Unicode版本的函数也是“自力更生”的，它们不会在内部调用ANSI版本。</p>
<p>字符（串）处理函数举例（使用时应该包含<mark class="label danger">TChar.h</mark>头文件）：</p>
<p>ANSI：<code>strlen</code></p>
<p>Unicode：<code>wcslen</code></p>
<p>通用版：<code>_tcslen</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _UNICODE </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _tcslen wcslen</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">#define_tcslen strlen</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<div class="note danger"><p>备注：有<code>_t</code>一般都是都用版本的宏，如<code>_tmain</code>。</p>
</div>

<h3 id="2-5-C运行库中的安全字符串函数"><a href="#2-5-C运行库中的安全字符串函数" class="headerlink" title="2.5 C运行库中的安全字符串函数"></a>2.5 C运行库中的安全字符串函数</h3><p>许多字符串处理函数默认以<code>\0</code>作为一个字符串的结束符，或者没有考虑缓冲区与处理字符串长度而导致缓冲区溢出。</p>
<p>所以建议使用安全函数，这些函数仅在原函数后面加了<code>_s</code>（代表Secure）后缀，在<mark class="label danger">StrSafe.h</mark>头文件中定义，使用该头文件时应该安全SDK才可以使用。</p>
<p>安全函数解析举例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PTSTR _tcscpy(PTSTR strDestination, PCTSTR strSource);</span><br><span class="line"><span class="keyword">errno_t</span> _tcscpy_s(PTSTR strDestination, <span class="keyword">size_t</span> numberOfcharacters, PCTSTR strSource);</span><br><span class="line"></span><br><span class="line">PTSTR _tcscat(PTSTR strDestination, PCTSTR strSource);</span><br><span class="line"><span class="keyword">errno_t</span> _tcscat_s(PTSTR strDestination, <span class="keyword">size_t</span> numberOfcharactere, PCTSTR strSource);</span><br></pre></td></tr></table></figure>

<p>安全解决方法：<mark class="label success">在将一个可写的缓冲区作为参数传递时，必须同时提供它的大小</mark>。</p>
<div class="note default"><p>关于<code>_countof</code>和<code>sizeof</code>：</p>
<ul>
<li><code>_countof</code>：Windows宏，用来计算一个静态分配的数组中的元素的个数。</li>
<li><code>sizeof</code>：运算符（不是函数），用来计算<strong>字节数</strong>。</li>
</ul>
<p>如使用宽字符的程序，一个字符占2字节，假设一个使用4个字符的字符串，<code>_countof</code>结果为4，<code>sizeof</code>结果为8。</p>
</div>

<p>MSDN中的许多Win32 API函数不指定参数使用<code>in bytes</code>（以字节为单位）时，默认使用<code>in TCHAR</code>（以字符为单位）。</p>
<p>还有些API函数名称就已经指定使用字符还是字节：</p>
<ul>
<li><code>StringCchCpy()</code>、<code>StringCchPrintf()</code>…：都含有<code>Cch</code>（Count of characters）使用字符数，则使用<code>_countof</code>；</li>
<li><code>StringCbCat(Ex)</code>、<code>StringCbCopy(Ex)</code>…：都含有<code>Cb</code>（Count of bytes）使用字节数，则使用<code>sizeof</code>。</li>
</ul>
<div class="note danger"><p>注意C运行库中的Ex函数会比其常规函数多三个参数（更安全，更详细），具体参见2.5.2最后，该<code>EX</code>应区别于Win32 API的<code>EX</code>。</p>
</div>



<h3 id="2-6-Windows字符串函数"><a href="#2-6-Windows字符串函数" class="headerlink" title="2.6 Windows字符串函数"></a>2.6 Windows字符串函数</h3><p>Windows中的许多字符串函数是不安全的，如<code>lstrcat</code>、<code>lstrcpy</code>等（Kernel32方法）。所以在<mark class="label danger">ShlwApi.h</mark>定义了大量字符串处理函数，以更安全的方式来使用。</p>
<div class="note info"><p><strong>Shlwapi</strong>是Windows的Shell API函数。主要分为三类函数，每一类函数都要区分A版和W版。：</p>
<ul>
<li>第一类是字符串处理函数，通常以<code>Str</code>开头；</li>
<li>第二类是路径或者文件夹处理函数，通常以<code>Path</code>开头；</li>
<li>第三类是注册表处理函数，通常以<code>SH</code>开头。</li>
</ul>
</div>

<p><strong>Unicode与ANSI字符串互相转换：</strong>使用函数<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/stringapiset/nf-stringapiset-multibytetowidechar">MultiByteToWideChar</a>与<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/stringapiset/nf-stringapiset-widechartomultibyte">WideCharToMultiByte</a>）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MultiByteToWideChar</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]            UINT                              CodePage,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]            DWORD                             dwFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]            _In_NLS_string_(cbMultiByte)LPCCH lpMultiByteStr,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]            <span class="keyword">int</span>                               cbMultiByte,</span></span></span><br><span class="line"><span class="function"><span class="params">  [out, optional] LPWSTR                            lpWideCharStr,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]            <span class="keyword">int</span>                               cchWideChar</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WideCharToMultiByte</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]            UINT                               CodePage,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]            DWORD                              dwFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]            _In_NLS_string_(cchWideChar)LPCWCH lpWideCharStr,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]            <span class="keyword">int</span>                                cchWideChar,</span></span></span><br><span class="line"><span class="function"><span class="params">  [out, optional] LPSTR                              lpMultiByteStr,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]            <span class="keyword">int</span>                                cbMultiByte,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional]  LPCCH                              lpDefaultChar,</span></span></span><br><span class="line"><span class="function"><span class="params">  [out, optional] LPBOOL                             lpUsedDefaultChar</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>应特别注意：</p>
<ul>
<li><code>cchWideChar</code>单位是：字符；</li>
<li><code>cbMultiByte</code>单位是：字节。</li>
</ul>
<p><strong>判断文本是ANSI还是Unicode：</strong>使用函数<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-istextunicode">IsTextUnicode</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">IsTextUnicode</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]                <span class="keyword">const</span> VOID *lpv,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]                <span class="keyword">int</span>        iSize,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, out, optional] LPINT      lpiResult</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<h2 id="3-内核对象"><a href="#3-内核对象" class="headerlink" title="3 内核对象"></a>3 内核对象</h2><p>各种对象的区分：</p>
<div class="note success"><ul>
<li><mark class="label danger">HINSTANCE</mark>：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/autopwn/p/15493308.html">HINSTANCE是个数据类型</a>，本质就是个结构体指针，里面结构体成员只有一个int类型变量，指向的是PE结构中讲到的ImageBase，仅此而已；</li>
<li><mark class="label danger">HMODULE</mark>：事实上，HMODULE和HINSTANCE完全是一回事。如果某个函数的文档指出需要一个HMODULE参数，我们可以传入一个HINSTANCE，反之亦然。之所以有两种数据类型，是由于在16位Windows中，HMODULE和HINSTANCE表示不同类型的数据。《Windows核心编程第五版-4.1.1进程实例句柄》</li>
<li><mark class="label danger">HWND</mark>：也是个结构体类型指针，里面定义的类型同样是int类型，只是她这个结构体指针指向的是Windows给其分配的一个唯一的ID而已；HWND同样是个数据类型，只是改了名称叫法而已，叫做窗口句柄，将其实例化后，就是个整型int类型的数据，只是是用指针的方式指向她，其本质是个结构体指针，里面结构体成员只有一个int类型变量，所以HWND是个带有int类型成员的结构体指针，指向每个不同的窗口，并且给不同的窗口分配唯一的编号，通过这个编号就能找到不同的窗口，仅此而已；</li>
<li>内核句柄<mark class="label danger">HANDLE</mark>：系统用索引来表示内核对象的信息保存在进程句柄表中的具体位置，要得到实际的索引值，句柄值实际应该除以4（或右移两位，以忽略Windows操作系统内部使用的最后两位）。所以，在调试应用程序时查看内核对象句柄的实际值时，会看到4、8之类的很小的值。记住，句柄的含义尚未公开，将来可能发生变化</li>
</ul>
</div>

<h3 id="3-1-内核对象是什么"><a href="#3-1-内核对象是什么" class="headerlink" title="3.1 内核对象是什么"></a>3.1 内核对象是什么</h3><div class="note danger"><p>每个内核对象都只是一个内存块，它由操作系统内核分配，并只能由操作系统内核访问。这个内存块是一个数据结构，其成员维护着与对象相关的信息。</p>
<p><mark class="label warning">每个内核对象都是一个数据结构</mark>。该结构少数成员（安全描述符和使用计数等）是所有对象都有的，但其他大多数成员都是不同类型的对象特有的。<strong>该数据结构只能由操作系统访问，应用程序无法访问</strong>。</p>
</div>

<p>例如：</p>
<ul>
<li>进程对象有一个进程ID、一个基本的优先级和一个退出代码；</li>
<li>文件对象有一个字节偏移量（byte offset）、一个共享模式和一个打开模式。</li>
</ul>
<div class="note danger"><p>创建一个内核对象，会返回一个句柄。32位的进程中，句柄值为32位；64位进程中句柄值为64位。</p>
<p>句柄值仅用于当前进程，其他进程不可用，因为不同进程中句柄值都是从1*4开始的。</p>
</div>

<h3 id="3-2-内核对象成员-使用计数"><a href="#3-2-内核对象成员-使用计数" class="headerlink" title="3.2 内核对象成员-使用计数"></a>3.2 内核对象成员-使用计数</h3><p>进程终止运行，内核对象并不一定会销毁。大多数情况下，这个内核对象是会销毁的，但假如另一个进程正在使用我们的进程创建的内核对象，那么在其他进程停止使用它之前，它是不会销毁的。<strong>总之，内核对象的生命期可能长于创建它的那个进程。</strong></p>
<p><strong>原因</strong>：内核对象的所有者是操作系统内核，而非进程。</p>
<div class="note info"><p>操作系统内核知道当前有多少个进程正在使用一个特定的内核对象，因为每个对象都包含一个使用计数（usage count）。<mark class="label primary">使用计数是所有内核对象类型都有的一个数据成员</mark>。初次创建一个对象的时候，其使用计数被设为1。另一个进程获得对现有内核对象的<strong>访问后</strong>，使用计数就会递增。进程终止运行后，操作系统内核将自动递减此进程仍然打开的所有内核对象的使用计数。如果一旦对象的使用计数变成0，操作系统内核就会销毁该对象。这样一来，可以保证系统中不存在没有被任何进程引用的内核对象。</p>
</div>

<h3 id="3-3-内核对象成员-安全属性"><a href="#3-3-内核对象成员-安全属性" class="headerlink" title="3.3 内核对象成员-安全属性"></a>3.3 内核对象成员-安全属性</h3><p>内核对象可以用一个安全描述符（security descriptor, SD）来保护。</p>
<div class="note danger"><p>用于创建内核对象的所有函数几乎都有指向一个<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>结构的指针<mark class="label danger">PSECURITY_ATTRIBUTES</mark>作为参数。</p>
</div>

<p>如下创建进程函数的第三、四参数就是描述进程、线程安全属性的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">CreateProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  __in_opt     LPCTSTR lpApplicationName,</span></span></span><br><span class="line"><span class="function"><span class="params">  __inout_opt  LPTSTR lpCommandLine,</span></span></span><br><span class="line"><span class="function"><span class="params">  __in_opt     LPSECURITY_ATTRIBUTES lpProcessAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">  __in_opt     LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">  __in         BOOL bInheritHandles,</span></span></span><br><span class="line"><span class="function"><span class="params">  __in         DWORD dwCreationFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  __in_opt     LPVOID lpEnvironment,</span></span></span><br><span class="line"><span class="function"><span class="params">  __in_opt     LPCTSTR lpCurrentDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">  __in         LPSTARTUPINFO lpStartupInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">  __out        LPPROCESS_INFORMATION lpProcessInformation</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>安全属性结构定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SECURITY_ATTRIBUTES</span> &#123;</span></span><br><span class="line">  DWORD  nLength;</span><br><span class="line">  LPVOID lpSecurityDescriptor;</span><br><span class="line">  BOOL   bInheritHandle;</span><br><span class="line">&#125; SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>nLength</code>：结构的字节大小，<code>sizeof(SECURITY_ATTRIBUTE)</code>；</li>
<li><code>lpSecurityDescriptor</code>：安全访问属性，指向一个<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-security_descriptor?redirectedfrom=MSDN">安全描述符结构</a>；</li>
<li><code>bInheritHandle</code>：控制内核对象句柄是否可被继承，<code>TRUE</code>或<code>FALSE</code>。</li>
</ul>
<p><strong>如果利用句柄来调用API函数，API往往是需要获得一定权限才可以访问的</strong>。如<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess">OpenProcess</a>函数的第一个参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">OpenProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] DWORD dwDesiredAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] BOOL  bInheritHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] DWORD dwProcessId</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="3-4-进程内核对象句柄表"><a href="#3-4-进程内核对象句柄表" class="headerlink" title="3.4 进程内核对象句柄表"></a>3.4 进程内核对象句柄表</h3><p>个进程在初始化时，系统将为它分配一个句柄表（handle table）。<strong>一个进程刚创建（初始化）时，其句柄表时空的</strong>。</p>
<p>每在该进程中创建一个内核对象，就会在该进程的内核对象句柄表中填充一项句柄表记录。</p>
<p>用于创建内核对象的任何函数都会返回一个与进程相关的句柄，这个句柄可由同一个进程中运行的额所有线程使用。</p>
<p><img data-src="https://i.loli.net/2021/11/08/RDKUTtOVds4i5wg.png" alt="3.png"></p>
<div class="note default"><p>句柄值和句柄表索引值的对应关系：<mark class="label danger">句柄值 &#x3D; 索引值*4</mark></p>
</div>

<p><strong>凡是用于创建内核对象的函数，都要仔细检查它的返回值，比如失败：有的返回0（<code>NULL</code>），有的返回（-1）<code>INVALID_HANDLE_VALUE</code>。</strong></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>Buy me a coffee</div>
  <button onclick="document.querySelector('.post-reward').classList.toggle('active');">
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechat.jpg" alt="Catecat 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpg" alt="Catecat 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Catecat
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://directoree.github.io/post/windows-core-programming/" title="Windows核心编程（第五版）_1_错误处理_字符处理_内核对象">https://directoree.github.io/post/windows-core-programming/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Windows%E5%86%85%E6%A0%B8/" rel="tag"><i class="fa fa-tag"></i> Windows内核</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/PEView-Tool/" rel="prev" title="PE 文件解析及利用工具">
                  <i class="fa fa-chevron-left"></i> PE 文件解析及利用工具
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/translater-start-entry-function/" rel="next" title="启动函数和入口函数">
                  启动函数和入口函数 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Catecat</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">2.3m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">35:31</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1.15.0/dist/lozad.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/local-search.js"></script>








<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  const url = element.dataset.target;
  const pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  const pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  const fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script>
if (document.querySelectorAll('.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8.7.0/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>








  

  
      <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//cdn.jsdelivr.net/npm/mathjax@3.1.0/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
NexT.utils.loadComments('#valine-comments', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    new Valine(Object.assign({"enable":true,"appId":"7zujCcS8pYH88CJXfdBlLyS8-gzGzoHsz","appKey":"lWGr7OPoNHo4v1YmVV5yr3E9","serverURLs":"https://7zujccs8.lc-cn-n1-shared.com","placeholder":"快来勾搭我呀🐶","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"lang":null,"visitor":true,"comment_count":true,"bg":"/images/comment_bg.png","recordIP":false,"enableQQ":false,"requiredFields":["nick"]}, {
      el: '#valine-comments',
      path: "/post/windows-core-programming/",
      serverURLs: "https://7zujccs8.lc-cn-n1-shared.com"
    }));
  }, window.Valine);
});
</script>

</body>
</html>
