<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon1.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"directoree.github.io","root":"/","scheme":"Mist","version":"8.0.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="ʕ •ᴥ•ʔ  ɔ:">
<meta property="og:type" content="article">
<meta property="og:title" content="Windows内核基础">
<meta property="og:url" content="https://directoree.github.io/post/Windows-Kernel-Base/index.html">
<meta property="og:site_name" content="Catecat">
<meta property="og:description" content="ʕ •ᴥ•ʔ  ɔ:">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img.shields.io/badge/%E6%9C%AC%E6%96%87%E5%8F%82%E8%80%83-%E3%80%8AWindows%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B-1fd0f6.svg?colorA=ff69b4">
<meta property="og:image" content="https://img.shields.io/badge/%E6%9C%AC%E6%96%87%E5%8F%82%E8%80%83-%E3%80%8A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC6%E7%89%88%E3%80%8B-1fd0f6.svg?colorA=ff69b4">
<meta property="og:image" content="https://i.loli.net/2021/05/14/Amb6SjJzFyM2oT9.png">
<meta property="og:image" content="https://i.loli.net/2021/05/14/faGeXuCDJ9zrKsx.png">
<meta property="og:image" content="https://i.loli.net/2021/05/18/gm2UhziLQqPZCFy.png">
<meta property="og:image" content="https://i.loli.net/2021/05/17/sauiwhGfdyonWFP.png">
<meta property="og:image" content="https://i.loli.net/2021/05/21/XvRPjltkhAZzxor.png">
<meta property="og:image" content="https://i.loli.net/2021/05/18/CDISNmHRtX8zwpq.png">
<meta property="og:image" content="https://i.loli.net/2021/05/18/vUcp4MDyhN8ElL9.png">
<meta property="og:image" content="https://i.loli.net/2021/05/23/BwbCPfAle1T4IVM.png">
<meta property="og:image" content="https://i.loli.net/2021/05/25/j3uBplzOT5sbxR9.png">
<meta property="og:image" content="https://i.loli.net/2021/05/18/nNp3YAsozRtj8dV.png">
<meta property="og:image" content="https://i.loli.net/2021/05/26/f6z1tYC8iWxBM4v.png">
<meta property="og:image" content="https://i.loli.net/2021/05/29/atLHVbdXJPMIfwi.png">
<meta property="og:image" content="https://img.shields.io/badge/%E3%80%8A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC6%E7%89%88%E3%80%8B-3.1%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E5%88%86%E5%8F%91-1fd0f6.svg?colorA=ff69b4">
<meta property="og:image" content="https://img.shields.io/badge/%E3%80%8AWindows%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B-8.1.3Windows%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E5%88%86%E5%8F%91-1fd0f6.svg?colorA=ff69b4">
<meta property="og:image" content="https://i.loli.net/2021/05/30/ics6bmURWLJSwuq.png">
<meta property="og:image" content="https://i.loli.net/2021/05/30/Nik2KQ1GEl7JeUt.png">
<meta property="og:image" content="https://i.loli.net/2021/06/08/lyvI9ojW78bs6wi.png">
<meta property="og:image" content="https://i.loli.net/2021/06/10/H4BRSyMsYwj5kDT.png">
<meta property="og:image" content="https://i.loli.net/2021/06/10/kV1ChfTWUFxD6ba.jpg">
<meta property="og:image" content="https://i.loli.net/2021/06/10/fdNwZQIkgmGvE9L.png">
<meta property="og:image" content="https://i.loli.net/2021/06/10/lTrgJzkQYm9ia7E.png">
<meta property="og:image" content="https://i.loli.net/2021/06/10/rW9boQ1YBU3cmOj.png">
<meta property="og:image" content="https://i.loli.net/2021/06/11/L7easlOwjvA3EZ5.png">
<meta property="og:image" content="https://i.loli.net/2021/06/15/LxrowB1pqlZjE3g.png">
<meta property="og:image" content="https://i.loli.net/2021/06/11/6zHG54kqN7icYLj.png">
<meta property="article:published_time" content="2021-05-14T02:19:27.000Z">
<meta property="article:modified_time" content="2021-09-02T12:43:07.783Z">
<meta property="article:author" content="Catecat">
<meta property="article:tag" content="Windows内核">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.shields.io/badge/%E6%9C%AC%E6%96%87%E5%8F%82%E8%80%83-%E3%80%8AWindows%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B-1fd0f6.svg?colorA=ff69b4">


<link rel="canonical" href="https://directoree.github.io/post/Windows-Kernel-Base/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Windows内核基础 | Catecat</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b832a9ae9a43377003fd975ca4e525ea";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Catecat</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">爱你所爱，行你所行，听从你心，无问西东。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/newcategories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-更新日志">

    <a href="/changelog" rel="section"><i class="fa fa-heartbeat fa-fw"></i>更新日志</a>

  </li>
        <li class="menu-item menu-item-空调房">

    <a href="/tips" rel="section"><i class="fa fa-wifi fa-fw"></i>空调房</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Windows-%E5%86%85%E6%A0%B8%E5%9F%BA%E7%A1%80"><span class="nav-text">1 Windows 内核基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-Widows-%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC"><span class="nav-text">1.1 Widows 内核版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E9%87%8D%E8%A6%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">1.2 重要的概念</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Windows%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="nav-text">2 Windows系统结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-CPU-%E6%A8%A1%E5%BC%8F"><span class="nav-text">2.1 CPU 模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F"><span class="nav-text">2.2 用户模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-Windows%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="nav-text">2.2.1 Windows子系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-%E5%AD%90%E7%B3%BB%E7%BB%9FDLL"><span class="nav-text">2.2.2 子系统DLL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-Ntdll-dll"><span class="nav-text">2.2.3 Ntdll.dll</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%86%85%E6%A0%B8%E6%A8%A1%E5%BC%8F"><span class="nav-text">2.3 内核模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84"><span class="nav-text">2.3.1 内核结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-%E5%86%85%E6%A0%B8%E5%8F%8ANtoskrnl-exe"><span class="nav-text">2.3.2 内核及Ntoskrnl.exe</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-%E6%89%A7%E8%A1%8C%E4%BD%93"><span class="nav-text">2.3.3 执行体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-4-%E7%B3%BB%E7%BB%9F%E6%9C%BA%E5%88%B6"><span class="nav-text">2.3.4 系统机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-5-%E9%99%B7%E9%98%B1%E5%88%86%E5%8F%91"><span class="nav-text">2.3.5 陷阱分发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-6-%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E5%88%86%E5%8F%91"><span class="nav-text">2.3.6 系统服务分发</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%83%A8%E5%88%861%EF%BC%9Aint-0x2E-%E5%92%8C-Sysenter"><span class="nav-text">部分1：int 0x2E 和 Sysenter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%83%A8%E5%88%862%EF%BC%9A%E5%8E%9F%E5%85%88%E6%A8%A1%E5%BC%8F"><span class="nav-text">部分2：原先模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%83%A8%E5%88%863%EF%BC%9ASSDT-%E5%92%8C-Shadow-SSDT"><span class="nav-text">部分3：SSDT 和 Shadow SSDT</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%83%A8%E5%88%864%EF%BC%9A%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E5%8F%B7"><span class="nav-text">部分4：系统服务号</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%83%A8%E5%88%865%EF%BC%9A%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E5%88%86%E5%8F%91"><span class="nav-text">部分5：系统服务分发</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%83%A8%E5%88%866%EF%BC%9ANt-%E5%92%8C-Zw"><span class="nav-text">部分6：Nt* 和 Zw*</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Catecat"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Catecat</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">152</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/newcategories/">
          
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">86</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Directoree" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Directoree" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhao_yilong@aliyun.com" title="E-Mail → mailto:zhao_yilong@aliyun.com" rel="noopener" target="_blank"><i class="fas fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://sighttp.qq.com/msgrd?v=1&uin=1003432683" title="QQ → http:&#x2F;&#x2F;sighttp.qq.com&#x2F;msgrd?v&#x3D;1&amp;uin&#x3D;1003432683" rel="noopener" target="_blank"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://treecatee.github.io/" title="https:&#x2F;&#x2F;treecatee.github.io" rel="noopener" target="_blank">Treecatee</a>
        </li>
    </ul>
  </div>

      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://directoree.github.io/post/Windows-Kernel-Base/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Catecat">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Catecat">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Windows内核基础
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-14 10:19:27" itemprop="dateCreated datePublished" datetime="2021-05-14T10:19:27+08:00">2021-05-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-09-02 20:43:07" itemprop="dateModified" datetime="2021-09-02T20:43:07+08:00">2021-09-02</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AC%94%E8%AE%B0/%E9%80%86%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">逆向</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AC%94%E8%AE%B0/%E9%80%86%E5%90%91/Windows%E5%86%85%E6%A0%B8/" itemprop="url" rel="index"><span itemprop="name">Windows内核</span></a>
        </span>
    </span>

  
    <span id="/post/Windows-Kernel-Base/" class="post-meta-item leancloud_visitors" data-flag-title="Windows内核基础" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/post/Windows-Kernel-Base/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/post/Windows-Kernel-Base/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>27k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>25 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>ʕ •ᴥ•ʔ  ɔ: </p>
<span id="more"></span>

<h2 id="1-Windows-内核基础"><a href="#1-Windows-内核基础" class="headerlink" title="1 Windows 内核基础"></a>1 Windows 内核基础</h2><p>本文具体实现过程可看<a target="_blank" rel="noopener" href="https://cataloc.gitee.io/blog/">cataLoc’s Blog</a></p>
<p><img data-src="https://img.shields.io/badge/%E6%9C%AC%E6%96%87%E5%8F%82%E8%80%83-%E3%80%8AWindows%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B-1fd0f6.svg?colorA=ff69b4"></p>
<p><img data-src="https://img.shields.io/badge/%E6%9C%AC%E6%96%87%E5%8F%82%E8%80%83-%E3%80%8A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC6%E7%89%88%E3%80%8B-1fd0f6.svg?colorA=ff69b4"></p>
<p>系统内核层，又叫零环（Ring0，简称<code>R0</code>，与此对应的应用层叫3环，即Ring3，简称<code>R3</code>），实际上是CPU的4个运行级别中的一个。CPU设计者将CPU的运行级别从内向外分为4个，依次为R0、R1、R2、R3，运行权限从R0到R3依次降低，也就是说，R0拥有最高执行权限，R3拥有最低执行权限。CPU 设计制造商在设计之初是让<mark class="label warning">R0运行内核，R1、R2 运行设备驱动，R3运行应用程序</mark>。</p>
<p>操作系统设计者与开发商在设计操作系统（例如微软Windows 和开源社区的Linus 编写的Linux）的时候，为了让工作变得简单，并没有使用R1和R2两个级别，而是将设备驱动运行在与内核同一个级别的R0级。<mark class="label default">在AMD64 CPU诞生之后，CPU的设计者干脆也和操作系统保持一致， 只保留了R0和R3两个级别</mark>。特权级环如图7.1 所示。</p>
<p><img data-src="https://i.loli.net/2021/05/14/Amb6SjJzFyM2oT9.png" alt="1.png"></p>
<h3 id="1-1-Widows-内核版本"><a href="#1-1-Widows-内核版本" class="headerlink" title="1.1 Widows 内核版本"></a>1.1 Widows 内核版本</h3><p>Microsoft在操作系统领域中的发展最早开始于MS-DOS，并于20世纪80年代后期开始按两个分支发展：</p>
<ol>
<li>一是基于MS-DOS的Windows 开发平台，并发展成Windows 95&#x2F;98&#x2F;Me这一系列操作系统；</li>
<li>另一个分支则是以Windows NT为代表的操作系统系列，经历了Windows NT 3.1&#x2F;3.5&#x2F;3.51&#x2F;4.0、Windows 2000、Windows XP&#x2F;Server 2003，一直到 Windows Vista&#x2F;Server 2008、Windows 7和Windows10。</li>
</ol>
<p>Windows NT由微软和IBM联合研制，分为微软的Microsoft OS&#x2F;2 NT与IBM的IBM OS&#x2F;2。协作后来不欢而散，IBM继续向市场提供先前的OS&#x2F;2版本，微软则把自己的OS&#x2F;2 NT的名称改为Windows NT，即第一代的Windows NT 3.1。</p>
<p>Windows内核（由于是从Windows NT发展而来的。也称为NT内核）从一开始就有良好的设计，其结构具备很好的可扩展性和安全性。所以，Windows 内核在20年的发展历程中一直能够很好地适应硬件的发展 ，在Windows操作系统的各个版本中并没有根本性的变化。本文介绍Windows 操作系统的基本框架，这些内容<strong>完全适用于Windows XP&#x2F;Server 2003及以后的版本</strong>。</p>
<p><img data-src="https://i.loli.net/2021/05/14/faGeXuCDJ9zrKsx.png" alt="2.png"></p>
<div class="note primary"><p><mark class="label success">WRK</mark></p>
<p>WRK的全称是“Windows Research Kernel”，它是微软为高校操作系统课程提供的可修改和跟踪的操作系统教学平台。它给出了Windows这个成功的商业操作系统的<strong>内核大部分代码</strong>，可以对其进行修改、编译，并且可以用这个内核启动Windows操作系统。可让学生将操作系统基本原理和商业操作系统内核联系起来，进一步加深对操作系统整体的理解</p>
<p>NT 5.2版本是一个特殊的版本，其核心代码经过简单的改编之后 已经向教育科研领域公开。这份公开源代码的内核称为Windows Research Kernel（Windows 研究内核），简称WRK。它包括了Windows内核中最重要的组件，例如内存管理器、进程和线程管理、对象管理器、缓存管理器、配置管理器、安全引用监视器和V&#x2F;O管理器等。 此内核源代码可以被编译成一个EXE可执行文件，然后安装到一个Windows Server 2003 SP1（x86系统）或Windows XP64位（AMD）系统中，替换其中的内核模块。因此，如果用户改变了源代码中的实现逻辑，则替换了内核模块之后的Windows Server 2003 SP1或 Windows XP 64位系统可以运行用户的代码逻辑。如果配置了调试环境，则还可以调试WRK内核和用户的代码。WRK是2006年7月份正式对外发布的，就当时而言，它代表了最新的Windows内核技术。</p>
</div>

<h3 id="1-2-重要的概念"><a href="#1-2-重要的概念" class="headerlink" title="1.2 重要的概念"></a>1.2 重要的概念</h3><ol>
<li><strong>Windows API函数</strong>：指Windows API中<strong>已被文档化</strong>的、可被调用的子例程（函数）， 例如 CreateProcess、CreateFile 和GetMessage。</li>
<li><strong>原生的系统服务</strong>（或者系统调用）：指操作系统中<strong>未文档化的</strong>、可在用户模式下调用的底层服务。例如，NtCreateUserProcess是一个内部系统服务，Windows 的CreateProcess函数调用该服务来创建新的进程。</li>
<li><strong>例程</strong>：即函数。</li>
<li><strong>子系统DLL</strong>：简单理解为Windows API，已文档化的API，native API。</li>
<li><strong>Native API</strong>：NT中有很多为公布的API（已文档化），习惯上大家喜欢把他们称为Native API。</li>
<li><strong>指令流</strong>：线程。</li>
<li><strong>陷阱处理器</strong>，是指与某个特定的中断或异常相关联的<strong>函数</strong>。</li>
</ol>
<p>搞懂子系统 执行体 ntdll.dll、ntoskrnl.exe</p>
<h2 id="2-Windows系统结构"><a href="#2-Windows系统结构" class="headerlink" title="2 Windows系统结构"></a>2 Windows系统结构</h2><p>图2.2显示了Windows基本结构。Windows 采用了双模式（dual mode）结构来保护操作系统本身，以避免被应用程序的错误所波及。操作系统核心运行在<mark class="label danger">内核模式</mark>（kemel mode）下，应用程序的代码运行在<mark class="label info">用户模式</mark>（user mode）下。每当应用程序需要用到系统内核或内核的扩展模块（内核驱动程序）所提供的服务时，应用程序通过硬件指令从用户模式切换到内核模式中，当系统内核完成了所请求的服务以后，CPU控制权又回到用户模式代码。</p>
<div class="note warning"><p>用户模式与内核模式指的是CPU处理器的访问模式。</p>
<p><strong>内核模式</strong>：它允许访问所有的系统内存和所有的CPU指令。</p>
<ul>
<li><p>虽然每个Windows进程都有自己私有的内存空间，<mark class="label warning">但是内核模式的操作系统和设备驱动程序代码共享同一个虛拟地址空间</mark>。虚拟内存中的每一个页面都被标记了处理器必须在什么访问模式下才可以读和&#x2F;或写该页面。系统空间中的页面只有在内核模式下才可以访问，而用户地址空间中的所有页面都可以在用户模式下访问。只读页面（比如那些包含静态数据的页面）在任何模式下都是不可写的。此外，在支持不可执行（no-execute）内存保护的处理器上，Windows将包含数据的页面标记为不可执行，从而防止数据区域被无意地或恶意地当作代码来执行。</p>
</li>
<li><p>对于在内核模式下运行的组件，32位Windows对它们所使用的私有系统内存并不提供读写保护。换句话说，一旦进入了内核模式，操作系统和设备驱动程序的代码可以完全访问系统空间的内存，也可以绕过Windows的安全机制直接访问对象。因为有大量的Windows操作系统代码运行在内核模式下。</p>
</li>
</ul>
</div>

<p><img data-src="https://i.loli.net/2021/05/18/gm2UhziLQqPZCFy.png" alt="4.png"></p>
<p><img data-src="https://i.loli.net/2021/05/17/sauiwhGfdyonWFP.png" alt="3.png"></p>
<p><img data-src="https://i.loli.net/2021/05/21/XvRPjltkhAZzxor.png" alt="8.png"></p>
<div class="note success"><p><strong>有4种用户模式进程：</strong></p>
<ol>
<li>固定的系统支持进程，如登陆进程，会话管理器进程。</li>
<li>服务进程，宿纳了windows服务，如进程管理器和假脱机服务。</li>
<li>用户应用程序，有6个类型：windows32位，windows64位，windows3.1 16位，ms-dos 16位，posix32位或者OS&#x2F;2 32位。</li>
<li>环境子系统服务进程，实现了操作系统环境的部分支持。这里的环境是指操作系统展示给用户或者程序员的个性化部分。</li>
</ol>
<p>在windows下，用户程序不能直接访问原始的windows服务，要通过一个或者多个子系统动态链接库。</p>
</div>

<div class="note danger"><p><strong>Windows内核组件（组成部分）包含：</strong></p>
<ol>
<li><strong>windows执行体</strong>，包含基本的操作系统服务，如内存管理，进程和线程管理，安全性，I&#x2F;O，网络，跨进程通信。</li>
<li><strong>windows内核</strong>，是由一组底层的操作系统功能构成，如线程调度，终端和异常处理分发。以及处理器同步。提供了一组例程和基础对象。执行体的其他部分利用这些例程和对象实现更高层次的功能。</li>
<li><strong>设备驱动程序</strong>，硬件设备驱动程序，也包含文件系统和网络驱动程序。其中硬件设备驱动程序将用户的I&#x2F;O函数调用转化为特定的硬件设备请求。</li>
<li><strong>硬件抽象层</strong>，指一层特殊代码，它把内核，设备驱动程序和windows执行体其他部分跟与平台相关的硬件差异隔离开来。</li>
<li><strong>窗口和图形系统</strong>：实现了图形用户界面函数。</li>
</ol>
</div>

<div class="note info"><p><strong>Windows子系统是Windows系统中一个不可缺少的组成部分</strong>，<mark class="label info">它与系统内核一起构成了用户应用程序的执行环境</mark>。Windows的原始设计是一个支持多环境子系统的操作系统，除了Windows子系统作为它的原生环境子系统，它还支持POSIX和OS&#x2F;2环境子系统，为UNIX类应用程序和OS&#x2F;2应用程序提供一个仿真执行环境。 随着Windows操作系统的发展，<mark class="label danger">自Windows XP以后，只有Windows子系统随系统一起发行</mark>。 Windows 子系统既有内核模式部分（图形和窗口管理），也有用户模式部分。用户模式部分包括一个单独的子系统进程和一组链接到各个应用进程中的系统DLL。</p>
</div>

<p><img data-src="https://i.loli.net/2021/05/18/CDISNmHRtX8zwpq.png" alt="5.png"></p>
<h3 id="2-1-CPU-模式"><a href="#2-1-CPU-模式" class="headerlink" title="2.1 CPU 模式"></a>2.1 CPU 模式</h3><p>在Intel x86处理器上，段描述符有一个 2位长度的特权级：<mark class="label danger">0</mark>表示最高特权级，<mark class="label default">3</mark>表示最低特权级。Windows 只使用0和3两种特权级（在有些资料上分别称为0环和3环）。通常特权级0表示CPU处于内核模式（kermel mode），3表示用户模式（user mdoe）。在任何时刻，处理器总是位于这两种模式之一。</p>
<p>处理器有许多指令只有在特权级0的模式下才可以使用，例如I&#x2F;O指令、操纵内部寄存器（如GDT、IDT、MSR）的指令等。</p>
<ul>
<li><p><strong>操作系统保护状态：</strong></p>
<ul>
<li>当处理器位于<strong>用户模式</strong>时，它处于一种相对隔离的状态：能够执行的指令是受限制的，能够访问的内存也是受限制的。且越过这些限制，就会<strong>引发处理器异常</strong>，因而操作系统可以捕获到这些异常，并决定处理器是否继续执行。因此，操作系统可以有足够的能力来<strong>保护</strong>自己免受用户模式代码的影响。（保护模式）</li>
<li>当处理器位于<strong>内核模式</strong>时，这<strong>一层保护不复存在</strong>，任何一个未被捕捉和处理的指令错误都会引起系统崩溃。</li>
</ul>
</li>
<li><p><strong>内存访问权限：</strong>在Windows中，当处理器位于不同模式下时，它可以访问的内存地址空间也是不一样的。</p>
<ul>
<li><strong>用户模式下</strong>，处理器只能访问当前进程的地址空间（有时也称为用户地址空间）；</li>
<li><strong>内核模式下</strong>，处理器不仅可以访问当前进程的地址空间，还可以访问系统地址空间。 内核模式下的代码和数据都是共享的，所有的进程一旦其指令流进人到内核模式下，则系统地址空间中的代码和数据都是相同的（有个别例外）。</li>
</ul>
</li>
</ul>
<p>一个指令流（即线程）在执行时，在以下情况下会发生<mark class="label warning">模式切换</mark>：</p>
<ul>
<li>用户模式代码触发了<mark class="label danger">异常</mark>，则控制流进入到内核模式，内核中的异常处理函数可以决定该控制流是否继续执行；</li>
<li>用户模式代码在执行时，被一个<mark class="label danger">中断</mark>打断 （软中断或硬中断），则控制流进入特权模式，等中断处理例程完成以后，它若调用<code>iret/iretd</code>指令，则控制流恢复到用户模式下，执行特殊的模式切换指令，例如Intel x86的<code>sysenter</code>指令，从用户模式切换到内核模式。而为了从内核模式切换到用户模式，通常简单地使用<code>sysexit</code>、<code>iret/iretd</code>这样的指令即可。由于系统空间是所有进程共享的，所以，任何一个进程在执行内核模式的代码时，实际上是在使用操作系统的服务。</li>
</ul>
<div class="note danger"><p>在Windows体系结构中，内核模式向上有一个执行体API，尽管它并非文档化的API，但对于应用程序而言，这便是系统服务。Windows将这些系统服务组织成了一张表，称为SDT（Service Descriptor Table，服务描述符表）。</p>
</div>



<h3 id="2-2-用户模式"><a href="#2-2-用户模式" class="headerlink" title="2.2 用户模式"></a>2.2 用户模式</h3><p><strong>（User mode）</strong></p>
<h4 id="2-2-1-Windows子系统"><a href="#2-2-1-Windows子系统" class="headerlink" title="2.2.1 Windows子系统"></a>2.2.1 Windows子系统</h4><div class="note default"><p>早期的Windows版本支持三个环境子系统：</p>
<ul>
<li><mark class="label primary">OS&#x2F;2</mark></li>
<li><mark class="label warning">POSIX</mark></li>
<li><mark class="label info">Windows</mark></li>
</ul>
<p><strong>到了Windows XP以后，只有Windows子系统（或Win32）随Windows操作系统起发行</strong>，而且，在Windows系统中，即使是没有交互用户登录的服务器系统，Windows 子系统也是必须运行的。相反，另外两个子系统被配置成按需启动。</p>
<p> Windows子系统的两个关键功能部件：窗口管理和GDI（Graphics Device Interface，图形设备接口）。</p>
</div>

<p>Windows对应用程序的支持是通过Windows的环境子系统来做到的，<mark class="label danger">任何一个用户应用程序都运行在特定的子系统环境中</mark>。</p>
<p>我们可以这样简单地理解：</p>
<ul>
<li>Windows 子系统是Windows操作系统不可分割的一部分，它在Windows内核的基础上，为应用程序提供了一个图形用户界面（GUI）环境；</li>
<li>OS&#x2F;2和POSIX则是为了兼容OS&#x2F;2和UNIX应用程序而提供的模拟环境。</li>
</ul>
<div class="note primary"><p>Windows子系统中既有用户模式部分，也有内核模式部分。</p>
<ul>
<li><p><strong>内核模式部分</strong>：核心是<mark class="label warning">win32k.sys</mark>，虽然它的形式是一个驱动程序，但实际上它并不处理I&#x2F;O请求，相反，它向用户代码提供了大量的系统服务。从功能上讲，它包含两部分：窗口管理（Window manager）和图形设备接口（GDI）。</p>
<ul>
<li>其中窗口管理部分负责收集和分发消息，以及控制窗口显示和管理屏幕输出；</li>
<li>图形设备接口部分包含各种形状绘制以及文本输出功能。</li>
</ul>
</li>
<li><p><strong>用户模式部分</strong>：包括Windows子系统进程<mark class="label warning">csrss.cxe</mark>以及一组动态链接库<mark class="label warning">DLL</mark>。</p>
<ul>
<li>Csrss.exe进程主要负责控制台窗口的功能，以及创建或删除进程和线程等。</li>
<li>子系统DLL则被直接链接到应用程序进程中，包括kernel32.dIl、user32.dIl、gdi32.dIl和advapi.dll等，负责实现<strong>已文档化</strong>的Windows API函数。除了有些可以直接在用户模式中完成以外，很多API函数需要调用执行体API或win32k.sys模块提供的系统服务。</li>
</ul>
</li>
</ul>
<p>应用程序通常并不直接使用操作系统提供的系统服务，而是通过调用系统DLL所提供的API函数，来间接地使用各种系统服务。Windows 子系统也使用了类似的模块结构，供应用程序直接调用的API函数位于一组子系统DLL中，这些子系统DLL再根据需要调用内核模式组件（win32k.sys）的功能。</p>
</div>

<p>子系统Windows结构如下图（图来自《Windows内核原理与实现》）：</p>
<p><img data-src="https://i.loli.net/2021/05/18/vUcp4MDyhN8ElL9.png" alt="7.png"></p>
<div class="note danger"><p>Windows子系统的组件为：</p>
<ol>
<li><p>用户模式部分：</p>
<ul>
<li><mark class="label warning">Windows子系统进程 Csrss.cxe</mark></li>
<li><mark class="label default">子系统DLL</mark></li>
</ul>
</li>
<li><p>内核模式部分：</p>
<ul>
<li><mark class="label primary">内核模块 Win32k.sys</mark></li>
<li><mark class="label info">图形设备驱动程序</mark></li>
</ul>
</li>
</ol>
</div>

<ol>
<li><mark class="label warning">Windows子系统进程 Csrss.cxe</mark>（运行在用户模式）：Windows子系统进程维护了所有属于该子系统的进程和线程的列表，并且设置进程的异常端口和调试端口，以便接收该进程中发生的异常和调试事件。类似地，当线程或进程退出或终止时，Windows子系统进程也会被通知到，从而维护子系统内部信息的一致性。

<p>它包含以下支持：</p>
<ul>
<li>控制台窗口。</li>
<li>创建和删除进程和线程。</li>
<li>支持16位虚拟DOS机（VDM，Virtual DOS Machine）进程。</li>
<li>其他一些函数，比如GetTempFile、DefinedDosDevice、ExitWindowsEx，以及少量自然语言支持函数。</li>
</ul>
</li>
<li><p>.<mark class="label default">子系统DLL</mark>：子系统DLL，例如user32.dIl、advapi32.dIl、gdi32.dll和kermel32.dlI，<strong>它们实现了已经文档化的Windows API函数</strong>，它们将已经文档化的Windows API函数，转译成Ntoskrnl.exe和Win32k.sys（<strong>两个内核模块</strong>）中恰当的且绝大多数未文档化的内核模式系统服务调用，甚至与环境子系统进程通信。</p>
</li>
<li><mark class="label primary">内核模块 Win32k.sys</mark>：虽然它的名称像是一个驱动程序，但实际上，win32k.sys并不遵从I/O管理器定义的程序模型，而仅仅是Windows内核的扩展而已。Win32k.sys包含两大功能组成部分：

<ul>
<li>窗口管理器（Window Manager）：负责控制窗口显示、管理屏幕输出、收集来自键盘、鼠标和其他设备的输人，以及将用户消息传递给应用程序。</li>
<li>GDI（Graphics Device Interface）：这是一个针对图形输出设备的函数库，包含了有关线、文本和图形绘制，以及操纵各种图形的函数。</li>
</ul>
</li>
<li><mark class="label info">图形设备驱动程序</mark>：这是一些与硬件相关的显示驱动程序、打印驱动程序，以及视频小端口驱动程序。</li>
</ol>
<p>用户应用程序并不直接调用Windows的系统服务，而是通过一个或者多个子系统DLL来进行。这些库导出的接口都有很好的文档说明，凡是链接（LoadLibrary函数）到该子系统的程序都可以调用这些接口。例如，<strong>Windows子系统DLL （比如Kernel32.dIl、Advapi32.dlI、 User32.dlI 和Gdi32.dI1）实现了Windows API函数</strong>。SUA子系统DLL (Psxll.dIl) 实现了SUA API函数。</p>
<h4 id="2-2-2-子系统DLL"><a href="#2-2-2-子系统DLL" class="headerlink" title="2.2.2 子系统DLL"></a>2.2.2 子系统DLL</h4><p>简单理解成<strong>子系统DLL为已经文档化的Windows API函数</strong>。</p>
<div class="note info"><p>应用程序调用子系统DLL中的某个函数时，可能有下述三种情况之一 :</p>
<ol>
<li>该函数完全是在该子系统DLL中实现的，在用户模式下运行。换句话说，该函数并没有给环境子系统进程（Csrss.exe）发送消息，也没有调用Windows执行体系统服务。该函数是在用户模式下完成的，运行的结果被返回给调用者。此类函数的例子有<code>GetCurrentProcess</code>（它总是返回-1，在所有与进程相关的函数中，-1被定义为代表当前进程）和<code>GetCurrentProcessld</code>（对于一个正在运行的进程，进程ID不会改变，所以此进程ID可以从某个缓存的地方获取到，从而避免要调用至内核中）。</li>
<li>该函数要求调用Windows执行体一次或者多次。例如，Windows的<code>ReadFile</code>、<code>WriteFile</code>函数分别要调用底层内部的（且无文档的） Windows I&#x2F;O系统服务<code>NtReadFile</code>和<code>NtWriteFile</code>。</li>
<li>该函数要求在环境子系统进程（Csrss.exe）中完成某些工作（环境子系统进程运行在用户模式下，负责维护那些在其控制下运行的客户应用程序的状态)。在这种情况下，该函数通过消息的形式向环境子系统发送客户机&#x2F;服务器请求，从而让子系统执行某个操作。然后子系统DLL等待应答，收到应答之后再返回调用者。</li>
</ol>
<p>有些函数可以是以上列出的第2和第3项的组合，比如Windows的<code>CreateProcess</code>和<code>CreateThread</code>函数。</p>
</div>

<div class="note warning"><p>从应用程序的角度来看，它通过给子系统DLL发出的服务请求（<mark class="label danger">即API调用</mark>）是如何被满足的。首先，由于这些子系统DLL被加载（LoadLibrary）到应用程序进程中，所以，这些服务请求是直接的函数调用（同一进程地址空间中跨模块的函数调用）。当子系统DLL接收到一个函数调用以后，根据该函数功能的复杂程度，可能有以下的处理方式：</p>
<ol>
<li>直接由子系统DLL包揽所有工作。这一类函数总是在用户模式下完成，不涉及处理器模式切换。这类函数的典型例子有：<ul>
<li><code>RtInRect</code>、<code> IsRectEmpty</code>这样的简单函数，无须内核模块或Windows子系统进程的介人即可完成；</li>
<li><code>GetCurrentProcess</code>函数，简单地返回一个伪句柄值（-1）代表当前进程；</li>
<li><code>GetCurrentProcessld</code>函数，可以从一个缓存的数据结构中获得当前进程的ID，无须每次调用都进入到内核中，因为进程ID在进程的生命周期中保持不变。</li>
</ul>
</li>
<li>需要调用Windows内核一次或多次。 在这种情形下，可能存在一次或多次模式切换，子系统DLL或者通过ndll.dll调用到Windows执行体，或者通过win32k.sys注册的系统服务表（<code>KeServiceDescriptorTableShadow</code>）调用到win32k.sys 中。这类API函数的例子有：<ul>
<li><code>ReadFile</code>和<code>WriteFile</code>函数，调用底层的<code>NtReadFile</code>或<code>NtWriteFile</code>系统服务；</li>
<li><code>PostMessage</code>和<code>BitBIt</code>这样的窗口管理和GDI函数，调用win32k.sys 中的<code>NtUserPostMessage</code>或<code>NtGdiBitBIt</code>来完成其功能（它们也可能会调用Windows执行体函数，比如为了获取用以保护共享资源的锁）。</li>
</ul>
</li>
<li>需要Windows子系统进程（ Csrss.cxe）的协助来完成其功能。在这种情况下，子系统DLL向csrss.exe进程发送一个请求（以LPC消息的形式)，然后等待应答消息，直至收到应答并完成所有功能之后再返回调用者。这类API函数最典型的例子是<code>CreateProccess</code>和<code>CreateThread</code>，它们需要通知子系统进程，以维护子系统环境中进程和线程的状态。</li>
</ol>
<p>以上三种可能的执行方式仅仅代表了子系统DLL在执行一个服务请求时可能的执行路径，并非简单地将API函数分成三类。</p>
</div>

<p>其他有关Windows子系统的窗口管理器和GDI详细细节，可参考《Windows内核原理与实现》9.2章节。</p>
<h4 id="2-2-3-Ntdll-dll"><a href="#2-2-3-Ntdll-dll" class="headerlink" title="2.2.3 Ntdll.dll"></a>2.2.3 Ntdll.dll</h4><p>2.2.2中所提到的应用程序调用子系统DLL时的第2种情况，即应用程序会调用到内核一次或多次，因为Windows API无法直接调用到内核服务，这个时候就会使用到ntdll.dll，ntdll.dll充当应用程序和内核服务的桥梁，即从R3到R0的桥梁。</p>
<div class="note success"><p>Windows内核为用户模式代码提供了一组系统服务，供应用程序使用内核中的功能。 应用程序通常并不直接调用这些系统服务，而是通过一组系统DLL，最终通过ntdll.dll切换到内核模式下的执行体API函数中，以调用内核中的系统服务。Ntdll.dlI是连接用户模式代码和内核模式系统服务的桥梁。<strong>对于内核提供的每一个系统服务， 该DLL都提供个相应的存根函数，这些存根函数的名称以“Nt” 作为前缀</strong>。</p>
</div>

<div class="note danger"><p>Ntdll.dlI是一个特殊的系统支持库， 主要用于子系统DLL。它包含两种类型的函数：</p>
<ol>
<li>（执行体）系统服务分发<mark class="label danger">存根</mark>（stub），这些存根函数（例程）会调用Windows执行体的系统服务。（此部分函数供应用程序从R3转入R0使用，这部分函数以 <code>Nt</code>为前缀）。</li>
<li>系统内部支持函数， 供子系统、子系统DLL以及其他的原生映像文件使用。（此部分函数不支持模式R3到R0的切换）。</li>
</ol>
</div>

<ol>
<li><p>第一组函数为Windows执行体系统服务提供了接口，在用户模式下可以通过这些接口函数调用Windows执行体的系统服务。这样的函数超过了400个，比如<code>NtCreateFile</code>、<code>NtSetEvent</code>等。 如前所述，这些函数的大多数功能可以通过Windows API来访问得到(然而，有些函数则不然，它们仅被用于操作系统内部)。对于每一个这样的函数，Ntdll包含 了一个同名的入口点。函数内部的代码包含了与处理器体系架构相关的模式切换指令，通过该指令可转换到内核模式下，从而调用系统服务分发 器（system service dispatcher）。系统服务分发器在检验某些参数以后，再调用真正的内核模式系统服务，其中包括Ntoskrml.exe内部的实际代码。</p>
</li>
<li><p>对于NtdlI中的内部（系统）支持函数，比如：</p>
<ul>
<li>映像加载（以<code>Ldr</code>开头的函数）；</li>
<li>堆管理器；</li>
<li>Windows子系统进程通信函数（以<code>Csr</code>开头的函数）；</li>
<li>一般性的运行库例程（以<code>Rtl</code>开头的函数）；</li>
<li>对用户模式调试调试函数（以<code>DbgUi</code>开头的函数）；</li>
<li>Windows事件跟踪的支持函数（以<code>Erw</code>开头的函数）；</li>
<li>用户模式异步过程调用（APC，Asynchronous Procedure Call）分发器和异常分发器；</li>
<li>C运行库（CRT）例程的子集，仅限于字符串和标准库中的一些例程，比如memcpy、 strepy，ioa，等等。</li>
</ul>
</li>
</ol>
<p><strong>本文主要讲第一种</strong>（具体参考《Windows内核原理与实现》8.1.2）</p>
<div class="note primary"><p>在Windows的系统结构中，内核提供的服务都通过ntdll.dll模块被应用程序使用。 Windows应用程序调用一组系统 DLL中的API函数，间接地通过ntdll.dll中的存根函数来调用内核提供的系统服务。</p>
<p>Windows内核中的执行体层暴露了大量的功能供应用程序使用，那么，应用程序如何调用这些功能呢？譬如，<code>NtCreateFile</code>是Windows内核中的“创建文件”服务例程（函数），它运行在处理器的内核模式下，而应用程序的代码运行在用户模式下，所以，应用程序为了调用此“创建文件”服务，必须将处理器从用户模式切换到内核模式下。当然，模式切换工作并不需要由应用程序自已来完成，Windows 提供了一个系统模块ntdll.dll，<strong>已经实现了所有系统服务的模式切换工作</strong>。这一模式切换依赖于硬件体系结构。</p>
</div>

<p>ntdll.dll是Windows系统从ring3到ring0的入口。位于<code>Kernel32.dll</code>和<code>user32.dll</code>中的所有win32 API 最终都是调用ntdll.dll中的函数实现的。ntdll.dll中的函数使用<code>SYSENTRY</code>进入ring0，函数的实现实体在ring0中。</p>
<p>ntdll.dll中的大部分函数都是在MSDN中找不到描述的，因为这些函数介于Windows API与内核API之间，微软并<br>未公开全部的内核函数。</p>
<p>Windows中应用程序与与Windows内核打交道的过程如下图：</p>
<p><img data-src="https://i.loli.net/2021/05/23/BwbCPfAle1T4IVM.png" alt="9.png"></p>
<p>Windows应用程序调用系统DLL中的函数，这是大量已经文档化的API函数；这些系统DLL函数可能又进一步调用ntdll.dll中的系统函数，这些系统函数要么是操作系统提供的支持函数，要么是一些系统服务存根( stub)。系统服务存根函数利用模式切换指令进入到内核模式，调用内核提供的系统服务来完成应用程序的请求。举例：</p>
<div class="note success"><ol>
<li>Windows应用程序调用Windows API函数<code>CreateFile</code>来创建文件，此API函数实际上是<code>CreateFileW</code>，位于kernel32.dll模块中。</li>
<li><code>CreateFileW</code>函数又进步调用ntdll.dll中的 <code>NtCreateFile</code>函数。Ntdll.dll中的<code>NtCreateFile</code>函数是一个存根函数，它只是简单地将创建文件的请求转<mark class="label default">交给内核</mark>中的<code>NtCreateFile</code>函数。为了做到这一点，它通过ntdll.dll中的 <code>KiIntSystemCall</code>或<code>KiFastSystemCall</code>函数执行<mark class="label warning">int 2e</mark>或<mark class="label warning">sysenter</mark>指令，以便切换到内核模式下，然后由内核模式的系统服务分发函数<code>KiSystemService</code>来调用<code>NtCreateFile</code>系统服务。</li>
<li>待<code>NtCreateFile</code>系统服务执行完成以后，<code>KiSystemService</code>调用<code>KiServiceExit</code>函数，最终通过<mark class="label warning">iretd</mark>或<mark class="label warning">sysexit</mark>指令返回到用户模式ntdll.dl模块中。</li>
</ol>
</div>

<p><img data-src="https://i.loli.net/2021/05/25/j3uBplzOT5sbxR9.png" alt="10.png"></p>
<h3 id="2-3-内核模式"><a href="#2-3-内核模式" class="headerlink" title="2.3 内核模式"></a>2.3 内核模式</h3><p><strong>（Kernel mode）</strong></p>
<h4 id="2-3-1-内核结构"><a href="#2-3-1-内核结构" class="headerlink" title="2.3.1 内核结构"></a>2.3.1 内核结构</h4><div class="note default"><p>Windows内核分为三层：</p>
<ul>
<li><mark class="label primary">执行体层</mark></li>
<li><mark class="label warning">内核层</mark></li>
<li><mark class="label success">硬件抽象层</mark></li>
</ul>
<p><mark class="label danger">执行体层和内核层位于同一个二进制模块中，即内核基本模块，其名称为ntoskrnl.exe</mark></p>
</div>



<ol>
<li><mark class="label success">硬件抽象层</mark>（Hardware Abstraction Layer，简称HAL）：与硬件直接打交道的这一层称为，这一层的用意是把所有与硬件相关联的代码逻辑隔离到一个专门的模块中，从而使上面的层次尽可能做到独立于硬件平台。</li>
<li><mark class="label warning">内核层</mark>：HAL之上是内核层，有时候也称为微内核（micro-kernel），这层包含了基本的操作系统原语和功能，如线程和进程、线程调度、中断和异常的处理、同步对象和各种同步机制。</li>
<li><mark class="label primary">执行体层</mark>：在内核层之上则是执行体（executive）层，这一层的目的是提供些可供上层应用程序或内核驱动程序直接调用的功能和语义。Windows内核的执行体包含一个对象管理器，用于一致地管理执行体中的对象。</li>
</ol>
<p>执行体层和内核层位于同一个二进制模块中，即内核基本模块，其名称为ntoskrnl.exe。内核层和执行体层的分工是：</p>
<ul>
<li>内核层实现操作系统的基本机制，而所有的策略决定则留给执行体。</li>
<li>执行体中的对象绝大多数封装了一个或者多个内核对象，并且通过某种方式（比如对象句柄）暴露给应用程序。</li>
</ul>
<p>Windows内核的详细组成结构如下图：</p>
<p><img data-src="https://i.loli.net/2021/05/18/nNp3YAsozRtj8dV.png" alt="6.png"></p>
<div class="note danger"><p><mark class="label default">Ntdll.dll</mark></p>
<p>Windows内核为用户模式代码提供了一组系统服务，供应用程序使用内核中的功能。应用程序通常并不直接调用这些系统服务，而是通过一组系统DLL，最终通过<mark class="label default">ntdll.dll</mark>切换到内核模式下的执行体API函数中，以调用内核中的系统服务。<mark class="label primary">Ntdll.dlI是连接用户模式代码和内核模式系统服务的桥梁。</mark><mark class="label warning">对于内核提供的每一个系统服务， 该DLL都提供个相应的存根函数</mark>，这些存根函数的名称以“Nt” 作为前缀，例如NCreateProcess NtOpenFile 和NtSetTimer。</p>
<p>另外，ntdll. dll还提供了许多系统级的支持函数：</p>
<ul>
<li>以 <code>Nt</code>为前缀：ntdll. dll存根函数的名称</li>
<li>以 <code>Ldr</code>为前缀：映像加载器函数</li>
<li>以 <code>Csr</code>为前缀：Windows子系统进程通信函数</li>
<li>以 <code>Dbg</code>为前缀：调试函数</li>
<li>以 <code>Etw</code>为前缀：系统事件函数</li>
<li>以 <code>Rt</code>为前缀：一般的运行支持函数</li>
<li>字符串支持函数等。</li>
</ul>
</div>

<div class="note success"><p><mark class="label info">执行体API函数</mark></p>
<p>执行体API函数接收的参数来自于各种应用程序，因此，为了确保系统的健壮性， 以及抵抗来自用户模式的恶意攻击，<mark class="label info">所有的执行体API函数必须保证参数的有效性</mark>。这意味着它们必须在恰当的时刻检查参数的值，若是指针的话，还必须保证调用者可以访问指针所指的内存。通常，执行体系统服务函数会在其开始处，对所接收的参数逐一探查它们的可访问性。</p>
</div>

<h4 id="2-3-2-内核及Ntoskrnl-exe"><a href="#2-3-2-内核及Ntoskrnl-exe" class="headerlink" title="2.3.2 内核及Ntoskrnl.exe"></a>2.3.2 内核及Ntoskrnl.exe</h4><p>Windows内核的执行体包含一个对象管理器，用于一致地管理执行体中的对象。执行体层和内核层位于同一个二进制模块中，即内核基本模块，其名称为<mark class="label primary">ntoskrnl.exe</mark>。执行体层是ntoskrnl.exe的上层部分，内核层是ntoskrnl.exe的下层部分。</p>
<div class="note danger"><p>内核层和执行体层的分工是：内核层实现操作系统的基本机制，而所有的策略决定则留给执行体。执行体中的对象绝大多数封装了一个或者多个内核对象，并且通过某种方式（比如对象句柄）暴露给应用程序。</p>
</div>



<p>Windows的内核（层）按照面向对象的思想来设计，它管理两种类型的对象：分发器对象（dispatcher object）和控制对象。</p>
<ul>
<li>分发器对象实现了各种同步功能，这些对象的状态会影响线程的调度。Windows内核实现的分发器对象包括：<ul>
<li>事件（event）</li>
<li>突变体（mutant）</li>
<li>信号量（semaphore）</li>
<li>进程（process）</li>
<li>线程（thread）</li>
<li>队列（queue</li>
<li>门（gate）</li>
<li>定时器（timer）</li>
</ul>
</li>
<li>控制对象被用于控制内核的操作，但是不影响线程的调度，它包括：<ul>
<li>异步过程调用（APC）</li>
<li>延迟过程调用（DPC）</li>
<li>中断对象等。</li>
</ul>
</li>
</ul>
<p><strong>关于Windows研究内核</strong></p>
<p>Windows并非一个开放源代码的操作系统，Micosoft 开放了一份以Windows XP x64和Windows Server 20003 SPI为基础的内核源代码，它可以编译和运行，作为教育科研机构的教学实践和研究的平台使用，称为<mark class="label default">WRK</mark>（Windows Research Kernel，Windows研究内核）。除了这份源代码本身，WRK还提供了其他一些材料。主要包含以下：</p>
<ul>
<li>WRK内核源代码，涉及进程、线程、内存管理、执行体、对象管理器、缓存管理器、本地过程调用（LPC）、注册表、I&#x2F;O管理器、安全引用监视器，以及线程调度、APC（异步过程调用）、DPC（延迟的过程调用）、中断以及异常处理等。随源代码起提供的还有相应的编译工具，因此，无须额外的编译器即可将WRK编译成Windows Server 2003 SP1的可执行内核。</li>
<li>NT设计文档。这是一组早期的文档，尽管其内容已不完全适用于现在的Windows操作系统以及WRK中的代码，但是，通过阅读这些文档一方面可以清楚地理解 Windows NT背后的原始设计思想，另一方面也可以看出Windows在这十多年中是如何发展和进化的。这些文档涵盖了Windows操作系统的方方面面，甚至包括文件系统设计大纲和内核的调试结构等。</li>
</ul>
<p>其他内容于《Windows内核原理与实现》2.3.1中。</p>
<p>Windows的内核模块文件是ntoskrnl.exe，位于Windws\Sytem32目录下，它包含了Windows体系结构中的执行体和内核（或微内核）部分。WRK提供的源代码可以编译得到这一内核模块文件。</p>
<p>WRK包含了编译ntoskrnl.exe内核模块所需要的绝大部分代码，<strong>未公开部分的代码主要包括即插即用设备管理、电源管理、设备驱动程序检验器和虚拟DOS机的实现</strong>。为了编译WRK源代码以得到实际可运行的内核模块，缺失的这部分被以二进制目标代码的形式包含在了WRK中，该目录还包含了其他些需要静态链接的目标文件。</p>
<div class="note warning"><p>内核模块内部的每个组件都提供了一些接口函数供其他组件调用，也有一些函数供该组件内部使用。有一些组件内部函数也有规律可循：前缀第一个字母后面跟一个<code>i</code>，或者在前缀后面跟一个<code>p</code>。</p>
<ul>
<li><code>i</code>：<code>internal</code>，即内部的；</li>
<li><code> p</code>：<code>private</code>，即私有的；</li>
<li><code>Ki</code>：微内核；</li>
<li><code>Mi</code>：内存管理器的内部函数；</li>
<li><code>Halp</code>：HAL的内部函数；</li>
<li><code>Psp</code>：进程和线程管理组件的内部函数；</li>
<li><code>Iop</code>：I&#x2F;O管理器的内部函数。</li>
</ul>
</div>

<p>表2.3列出了一些常用的标识性前缀。</p>
<p><img data-src="https://i.loli.net/2021/05/26/f6z1tYC8iWxBM4v.png" alt="12.png"></p>
<h4 id="2-3-3-执行体"><a href="#2-3-3-执行体" class="headerlink" title="2.3.3 执行体"></a>2.3.3 执行体</h4><p>Windows执行体是Windows内核体的上层接口，包含了基本的<mark class="label warning">操作系统服务</mark>。这些系统服务由不同的组件组成，执行体包含以下组件：</p>
<ol>
<li><strong>进程和线程管理器</strong>。负贵创建进程和线程，以及终止进程和线程。在Windows中，对于进程和线程的底层支持是在内核层提供的，执行体在内核层的进程和线程对象的基础上，又提供了一些语义和功能。</li>
<li><strong>内存管理器</strong>。此组件实现了虚报内存管理，既负责系统地址空间的内存管理，又为每个进程提供了一个私有的地址空间，并且也支持进程之间内存共享。内存管理器也为缓存管理器提供了底层支持。</li>
<li><strong>安全引用监视器</strong>（SRM，Security Reference Monitor）。该组件强制在本地计算机上实施安全策略，它守护着操作系统的资源，执行对象的保护和审计。</li>
<li><strong>I&#x2F;O管理器</strong>。它实现了与设备无关的输入和输出功能，负责将IO请求分发给正确的设备驱动程序以便进步处理。</li>
<li><strong>缓存管理器</strong>。它为文件系统提供了统一的数据缓存支持， 允许文件系统驱动程序将磁盘上的数据映射到内存中，并通过内存管理器来协调物理内存的分配。</li>
<li><strong>配置管理器</strong>。它负责系统注册表的实现和管理。</li>
<li><strong>即插即用管理器</strong>。它负责列举设备，并为每个列举到的设备确定哪些驱动程序是必需的，然后加载并初始化这些驱动程序。当它检测到系统中的设备变化（增加或移除设备）时，负责发送恰当的事件通知。</li>
<li><strong>电源管理器</strong>。它负责协调电源事件，向设备驱动程序发送电源I&#x2F;O通知。当系统电源状态变化时，通知设备驱动程序处理设备的电源状态。即插即用设备的管理和电源的管理也可以看做是IO管理器的扩展功能。</li>
<li>……</li>
</ol>
<div class="note primary"><p>执行体包含以下5种类型的函数：</p>
<ol>
<li><p>可在用户模式下调用的<mark class="label warning">导出函数</mark>。这些函数称为<mark class="label default">系统服务</mark>，对这些函数的调用接口位于Ntdll模块中，即通过Ntdll导出。可分为：</p>
<ul>
<li>应用程序可通过Windows API来间接地调用这些函数；</li>
<li>应用程序无法通过Windows API来调用的函数，直接链接ntdll.dll来完成。如LPC（Local Procedure Call，本地过程调用）函数、各种查询函数（如<code>NtQueryInformation&lt;Xxx&gt;</code>），以及一些专用的函数，比如<code>NtCreatePagingFile</code>等。</li>
</ul>
</li>
<li><p>可通过<code>DeviceIoControl</code>函数来调用的<mark class="label warning">设备驱动程序函数</mark>。这为从用户模式到内核模式提供了一个通用的接口，因而在用户模式下可以调用设备驱动程序中并不与读或者写操作关联的函数。并且在Windows DDK中有关于这些函数的文档。</p>
</li>
<li><p>只能在<mark class="label warning">内核模式下调用</mark>的<strong>导出函数</strong>。已经<strong>被文档化</strong>的，这些函数可以被设备驱动程序调用。</p>
</li>
<li><p>在内核模式下调用，未被导出的函数，供执行体组件之间相互调用，但<strong>未被文档化</strong>的函数。这包括执行体内部使用的一组支持函数。</p>
</li>
<li><p>属于一个组件的内部（模块）函数。</p>
</li>
</ol>
</div>

<div class="note info"><p>此外，执行体还包含4组主要的支持函数，供以上这些<mark class="label success">执行体组件调用</mark>。差不多有1&#x2F;3的支持函数可以在Windows DDK中找到相应的文档，因为设备驱动程序也要调用它们。这4类支持函数如下所列：</p>
<ol>
<li>对象管理器。它负责创建、管理和删除Windows执行体对象，以及用于表达操作系统资源的抽象数据类型，比如进程、线程和各种同步对象。</li>
<li>LPC设施。LPC设施负责在同一台机器上的客户进程和服务器进程之间传递消息。 LPC是RPC（Remote Procedure Call，远程过程调用，关于网络上客户进程和服务器进程之间通信的工业标准）的一个优化版本。</li>
<li>一组运行时库函数。其功能广泛，涵盖字符串处理、算术运算、数据类型转换以及安全结构处理等。</li>
<li>执行体支持例程。例如系统内存分配（换页内存池和非换页内存池）、互锁的内存访问，以及对两种特殊类型同步对象（资源和互斥体）的支持。</li>
</ol>
</div>





<h4 id="2-3-4-系统机制"><a href="#2-3-4-系统机制" class="headerlink" title="2.3.4 系统机制"></a>2.3.4 系统机制</h4><ul>
<li>系统机制<ul>
<li>陷阱分发<ul>
<li>系统服务分发</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Windows操作系统提供了一些基本的<mark class="label success">机制</mark><mark class="label danger">供内核模式的组件</mark>（比如执行体、内核和设备驱动程序）使用。本节将介绍下面的系统机制中的陷阱（其他机制可查看《深入解析Windows操作系统第6版》第3章）：</p>
<ol>
<li><mark class="label default">陷阱分发</mark>， 包括
<ul>
<li>中断；</li>
<li>延迟的过程调用（DPC）；</li>
<li>异步过程调用（APC）；</li>
<li>异常分发；</li>
<li><mark class="label default">系统服务分发</mark>。</li>
</ul>
</li>
<li>执行体对象管理器。</li>
<li>同步，包括自旋锁、内核分发器对象、等待是如何实现的，以及一些专门针对用户模式的同步原语（它们不同于传统的同步对象，可避免切换至内核模式）。</li>
<li>系统辅助线程</li>
<li>其他的机制，比如Windows全局标志。</li>
<li>高级的本地过程调用（ALPC）。</li>
<li>内核事件跟踪。</li>
<li>Wow64。</li>
<li>用户模式调试。</li>
<li>映像加载器。</li>
<li>超级管理器（Hyper-V）。</li>
<li>内核事务管理器（KTM）。</li>
<li>内核补丁保护（KPP）。</li>
<li>代码完整性。</li>
</ol>
<h4 id="2-3-5-陷阱分发"><a href="#2-3-5-陷阱分发" class="headerlink" title="2.3.5 陷阱分发"></a>2.3.5 陷阱分发</h4><div class="note danger"><p><mark class="label info">中断</mark>和<mark class="label warning">异常</mark>是导致处理器转向正常控制流<strong>之外</strong>代码的两种操作系统条件。硬件或者软件都可以检测到这两种条件。</p>
</div>

<p>术语<strong>陷阱</strong>（trap）指的是这样种机制：当异常或者中断发生时，处理器捕捉到一个执行线程，并且将控制权转移到操作系统中某一固定地址处。在Windows中， 处理器会将控制权转给<strong>陷阱处理器</strong>（trap handler）。所谓陷阱处理器，是指与某个特定的中断或异常相关联的<strong>函数</strong>。</p>
<div class="note danger"><p><strong>陷阱分发</strong>：陷阱处理器用以区分和确认硬件或者软件产生的陷阱属于中断还是异常或是系统服务。然后转由相应的中断分发、异常分发或系统服务分发去处理后续事项。同时分发任务由相应的处理器去完成，处理器实际上就是一些函数（例程）。</p>
</div>

<p>图3.1显示了一些能激活陷阱处理器的条件：</p>
<p><img data-src="https://i.loli.net/2021/05/29/atLHVbdXJPMIfwi.png" alt="13.png"></p>
<p>导致陷阱的条件有如：中断、异常、系统服务调用（分发）、DPC及APC等。</p>
<div class="note default"><p>关于中断和异常：</p>
<p><mark class="label warning">中断</mark>：中断分为异步中断和同步中断。</p>
<ul>
<li><mark class="label info">异步中断</mark>，也叫硬中断、外部中断、中断。是指由于外部设备事件所引起的中断。中断由外因引起。</li>
<li><mark class="label info">同步中断</mark>，也叫内中断、<strong>异常</strong>。是指由于 CPU 内部事件所引起的中断。异常由CPU本身原因引起。同时，<strong>软中断属于异常中的一种</strong>。同步中断就属于异常。</li>
</ul>
<p><strong>硬中断就是外部设备（比如IO，时钟设备）的中断，<mark class="label warning">软中断就是INT指令</mark>，异常就是CPU内部的中断</strong>，比如除零异常。</p>
<p>硬件的中断可分为<strong>上半部分</strong>和<strong>下半部分</strong>，下半部分也叫做软中断。上半部在屏蔽中断的上下文中运行，用于完成关键性的处理动作，然后产生软中断。下半部就是软中断处理程序，对时间要求不是非常紧急，通常比较耗时的，因此不在硬中断服务程序中执行。</p>
<p><strong>异常的分类： 处理器探测到的异常、编程异常（也称<mark class="label warning">软中断</mark>）。</strong></p>
<ul>
<li>处理器探测到的异常：<ul>
<li>故障（Fault）</li>
<li>陷阱（Trap）</li>
<li>异常终止（Abort）</li>
</ul>
</li>
<li>编程异常（也称软中断）：<ul>
<li>int指令</li>
</ul>
</li>
</ul>
<p>对于中断和异常的处理，主要是利用<strong>中断描述符表IDT</strong>中的中断描述符。</p>
<p>陷入中断(trap interrupt)， 也称软中断(soft interrupt)，系统调用(system call)简称trap：在程序中使用请求系统服务的系统调用而引发的事件。陷入是由在 cpu 上运行的当前进程导致的。如：</p>
<ul>
<li>除零错；</li>
<li>地址访问越界等。</li>
</ul>
</div>

<p>参考：</p>
<ul>
<li>《<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/30432536#:~:text=%E8%BD%AF%E4%B8%AD%E6%96%AD%E5%8F%88%E5%8F%AB%E5%81%9A%E7%BC%96%E7%A8%8B%E5%BC%82%E5%B8%B8%EF%BC%8C%E4%B8%BB%E8%A6%81%E7%94%A8%E4%BA%8E%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8D%B3int%200x80%E4%BB%A5%E5%8F%8A%E7%BB%99%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F%E9%80%9A%E6%8A%A5%E4%B8%80%E4%B8%AA%E7%89%B9%E5%AE%9A%E7%9A%84%E4%BA%8B%E4%BB%B6%EF%BC%8C%E6%89%80%E4%BB%A5%E8%BD%AF%E4%B8%AD%E6%96%AD%E6%98%AF%E5%BC%82%E5%B8%B8%E7%9A%84%E4%B8%80%E7%A7%8D%EF%BC%8C%E5%B1%9E%E4%BA%8E%E5%90%8C%E6%AD%A5%E4%B8%AD%E6%96%AD%E3%80%82%20%E6%89%80%E4%BB%A5%E4%B8%8D%E8%83%BD%E8%AF%B4%E5%BC%82%E6%AD%A5%E4%B8%AD%E6%96%AD%E5%88%86%E4%B8%BA%E8%BD%AF%E4%B8%AD%E6%96%AD%E5%92%8C%E7%A1%AC%E4%B8%AD%E6%96%AD%E3%80%82%20%E6%AD%A3%E5%A6%82%E6%A5%BC%E4%B8%BB%E6%89%80%E8%AF%B4%EF%BC%8C%E4%B8%AD%E6%96%AD%E5%88%86%E4%B8%BA%E5%90%8C%E6%AD%A5%E4%B8%AD%E6%96%AD%EF%BC%8C%E4%B9%9F%E7%A7%B0%E5%BC%82%E5%B8%B8%EF%BC%8C%E5%92%8C%E5%BC%82%E6%AD%A5%E4%B8%AD%E6%96%AD%EF%BC%8C%E4%B9%9F%E7%A7%B0%E4%B8%AD%E6%96%AD%E3%80%82%20%E5%BD%93%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%97%B6%E7%94%B1CPU%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E4%BA%A7%E7%94%9F%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%8F%AA%E6%9C%89%E5%9C%A8%E8%AF%A5%E6%8C%87%E4%BB%A4%E7%BB%88%E6%AD%A2%E6%89%A7%E8%A1%8C%E5%90%8ECPU%E6%89%8D%E4%BC%9A%E5%8F%91%E5%87%BA%E4%B8%AD%E6%96%AD%E3%80%82%20%E5%BC%82%E5%B8%B8%E5%8F%AF%E4%BB%A5%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%BB%86%E5%88%86%E4%B8%BA%E5%A4%84%E7%90%86%E5%99%A8%E6%8E%A2%E6%B5%8B%E5%BC%82%E5%B8%B8%E5%92%8C%E5%89%8D%E9%9D%A2%E6%8F%90%E5%88%B0%E7%9A%84%E7%BC%96%E7%A8%8B%E5%BC%82%E5%B8%B8%E3%80%82%20%E6%95%85%E9%9A%9C,%E6%95%85%E9%9A%9C%E5%BE%88%E6%9C%89%E7%89%B9%E7%82%B9%EF%BC%8C%E6%95%85%E9%9A%9C%E6%98%AF%E5%8F%AF%E4%BB%A5%E7%BA%A0%E6%AD%A3%E7%9A%84%EF%BC%8C%E4%B8%80%E6%97%A6%E7%BA%A0%E6%AD%A3%EF%BC%8C%E4%BC%9A%E9%87%8D%E6%96%B0%E6%89%A7%E8%A1%8C%E5%BC%95%E8%B5%B7%E6%95%85%E9%9A%9C%E7%9A%84%E6%8C%87%E4%BB%A4%E3%80%82%20%E8%BF%99%E5%B0%B1%E6%98%AF%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8%E7%9A%84%E6%9C%BA%E5%88%B6%E3%80%82%20%E7%94%B1%E5%85%B6%E4%BB%96%E7%A1%AC%E4%BB%B6%E9%9A%8F%E6%9C%BA%E4%BA%A7%E7%94%9F%E3%80%82%20%E5%8F%AF%E4%BB%A5%E5%88%86%E4%B8%BA%E5%8F%AF%E5%B1%8F%E8%94%BD%E4%B8%AD%E6%96%AD%E5%92%8C%E9%9D%9E%E5%B1%8F%E8%94%BD%E4%B8%AD%E6%96%AD%E3%80%82%20%E5%AF%B9%E4%BA%8E%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%EF%BC%8C%E4%B8%BB%E8%A6%81%E6%98%AF%E5%88%A9%E7%94%A8%20%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8IDT%20%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6%E3%80%82%20%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B1%9E%E4%BA%8E%E7%B3%BB%E7%BB%9F%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%8C%E4%B8%8E%E4%BB%A3%E7%A0%81%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E3%80%81%E6%95%B0%E6%8D%AE%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8D%E5%90%8C%E3%80%82">中断，异常，陷阱，软硬中断，同异步中断？？</a>》</li>
<li>《<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangxinrun/article/details/5967233">同步中断（异常）和 软中断</a>》</li>
<li>《<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45783996/article/details/109134900">硬中断，软中断，信号，异常</a>》</li>
<li>《<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_29996285/article/details/88078939">面试考点——中断和异常的区别</a>》</li>
<li>《<a target="_blank" rel="noopener" href="https://www.cnblogs.com/charlesblc/p/6277810.html">信号和中断的比较 + 中断和异常的比较</a>》</li>
<li>《<a target="_blank" rel="noopener" href="https://www.cnblogs.com/HsinTsao/p/6395570.html">异常、中断、陷阱</a>》</li>
</ul>
<div class="note success"><p>中断和异常的区分（内核按照下面的方法来区分中断和异常。）：</p>
<ul>
<li><strong>中断</strong>是一个<mark class="label primary">异步</mark>事件（可以在任何时候发生），并且与处理器当前正在执行的任务毫无关系。中断主要是由I&#x2F;O设备、处理器时钟或者定时器产生的，并且可以被启用（打开）或者禁用（关闭）。<ul>
<li>I&#x2F;O设备；</li>
<li>处理器时钟；</li>
<li>定时器。</li>
</ul>
</li>
<li><strong>异常</strong>是一个<mark class="label primary">同步</mark>条件，它往往是一个特殊指令执行的结果。（中止（abort）-- 比如机器检查，是一种典型的不与指令执行有关联的处理器异常。）在同样的条件下用同样的数据第二次运行程序可以重现原来的异常。异常的例子有（内核把系统服务调用看作是异常，不过，从技术上讲，它们是系统陷阱。）：<ul>
<li>内存访问违例；</li>
<li>特定的调试器指令；</li>
<li>除零错误；</li>
<li><mark class="label warning">系统服务调用</mark>。</li>
</ul>
</li>
</ul>
</div>

<div class="note danger"><p><mark class="label info">无论是硬件还是软件都能够产生异常和中断</mark>。例如，总线错误异常是由于硬件问题引起的，而除零异常则是软件错误的结果。同样，I&#x2F;O设备可以产生中断，内核本身也可以发出软中断（比如 APC 或者 DPC）。</p>
<ol>
<li><p>（硬中断）当硬件异常或者中断产生时：</p>
<ul>
<li><strong>内核模式下</strong>：处理器将在被中断的线程的内核栈中记录下足够多的机器状态信息，因而可以回到控制流中的该点处继续执行，就好像什么也没有发生过一样。</li>
<li><strong>用户模式下</strong>：如果该线程在用户模式下执行，那么 Windows 就<strong>切换到该线程的内核模式栈</strong>。然后，Windows 在被中断线程的内核栈上创建一个陷阱栈帧（trap frame），并且把线程的执行状态保存到陷阱帧里。陷阱帧是一个线程的完整执行环境的一个子集，在内核调试器中输入<code>dtnt!_trap_frame</code>就可以看到陷阱帧的定义。（<strong>即从用户模式切换到内核模式，同时栈帧也从用户模式切换到内核模式</strong>）。</li>
</ul>
</li>
<li><p>（软中断，即异常）</p>
<p>内核在处理软中断时，或者将软中断当作硬中断处理的一部分，或者当线程调用与软中断相关的内核函数时以同步方式（即异常）进行处理。</p>
</li>
</ol>
</div>

<p><strong>陷阱分发：</strong></p>
<p>在大多数情况下，内核安装了前端陷阱处理函数（陷阱分发处理器），在内核将控制权转交给与特定陷阱相关的处理函数之前或者之后，由这些前端陷阱处理函数来执行一些常规的陷阱处理任务（陷阱分发）。例如：</p>
<ul>
<li>如果陷阱条件是一个设备中断，则内核的硬件中断陷阱处理器（函数）将控制权转交给一个由设备驱动程序提供给该中断设备的中断服务例程（ISR，interrupt service routine）。</li>
<li>如果陷阱条件是因为调用一个<strong>系统服务而引发</strong>的，那么，通用的系统服务陷阱处理器将控制权转交给<strong>执行体中指定的系统服务函数</strong>（系统服务分发器）。</li>
<li>内核也会为它不希望看到的或者根本不处理的陷阱安装陷阱处理器。这些陷阱处理器一般的做法是执行系统函数<code>KebugCheckEx</code>，当内核检测到可能导致数据破坏的有问题行为或者不正确行为时，该函数会停止计算机</li>
</ul>
<h4 id="2-3-6-系统服务分发"><a href="#2-3-6-系统服务分发" class="headerlink" title="2.3.6 系统服务分发"></a>2.3.6 系统服务分发</h4><p><img data-src="https://img.shields.io/badge/%E3%80%8A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC6%E7%89%88%E3%80%8B-3.1%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E5%88%86%E5%8F%91-1fd0f6.svg?colorA=ff69b4"></p>
<p><img data-src="https://img.shields.io/badge/%E3%80%8AWindows%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B-8.1.3Windows%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E5%88%86%E5%8F%91-1fd0f6.svg?colorA=ff69b4"></p>
<p><strong>系统服务分发</strong>（System Service Dispatching）：内核中接收到合法的应用程序（用户模式的ntdll）调用时，根据<code>ntdll.dll    </code>中的系统服务存根函数指定的<mark class="label danger">系统服务号</mark>，在内核模式下，<code>KiSystemServiceRepeat</code>根据此系统服务号，知道该调用内核中哪个系统服务例程，以及从用户栈拷贝多少数据到内核栈中，然后执行该系统服务。</p>
<ul>
<li>接收系统服务号的是<mark class="label danger">系统服务分发器</mark>，然后根据系统服务号决定系统去执行哪一个系统服务。</li>
</ul>
<div class="note warning"><p>处理器一旦被中断，就会询问中断控制器以获得此中断请求（IRQ， Interrupt request）。中断控制器将该 IRQ 转译成一个<mark class="label info">中断号</mark>，利用该编号作为索引，在一个称为<strong>中断分发表</strong>（<mark class="label info">IDT</mark>，Interrupt dispatch table）的结构中找到一个IDT项，并且将控制权传递给恰当的中断分发器（例程）。在系统引导的时候，Windows会填充IDT，其中包含了指向负责处理每个中断和异常的内核器（例程）的指针。</p>
<p>Windows将硬件IRQ映射至IDT中的中断号上，同时利用IDT来为异常配置陷阱处理器，然后进行陷阱分发。</p>
</div>

<div class="note primary"><p><strong>硬中断和异常都会产生中断号，直接对应于IDT中的表项。</strong></p>
<p>在x86和x64处理器上，所有的异常（包括系统服务调用）都有预定义的中断号，直接对应于IDT中的表项，而每个表项又指向某个特定异常的陷阱处理器。表3.6显示了x86定义的异常，以及为它们分配的中断号。因为IDT中前面的表项是用于异常的，所以，硬件中断被分配了后面的表项。</p>
</div>

<p><img data-src="https://i.loli.net/2021/05/30/ics6bmURWLJSwuq.png" alt="14.png"></p>
<p><img data-src="https://i.loli.net/2021/05/30/Nik2KQ1GEl7JeUt.png" alt="15.png"></p>
<p><strong>系统服务分发：</strong></p>
<div class="note danger"><p><strong>系统服务分发顺序：</strong></p>
<p>$$中断号45 –&gt; 查IDT表第46项 –&gt; 系统服务分发器 –&gt; 从EAX获取系统服务号 –&gt; 查SDT –&gt; 得到XXX系统服务。$$</p>
<p>CPU从用户模式切换到内核模式，需要一个进行一个陷阱处理，能触发陷阱的是ntdll.dll中的<code>int 2E</code>和<code>sysenter</code>两个指令，产生一个中断号45。Windows填充IDT的46号表项，使其指向系统服务分发器。</p>
</div>

<h5 id="部分1：int-0x2E-和-Sysenter"><a href="#部分1：int-0x2E-和-Sysenter" class="headerlink" title="部分1：int 0x2E 和 Sysenter"></a>部分1：int 0x2E 和 Sysenter</h5><mark class="label info">int 0x2e</mark><mark class="label warning">sysenter</mark>

<ul>
<li><p>在Pentium I之前的x86处理器上，Windows使用<mark class="label info">int 0x2e</mark>指令（十进制是46），它会导致一个陷阱。</p>
<ul>
<li>该陷阱导致执行线程转换到内核模式中，并且进入系统服务分发器。</li>
<li>在处理器的<mark class="label default">EAX</mark>寄存器中传递的数值参数指明了所请求的<mark class="label default">系统服务号</mark>，<mark class="label primary">由ntdll.dll的存根函数指定服务号</mark>。</li>
<li><mark class="label default">EDX</mark>寄存器指向调用者传递给该系统服务的参数列表<mark class="label default">地址</mark>。</li>
<li>要回到用户模式，系统服务分发器需要使用<code>iret</code>指令（即中断返回指令）。</li>
</ul>
</li>
<li><p>在x86 Pentium II 及更高级的处理器上，Windows使用专门的<mark class="label warning">sysenter</mark>指令（32位使用sysenter指令，x64使用syscall指令，IA64使用epc指令。），这是InteI特别为<strong>快速系统服务分发</strong>而定义的指令。</p>
<ul>
<li>为了支持这一指令， Windows在引导时将内核的系统服务分发器例程的地址保存在与该指令相关联的3个<mark class="label default">MSR</mark>（machine specific register）寄存器中。</li>
<li>该指令一旦被执行，就会导致变换到内核模式下，并且执行系统服务分发器。</li>
<li>系统服务号是通过处理器的EAX寄存器来传递的，而EDX寄存器则指向调用者参数的列表地址。</li>
<li>为了返回到用户模式，系统服务分发器通常执行<code>sysexit</code>指令。</li>
</ul>
</li>
</ul>
<div class="note warning"><p>ntdll.dll中的<code>KiIntSystemCall</code>函数执行<code>int 2e</code>，<code>KiFastSystemCall</code>执行<code>sysenter</code>指令，以便切换到内核模式下，然后由内核模式的系统服务分发函数<code>KiSystemService</code>或<code>KiFastCallEntry</code>（系统服务分发器）来调用系统服务函数。待系统服务函数执行完成以后，<code>KiSystemService </code>调用<code>KiServiceExit</code>函数，最终通过<code>iretd</code>或<code>sysexit</code>指令返回到用户模式ntdll.dll模块中。</p>
<ul>
<li>用户模式下：<ul>
<li><code>SystemCall</code> --&gt; <code>KiIntSystemCall</code> --&gt; <code>int 2e</code>；</li>
<li><code>SystemCall</code>  --&gt; <code>KiFastSystemCall</code>--&gt; <code>sysenter</code>。</li>
</ul>
</li>
<li>内核模式下：<ul>
<li><code>KiIntSystemCall</code> --&gt; <code>int 2e</code> --&gt; <code>KiSystemService</code> --&gt; 系统服务函数 --&gt; <code>KiServiceExit</code> --&gt; <code>iretd</code> --&gt; 返回用户模式；</li>
<li><code>KiFastSystemCall</code>--&gt; <code>sysenter</code> --&gt; <code>KiFastCallEntry</code> --&gt; 系统服务函数 --&gt; <code>KiServiceExit2</code> --&gt; <code>sysexit</code> --&gt; 返回用户模式。</li>
</ul>
</li>
</ul>
<p><code>SystemCall</code>和<code>SystemCallReturm</code>成员：</p>
<ul>
<li>这是两个<mark class="label default">函数地址</mark>，<code>SystemCall</code>成员指示了从用户模式切换至内核模式的函数地址；<code>SystemCallReturn</code>成员指示了从内核模式返回至用户模式的函数地址。</li>
<li>当处理器支持快速系统调用时，SystemCall成员指向<code>KiFastSystemCall</code>函数，<code>SystemCallReturn</code>成员指向<code>KiFastSystemCallRet</code>函数；否则，<code>SystemCall</code>成员指向<code>KiIntSystemCall</code>函数。</li>
</ul>
</div>

<p>在切换至内核模式以前，edx寄存器指向用户栈中的某个位置。显然，edx的用意是向内核模式的系统服务函数传递有关参数的信息。内核中哪个函数被执行呢（<mark class="label primary">指定哪个系统分发器</mark>）？</p>
<ul>
<li>如果是由<code>int 2e</code>指令进入的，则<code>KiSystemService</code>（<mark class="label default">系统服务分发器</mark>）函数获得控制权，这是在IDT的<code>0x2e</code>项中指定的；</li>
<li>如果是借由<code>syenter</code>指令跳转过来的，则<code>KiFastCallEntry</code>（<mark class="label default">系统服务分发器</mark>）函数获得控制权，这是由MSR寄存器<code>IA32_SYSENTER_EIP</code>指定的。</li>
</ul>
<h5 id="部分2：原先模式"><a href="#部分2：原先模式" class="headerlink" title="部分2：原先模式"></a>部分2：原先模式</h5><p>系统服务分发器将调用者的参数从线程的用户模式栈中复制到内核模式找中（所以，当内核在访问参数时，用户不能改变它们），然后执行该系统服务。内核知道要从栈中复制多少字节，因为它使用了第二个表， 称为参数表<mark class="label default">SSPT</mark>。参数表是一个<mark class="label warning">字节数组</mark>（而并非像服务分发表那样是一个<mark class="label warning">指针数组</mark>），每一项描述了要复制的字节数。在64位系统上，Windows通过一个称为<strong>系统调用表缩紧</strong>（system call table compaction）的过程，将这一信息实际编码在服务表内部。如果传递给一个系统服务的参数指向了用户空间中的缓冲区，那么，内核模式的代码在复制数据到这些缓冲区中，或者从缓冲区中复制数据以前，必须要先探查这些缓冲区是否是可以访问的。只有当线程的原先模式（previous mode）属性被设置为用户模式，才会执行缓冲区探查工作。</p>
<mark class="label warning">原先模式</mark>：是内核在执行陷阱处理器时保存在线程中的一个值（内核或用户），<mark class="label info">代表了这一进来的异常、陷阱或系统调用是从哪个特权级别（R3/R0）进来的</mark>。作为一项优化措施：

<ul>
<li>如果一个系统调用来自于<strong>驱动程序</strong>或<strong>内核本身</strong>，则对参数的探查和异常捕获可以忽略，所有的参数都假定指向有效的内核模式缓冲区(而且，访问内核模式数据也是允许的)。调用者已经在内核模式下了，不需要<code>中断</code>或<code>sysenter</code>操作CPU已经在正确的特权级上了，而且，驱动程序和内核一样， 应该只能直接调用所请求的函数。<ul>
<li>但如果直接像调用API一般直接调用<code>NtOpenProcess</code>之类的系统服务函数时，内核保存的原先模式值仍然是用户模式（进内核之前当然是用户模式咯~），但又检测到传递来的地址是一个内核模式地址（因为在当前内核模式下调用），于是会导致调用失败（<code>STATUS_ACCESS_VIOLATION</code>）。</li>
</ul>
</li>
<li>如果原先模式为用户模式，在给系统服务传递的参数指向了用户空间缓冲区时，内核模式代码在操作该缓冲区前会检查是否可以访问该缓冲区。</li>
</ul>
<h5 id="部分3：SSDT-和-Shadow-SSDT"><a href="#部分3：SSDT-和-Shadow-SSDT" class="headerlink" title="部分3：SSDT 和 Shadow SSDT"></a>部分3：SSDT 和 Shadow SSDT</h5><p>ntdll.dll中的系统服务存根函数调用<code>int 2e</code>或<code>sysenter</code>产生中断（<mark class="label danger">中断号</mark>），同时存根函数指定一个<mark class="label primary">系统服务号</mark>。一个存根函数对应一个系统服务号。 </p>
<div class="note info"><p>系统服务分发过程中有两个重要的系统服务分发表，在 NT 4.0 以上的 Windows 操作系统中（Windows 2000），默认就存在两个系统服务描述表，这两个调度表对应了两类不同的系统服务，这两个调度表为：</p>
<ul>
<li><p><mark class="label danger">SSDT：</mark><mark class="label success">KeServiceDescriptorTable</mark></p>
</li>
<li><p><mark class="label danger">ShadowSSDT：</mark><mark class="label success">KeServiceDescriptorTableShadow</mark></p>
</li>
</ul>
<ol>
<li><code>KeServiceDeseriptorTable</code>定义了<code>Ntoskrnl.exe</code>中实现的核心执行体系统服务。<code>KeSericeDescriptorTableShadow</code>包含了在Windows子系统的内核模式部分<code>Win32k.sys</code>中实现的Windows USER和GDI服务。</li>
<li>针对Windows执行体服务的系统服务分发指令位于系统库ntdll.dll中。子系统DLL调用 Ntdll.dll中的函数来实现其已文档化的函数。只有Windows USER和GDI函数例外，在这些函数中，系统服务分发指令是直接在User32.dII和Gdi32.dll中实现的，没有涉及Ntdll.dll。</li>
<li>在32位和IA64版本的Windows 上，当Windows线程第一次调用Windows USER或GDI服务时，该线程的系统服务表的地址被改变成指向个包含Windows USER和GDI服务的表。KeaddSystemerviceTable 函数使Win32k.sys可以增加一个系统服务表。</li>
<li>win32k.sys只有在GUI线程中才加载，一般情况下是不加载的，所以要Hook KeServieDescriptorTableShadow的话，一般是用一个GUI程序通过IoControlCode来触发。</li>
</ol>
</div>

<p>Windows 操作系统共有4个系统服务描述符。其中只用了两个，第一个是SSDT，第二个是ShadowSSDT。SSDT与ShadowSSDT的结构如下(参考《Undocument Windows 2000 Secretes》第二章)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KSYSTEM_SERVICE_TABLE 和 KSERVICE_TABLE_DESCRIPTOR</span></span><br><span class="line"><span class="comment">// 用来定义 SSDT 结构</span></span><br><span class="line"><span class="comment">/********</span></span><br><span class="line"><span class="comment">  ***</span></span><br><span class="line"><span class="comment">  KeServiceDeseriptorTable结构</span></span><br><span class="line"><span class="comment">  ***</span></span><br><span class="line"><span class="comment">*********/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KSYSTEM_SERVICE_TABLE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PULONG  *ServiceTableBase;                         <span class="comment">// SSDT (System Service Dispatch Table)的基地址</span></span><br><span class="line">    PULONG  *ServiceCounterTableBase;                  <span class="comment">// 用于 checked builds, 包含 SSDT 中每个服务被调用的次数</span></span><br><span class="line">    ULONG   NumberOfService;                           <span class="comment">// SSDT服务函数的个数, NumberOfService * 4 就是整个地址表的大小</span></span><br><span class="line">    ULONG   * ParamTableBase;                          <span class="comment">// SSPT(System Service Parameter Table)的基地址</span></span><br><span class="line">&#125; KSYSTEM_SERVICE_TABLE, *PKSYSTEM_SERVICE_TABLE;</span><br><span class="line"><span class="comment">/********</span></span><br><span class="line"><span class="comment">  ***</span></span><br><span class="line"><span class="comment">  KeServiceDeseriptorTableShadow结构</span></span><br><span class="line"><span class="comment">  ***</span></span><br><span class="line"><span class="comment">*********/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KSERVICE_TABLE_DESCRIPTOR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    KSYSTEM_SERVICE_TABLE   ntoskrnl;                  <span class="comment">// ntoskrnl.exe 的服务函数</span></span><br><span class="line">    KSYSTEM_SERVICE_TABLE   win32k;                    <span class="comment">// win32k.sys 的服务函数(GDI32.dll/User32.dll 的内核支持)</span></span><br><span class="line">    KSYSTEM_SERVICE_TABLE   notUsed1;</span><br><span class="line">    KSYSTEM_SERVICE_TABLE   notUsed2;</span><br><span class="line">&#125;KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;</span><br></pre></td></tr></table></figure>



<div class="note danger"><p><strong>说明：</strong></p>
<ol>
<li><p><code>KeServiceDescriptorTable</code>由ntoskrnl.exe导出和<code>KeServiceDescriptorTableShadow</code>没有导出，二者都<mark class="label default">是数组</mark>；</p>
<ul>
<li><p>系统使用的基本 SSDT，即<code>KeServiceDescriptorTable[0]</code>，<code>KeServiceDescriptorTable[1]</code>元素不使用。是在<code>KiInitsystem</code>函数中被初始化的，此 SSDT 的原始数据分别来自于内部变量<code>KiserviceTable</code>、<code>KiserviceLimit</code>和 <code>Kiargumenttable</code>，其中<code>Count</code>成员被初始化为<code>NULL</code>，参见下图。</p>
</li>
<li><p><code>KeServiceDescriptorTableShadow</code>是一个内部数组，<strong>它的第 2 个元素为ShadowSSDT</strong>，即  <code>KeServiceDescriptorTableShadow[1]</code>表项，专门用于 Windows 子系统，其他的表项与  <code>KeServiceDescriptorTable</code>完全相同。<code>KeServiceDescriptorTable[0]</code>为SSDT，<strong>但是不使用</strong>。</p>
<p><img data-src="https://i.loli.net/2021/06/08/lyvI9ojW78bs6wi.png" alt="16.png"></p>
</li>
</ul>
</li>
<li><p>SSDT、SSPT表都属于<code>KeServiceDescriptorTable</code>结构的<mark class="label default">第一和第四个元素</mark>。Shadow SSDT属于<code>KeServiceDescriptorTableShadow</code>结构的<mark class="label default">第二个元素</mark>。<strong>SSDT的函数是Native API</strong>。</p>
</li>
<li><p>SSDT是<code>KeServiceDescriptorTable</code>的第一个元素<code>ServiceTableBase</code>，且为一个数组或指针，指向ntoskrnl.dll中系统函数的<mark class="label default">入口地址</mark>。</p>
<ul>
<li><p>某个系统服务函数的地址的计算方法为：</p>
<p>$$Address &#x3D; KeServiceDescriptorTable.ServiceTableBase + 4 * 系统服务号$$</p>
</li>
</ul>
</li>
<li><p><code>KeServiceDescriptorTableShadow</code>包含4个子结构，其中第一个就是ntoskrnl.exe ( native api )，不用，我们真正需要获得的是第二个win32k.sys (gdi&#x2F;user support)，第三个和第四个一般不使用。</p>
</li>
<li><p>两者的区别是，<code>KeServiceDescriptorTable</code>仅有ntoskrnel一项，<code>KeServieDescriptorTableShadow</code>包含了ntoskrnel以及win32k。一般的Native API的服务地址由<code>KeServiceDescriptorTable</code>分派，<code>gdi.dll/user.dll</code>的内核API调用服务地址由<code>KeServieDescriptorTableShadow</code>分派。</p>
</li>
<li><p>SSDT中系统服务函数的个数随着Windows发展在不断增加，且不同版本中的系统服务函数对应的系统服务号一般不同。</p>
</li>
</ol>
</div>

<p><strong>1）</strong>对照KeServiceDescriptorTable结构，Windbg查看其结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">lkd&gt; dd KeServiceDescriptorTable   </span><br><span class="line"><span class="number">80563520</span>  <span class="number">804e58</span>b0 <span class="number">00000000</span> <span class="number">0000011</span>c <span class="number">805120</span>cc  <span class="comment">//804e58b0就是SSDT表的起始地址，805120cc为SSPT表的起始地址</span></span><br><span class="line"><span class="number">80563530</span>  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>  <span class="comment">//KeServiceDescriptorTableShadow未公开</span></span><br><span class="line"><span class="number">80563540</span>  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">80563550</span>  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> </span><br><span class="line">...</span><br><span class="line">lkd&gt; dd <span class="number">804e58</span>b0               <span class="comment">//SSDT基址</span></span><br><span class="line"><span class="number">804e58</span>b0  <span class="number">80591b</span>fb <span class="number">80585358</span> <span class="number">805e1</span>f35 <span class="number">805</span>dbc4a</span><br><span class="line"><span class="number">804e58</span>c0  <span class="number">805e1</span>fbc <span class="number">80640</span>ce4 <span class="number">80642e75</span> <span class="number">80642</span>ebe</span><br><span class="line"><span class="number">804e58</span>d0  <span class="number">805835</span>aa <span class="number">80650b</span>e3 <span class="number">806404</span>a3 <span class="number">805e1787</span></span><br><span class="line"><span class="number">804e58</span>e0  <span class="number">806387b</span>a <span class="number">80586f</span>a3 <span class="number">805e08</span>e8 <span class="number">8062f</span>462</span><br><span class="line">...</span><br><span class="line">若sysenter的ID（系统服务号）是<span class="number">0x105</span>，对应函数ntos!NtQuerySystemInformation=<span class="number">0x804e58b0</span>+<span class="number">4</span>*<span class="number">0x105</span>=<span class="number">0x804e5cc4</span>，</span><br><span class="line">  跟踪进去：</span><br><span class="line">lkd&gt; u <span class="number">804e5</span>cc4</span><br><span class="line">nt!NtQuerySystemInformation:</span><br><span class="line"><span class="number">8464</span>ae3e  <span class="number">8b</span>ff          mov     edi,edi</span><br><span class="line"><span class="number">8464</span>ae40  <span class="number">55</span>            push    ebp</span><br><span class="line"><span class="number">8464</span>ae41  <span class="number">8b</span>ec          mov     ebp,esp</span><br><span class="line"><span class="number">8464</span>ae43  <span class="number">8b</span>5508        mov     edx,dword ptr [ebp+<span class="number">8</span>]</span><br><span class="line"><span class="number">8464</span>ae46  <span class="number">83f</span>a53        cmp     edx,<span class="number">53</span>h</span><br><span class="line"><span class="number">8464</span>ae49  <span class="number">7f</span>21          jg      nt!NtQuerySystemInformation+<span class="number">0x2e</span> (<span class="number">8464</span>ae6c)</span><br><span class="line"><span class="number">8464</span>ae4b  <span class="number">7440</span>          je      nt!NtQuerySystemInformation+<span class="number">0x4f</span> (<span class="number">8464</span>ae8d)</span><br><span class="line"><span class="number">8464</span>ae4d  <span class="number">83f</span>a08        cmp     edx,<span class="number">8</span></span><br></pre></td></tr></table></figure>

<p><strong>2）</strong>对照KeServiceDescriptorTableShadow结构，Windbg查看其结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd KeServiceDescriptorTableShadow  </span><br><span class="line"><span class="number">805634e0</span>  <span class="number">804e58</span>b0 <span class="number">00000000</span> <span class="number">0000011</span>c <span class="number">805120</span>cc    KeServiceDescriptorTableShadow[<span class="number">0</span>]，SSDT表 Ntoskrnel.exe，不用</span><br><span class="line"><span class="number">805634f</span>0  bf99a000 <span class="number">00000000</span> <span class="number">0000029b</span> bf99ad10    KeServiceDescriptorTableShadow[<span class="number">1</span>]，SSDT Shdow表 Win32k.sys</span><br><span class="line"><span class="number">80563500</span>  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">80563510</span>  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">80563520</span>  <span class="number">804e58</span>b0 <span class="number">00000000</span> <span class="number">0000011</span>c <span class="number">805120</span>cc       <span class="comment">//KeServiceDescriptorTable 表</span></span><br><span class="line"><span class="number">80563530</span>  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br></pre></td></tr></table></figure>

<p>同时还发现，在XP系统下，KeServiceDescriptorTableShadow表位于KeServiceDescriptorTable表下方，偏移0x40处。</p>
<div class="note primary"><p>结论：</p>
<p>ShadowSSDT在<mark class="label info">KeServiceDescriptorTableShadow[1]</mark>中第二个元素，而<mark class="label warning">KeServiceDescriptorTableShadow[0]</mark>第一个元素为SSDT。</p>
</div>

<p><img data-src="https://i.loli.net/2021/06/10/H4BRSyMsYwj5kDT.png" alt="17.png"></p>
<p><img data-src="https://i.loli.net/2021/06/10/kV1ChfTWUFxD6ba.jpg" alt="21.jpeg"></p>
<p>参考：</p>
<ul>
<li>《<a target="_blank" rel="noopener" href="https://blog.csdn.net/xuemao1230/article/details/79397553">ssdt与shadowssdt区别</a>》</li>
<li>《<a target="_blank" rel="noopener" href="https://cataloc.gitee.io/blog/2020/03/27/API%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E8%A1%A8%EF%BC%89/#SharedCode%E5%88%86%E6%9E%90">API函数的调用过程（系统服务表）</a>》</li>
<li>《<a target="_blank" rel="noopener" href="https://www.cnblogs.com/onetrainee/p/11717309.html">Windows系统调用中的系统服务表描述符(SSDT)</a>》</li>
</ul>
<div class="note default"><p>由于KeServiceDescriptorTableShadow表属于未导出，因此我们需要定位地址。<br>定位未导出函数和结构的思想就是利用已导出函数和结构，暴力搜索内存空间。<br>方法一、依据KeServiceDescriptorTable的地址和两者之间的偏移<br>方法二、搜索KeAddSystemServiceTable导出函数<br>方法三、搜索线程的ServiceTable指向<br>方法四、MJ提出的搜索有效内存地址</p>
</div>

<h5 id="部分4：系统服务号"><a href="#部分4：系统服务号" class="headerlink" title="部分4：系统服务号"></a>部分4：系统服务号</h5><p>系统服务号用来定位所要寻找的系统服务表的函数。</p>
<div class="note warning"><p><mark class="label info">系统服务号只有低13位是有用的</mark></p>
<ul>
<li>下标12：判断去查服务表，<mark class="label warning">0</mark>去查第一张表SSDT；<mark class="label warning">1</mark>去查第二张表ShadowSSDT</li>
<li>下标0~11：表内索引，函数地址表的索引，范围0H ~ FFFH。<ul>
<li>SSDT函数服务号范围0x00000000 ~ 0x00000FFF；</li>
<li>ShadowSSDT服务号范围0x00001000 ~ 0x00001FFF。</li>
</ul>
</li>
</ul>
</div>

<p><img data-src="https://i.loli.net/2021/06/10/fdNwZQIkgmGvE9L.png" alt="18.png"></p>
<p><img data-src="https://i.loli.net/2021/06/10/lTrgJzkQYm9ia7E.png" alt="19.png"></p>
<h5 id="部分5：系统服务分发"><a href="#部分5：系统服务分发" class="headerlink" title="部分5：系统服务分发"></a>部分5：系统服务分发</h5><p>以函数WriteFile函数为例，从R3到R0的调用过程：</p>
<ol>
<li>如图3.17所示，位于Kernel32.dll中的Windows WriteFile函数导入并调用<code>API-MS-Win-Core-File-L1-1-0.dll</code>中的NtWriteFile函数，这是一个MinWin重定向DLL；</li>
<li>这里的NtWriteFile函数又调用<code>KernelBase.dll</code>中的WriteFile函数，这才是真正的实现所在。</li>
<li>KernelBase.dll.WriteFile函数对子系统相关的参数做了检查以后，再调用<code>Ndll.dll</code>中的<code>NtWriteFile</code>函数，然后NtWriteFile函数又执行适当的指令以引发一个系统服务陷阱并且把代表<code>NtWriteFile</code>的系统服务号传递过去。</li>
<li>系统服务分发器（即Ntoskml.exe中的<code>KiSystemService</code>函数）然后调用真正的<code>nt!NtWriteFile</code>来处理该IO请求。</li>
<li>对于Windows USER和GDI函数，系统服务分发器调用Windows子系统的可加载内核模式部分（Win32k.sys）中的函数。</li>
</ol>
<div class="note danger"><p>总结为：</p>
<p><code>Kernel32.dll.WriteFile --&gt; API-MS-Win-Core-File-L1-1-0.dll.NtWriteFile --&gt; KernelBase.dll.WriteFile --&gt;  Ndll.dll.NtWriteFile --&gt; KiFastSystemCall --&gt; sysenter --&gt; KiFastCallEntry（系统服务分发器） --&gt; 查找SSDT</code></p>
<p><img data-src="https://i.loli.net/2021/06/10/rW9boQ1YBU3cmOj.png" alt="20.png"></p>
</div>

<p>过程如下：</p>
<p><img data-src="https://i.loli.net/2021/06/11/L7easlOwjvA3EZ5.png" alt="22.png"></p>
<p>上图参考《<a target="_blank" rel="noopener" href="https://wenku.baidu.com/view/5e4e0bda69dc5022abea001b.html?fr=search-1-wk_es_paddle-income5&fixfr=kZolUMQwRLbkNUCGioehqw==">SSDT 及SSDT Shadow 完全解析</a>》（可下载）</p>
<ul>
<li>《<a target="_blank" rel="noopener" href="https://www.cnblogs.com/uAreKongqi/p/6597701.html">浅谈系统服务分发</a>》</li>
<li>《<a target="_blank" rel="noopener" href="https://blog.csdn.net/cdsntxz158/article/details/8020629">SSDT获取原始服务地址的方法与原理</a>》</li>
<li>《<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/38339756">Hook原理</a>》</li>
<li>《<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1471088?from=article.detail.1471284">SSDT表概念详解</a>》</li>
<li>《<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/328757029">SSDT Hook底层原理介绍以及如何实现进程保护</a>》</li>
</ul>
<h5 id="部分6：Nt-和-Zw"><a href="#部分6：Nt-和-Zw" class="headerlink" title="部分6：Nt* 和 Zw*"></a>部分6：Nt* 和 Zw*</h5><p><img data-src="https://i.loli.net/2021/06/15/LxrowB1pqlZjE3g.png" alt="24-1"></p>
<p><img data-src="https://i.loli.net/2021/06/11/6zHG54kqN7icYLj.png" alt="23.png"></p>
<div class="note info"><p><strong>nt!Zw*函数是nt!Nt*的一个stub(存根)函数</strong>，只是mov系统调用号到eax中，转而直接调用nt!KiSystemService去从SSDT中找到相应号码的函数再调用之，真正的实现都在Nt*函数中。</p>
</div>

<ul>
<li><code>ntdll!Zw*</code>仅仅是<code>ntdll!*</code>函数的别名而已</li>
<li>内核模式下Nt系列API将直接调用对应的函数代码，而Zw系列API则通过KiSystemService，SSDT最终跳转到对应的NT函数代码。</li>
<li>两种不同的调用对内核中previous mode（原先模式）的改变，如果是从用户模式调用Native API则previous mode是用户态，如果从内核模式调用Native API则previous mode是内核态。previous为用户态时Native API将对传递的<strong>参数进行严格的检查</strong>，而为内核态时则不会。</li>
<li>调用用户模式Nt API时不会改变previous mode的状态，调用内核模式Zw API时会将previous mode改为内核态，因此在进行Kernel Mode Driver开发时可以使用内核模式Zw系列API可以避免额外的参数列表检查，提高效率。</li>
<li>内核模式下Zw*函数会把PreviousMode设置为KernelMode  然后再调用Nt*函数，因此在Nt*函数中就不会进行参数检查。而如果直接调用Nt*函数的话 , 必须自己将PreviousMode设置为KernelMode，否则PreviousMode很可能仍然是UserMode，这样的话Nt*函数就会认为对它的调用来自用户态，从而做一些检查,这时就会产生问题了。因此要自己调用Nt*的话必须先将PreviousMode设为KernelMode。</li>
<li>R3下无论如何调用，均无法绕过SSDT HOOK，R0下若在驱动中直接调用Nt系列函数，调用Nt*可以绕过SSDT HOOK。</li>
</ul>
<p>参考：</p>
<ul>
<li>《<a target="_blank" rel="noopener" href="https://blog.csdn.net/qiaoli278141408/article/details/39502285?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.control">Nt*和Zw*开头的函数</a>》</li>
<li>《<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhuhuibeishadiao/article/details/51114094">ZW与NT函数区别</a>》</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>Buy me a coffee</div>
  <button onclick="document.querySelector('.post-reward').classList.toggle('active');">
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechat.jpg" alt="Catecat 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpg" alt="Catecat 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Catecat
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://directoree.github.io/post/Windows-Kernel-Base/" title="Windows内核基础">https://directoree.github.io/post/Windows-Kernel-Base/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Windows%E5%86%85%E6%A0%B8/" rel="tag"><i class="fa fa-tag"></i> Windows内核</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/0day2-3-4/" rel="prev" title="0day安全：软件漏洞分析技术（第二版）读书笔记（3-4）">
                  <i class="fa fa-chevron-left"></i> 0day安全：软件漏洞分析技术（第二版）读书笔记（3-4）
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/encryption-and-cracking-1-basic/" rel="next" title="《加密与解密》_1_基础知识">
                  《加密与解密》_1_基础知识 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Catecat</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">2.4m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">36:28</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1.15.0/dist/lozad.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/local-search.js"></script>








<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  const url = element.dataset.target;
  const pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  const pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  const fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script>
if (document.querySelectorAll('.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8.7.0/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>








  

  
      <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//cdn.jsdelivr.net/npm/mathjax@3.1.0/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
NexT.utils.loadComments('#valine-comments', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    new Valine(Object.assign({"enable":true,"appId":"7zujCcS8pYH88CJXfdBlLyS8-gzGzoHsz","appKey":"lWGr7OPoNHo4v1YmVV5yr3E9","serverURLs":"https://7zujccs8.lc-cn-n1-shared.com","placeholder":"快来勾搭我呀🐶","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"lang":null,"visitor":true,"comment_count":true,"bg":"/images/comment_bg.png","recordIP":false,"enableQQ":false,"requiredFields":["nick"]}, {
      el: '#valine-comments',
      path: "/post/Windows-Kernel-Base/",
      serverURLs: "https://7zujccs8.lc-cn-n1-shared.com"
    }));
  }, window.Valine);
});
</script>

</body>
</html>
