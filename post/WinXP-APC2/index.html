<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon1.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"directoree.github.io","root":"/","scheme":"Mist","version":"8.0.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="ʕ •̀ o •́ ʔ">
<meta property="og:type" content="article">
<meta property="og:title" content="Windows XP APC（二）">
<meta property="og:url" content="https://directoree.github.io/post/WinXP-APC2/index.html">
<meta property="og:site_name" content="Catecat">
<meta property="og:description" content="ʕ •̀ o •́ ʔ">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/06/26/EiufXmxktJYCPq7.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/27/Q5nAgaFuTG3WIEZ.png">
<meta property="og:image" content="https://s2.loli.net/2022/06/27/Pv79dtf5kxi3sCT.png">
<meta property="article:published_time" content="2022-06-26T06:13:29.000Z">
<meta property="article:modified_time" content="2022-06-28T16:57:01.199Z">
<meta property="article:author" content="Catecat">
<meta property="article:tag" content="WinXP内核">
<meta property="article:tag" content="APC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/06/26/EiufXmxktJYCPq7.png">


<link rel="canonical" href="https://directoree.github.io/post/WinXP-APC2/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Windows XP APC（二） | Catecat</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b832a9ae9a43377003fd975ca4e525ea";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Catecat</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">爱你所爱，行你所行，听从你心，无问西东。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-更新日志">

    <a href="/changelog" rel="section"><i class="fa fa-heartbeat fa-fw"></i>更新日志</a>

  </li>
        <li class="menu-item menu-item-空调房">

    <a href="/tips" rel="section"><i class="fa fa-wifi fa-fw"></i>空调房</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-APC%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C"><span class="nav-text">1 APC函数执行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-APC%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="nav-text">1.1 APC函数执行的条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%86%85%E6%A0%B8APC%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-text">1.2 内核APC执行过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E7%94%A8%E6%88%B7APC%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-text">1.3 用户APC执行过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-KiDeliverApc"><span class="nav-text">2 KiDeliverApc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-KeTestAlertThread"><span class="nav-text">3 KeTestAlertThread</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-KiInitializeUserApc"><span class="nav-text">4 KiInitializeUserApc</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Catecat"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Catecat</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">117</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">63</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Directoree" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Directoree" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhao_yilong@aliyun.com" title="E-Mail → mailto:zhao_yilong@aliyun.com" rel="noopener" target="_blank"><i class="fas fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://sighttp.qq.com/msgrd?v=1&uin=1003432683" title="QQ → http:&#x2F;&#x2F;sighttp.qq.com&#x2F;msgrd?v&#x3D;1&amp;uin&#x3D;1003432683" rel="noopener" target="_blank"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://treecatee.github.io/" title="https:&#x2F;&#x2F;treecatee.github.io" rel="noopener" target="_blank">Treecatee</a>
        </li>
    </ul>
  </div>

      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://directoree.github.io/post/WinXP-APC2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Catecat">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Catecat">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Windows XP APC（二）
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-26 14:13:29" itemprop="dateCreated datePublished" datetime="2022-06-26T14:13:29+08:00">2022-06-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-29 00:57:01" itemprop="dateModified" datetime="2022-06-29T00:57:01+08:00">2022-06-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AC%94%E8%AE%B0/APC/" itemprop="url" rel="index"><span itemprop="name">APC</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AC%94%E8%AE%B0/APC/Windows%E5%86%85%E6%A0%B8/" itemprop="url" rel="index"><span itemprop="name">Windows内核</span></a>
        </span>
    </span>

  
    <span id="/post/WinXP-APC2/" class="post-meta-item leancloud_visitors" data-flag-title="Windows XP APC（二）" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/post/WinXP-APC2/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/post/WinXP-APC2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>19k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>17 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><a target="_blank" rel="noopener" href="https://unicode-table.com/cn/kaomoji/">ʕ •̀ o •́ ʔ </a></p>
<a id="more"></a>

<h2 id="1-APC函数执行"><a href="#1-APC函数执行" class="headerlink" title="1 APC函数执行"></a>1 APC函数执行</h2><p>上一篇文章《<a href="https://directoree.github.io/post/WinXP-APC/">Windows XP APC（一）</a>》已经将APC内核对象插入到目标线程的APC队列讲解完成了，接下来讲解APC函数在目标线程中是如何执行的。</p>
<p>一个线程如果要执行挂在APC队列的APC函数，最先会调用函数<mark class="label danger">KiDeliverApc</mark>去处理后续的流程。</p>
<h3 id="1-1-APC函数执行的条件"><a href="#1-1-APC函数执行的条件" class="headerlink" title="1.1 APC函数执行的条件"></a>1.1 APC函数执行的条件</h3><div class="note success"><p>哪些情况下线程会执行APC函数：</p>
<ol>
<li><mark class="label warning">线程切换</mark>。线程切换后（<code>KiSwapThread</code>），新线程执行时会调用<code>KiDeliverApc</code>。</li>
<li><mark class="label primary">系统调用、中断、异常</mark>。会执行函数<code>_KiServiceExit</code>，然后调用<code>KiDeliverApc</code>。</li>
</ol>
</div>

<div class="note primary"><p><strong>总结一句话</strong>：凡是会调用<code>KiDeliverApc</code>函数的点，都有机会执行APC函数。</p>
</div>

<p>函数<code>_KiServiceExit</code>是CPU从系统调用、中断或异常处理返回用户空间时的必经之路。</p>
<p>在函数<code>KiDeliverApc</code>按一下<code>X</code>查看一下交叉引用（<code>ntkrpamp.exe</code>2-9-9-12分页多核）：</p>
<p><img data-src="https://s2.loli.net/2022/06/26/EiufXmxktJYCPq7.png" alt="2.png"></p>
<p>实际上调用<code>KiDeliverApc</code>的函数有以上那些。</p>
<p>然后看一下《Windows内核原理与实现5.2 P335》中，在WRK版本里除了上面提到的<strong>线程切换、系统调用、中断、异常</strong>，还有一种情况是：</p>
<blockquote>
<p>当内核代码离开一个临界区或者守护区（调用<code>KeLeaveGuardedRegion</code>或<code>KeLeaveCriticalRegion</code>）时，通过<code>KiCheckForKernelApcDelivery</code>函数直接调用<code>KiDeliverApc</code>，或者调用<code>KiRequestSoftwareInterrupt</code>函数请求一个<code>APC_LEVEL</code>的软件中断。这是因为，当线程进入临界区或守护区时，普通内核模式APC或特殊内核模式APC被禁止了，所以，当离开时，<code>KiCheckForKernelApcDelivery</code>函数被调用，以便及时地交付内核模式APC。</p>
</blockquote>
<h3 id="1-2-内核APC执行过程"><a href="#1-2-内核APC执行过程" class="headerlink" title="1.2 内核APC执行过程"></a>1.2 内核APC执行过程</h3><p><code>KiDeliverApc</code>函数执行内核APC流程：<br>1）判断第一个链表是否为空<br>2）判断KTHREAD.ApcState.KernelApcInProgress是否为1<br>3）判断是否禁用内核APC(KTHREAD.KernelApcDisable是否为1)<br>4）将当前KAPC结构体从链表中摘除<br>5）执行KAPC.KernelRoutine指定的函数 释放KAPC结构体占用的空间<br>6）将KTHREAD.ApcState.KernelApcInProgress设置为1 标识正在执行内核APC<br>7）执行真正的内核APC函数(KAPC.NormalRoutine)<br>8）执行完毕 将KernelApcInProgress改为0<br>9）循环</p>
<p>实际执行过程会在后面的<code>KiDeliverApc</code>函数逆向分析时候具体解释。</p>
<p><strong>总结：</strong><br>1）内核APC在线程切换的时候就会执行，这也就意味着，只要插入内核APC很快就会执行。<br>2）在执行用户APC之前会先执行内核APC。<br>3）内核APC在内核空间执行，不需要换栈，一个循环全部执行完毕。</p>
<h3 id="1-3-用户APC执行过程"><a href="#1-3-用户APC执行过程" class="headerlink" title="1.3 用户APC执行过程"></a>1.3 用户APC执行过程</h3><p>处理用户APC要比内核APC复杂的多，因为用户APC函数要在用户空间执行的，这里涉及到大量换栈的操作：</p>
<ol>
<li>当线程从用户层进入内核层时，要保留原来的运行环境，比如各种寄存器，栈的位置等等  (<code>_Trap_Frame</code>)，然后切换成内核的堆栈，如果正常返回，恢复堆栈环境即可。</li>
<li>但如果有用户APC要执行的话，就意味着线程要提前返回到用户空间去执行，而且返回的位置不是线程进入内核时的位置，而是返回到其他的位置，每处理一个用户APC都会涉及到：内核 –&gt; 用户空间 –&gt; 再回到内核空间。</li>
</ol>
<p><code>KiDeliverApc</code>函数分析：<br>1）判断用户APC链表是否为空<br>2）判断第一个参数是为1<br>3）判断ApcState.UserApcPending是否为1<br>4）将ApcState.UserApcPending设置为0<br>5）链表操作 将当前APC从用户队列中拆除<br>6）调用函数(KAPC.KernelRoutine)释放KAPC结构体内存空间<br>7）调用<code>KiInitializeUserApc</code>函数</p>
<ol>
<li><p><code>KiInitializeUserApc</code>函数分析：备份<code>CONTEXT</code>。</p>
<p>线程进0环时，原来3环的运行环境（寄存器栈顶等）保存到0环的一块内存<code>_Trap_Frame</code>结构体中，如果要提前返回3环去处理用户APC，就必须要修改<code>_Trap_Frame</code>结构体，但是又要保证不影响正常调用时线程返回到原来3环的地方，所以需要对<code>_Trap_Frame</code>的值进行备份：</p>
<ul>
<li>比如：进0环时的位置存储在EIP中，现在要提前返回，而且返回的并不是原来的位置，那就意味着必须要修改EIP为新的返回位置。还有堆栈ESP也要修改为处理APC需要的堆栈。那原来的值怎么办呢？处理完APC后该如何返回原来的位置呢？</li>
<li>函数<code>KiInitializeUserApc</code>要做的第一件事就是备份：<mark class="label danger">将原来_Trap_Frame的值备份到一个新的结构体中（CONTEXT）</mark>，这个功能由其子函数<code>KeContextFromKframes</code>来完成。</li>
</ul>
</li>
<li><p><code>KiInitializeUserApc</code>函数分析：线程0环与3环堆栈切换、准备用户层执行环境。</p>
<ul>
<li><p>堆栈示意图如下</p>
<p><img data-src="https://s2.loli.net/2022/06/27/Q5nAgaFuTG3WIEZ.png" alt="3.png"></p>
</li>
<li><p>准备用户层执行环境</p>
<p><img data-src="https://s2.loli.net/2022/06/27/Pv79dtf5kxi3sCT.png" alt="4.png"></p>
</li>
</ul>
</li>
<li><p><code>ntdll.KiUserApcDispatcher</code>函数分析：</p>
<p>1、当用户在3环调用<code>QueueUserAPC</code>函数来插入APC时，不需要提供<code>NormalRoutine</code>，这个参数是在<code>QueueUserAPC</code>内部指定的：<br><code>BaseDispatchAPC</code>。<br>2、<code>ZwContinue</code>函数的意义：</p>
<ul>
<li>返回内核，如果还有用户APC，重复上面的执行过程。</li>
<li>如果没有需要执行的用户APC，会将CONTEXT赋值给Trap_Frame结构体。就像从来没有修改过一样。ZwContinue后面的代码不会执行，线程从哪里进0环仍然会从哪里回去。</li>
</ul>
</li>
</ol>
<h2 id="2-KiDeliverApc"><a href="#2-KiDeliverApc" class="headerlink" title="2 KiDeliverApc"></a>2 KiDeliverApc</h2><p><code>KiDeliverApc</code>：This function is called from the APC interrupt code and when one or more of the APC pending flags are set at system exit and the previous IRQL is zero. All <strong>special kernel APC’s are delivered first, followed by normal kernel APC’s if one is not already in progress, and finally if the user APC queue is not empty, the user APC pending flag is set, and the previous mode is user, then a user APC is delivered</strong>. On entry to this routine IRQL is set to APC_LEVEL. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID __stdcall <span class="title">KiDeliverApc</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN KPROCESSOR_MODE PreviousMode,	<span class="comment">//调用函数的先前模式</span></span></span></span><br><span class="line"><span class="function"><span class="params">    IN PKEXCEPTION_FRAME ExceptionFrame,<span class="comment">//指向异常帧，在 NT386 模式下该指针为 NULL</span></span></span></span><br><span class="line"><span class="function"><span class="params">    IN PKTRAP_FRAME TrapFrame		<span class="comment">//_Trap_Frame</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span></span><br></pre></td></tr></table></figure>

<p>函数逆向分析如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID __stdcall <span class="title">KiDeliverApc</span><span class="params">(PreviousMode, ExceptionFrame, TrapFrame)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(TrapFrame != <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(TrapFrame-&gt;eip &gt;= (ULONG)&amp;ExpInterlockedPopEntrySListResume &amp;&amp; </span><br><span class="line">     TrapFrame-&gt;eip &lt;= (ULONG)&amp;ExpInterlockedPopEntrySListEnd)</span><br><span class="line">  &#123;</span><br><span class="line">    TrapFrame-&gt;eip = (ULONG)&amp;ExpInterlockedPopEntrySListResume;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Old_TrapFrame = CurrentThread-&gt;TrapFrame;</span><br><span class="line">Old_Process = CurrentThread-&gt;ApcState-&gt;Process;</span><br><span class="line"></span><br><span class="line">CurrentThread-&gt;TrapFrame = TrapFrame;</span><br><span class="line">CurrentThread-&gt;ApcState-&gt;KernelApcPending = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内核APC不为空</span></span><br><span class="line"><span class="keyword">while</span>(&amp;CurrentThread-&gt;ApcState-&gt;ApcListHead[<span class="number">0</span>] != CurrentThread-&gt;ApcState-&gt;ApcListHead[<span class="number">0</span>]-&gt;Flink)</span><br><span class="line">&#123;</span><br><span class="line">  NextEntry = CurrentThread-&gt;ApcState-&gt;ApcListHead[<span class="number">0</span>]-&gt;Flink;</span><br><span class="line">  Apc = (KAPC)(KAPC-&gt;ApcListEntry - <span class="number">0xC</span>);</span><br><span class="line">  KernelRoutine = Apc-&gt;KernelRoutine;</span><br><span class="line">  NormalRoutine = Apc-&gt;NormalRoutine;</span><br><span class="line">  NormalContext = Apc-&gt;NormalContext;</span><br><span class="line">  SystemArgument1 = Apc-&gt;SystemArgument1;</span><br><span class="line">  SystemArgument2 = Apc-&gt;SystemArgument2;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//普通内核APC函数</span></span><br><span class="line">  <span class="keyword">if</span>(Apc-&gt;NormalRoutine != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(CurrentThread.ApcState.KernelApcInProgress == <span class="number">0</span> &amp;&amp; CurrentThread.KernelApcDisable == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//将当前APC对象从内核APC队列里摘除</span></span><br><span class="line">      <span class="comment">//将CurrentThread-&gt;ApcState-&gt;ApcListHead[0]-&gt;Flink摘除</span></span><br><span class="line">      ecx = NextEntry-&gt;Flink;</span><br><span class="line">      eax = NextEntry-&gt;Blink;</span><br><span class="line">      NextEntry-&gt;Blink-&gt;Flink = NextEntry-&gt;Flink;</span><br><span class="line">      NextEntry-&gt;Flink-&gt;Blink = NextEntry-&gt;Blink;</span><br><span class="line">      </span><br><span class="line">      Apc.Inserted = <span class="number">0</span>;</span><br><span class="line">      (KernelRoutine)(Apc,</span><br><span class="line">                      &amp;NormalRoutine,</span><br><span class="line">                      &amp;NormalContext,</span><br><span class="line">                      &amp;SystemArgument1,</span><br><span class="line">                      &amp;SystemArgument2);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(Apc-&gt;NormalRoutine != <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        CurrentThread-&gt;ApcState-&gt;KernelApcInProgress = <span class="number">1</span>;</span><br><span class="line">        KfLowerIrql(<span class="number">0</span>);</span><br><span class="line">        NormalRoutine(NormalContext, SystemArgument1, SystemArgument2);</span><br><span class="line">        KfRaiseIrql(<span class="number">1</span>);	<span class="comment">//APC_LEVEL</span></span><br><span class="line">      &#125;	<span class="comment">//00428896</span></span><br><span class="line">      CurrentThread-&gt;ApcState-&gt;KernelApcInProgress = <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>  <span class="comment">//00428967,CurrentThread.ApcState.KernelApcInProgress != 0 || CurrentThread.KernelApcDisable != 0</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">goto</span> BugCheckAndReturn;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//特殊APC,KAPC-&gt;NormalRoutine == 0,00428818</span></span><br><span class="line">  &#125;<span class="keyword">else</span>	</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//将当前APC对象从内核APC队列里摘除</span></span><br><span class="line">    <span class="comment">//将CurrentThread-&gt;ApcState-&gt;ApcListHead[0]-&gt;Flink摘除</span></span><br><span class="line">    ecx = NextEntry-&gt;Flink;</span><br><span class="line">    eax = NextEntry-&gt;Blink;</span><br><span class="line">    NextEntry-&gt;Blink-&gt;Flink = NextEntry-&gt;Flink;</span><br><span class="line">    NextEntry-&gt;Flink-&gt;Blink = NextEntry-&gt;Blink;</span><br><span class="line">    </span><br><span class="line">    Apc.Inserted = <span class="number">0</span>;</span><br><span class="line">    (KernelRoutine)(Apc,</span><br><span class="line">                      &amp;NormalRoutine,</span><br><span class="line">                      &amp;NormalContext,</span><br><span class="line">                      &amp;SystemArgument1,</span><br><span class="line">                      &amp;SystemArgument2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用户APC，004288D4,004288E1</span></span><br><span class="line">NextEntry = CurrentThread-&gt;ApcState-&gt;ApcListHead[<span class="number">1</span>]-&gt;Flink;</span><br><span class="line"><span class="keyword">if</span>(&amp;CurrentThread-&gt;ApcState-&gt;ApcListHead[<span class="number">1</span>] != NextEntry &amp;&amp; PreviousMode == <span class="number">1</span> &amp;&amp;</span><br><span class="line">   CurrentThread-&gt;ApcState-&gt;UserApcPending == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//提前声明用户APC队列没有正在等待执行的用户APC</span></span><br><span class="line">  Thread-&gt;ApcState.UserApcPending = FALSE;</span><br><span class="line">  </span><br><span class="line">  Apc = (KAPC)(KAPC-&gt;ApcListEntry - <span class="number">0xC</span>);</span><br><span class="line">  KernelRoutine = Apc-&gt;KernelRoutine;</span><br><span class="line">  NormalRoutine = Apc-&gt;NormalRoutine;</span><br><span class="line">  NormalContext = Apc-&gt;NormalContext;</span><br><span class="line">  SystemArgument1 = Apc-&gt;SystemArgument1;</span><br><span class="line">  SystemArgument2 = Apc-&gt;SystemArgument2;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//将当前APC对象从用户APC队列里摘除</span></span><br><span class="line">  ecx = NextEntry-&gt;Flink;</span><br><span class="line">  eax = NextEntry-&gt;Blink;</span><br><span class="line">  NextEntry-&gt;Blink-&gt;Flink = NextEntry-&gt;Flink;</span><br><span class="line">  NextEntry-&gt;Flink-&gt;Blink = NextEntry-&gt;Blink;</span><br><span class="line">  </span><br><span class="line">  Apc-&gt;Inserted = <span class="number">0</span>;</span><br><span class="line">  (KernelRoutine)(Apc,</span><br><span class="line">                      &amp;NormalRoutine,</span><br><span class="line">                      &amp;NormalContext,</span><br><span class="line">                      &amp;SystemArgument1,</span><br><span class="line">                      &amp;SystemArgument2);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(Apc-&gt;NormalRoutine != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 准备回3环调用 NormalContext</span></span><br><span class="line">    KiInitializeUserApc(ExceptionFrame,</span><br><span class="line">                        TrapFrame,</span><br><span class="line">                        NormalRoutine,		<span class="comment">// 用户APC总入口 BaseDispatchAPC（3环函数）</span></span><br><span class="line">                        NormalContext,		<span class="comment">// 3环APC函数</span></span><br><span class="line">                        SystemArgument1,	<span class="comment">// 3环APC函数的参数</span></span><br><span class="line">                        SystemArgument2);	<span class="comment">// 作用不明，BaseDispatchAPC 里用到了</span></span><br><span class="line">  &#125;<span class="keyword">else</span>	<span class="comment">//0042893F</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//检查该线程是否可以交付另一个用户模式的APC</span></span><br><span class="line">    KeTestAlertThread(UserMode);	<span class="comment">//UserMode == 1</span></span><br><span class="line">    <span class="keyword">goto</span> BugCheckAndReturn;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BugCheckAndReturn:</span><br><span class="line">	<span class="comment">//Check if process was attached during the APC routine</span></span><br><span class="line">	<span class="keyword">if</span>(CurrentThread-&gt;ApcState-&gt;Process != Old_Process) KeBugCheckEx();</span><br><span class="line">	CurrentThread-&gt;TrapFrame = Old_TrapFrame;</span><br><span class="line">	<span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<div class="note warning"><p>函数<code>KiDeliverApc</code>主要功能如下：</p>
<ol>
<li>先将当前线程的<code>TrapFrame</code>和所属进程进行<strong>备份</strong>，然后使用参数中的<code>TrapFrame</code>给当前线程的<code>TrapFrame</code>赋值；</li>
<li><strong>循环检查内核APC队列</strong>，不为空的话，再判断内核APC函数是普通APC还是特殊APC：<ul>
<li><strong>普通APC</strong>：<ul>
<li>如果<code>KernelApcInProgress ==0 &amp;&amp; CurrentThread.KernelApcDisable == 0</code>，将当前APC对象从内核APC队列里摘除。如果前面的条件不满足就去<code>BugCheckAndReturn</code>检查是否需要调用函数<code>KeBugCheckEx</code>去蓝屏；</li>
<li>执行函数<code>Apc-&gt;KernelRoutine</code>；</li>
<li>如果<code>Apc-&gt;NormalRoutine != 0</code>的话（<code>KernelRoutine</code>的执行有可能改变这个指针的值）就先将<code>KernelApcInProgress = TRUE</code>，并将IRQL降为<code>PASSIVE_LEVEL(0)</code>；</li>
<li>执行函数<code>Apc-&gt;NormalRoutine</code>；</li>
<li>将IRQL升为<code>APC_LEVEL(1)</code>。</li>
<li>设置<code>KernelApcInProgress = FALSE</code>。</li>
</ul>
</li>
<li><strong>特殊APC</strong>：<ul>
<li>将当前APC对象从内核APC队列里摘除；</li>
<li>执行函数<code>Apc-&gt;KernelRoutine</code>；</li>
</ul>
</li>
</ul>
</li>
<li>如果<strong>用户APC队列</strong>不为空，并且<code>UserApcPending == 1</code>，就会试图执行用户APC。<ul>
<li><code>UserApcPending = FALSE</code>，提前声明用户APC队列没有正在等待执行的用户APC，因为一次只会执行一次（没有循环）；</li>
<li>将当前APC对象从用户APC队列里摘除；</li>
<li>执行函数<code>Apc-&gt;KernelRoutine</code>；</li>
<li>判断<code>Apc-&gt;NormalRoutine</code>是否为<code>0</code>（<code>KernelRoutine</code>的执行有可能改变这个指针的值）：<ul>
<li><code>Apc-&gt;NormalRoutine != 0</code>，调用<code>KiInitializeUserApc</code>函数准备回3环调用<code>Apc-&gt;NormalContext</code>；</li>
<li><code>Apc-&gt;NormalRoutine == 0</code>，调用<code>KeTestAlertThread</code>函数（<a target="_blank" rel="noopener" href="https://blog.csdn.net/xiangbaohui/article/details/104897855">没有用户层的回调函数，那么自己alert，执行后面的APC</a>）检查该线程是否可以交付另一个用户模式的APC。</li>
</ul>
</li>
</ul>
</li>
<li><strong>恢复TrapFrame</strong>。用之前备份的<code>TrapFrame</code>给当前线程的<code>TrapFrame</code>赋值。</li>
</ol>
</div>

<div class="note success"><p>需要注意一下几点：</p>
<ul>
<li>执行内核<code>NormalRoutine</code>时才会<code>KernelApcInProgress = 1</code>，执行<code>KernelRoutine</code>时<code>KernelApcInProgress</code>不会置1。</li>
<li>执行内核<code>NormalRoutine</code>IRQL是<code>0</code>。</li>
<li>用函数<code>KiInitializeUserApc</code>去准备回3环调用<code>Apc-&gt;NormalContext</code>时并不会将IRQL降为<code>0</code>。</li>
<li>每次进入函数<code>KiDeliverApc</code>，会将当前线程的所有内核APC函数全部循环执行了，但是只会执行挂在用户APC队列的第一个用户APC函数，处理用户APC函数并没有循环。《Windows内核情景分析5.8 P373》</li>
</ul>
</div>

<p>APC整个执行过程在《Windows内核情景分析5.8》都有函数分析。</p>
<p>源代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">KiDeliverApc</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN KPROCESSOR_MODE PreviousMode,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PKEXCEPTION_FRAME ExceptionFrame,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PKTRAP_FRAME TrapFrame</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span></span><br><span class="line"><span class="function"><span class="comment">/*++</span></span></span><br><span class="line"><span class="function"><span class="comment">Routine Description:</span></span></span><br><span class="line"><span class="function"><span class="comment">    This function is called from the APC interrupt code and when one or</span></span></span><br><span class="line"><span class="function"><span class="comment">    more of the APC pending flags are set at system exit and the previous</span></span></span><br><span class="line"><span class="function"><span class="comment">    IRQL is zero. All special kernel APC&#x27;s are delivered first, followed</span></span></span><br><span class="line"><span class="function"><span class="comment">    by normal kernel APC&#x27;s if one is not already in progress, and finally</span></span></span><br><span class="line"><span class="function"><span class="comment">    if the user APC queue is not empty, the user APC pending flag is set,</span></span></span><br><span class="line"><span class="function"><span class="comment">    and the previous mode is user, then a user APC is delivered. On entry</span></span></span><br><span class="line"><span class="function"><span class="comment">    to this routine IRQL is set to APC_LEVEL.</span></span></span><br><span class="line"><span class="function"><span class="comment">    </span></span></span><br><span class="line"><span class="function"><span class="comment">    N.B. The exception frame and trap frame addresses are only guaranteed</span></span></span><br><span class="line"><span class="function"><span class="comment">         to be valid if, and only if, the previous mode is user.</span></span></span><br><span class="line"><span class="function"><span class="comment">Arguments:</span></span></span><br><span class="line"><span class="function"><span class="comment">    PreviousMode - Supplies the previous processor mode.</span></span></span><br><span class="line"><span class="function"><span class="comment">    </span></span></span><br><span class="line"><span class="function"><span class="comment">    指向异常帧，在 NT386 模式下该指针为 NULL</span></span></span><br><span class="line"><span class="function"><span class="comment">    ExceptionFrame - Supplies a pointer to an exception frame.</span></span></span><br><span class="line"><span class="function"><span class="comment">    TrapFrame - Supplies a pointer to a trap frame.</span></span></span><br><span class="line"><span class="function"><span class="comment">Return Value: None.</span></span></span><br><span class="line"><span class="function"><span class="comment">--*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    PKAPC Apc;</span><br><span class="line">    PKKERNEL_ROUTINE KernelRoutine;</span><br><span class="line">    KLOCK_QUEUE_HANDLE LockHandle;</span><br><span class="line">    PLIST_ENTRY NextEntry;</span><br><span class="line">    ULONG64 NewPC;</span><br><span class="line">    PVOID NormalContext;</span><br><span class="line">    PKNORMAL_ROUTINE NormalRoutine;</span><br><span class="line">    ULONG64 PC; </span><br><span class="line">    PKPROCESS Process;</span><br><span class="line">    PVOID SystemArgument1;</span><br><span class="line">    PVOID SystemArgument2;</span><br><span class="line">    PKTHREAD Thread;</span><br><span class="line">    PKTRAP_FRAME OldTrapFrame;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If the thread was interrupted in the middle of the SLIST pop code,</span></span><br><span class="line">    <span class="comment">// then back up the PC to the start of the SLIST pop. </span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TrapFrame != <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_AMD64_)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((TrapFrame-&gt;Rip &gt;= (ULONG64)&amp;ExpInterlockedPopEntrySListResume) &amp;&amp;</span><br><span class="line">            (TrapFrame-&gt;Rip &lt;= (ULONG64)&amp;ExpInterlockedPopEntrySListEnd)) &#123;</span><br><span class="line"></span><br><span class="line">            TrapFrame-&gt;Rip = (ULONG64)&amp;ExpInterlockedPopEntrySListResume;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_IA64_)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Add the slot number so we do the right thing for the instruction</span></span><br><span class="line">        <span class="comment">// group containing the interlocked compare exchange.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        PC = TrapFrame-&gt;StIIP + ((TrapFrame-&gt;StIPSR &amp; IPSR_RI_MASK) &gt;&gt; PSR_RI);</span><br><span class="line">        NewPC = (ULONG64)((PPLABEL_DESCRIPTOR)ExpInterlockedPopEntrySListResume)-&gt;EntryPoint;</span><br><span class="line">        <span class="keyword">if</span> ((PC &gt;= NewPC) &amp;&amp;</span><br><span class="line">            (PC &lt;= (ULONG64)((PPLABEL_DESCRIPTOR)ExpInterlockedPopEntrySListEnd)-&gt;EntryPoint)) &#123;</span><br><span class="line"></span><br><span class="line">            TrapFrame-&gt;StIIP = NewPC;</span><br><span class="line">            TrapFrame-&gt;StIPSR &amp;= ~IPSR_RI_MASK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_X86_)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((TrapFrame-&gt;Eip &gt;= (ULONG)&amp;ExpInterlockedPopEntrySListResume) &amp;&amp;</span><br><span class="line">            (TrapFrame-&gt;Eip &lt;= (ULONG)&amp;ExpInterlockedPopEntrySListEnd)) &#123;</span><br><span class="line"></span><br><span class="line">            TrapFrame-&gt;Eip = (ULONG)&amp;ExpInterlockedPopEntrySListResume;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">&quot;No Target Architecture&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Raise IRQL to dispatcher level and lock the APC queue.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread = KeGetCurrentThread();</span><br><span class="line"></span><br><span class="line">    OldTrapFrame = Thread-&gt;TrapFrame;</span><br><span class="line"></span><br><span class="line">    Thread-&gt;TrapFrame = TrapFrame;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取当前进程（提供CR3的进程）</span></span><br><span class="line">    Process = Thread-&gt;ApcState.Process;</span><br><span class="line"></span><br><span class="line">    KeAcquireInStackQueuedSpinLock(&amp;Thread-&gt;ApcQueueLock, &amp;LockHandle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Get address of current thread object, clear kernel APC pending, and</span></span><br><span class="line">    <span class="comment">// check if any kernel mode APC&#x27;s can be delivered.</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 接下来要执行内核APC，这里提前声明处理完毕</span></span><br><span class="line">    Thread-&gt;ApcState.KernelApcPending = FALSE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历内核APC队列</span></span><br><span class="line">    <span class="keyword">while</span> (IsListEmpty(&amp;Thread-&gt;ApcState.ApcListHead[KernelMode]) == FALSE) &#123;</span><br><span class="line">		<span class="comment">// 获取 APC，获取 APC 的成员</span></span><br><span class="line">        NextEntry = Thread-&gt;ApcState.ApcListHead[KernelMode].Flink;</span><br><span class="line">        Apc = CONTAINING_RECORD(NextEntry, KAPC, ApcListEntry);</span><br><span class="line">        KernelRoutine = Apc-&gt;KernelRoutine;</span><br><span class="line">        NormalRoutine = Apc-&gt;NormalRoutine;</span><br><span class="line">        NormalContext = Apc-&gt;NormalContext;</span><br><span class="line">        SystemArgument1 = Apc-&gt;SystemArgument1;</span><br><span class="line">        SystemArgument2 = Apc-&gt;SystemArgument2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (NormalRoutine == (PKNORMAL_ROUTINE)<span class="literal">NULL</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// NormalRoutine 等于 NULL 的情况属于特殊内核APC，我不知道什么时候会插入这样的APC</span></span><br><span class="line">			<span class="comment">// 所以这里就不分析了，假如您读到这里，又知道相关的信息，不妨留言提示我一下^_^</span></span><br><span class="line">			<span class="comment">// 2020年11月29日21:04:21</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// First entry in the kernel APC queue is a special kernel APC.</span></span><br><span class="line">            <span class="comment">// Remove the entry from the APC queue, set its inserted state</span></span><br><span class="line">            <span class="comment">// to FALSE, release dispatcher database lock, and call the kernel</span></span><br><span class="line">            <span class="comment">// routine. On return raise IRQL to dispatcher level and lock</span></span><br><span class="line">            <span class="comment">// dispatcher database lock.</span></span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            RemoveEntryList(NextEntry);</span><br><span class="line"></span><br><span class="line">            Apc-&gt;Inserted = FALSE;</span><br><span class="line"></span><br><span class="line">            KeReleaseInStackQueuedSpinLock(&amp;LockHandle);</span><br><span class="line"></span><br><span class="line">            (KernelRoutine)(Apc,</span><br><span class="line">                            &amp;NormalRoutine,</span><br><span class="line">                            &amp;NormalContext,</span><br><span class="line">                            &amp;SystemArgument1,</span><br><span class="line">                            &amp;SystemArgument2);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DBG</span></span><br><span class="line">			<span class="comment">// 蓝屏警告</span></span><br><span class="line">            <span class="keyword">if</span> (KeGetCurrentIrql() != LockHandle.OldIrql) &#123;</span><br><span class="line">                KeBugCheckEx(IRQL_UNEXPECTED_VALUE,</span><br><span class="line">                             KeGetCurrentIrql() &lt;&lt; <span class="number">16</span> | LockHandle.OldIrql &lt;&lt; <span class="number">8</span>,</span><br><span class="line">                             (ULONG_PTR)KernelRoutine,</span><br><span class="line">                             (ULONG_PTR)Apc,</span><br><span class="line">                             (ULONG_PTR)NormalRoutine);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            KeAcquireInStackQueuedSpinLock(&amp;Thread-&gt;ApcQueueLock, &amp;LockHandle);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">      <span class="comment">// 走这个分支说明 NormalRoutine 非空，是普通的内核APC，PspTerminateThreadByPointer 和 NtQueueApcThread 都走这里</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// First entry in the kernel APC queue is a normal kernel APC.</span></span><br><span class="line">            <span class="comment">// If there is not a normal kernel APC in progress and kernel</span></span><br><span class="line">            <span class="comment">// APC&#x27;s are not disabled, then remove the entry from the APC</span></span><br><span class="line">            <span class="comment">// queue, set its inserted state to FALSE, release the APC queue</span></span><br><span class="line">            <span class="comment">// lock, call the specified kernel routine, set kernel APC in</span></span><br><span class="line">            <span class="comment">// progress, lower the IRQL to zero, and call the normal kernel</span></span><br><span class="line">            <span class="comment">// APC routine. On return raise IRQL to dispatcher level, lock</span></span><br><span class="line">            <span class="comment">// the APC queue, and clear kernel APC in progress.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((Thread-&gt;ApcState.KernelApcInProgress == FALSE) &amp;&amp;	<span class="comment">// 没有内核APC正在执行 并且</span></span><br><span class="line">               (Thread-&gt;KernelApcDisable == <span class="number">0</span>))		<span class="comment">// 没有禁用内核APC</span></span><br><span class="line">			&#123;</span><br><span class="line">              <span class="comment">// 从内核 APC 队列中移除这个 APC</span></span><br><span class="line">                RemoveEntryList(NextEntry);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// APC Inserted 标志清零</span></span><br><span class="line">                Apc-&gt;Inserted = FALSE;</span><br><span class="line"></span><br><span class="line">                KeReleaseInStackQueuedSpinLock(&amp;LockHandle);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 调用 KernelRoutine，举两个例子说明</span></span><br><span class="line">              <span class="comment">// 如果 APC 通过PspTerminateThreadByPointer 构造， KernelRoutine 是 PsExitSpecialApc ，</span></span><br><span class="line">              <span class="comment">// 那么执行的操作就是释放APC内存，并终止当前线程</span></span><br><span class="line">              <span class="comment">// 如果 APC 通过 NtQueueApcThread 构造，KernelRoutine 是 PspQueueApcSpecialApc，</span></span><br><span class="line">              <span class="comment">//执行的操作仅仅是释放APC内存</span></span><br><span class="line">              <span class="comment">// 不过 NtQueueApcThread 插入的属于用户APC，不走这里，而是等内核APC执行完后再执行</span></span><br><span class="line">              <span class="comment">// KernelRoutine 的工作是释放APC内存，也可能包括一些额外的工作，如退出、挂起、恢复线程</span></span><br><span class="line">              <span class="comment">// KernelRoutine 是调用 KeInitializeApc 时决定的，是不确定的，各种函数对参数的使用情况都不一样</span></span><br><span class="line">              <span class="comment">// 例如 PspTerminateThreadByPointer 初始化 KernelRoutine 传的函数是 PsExitSpecialApc，</span></span><br><span class="line">              <span class="comment">//就只使用了第一个参数 Apc</span></span><br><span class="line">                (KernelRoutine)(Apc,</span><br><span class="line">                                &amp;NormalRoutine,</span><br><span class="line">                                &amp;NormalContext,</span><br><span class="line">                                &amp;SystemArgument1,</span><br><span class="line">                                &amp;SystemArgument2);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DBG</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (KeGetCurrentIrql() != LockHandle.OldIrql) &#123;</span><br><span class="line">                    KeBugCheckEx(IRQL_UNEXPECTED_VALUE,</span><br><span class="line">                                 KeGetCurrentIrql() &lt;&lt; <span class="number">16</span> | LockHandle.OldIrql &lt;&lt; <span class="number">8</span> | <span class="number">1</span>,</span><br><span class="line">                                 (ULONG_PTR)KernelRoutine,</span><br><span class="line">                                 (ULONG_PTR)Apc,</span><br><span class="line">                                 (ULONG_PTR)NormalRoutine);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">              <span class="comment">// NormalRoutine 是内核APC函数，经分析，我觉得能执行到这里，NormalRoutine 应该不是 NULL 的</span></span><br><span class="line">              <span class="comment">// 唯一可能修改 NormalRoutine 的就是上面调用的 KernelRoutine 函数</span></span><br><span class="line">                <span class="keyword">if</span> (NormalRoutine != (PKNORMAL_ROUTINE)<span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 内核APC正在执行</span></span><br><span class="line">                    Thread-&gt;ApcState.KernelApcInProgress = TRUE;</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 降低IRQL到0</span></span><br><span class="line">                    KeLowerIrql(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 调用内核APC函数</span></span><br><span class="line">                    (NormalRoutine)(NormalContext,</span><br><span class="line">                                    SystemArgument1,</span><br><span class="line">                                    SystemArgument2);</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 恢复IRQL到APC_LEVEL（1）</span></span><br><span class="line">                    KeRaiseIrql(APC_LEVEL, &amp;LockHandle.OldIrql);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                KeAcquireInStackQueuedSpinLock(&amp;Thread-&gt;ApcQueueLock, &amp;LockHandle);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 没有内核APC正在执行</span></span><br><span class="line">                Thread-&gt;ApcState.KernelApcInProgress = FALSE;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                KeReleaseInStackQueuedSpinLock(&amp;LockHandle);</span><br><span class="line">                <span class="keyword">goto</span> CheckProcess;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Kernel APC queue is empty. If the previous mode is user, user APC</span></span><br><span class="line">    <span class="comment">// pending is set, and the user APC queue is not empty, then remove</span></span><br><span class="line">    <span class="comment">// the first entry from the user APC queue, set its inserted state to</span></span><br><span class="line">    <span class="comment">// FALSE, clear user APC pending, release the dispatcher database lock,</span></span><br><span class="line">    <span class="comment">// and call the specified kernel routine. If the normal routine address</span></span><br><span class="line">    <span class="comment">// is not NULL on return from the kernel routine, then initialize the</span></span><br><span class="line">    <span class="comment">// user mode APC context and return. Otherwise, check to determine if</span></span><br><span class="line">    <span class="comment">// another user mode APC can be processed.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">	<span class="comment">// 内核APC执行完毕</span></span><br><span class="line">	<span class="comment">// 如果 PreviousMode 是用户模式（1），并且有用户APC，并且用户APC队列非空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((IsListEmpty(&amp;Thread-&gt;ApcState.ApcListHead[UserMode]) == FALSE) &amp;&amp;</span><br><span class="line">       (PreviousMode == UserMode) &amp;&amp; </span><br><span class="line">	   (Thread-&gt;ApcState.UserApcPending != FALSE)) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 提前声明用户APC队列已清空</span></span><br><span class="line">        Thread-&gt;ApcState.UserApcPending = FALSE;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取APC和其属性</span></span><br><span class="line">        NextEntry = Thread-&gt;ApcState.ApcListHead[UserMode].Flink;</span><br><span class="line">        Apc = CONTAINING_RECORD(NextEntry, KAPC, ApcListEntry);</span><br><span class="line">        KernelRoutine = Apc-&gt;KernelRoutine;</span><br><span class="line">        NormalRoutine = Apc-&gt;NormalRoutine;</span><br><span class="line">        NormalContext = Apc-&gt;NormalContext;</span><br><span class="line">        SystemArgument1 = Apc-&gt;SystemArgument1;</span><br><span class="line">        SystemArgument2 = Apc-&gt;SystemArgument2;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 从用户APC队列中取出</span></span><br><span class="line">        RemoveEntryList(NextEntry);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 标记插入状态为FALSE</span></span><br><span class="line">        Apc-&gt;Inserted = FALSE;</span><br><span class="line"></span><br><span class="line">        KeReleaseInStackQueuedSpinLock(&amp;LockHandle);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// KernelRoutine 应该就是 PspQueueApcSpecialApc </span></span><br><span class="line">		<span class="comment">// 因为用户APC是 NtQueueApcThread 函数构造和插入的，它就是这样初始化APC的</span></span><br><span class="line">		<span class="comment">// PspQueueApcSpecialApc 的唯一作用是释放APC内存</span></span><br><span class="line">        (KernelRoutine)(Apc,</span><br><span class="line">                        &amp;NormalRoutine,</span><br><span class="line">                        &amp;NormalContext,</span><br><span class="line">                        &amp;SystemArgument1,</span><br><span class="line">                        &amp;SystemArgument2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (NormalRoutine == (PKNORMAL_ROUTINE)<span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="comment">// 此函数定义在 thredobj.c			</span></span><br><span class="line">            KeTestAlertThread(UserMode);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 准备回3环调用 NormalContext</span></span><br><span class="line">            KiInitializeUserApc(ExceptionFrame,</span><br><span class="line">                                TrapFrame,</span><br><span class="line">                                NormalRoutine,		<span class="comment">// 用户APC总入口 BaseDispatchAPC（3环函数）</span></span><br><span class="line">                                NormalContext,		<span class="comment">// 3环APC函数</span></span><br><span class="line">                                SystemArgument1,	<span class="comment">// 3环APC函数的参数</span></span><br><span class="line">                                SystemArgument2);	<span class="comment">// 作用不明，BaseDispatchAPC 里用到了</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        KeReleaseInStackQueuedSpinLock(&amp;LockHandle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if process was attached during the APC routine.</span></span><br><span class="line">    <span class="comment">// 检查当前进程是否发生变化（执行 APC 函数时发生了 attach）</span></span><br><span class="line"></span><br><span class="line">CheckProcess:</span><br><span class="line">    <span class="keyword">if</span> (Thread-&gt;ApcState.Process != Process) &#123;</span><br><span class="line">		<span class="comment">// 蓝屏警告</span></span><br><span class="line">        KeBugCheckEx(INVALID_PROCESS_ATTACH_ATTEMPT,</span><br><span class="line">                     (ULONG_PTR)Process,</span><br><span class="line">                     (ULONG_PTR)Thread-&gt;ApcState.Process,</span><br><span class="line">                     (ULONG)Thread-&gt;ApcStateIndex,</span><br><span class="line">                     (ULONG)KeIsExecutingDpc());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread-&gt;TrapFrame = OldTrapFrame;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-KeTestAlertThread"><a href="#3-KeTestAlertThread" class="headerlink" title="3 KeTestAlertThread"></a>3 KeTestAlertThread</h2><p>通过对函数<code>KiDeliverApc</code>交付（Deliver）用户APC函数的过程，在交付用户过程中会先执行<code>KernelRoutine</code>函数（参数包含<code>NormalRoutine</code>），函数执行过程中有可能会修改<code>NormalRoutine</code>，所以需要对<code>NormalRoutine</code>进行检查是否为<code>0</code>。</p>
<p>为什么需要判断<code>NormalRoutine</code>是否为<code>NULL</code>，是因为多核情况下其他CPU在某个过程中已经执行了这个用户APC么？</p>
<p>我认为，并不是因为多核的原因。因为在交付用户APC函数之前，调用了函数<code>KeReleaseInStackQueuedSpinLock</code>上了自旋锁。同时参考《Windows情景分析P371》，<code>KernelRoutine</code>执行的时候有可能改变指针<code>NormalRoutine</code>的值，所以需要测试一下。</p>
<p>函数<code>KeTestAlertThread</code>：This function tests to determine if the alerted variable for the specified processor mode has a value of TRUE or whether a user mode APC should be delivered to the current thread.（processor mode：UserMode&#x2F;KernelMode处理器模式，variable-变量，specified-指定的）</p>
<p><strong>该函数检查当前线程是否可以交付第一个用户模式的APC</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOLEAN __stdcall <span class="title">KeTestAlertThread</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN KPROCESSOR_MODE AlertMode</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  BOOLEAN Alerted;</span><br><span class="line">  KLOCK_QUEUE_HANDLE LockHandle;</span><br><span class="line">  PKTHREAD Thread;</span><br><span class="line">  </span><br><span class="line">  ASSERT(KeGetCurrentIrql() &lt;= DISPATCH_LEVEL);</span><br><span class="line">  Thread = KeGetCurrentThread();</span><br><span class="line">  KeAcquireInStackQueuedSpinLockRaiseToSynch(&amp;Thread-&gt;ApcQueueLock, &amp;LockHandle);</span><br><span class="line">  KiLockDispatcherDatabaseAtSynchLevel</span><br><span class="line">  </span><br><span class="line">  Alerted = Thread-&gt;Alerted[AlertMode];</span><br><span class="line">  <span class="keyword">if</span> (Alerted == TRUE) &#123;	</span><br><span class="line">    Thread-&gt;Alerted[AlertMode] = FALSE;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((AlertMode == UserMode) &amp;&amp;</span><br><span class="line">             (IsListEmpty(&amp;Thread-&gt;ApcState.ApcListHead[UserMode]) != TRUE)) &#123;</span><br><span class="line">    Thread-&gt;ApcState.UserApcPending = TRUE;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  KiUnlockDispatcherDatabaseFromSynchLevel();</span><br><span class="line">  KeReleaseInStackQueuedSpinLock(&amp;LockHandle);</span><br><span class="line">  <span class="keyword">return</span> Alerted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Alerted：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/LittleHann/p/3456697.html">用来说明线程在指定模式下是否为”已经被吵醒” 。</a>具体在哪进行修改，目前就知道在函数<code>KeAlertThread</code>中，当吵醒条件不满足时候就会<code>Thread-&gt;Alerted[AlertMode] = TRUE;</code>来说明已经调用过该函数一次了，只是吵醒条件不满足，如果可以吵醒是不会设置的为<code>TRUE</code>的。所以这里的<code>Thread-&gt;Alerted[AlertMode] = FALSE;</code>我理解就是一个额外的修正操作。</p>
<p>在APC注入过程中，经常使用该函数，因为函数<code>KiInsertQueueApc</code>在KAPC插入过后判断条件满足：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Thread.State == Waiting &amp;&amp; Thread.WaitMode == <span class="number">1</span> &amp;&amp; (Thread.Alertable == <span class="number">1</span> || Thread.ApcState.UserApcPending == <span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p>就会设置<code>Thread.ApcState.UserApcPending = 1</code>然后调用<code>KiUnwaitThread</code>让线程开始转为就绪，线程切换后就有机会执行APC函数。上面可以看到<code>Alertable == 1</code>与<code>UserApcPending == 1</code>满足其一即可，所以一般调用函数<code>KeTestAlertThread</code>就可进行注入，可以参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/361808484">驱动病毒那些事(三)—-APC注入</a></li>
<li><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/252487">深入理解APC机制（二）</a></li>
<li><a target="_blank" rel="noopener" href="https://yhsnlkm.github.io/2021/01/04/%E6%94%BB%E9%98%B2%E4%BF%9D%E6%8A%A4/%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%AD%E4%BD%BF%E7%94%A8APC%E6%B3%A8%E5%85%A5DLL%E5%88%B0R3%E8%BF%9B%E7%A8%8B-2/">在内核中使用APC注入DLL到R3进程(2)</a>。</li>
</ul>
<h2 id="4-KiInitializeUserApc"><a href="#4-KiInitializeUserApc" class="headerlink" title="4 KiInitializeUserApc"></a>4 KiInitializeUserApc</h2>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>Buy me a coffee</div>
  <button onclick="document.querySelector('.post-reward').classList.toggle('active');">
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechat.jpg" alt="Catecat 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpg" alt="Catecat 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Catecat
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://directoree.github.io/post/WinXP-APC2/" title="Windows XP APC（二）">https://directoree.github.io/post/WinXP-APC2/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/WinXP%E5%86%85%E6%A0%B8/" rel="tag"># WinXP内核</a>
              <a href="/tags/APC/" rel="tag"># APC</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/WinXP-APC/" rel="prev" title="Windows XP APC（一）">
                  <i class="fa fa-chevron-left"></i> Windows XP APC（一）
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/column-1/" rel="next" title="读书笔记">
                  读书笔记 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Catecat</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">1.2m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">18:15</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1.15.0/dist/lozad.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/local-search.js"></script>








<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  const url = element.dataset.target;
  const pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  const pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  const fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script>
if (document.querySelectorAll('.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8.7.0/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>








  

  
      <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//cdn.jsdelivr.net/npm/mathjax@3.1.0/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
NexT.utils.loadComments('#valine-comments', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    new Valine(Object.assign({"enable":true,"appId":"7zujCcS8pYH88CJXfdBlLyS8-gzGzoHsz","appKey":"lWGr7OPoNHo4v1YmVV5yr3E9","serverURLs":"https://7zujccs8.lc-cn-n1-shared.com","placeholder":"快来勾搭我呀🐶","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"lang":null,"visitor":true,"comment_count":true,"bg":"/images/comment_bg.png","recordIP":false,"enableQQ":false,"requiredFields":["nick"]}, {
      el: '#valine-comments',
      path: "/post/WinXP-APC2/",
      serverURLs: "https://7zujccs8.lc-cn-n1-shared.com"
    }));
  }, window.Valine);
});
</script>

</body>
</html>
