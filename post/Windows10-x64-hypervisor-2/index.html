<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/favicon.png" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"directoree.github.io","root":"/","scheme":"Mist","version":"8.0.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="😄">
<meta property="og:type" content="article">
<meta property="og:title" content="Hypervisor（二）：VMCS region">
<meta property="og:url" content="https://directoree.github.io/post/Windows10-x64-hypervisor-2/index.html">
<meta property="og:site_name" content="˗ˋˏ♡ˎˊ˗">
<meta property="og:description" content="😄">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/04/11/bxKdOwB1L4AehvD.png">
<meta property="og:image" content="https://s2.loli.net/2023/04/15/Fszai4l7tqYZxcd.png">
<meta property="og:image" content="https://s2.loli.net/2023/04/18/PyIZdJpoN6sC4az.png">
<meta property="og:image" content="https://s2.loli.net/2023/04/15/vwjoD12tnNhxWrl.png">
<meta property="og:image" content="https://s2.loli.net/2023/04/19/eqJUEZuogjh1YA7.png">
<meta property="og:image" content="https://s2.loli.net/2023/04/20/Ray8ugxbFf41AXs.png">
<meta property="og:image" content="https://s2.loli.net/2023/04/18/rBNHxfUCeAOWs5Y.png">
<meta property="og:image" content="https://s2.loli.net/2023/04/19/WjcbrBvd6TKMq1g.png">
<meta property="og:image" content="https://s2.loli.net/2024/01/19/MnAkaHli21ux8Vc.png">
<meta property="og:image" content="https://s2.loli.net/2024/01/20/plxd3sWmoAUZQcn.png">
<meta property="og:image" content="https://s2.loli.net/2023/04/19/zI4JZR7qMFYjVgi.png">
<meta property="og:image" content="https://s2.loli.net/2023/04/20/a9zgWUMvuyibQZ6.png">
<meta property="og:image" content="https://s2.loli.net/2023/04/20/5AiHsl3fhDNxFdM.png">
<meta property="og:image" content="https://s2.loli.net/2023/04/25/o3rfOXAtRk4QTYg.png">
<meta property="og:image" content="https://s2.loli.net/2023/05/09/aOG7n3AveCrzTLx.png">
<meta property="og:image" content="https://s2.loli.net/2023/04/20/wihJ6yTO4MGoScV.png">
<meta property="og:image" content="https://s2.loli.net/2023/04/20/k4qEh5ebQosKUpO.png">
<meta property="og:image" content="https://s2.loli.net/2023/04/21/pCcjZLun1gIseWP.png">
<meta property="og:image" content="https://s2.loli.net/2023/04/21/jAdhTQSmX2ZI5GN.png">
<meta property="og:image" content="https://s2.loli.net/2023/04/21/1bTCoXpl5Pa2ZSz.png">
<meta property="og:image" content="https://s2.loli.net/2023/04/21/b5pJln1uxq2AXIB.png">
<meta property="og:image" content="https://s2.loli.net/2023/04/22/JjLCnwY84SMp9XW.png">
<meta property="og:image" content="https://s2.loli.net/2024/01/21/H76mXoJYcPTKlIU.png">
<meta property="og:image" content="https://s2.loli.net/2024/01/19/iCcaDZA4nSzMVEQ.png">
<meta property="og:image" content="https://s2.loli.net/2024/01/21/r4ls2X9CB35vk6i.png">
<meta property="og:image" content="https://s2.loli.net/2024/01/21/qAu3OPCyv47DeEd.png">
<meta property="og:image" content="https://s2.loli.net/2023/04/22/er4vpafoyGRQMhP.png">
<meta property="article:published_time" content="2023-04-18T14:38:57.000Z">
<meta property="article:modified_time" content="2024-01-22T14:43:19.604Z">
<meta property="article:author" content="Catecat">
<meta property="article:tag" content="虚拟化">
<meta property="article:tag" content="VT-x">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/04/11/bxKdOwB1L4AehvD.png">


<link rel="canonical" href="https://directoree.github.io/post/Windows10-x64-hypervisor-2/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Hypervisor（二）：VMCS region | ˗ˋˏ♡ˎˊ˗</title>
  


  <script data-pjax>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b832a9ae9a43377003fd975ca4e525ea";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<style>.darkmode--activated{--body-bg-color:#222;--content-bg-color:#222;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#2d2f31;--highlight-foreground:#ccc;--highlight-gutter-background:#333;--highlight-gutter-foreground:#888}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#fff;background:#555}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">˗ˋˏ♡ˎˊ˗</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">爱你所爱，行你所行，听从你心，无问西东。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/newcategories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-更新日志">

    <a href="/changelog" rel="section"><i class="fa fa-heartbeat fa-fw"></i>更新日志</a>

  </li>
        <li class="menu-item menu-item-空调房">

    <a href="/tips" rel="section"><i class="fa fa-wifi fa-fw"></i>空调房</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-VMCS-region"><span class="nav-text">1 VMCS region</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-VMCS-%E6%A6%82%E8%BF%B0"><span class="nav-text">1.1 VMCS 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-VMCS-%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-text">1.2 VMCS 的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E7%94%B3%E8%AF%B7-VMCS-region"><span class="nav-text">1.3 申请 VMCS region</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-VMCS-%E7%BB%93%E6%9E%84"><span class="nav-text">1.4 VMCS 结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-VMCS-%E5%AD%97%E6%AE%B5-ID"><span class="nav-text">1.5 VMCS 字段 ID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-Control-%E5%AD%97%E6%AE%B5%E4%BF%9D%E7%95%99%E5%80%BC"><span class="nav-text">1.6 Control 字段保留值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Guest-state-area"><span class="nav-text">2 Guest-state area</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%AF%84%E5%AD%98%E5%99%A8%E7%B1%BB%E5%AD%97%E6%AE%B5"><span class="nav-text">2.1 寄存器类字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E9%9D%9E%E5%AF%84%E5%AD%98%E5%99%A8%E7%B1%BB%E5%AD%97%E6%AE%B5"><span class="nav-text">2.2 非寄存器类字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85"><span class="nav-text">2.3 字段填充</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Host-state-area"><span class="nav-text">3 Host-state area</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E5%AF%84%E5%AD%98%E5%99%A8%E7%B1%BB%E5%AD%97%E6%AE%B5"><span class="nav-text">3.1 寄存器类字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85"><span class="nav-text">3.2 字段填充</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-VM-execution-control-fields"><span class="nav-text">4 VM-execution control fields</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E5%AD%97%E6%AE%B5%E8%A7%A3%E9%87%8A"><span class="nav-text">4.1 字段解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85"><span class="nav-text">4.2 字段填充</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-VM-entry-control-fields"><span class="nav-text">5 VM-entry control fields</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E5%AD%97%E6%AE%B5%E8%A7%A3%E9%87%8A"><span class="nav-text">5.1 字段解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E5%90%91%E9%87%8F%E5%8C%96%E4%BA%8B%E4%BB%B6"><span class="nav-text">5.2 向量化事件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-VM-exit-control-fields"><span class="nav-text">6 VM-exit control fields</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E5%AD%97%E6%AE%B5%E8%A7%A3%E9%87%8A"><span class="nav-text">6.1 字段解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85"><span class="nav-text">6.2 字段填充</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-VM-exit-information-fields"><span class="nav-text">7  VM-exit information fields</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%E7%B1%BB%E5%AD%97%E6%AE%B5"><span class="nav-text">7.1 基本信息类字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-%E7%9B%B4%E6%8E%A5%E4%B8%8E%E9%97%B4%E6%8E%A5%E5%90%91%E9%87%8F%E4%BA%8B%E4%BB%B6"><span class="nav-text">7.2 直接与间接向量事件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%90%91%E9%87%8F%E4%BA%8B%E4%BB%B6"><span class="nav-text">直接向量事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%B4%E6%8E%A5%E5%90%91%E9%87%8F%E4%BA%8B%E4%BB%B6"><span class="nav-text">间接向量事件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-%E6%8C%87%E4%BB%A4%E4%BF%A1%E6%81%AF%E7%B1%BB"><span class="nav-text">7.3 指令信息类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-%E6%8C%87%E4%BB%A4%E9%94%99%E8%AF%AF%E7%B1%BB"><span class="nav-text">7.4 指令错误类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-VM-exit-%E5%88%86%E7%B1%BB"><span class="nav-text">7.5 VM-exit 分类</span></a></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Catecat"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Catecat</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">139</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/newcategories/">
          
        <span class="site-state-item-count">62</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">81</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Directoree" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Directoree" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhao_yilong@aliyun.com" title="E-Mail → mailto:zhao_yilong@aliyun.com" rel="noopener" target="_blank"><i class="fas fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://sighttp.qq.com/msgrd?v=1&uin=1003432683" title="QQ → http:&#x2F;&#x2F;sighttp.qq.com&#x2F;msgrd?v&#x3D;1&amp;uin&#x3D;1003432683" rel="noopener" target="_blank"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://catecat.gitee.io/" title="Cutecat → https:&#x2F;&#x2F;catecat.gitee.io" rel="noopener" target="_blank"><i class="fas fa-heartbeat fa-fw"></i>Cutecat</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://catecat.top/" title="Directoree → https:&#x2F;&#x2F;catecat.top" rel="noopener" target="_blank"><i class="fas fa-heart fa-fw"></i>Directoree</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://treecatee.github.io/" title="https:&#x2F;&#x2F;treecatee.github.io" rel="noopener" target="_blank">Treecatee</a>
        </li>
    </ul>
  </div>

      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://directoree.github.io/post/Windows10-x64-hypervisor-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Catecat">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="˗ˋˏ♡ˎˊ˗">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Hypervisor（二）：VMCS region
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-18 22:38:57" itemprop="dateCreated datePublished" datetime="2023-04-18T22:38:57+08:00">2023-04-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2024-01-22 22:43:19" itemprop="dateModified" datetime="2024-01-22T22:43:19+08:00">2024-01-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/VT-x/" itemprop="url" rel="index"><span itemprop="name">VT-x</span></a>
        </span>
    </span>

  
    <span id="/post/Windows10-x64-hypervisor-2/" class="post-meta-item leancloud_visitors" data-flag-title="Hypervisor（二）：VMCS region" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/post/Windows10-x64-hypervisor-2/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/post/Windows10-x64-hypervisor-2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>33k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>30 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>😄</p>
<span id="more"></span>



<h2 id="1-VMCS-region"><a href="#1-VMCS-region" class="headerlink" title="1 VMCS region"></a>1 VMCS region</h2><p>在 VMX 架构下，至少需要实现一个被称为 <mark class="label danger">VMXON region</mark>，以及一个被称为 <mark class="label success">VMCS region</mark> 的物理区域。</p>
<ul>
<li><strong>VMXON 区域对应于 VMM</strong>，VMM 使用 VMXON 区域对一些数据进行记录和维护。</li>
<li>每个 VMCS（Virtual Machine Control Structure，虚拟机控制结构）<strong>区域对应着一个 VM</strong>。VMM 使用 VMCS 区域来配置 VM 的运行环境，以及控制 VM 的运行。</li>
<li>在进入 VMX operation 模式前，必须先为 VMM 准备一份 VMXON 区域，同样在进入 VM 前也必须准备相应的 VMCS 区域，并配置 VM 的运行环境。</li>
</ul>
<h3 id="1-1-VMCS-概述"><a href="#1-1-VMCS-概述" class="headerlink" title="1.1 VMCS 概述"></a>1.1 VMCS 概述</h3><p>VMM 通过虚拟机控制结构 VMCS 来设置和保存 VMX root、VMX non-root 模式切换中涉及的数据、寄存器值等。VMCS 具有以下几点特征：</p>
<ol>
<li><strong>一个逻辑处理器对应 VMM 中的一块 VMCS</strong>（该区域称为 VMCS region），而不是一个 VM 对应着一个 VMCS。如果一个 VM 使用了几个逻辑处理器 vCPU，则就应该有几个对应的 VMCS 结构。可以使用 MSR <code>IA32_VMX_BASIC</code> 来确定 VMCS 区域的大小。</li>
<li>每个逻辑处理器中都有一个 VMCS 指针（64 bits）指向 VMCS 块的<strong>物理地址</strong>，应与 4KB 边界对齐。使用 <code>VMPTRST</code> 和 <code>VMPTRLD</code> 读取和写入 VMCS 指针的值。如果 <code>IA32_VMX_BASIC[48] = 1</code>，则这些指针不得设置 <code>63:32</code> 范围内的任何位，见附录 A.1。</li>
<li>VMM 使用 <code>VMREAD</code>、<code>VMWRITE</code> 和 <code>VMCLEAR</code> 指令配置 VMCS。</li>
</ol>
<h3 id="1-2-VMCS-的状态"><a href="#1-2-VMCS-的状态" class="headerlink" title="1.2 VMCS 的状态"></a>1.2 VMCS 的状态</h3><p>在 VMX root、VMX non-root 模式切换中，从 VMX root 切换到 VMX non-root 模式被称为 <strong>VM-entry</strong>；从 VMX non-root 切换到 VMX root 模式被称为 <strong>VM-exit</strong>。</p>
<hr>
<p><strong>注意⚠️：VM-exit 和 VM-entry 不会改变 VMCS 的状态</strong>。</p>
<hr>
<div class="note danger"><p>VMCS 的三类属性状态：</p>
<ol>
<li>active — inactive，活动的—非活动的。</li>
<li>current — not current，当前的—非当前的。在一个逻辑处理器上一个时刻只能有一个 VMCS 处于 current（current-VMCS）。</li>
<li>launched — clear，已启动—干净。</li>
</ol>
</div>

<div class="note default"><p><strong>启动 VMCS region 区域顺序</strong>：</p>
<ol>
<li>VMCS region 区域初始化之后要先试用 <code>VMCLEAR</code> 使该 VMCS 处于 inactive、not current、clear。</li>
<li>使用 <code>VMPTRLD</code> 使 VMCS 变成 active、current。</li>
<li>使用 <code>VMLAUNCH</code> 使 VMCS 变成 launched。</li>
</ol>
</div>

<div class="note warning"><p>制约关系：</p>
<ul>
<li>使用 <code>VMLAUNCH</code> 指令前，必须先使用 <code>VMCLEAR</code> 使 VMCS region 处于 clear 状态（此时 <code>current-VMCS pointer == 0xFFFFFFFFFFFFFFFF</code>），然后使用 <code>VMPTRLD</code> 将 VMCS 变成 active、current，最后使用 <code>VMLAUNCH</code> 指令。</li>
<li>使用 <code>VMRESUME</code> 进入 VM 前，该 VM 必须已经使用 <code>VMLAUNCH</code> 启动过了。</li>
<li><code>VMREAD</code>，<code>VMWRITE</code>，<code>VMLAUNCH</code>，<code>VMRESUME</code> 及 <code>VMPTRST</code> 指令的操作<strong>都是实施在 current-VMCS 之上的</strong>。</li>
</ul>
</div>

<div class="note success"><p><strong>注意</strong>：</p>
<ol>
<li>假设先使用 <code>VMPTRLD</code> 使得 VMCS-A 变成 active、current，current-VMCS point 是  VMCS-A 的。</li>
<li>然后又使用 <code>VMPTRLD</code> 使得 VMCS-B 变成 active、current，current-VMCS point 是  VMCS-B 的。那么此时 VMCS-A 的状态是 active（活动状态不变）、<strong>not current</strong>。</li>
<li>在软件中<strong>没有任何方法</strong>来读取某个 VMCS 处在哪一个状态，CPU 维护这些状态。</li>
<li><code>VMCLEAR</code>、<code>VMPTRLD</code> 指令的操作数都是物理地址。</li>
</ol>
</div>



<p>下图描述了 VMCS 的状态变化，在 Intel 手册中使用 “The VMCS” 表示 “Current VMCS”。</p>
<p><img data-src="https://s2.loli.net/2023/04/11/bxKdOwB1L4AehvD.png" alt="7.png"></p>
<h3 id="1-3-申请-VMCS-region"><a href="#1-3-申请-VMCS-region" class="headerlink" title="1.3 申请 VMCS region"></a>1.3 申请 VMCS region</h3><p>申请 VMCS region 和申请 VMXON region 类似。</p>
<ol>
<li>通过 IA32_VMX_BASIC[44:32] 得到 VMCS 所需空间大小（0x1000，4096 bytes）。</li>
<li>通过 IA32_VMX_BASIC[53:50] 得到 VMCS 所需内存类型，如 write-back。</li>
<li>调用 MmAllocateContiguousMemorySpecifyCache 函数申请连续指定大小和类型的物理内存。</li>
<li>判断返回地址是否在边界对齐 4KB（bit 11:0 为 0）。</li>
<li>将 IA32_VMX_BASIC[31:0] 的 VMCS revision identifier 写入 VMCS 前 4 字节的 [bit30:0]。</li>
<li>将 VMCS 的 bit 31 &#x3D; 0（不是 shadow VMCS）。</li>
<li>使用 <code>VMCLEAR</code> 使 VMCS region 处于 clear 状态。</li>
<li>使用 <code>VMPTRLD</code> 使 VMCS 变成 active、current。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 1. 通过 IA32_VMX_BASIC[44:32] 得到 VMCS 所需空间大小（0x1000，4096 bytes）。</span></span><br><span class="line"><span class="comment">// 2. 通过 IA32_VMX_BASIC[53:50] 得到 VMCS 所需内存类型，如 write-back。</span></span><br><span class="line"><span class="comment">// 3. 调用 MmAllocateContiguousMemorySpecifyCache 函数申请连续指定大小和类型的物理内存。</span></span><br><span class="line"><span class="comment">// 4. 判断返回地址是否在边界对齐 4KB（bit 11:0 为 0）。</span></span><br><span class="line"><span class="comment">// 5. 将 IA32_VMX_BASIC[31:0] 的 VMCS revision identifier 写入 VMCS 前 4 字节的 [bit30:0]。</span></span><br><span class="line"><span class="comment">// 6. 将 VMCS 的 bit 31 = 0（不是 shadow VMCS）。</span></span><br><span class="line"><span class="comment">// 7. 使用 VMCLEAR 使 VMCS region 处于 clear 状态。</span></span><br><span class="line"><span class="comment">// 8. 使用 VMPTRLD 使 VMCS 变成 active、current。</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">VmxAllocateVmcsRegion</span><span class="params">(VIRTUAL_MACHINE_STATE* CurrentGuestState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	IA32_VMX_BASIC_MSR MsrVmxBasic = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	ULONG VmcsRegionSize = <span class="number">0</span>;</span><br><span class="line">	UCHAR VmcsRegionType = <span class="number">0</span>;</span><br><span class="line">	PVOID pVmcsRegion_VA = <span class="literal">NULL</span>;</span><br><span class="line">	PHYSICAL_ADDRESS pVmcsRegion_Phy = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	PHYSICAL_ADDRESS Lowphys = &#123; <span class="number">0</span> &#125;, Highphys = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	ULONG64 uAlignVirtualAddress = <span class="number">0</span>;</span><br><span class="line">	ULONG64 uAlignPhysicalAddress = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// get the Vmcs region size and type.</span></span><br><span class="line">	MsrVmxBasic.All = __readmsr(MSR_IA32_VMX_BASIC);</span><br><span class="line">	<span class="keyword">if</span> (MsrVmxBasic.All)</span><br><span class="line">	&#123;</span><br><span class="line">		VmcsRegionSize = (MsrVmxBasic.All &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0x1FFF</span>;</span><br><span class="line">		VmcsRegionType = (MsrVmxBasic.All &gt;&gt; <span class="number">50</span>) &amp; <span class="number">0xF</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (VmcsRegionSize != PAGE_SIZE)</span><br><span class="line">	&#123;</span><br><span class="line">		DbgPrint(<span class="string">&quot;[*] Error : The VMCS region size is error getting from IA32_VMX_BASIC[44:32].&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		Lowphys.QuadPart = <span class="number">0</span>;</span><br><span class="line">		Highphys.QuadPart = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (VmcsRegionType)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:	<span class="comment">// uncache</span></span><br><span class="line">			pVmcsRegion_VA = MmAllocateContiguousMemorySpecifyCache(VmcsRegionSize * <span class="number">2</span>, Lowphys, Highphys, Lowphys, MmNonCached);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">6</span>:	<span class="comment">// write-back</span></span><br><span class="line">			pVmcsRegion_VA = MmAllocateContiguousMemorySpecifyCache(VmcsRegionSize * <span class="number">2</span>, Lowphys, Highphys, Lowphys, MmCached);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pVmcsRegion_VA == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			DbgPrint(<span class="string">&quot;[*] Error : Couldn&#x27;t Allocate Buffer for VMCS Region.&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> FALSE;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		RtlSecureZeroMemory(pVmcsRegion_VA, VmcsRegionSize * <span class="number">2</span>);</span><br><span class="line">		pVmcsRegion_Phy = MmGetPhysicalAddress(pVmcsRegion_VA);</span><br><span class="line">		uAlignVirtualAddress = (ULONG64)pVmcsRegion_VA;</span><br><span class="line">		uAlignPhysicalAddress = (ULONG64)pVmcsRegion_Phy.QuadPart;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// align the physical address to 0x1000(bit 11:0 to 0)</span></span><br><span class="line">		<span class="comment">// the address align formula: if align to n bytes,(address + n-1) &amp; (~(n-1))</span></span><br><span class="line">		<span class="comment">// https://catecat.top/post/WinXP-Struct/</span></span><br><span class="line">		uAlignPhysicalAddress = ((ULONG64)uAlignPhysicalAddress + PAGE_SIZE - <span class="number">1</span>) &amp; (~(PAGE_SIZE - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (((uAlignPhysicalAddress &amp; <span class="number">0xFFF</span>) != <span class="number">0</span>) &amp;&amp; ((ULONG64)uAlignPhysicalAddress - (ULONG64)pVmcsRegion_Phy.QuadPart &lt;= PAGE_SIZE))</span><br><span class="line">		&#123;</span><br><span class="line">			uAlignPhysicalAddress++;</span><br><span class="line">			uAlignPhysicalAddress = ((ULONG64)uAlignPhysicalAddress + PAGE_SIZE - <span class="number">1</span>) &amp; (~(PAGE_SIZE - <span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((uAlignPhysicalAddress &amp; <span class="number">0xFFF</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            MmFreeContiguousMemory(pVmcsRegion_VA);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> ((uAlignPhysicalAddress &amp; <span class="number">0xFFF</span>) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (uAlignVirtualAddress == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		DbgPrint(<span class="string">&quot;[*] Error : MmGetVirtualForPhysical have a fault in VmxAllocateVmcsRegion function.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pVmcsRegion_Phy.QuadPart = uAlignPhysicalAddress;</span><br><span class="line">	uAlignVirtualAddress = (ULONG64)MmGetVirtualForPhysical(pVmcsRegion_Phy);</span><br><span class="line"></span><br><span class="line">	CurrentGuestState-&gt;VmvsRegionAllocVirtualAddress = (ULONG64)pVmcsRegion_VA;</span><br><span class="line">	CurrentGuestState-&gt;VmcsRegionAlignedVirtualAddress = uAlignVirtualAddress;</span><br><span class="line">	CurrentGuestState-&gt;VmcsRegionAlignedPhysicalAddress = uAlignPhysicalAddress;</span><br><span class="line"></span><br><span class="line">	DbgPrint(<span class="string">&quot;[*] Virtual allocated buffer for VMCS at %llx\n&quot;</span>, (ULONG64)pVmcsRegion_VA);</span><br><span class="line">	DbgPrint(<span class="string">&quot;[*] Virtual aligned allocated buffer for VMCS at %llx\n&quot;</span>, uAlignVirtualAddress);</span><br><span class="line">	DbgPrint(<span class="string">&quot;[*] Aligned physical buffer allocated for VMCS at %llx\n&quot;</span>, uAlignPhysicalAddress);</span><br><span class="line"></span><br><span class="line">	*(PULONG64)CurrentGuestState-&gt;VmcsRegionAlignedVirtualAddress = MsrVmxBasic.Fields.RevisionIdentifier;</span><br><span class="line">	_bittestandreset64((PULONG64)CurrentGuestState-&gt;VmcsRegionAlignedVirtualAddress, <span class="number">31</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="1-4-VMCS-结构"><a href="#1-4-VMCS-结构" class="headerlink" title="1.4 VMCS 结构"></a>1.4 VMCS 结构</h3><p><img data-src="https://s2.loli.net/2023/04/15/Fszai4l7tqYZxcd.png" alt="15.png"></p>
<p><img data-src="https://s2.loli.net/2023/04/18/PyIZdJpoN6sC4az.png" alt="16.png"></p>
<table>
<thead>
<tr>
<th>偏移</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>Bits 30:0 使用 VMCS revision identifier 来填充。来自于 <code>IA32_VMX_BASIC[30:0]</code>。<br />Bit 31 指示当前 VMCS 是否是 shadow VMCS。0 表示普通的 VMCS，1 表示 shadow VMCS（只有在）VM-execution control fields 的 <code>VMCS shadowing == 1</code> 时该位才有效。</td>
</tr>
<tr>
<td>4</td>
<td>当进行 VM-exit 操作遇到一个错误时，会产生 <strong>VMX-abort</strong>，然后处理器会将一个<strong>非零的值</strong>填充到当前的 VMX-abort indicator。通常导致 VMX Abort 事件的原因包括保存客户虚拟机 MSR 奇存器失败、当前 VMCS 区域损坏、加载 Hypervisor 的 MSR 寄存器失败等。</td>
</tr>
<tr>
<td>8</td>
<td>VMCS 数据区包含 6 个区域，每个区域都有若干字段。用于 VMM root operation 和  VMM non-root operation 转换时提供&#x2F;保存信息。<br />1. Guest-state area：VM-exit 时，处理器的当前状态保存在该区域。VM-entry 时从该区域加载处理器的状态值。<br />2. Host-state area：VM-exit 时从该区域加载处理器的状态值。这个区域记录了所有有关 Hypervisor 的状态信息<br />3. VM-execution control fields：重点关注该区域。控制着处理器在 Guest 的行为，设置 VM-exit 的条件。<br />4. VM-exit control fields：该区域定义了在 VM-exit 事件发生后硬件立即要做的事情。<br />5. VM-entry control fields：该区域定义了在 VM-entry 事件发生后硬件立即要做的事情。<br />6. VM-exit information fields：记录引起 VM-exit 事件的原因及接收相关的明细信息。在许多处理器中，该区域都是只读的。如果 MSR <code>IA32_VMX_MISC[bit29] = 1</code> 则表示该区域可使用 <code>VMWRITE</code> 写。</td>
</tr>
</tbody></table>
<div class="note danger"><p>注意：由于目前 VMCS 中部分区域需要是 write-back 内存类型，目前申请 VMCS 的内存类型都是 write-back，但是未来可能需要不同的内存类型（Intel 卷3 24.2）。</p>
<p><img data-src="https://s2.loli.net/2023/04/15/vwjoD12tnNhxWrl.png" alt="17.png"></p>
</div>

<p>参考资料：</p>
<ul>
<li>处理器虚拟化技术（邓志）</li>
<li>New Blue Pill 深入理解硬件虚拟机</li>
<li>加密与解密第 4 版 Chapter 10</li>
<li>Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3 (3A, 3B, 3C &amp; 3D): System Programming Guide Chapter 23</li>
</ul>
<h3 id="1-5-VMCS-字段-ID"><a href="#1-5-VMCS-字段-ID" class="headerlink" title="1.5 VMCS 字段 ID"></a>1.5 VMCS 字段 ID</h3><p>VMCS 分为 6 个区域，每个区域里面都有很多字段，每个字段由一个 ID 值来表示（该 ID 值为 32 bits）。每个字段一般有以下几种宽度：</p>
<ol>
<li>16 bits（2 bytes）</li>
<li>32 bits（4 bytes）</li>
<li>64 bits（8 bytes）</li>
<li>natural-width（在 32 位系统为 32 bits，在 64 位系统为 64 bits）</li>
</ol>
<p>对于 VMCS 字段的读写，只能使用 <code>VMREAD</code>、<code>VMWRITE</code>，不能使用 <code>MOV</code>。</p>
<p>ID 字段格式：</p>
<p><img data-src="https://s2.loli.net/2023/04/19/eqJUEZuogjh1YA7.png" alt="20.png"></p>
<p>每个字段对应一个 ID 值，参看 <a target="_blank" rel="noopener" href="https://github.com/tandasat/HyperPlatform/blob/master/HyperPlatform/ia32_type.h">HyperPlatform—VmcsField</a>。</p>
<p>如 <code>GuestEsSelector = 0x00000800</code>，<code>GuestEsSelector</code> 表示 ES 段寄存器的选择子，其对应的 ID 值为 <code>0x00000800</code>。后续对该 16 bits 大小的字段读写就可以使用 <code>VMREAD/VMWRITE</code> 指令了。</p>
<h3 id="1-6-Control-字段保留值"><a href="#1-6-Control-字段保留值" class="headerlink" title="1.6 Control 字段保留值"></a>1.6 Control 字段保留值</h3><p>控制区：<em>VM-execution control fields、VM-exit control fields、VM-entry control fields</em> 中有许多值都必须使用保留值，保留值取 <code>0/1</code>，需要在 <code>IA32_VMX_BASIC[55](0x480)</code> 的影响下进行取值。</p>
<table>
<thead>
<tr>
<th>影响的 VMCS字段</th>
<th>bit 55 &#x3D; 0</th>
<th>bit 55 &#x3D; 1</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Pin-Based</strong> VM-Execution Controls</td>
<td>IA32_VMX_PINBASED_CTLS（0x481）</td>
<td>IA32_VMX_TRUE_PINBASED_CTLS（0x48D）</td>
</tr>
<tr>
<td><strong>primary processor-based</strong> VM-execution control</td>
<td>IA32_VMX_PROCBASED_CTLS（0x482）</td>
<td>IA32_VMX_TRUE_PROCBASED_CTLS（0x48E）</td>
</tr>
<tr>
<td><strong>secondary processor-based</strong> VM-execution control</td>
<td>IA32_VMX_PROCBASED_CTLS2（0x48B）</td>
<td>IA32_VMX_PROCBASED_CTLS2（0x48B）</td>
</tr>
<tr>
<td><strong>tertiary</strong> VM-execution controls</td>
<td>IA32_VMX_PROCBASED_CTLS2（0x492）</td>
<td>IA32_VMX_PROCBASED_CTLS2（0x492）</td>
</tr>
<tr>
<td>VM-exit contorl</td>
<td>IA32_VMX_EXIT_CTLS（0x483）</td>
<td>IA32_VMX_TRUE_EXIT_CTLS（0x48F）</td>
</tr>
<tr>
<td>VM-entry control</td>
<td>IA32_VMX_ENTRY_CTLS（0x484）</td>
<td>IA32_VMX_TRUE_ENTRY_CTLS（0x490）</td>
</tr>
</tbody></table>
<p>上表中的 10 个 MSR 寄存器都是 64 bits，需要将其分为高&#x2F;低 32 bits，如下图。</p>
<p><img data-src="https://s2.loli.net/2023/04/20/Ray8ugxbFf41AXs.png" alt="23.png"></p>
<p><strong>用法</strong>：</p>
<ul>
<li>当 MSR 高 32 bits [63:32] 中的位为 0 时，对应的控制字段相应的位必须为 0。</li>
<li>当 MSR 低 32 bits [31:0] 中的位为 1 时，对应的控制字段相应的位允许为 1。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ULONG <span class="title">AdjustControls</span><span class="params">(ULONG Ctl<span class="comment">/*预设的初始值*/</span>, ULONG Msr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MSR MsrValue = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	MsrValue.Content = __readmsr(Msr);</span><br><span class="line">	Ctl &amp;= MsrValue.High;     <span class="comment">/* bit == 0 in high word ==&gt; must be zero */</span></span><br><span class="line">	Ctl |= MsrValue.Low;      <span class="comment">/* bit == 1 in low word  ==&gt; must be one  */</span></span><br><span class="line">	<span class="keyword">return</span> Ctl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：由于上面的控制字段都是 32 bits 的，所以将 MSR 的高 32 位类似于低 32 位一样使用。</p>
</blockquote>
<p>举例说明：</p>
<ol>
<li>假设将 <strong>Pin-Based</strong> VM-Execution Controls 初始值设置为 0。</li>
<li>此时 <code>IA32_VMX_BASIC[55] = 1</code>。</li>
<li><code>IA32_VMX_TRUE_PINBASED_CTLS</code> 高 32 bits 为 <code>0x0000003F</code>，低 32 bits 为 <code>0x00000016</code>。</li>
<li>计算 <code>0 &amp; 0x0000003F == 0</code>，<code>0 | 0x00000016 == 0x00000016</code>。</li>
<li>则 bit-1，bit-2，bit-4 必须为 1，其余位都可以为 0。</li>
</ol>
<p>VM-function control字段，另说，P153。</p>
<h2 id="2-Guest-state-area"><a href="#2-Guest-state-area" class="headerlink" title="2 Guest-state area"></a>2 Guest-state area</h2><p>Guest-state area 包含寄存器类和非寄存器类字段。VM-exit 时，处理器的当前状态保存在该区域，VM-entry 时从该区域加载处理器的状态值。</p>
<p><img data-src="https://s2.loli.net/2023/04/18/rBNHxfUCeAOWs5Y.png" alt="18.png"></p>
<h3 id="2-1-寄存器类字段"><a href="#2-1-寄存器类字段" class="headerlink" title="2.1 寄存器类字段"></a>2.1 寄存器类字段</h3><ul>
<li>控制寄存器：CR0、CR3、CR4。</li>
<li>调试寄存器：DR7。</li>
<li>堆栈、指令寄存器：RSP、RIP、RFLSGS。</li>
<li>段寄存器：CS、SS、DS、ES、FS、GS、TR。</li>
<li>描述符寄存器：GDTR、LDTR、IDTR。</li>
<li>MSR 寄存器。</li>
</ul>
<div class="note danger"><p><strong>说明</strong>：对于 MSR 寄存器，只有在 <em>VM-exit control</em>、<em>VM-entry control</em> 区域中对应的寄存器字段设置为 <code>1</code> 时， <em>Guest-state area</em> 区域中的寄存器字段才有效。</p>
</div>

<h3 id="2-2-非寄存器类字段"><a href="#2-2-非寄存器类字段" class="headerlink" title="2.2 非寄存器类字段"></a>2.2 非寄存器类字段</h3><ol>
<li><p><strong>activity state</strong> 字段（32 bits，表示虚拟处理的状态）</p>
<p>该字段指示在 VM-entry 和 VM-exit 时，<strong>虚拟处理器的当前活动状态</strong>。包括 active（活动）与 inactive（非活动）两大类状态。目前 VMX 架构支持的状态如表 3-18 所示。</p>
<ul>
<li>active：逻辑处理器可以正常执行 Guest 的指令。</li>
<li>inactive：逻辑处理器<strong>不可以</strong>正常执行 Guest 的指令，需要 VMM 进行处理才可以执行 Guest 的指令。</li>
</ul>
<p><img data-src="https://s2.loli.net/2023/04/19/WjcbrBvd6TKMq1g.png" alt="19.png"></p>
<p>可以查看 <code>IA32_VMX_MISC(0x485)[8:6]</code>，可以看到以上所有状态都支持。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; rdmsr <span class="number">0x485</span></span><br><span class="line">msr[<span class="number">485</span>] = <span class="number">00000000</span>`<span class="number">5004</span>c1e7</span><br><span class="line"></span><br><span class="line">kd&gt; .formats <span class="number">0x00000000</span>`<span class="number">5004</span>c1e7</span><br><span class="line">Evaluate expression:</span><br><span class="line">  Hex:     <span class="number">00000000</span>`<span class="number">5004</span>c1e7</span><br><span class="line">  Decimal: <span class="number">1342489063</span></span><br><span class="line">  Octal:   <span class="number">0000000000012001140747</span></span><br><span class="line">  Binary:  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">01010000</span> <span class="number">00000100</span> <span class="number">11000001</span> <span class="number">11100111</span></span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>Interruptibility state</strong> 字段（32 bits）</p>
<p>该字段指示当前 Guest 中有没有被阻塞的中断，x86&#x2F;64 体系中一共有 5 种中断阻塞状态。如下图：</p>
<p><img data-src="https://s2.loli.net/2024/01/19/MnAkaHli21ux8Vc.png" alt="82.png"></p>
<div class="note primary"><ul>
<li><code>cli</code> 指令禁止中断发生，使 <code>rflags.IF = 0</code>，关中断，屏蔽可屏蔽中断（NMI 不可屏蔽）。</li>
<li><code>sti</code> 指令允许中断发生，使 <code>rflags.IF = 1</code>，开中断，响应中断。</li>
</ul>
</div>



<p>x86 架构允许某些事件在一段时间内被阻止的功能。该字段的<strong>每一个位指示了当前有哪种状态被阻塞</strong>。</p>
<table>
<thead>
<tr>
<th>bit</th>
<th>中断被阻塞</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>blocking by STI</td>
<td>指示当前有 STI 阻塞状态。<br /><br /><div class="note success"><p>在 <code>rflags.IF = 0</code>（不响应可屏蔽的中断）情况下，执行 <code>sti</code> 指令以响应可屏蔽中断时，在 <code>sti</code> 指令的下一条指令执行完毕前发生的<strong>外部中断</strong>，会被阻塞起来，当下一条指令执行完毕后，阻塞状态会被自动解除。这个时候才开始 delivery 刚才被阻塞的外部中断。<br />如果在执行 <code>sti</code> 指令前 <code>eflags.IF = 1</code> ，那么，这条 <code>sti</code> 指令的下一条指令不会存阻塞的状态。<br /></p>
</div><br />举例如下：<br /><code>sti;</code><br /><code>mov [eax], ebx;</code><br />如上代码，假设执行 <code>sti</code> 指令前 <code>rflags.IF = 0</code>，那么，执行 <code>sti</code> 指令后，下一条 <code>mov</code> 指令执行完毕前如果发生外部中断将被阻塞（某些处理器也可能会阻塞 NMI）。下一条 <code>mov</code> 指令执行完毕后这个阻塞状态将被<strong>自动解除</strong>，如果此时有被阻塞的外部中断，将会开始进行 delivery。<br />但是，如果此时执行的 <code>mov [eax], ebx</code> 指令产生了 #PF 异常（页面错误），且 exception bitmap 字段的 bit 14 为 1 时将直接导致 VM-exit 发生。VM-exit 时会设置 interruptibility state—<code>blocking by STI = 1</code> ，表示 VM-exit 时在 Guest 中存在 <code>blocking by STI</code>。<br /><br /><br />Intel 设计 <code>blocking by STI</code> 阻塞状态的初衷是用在下面的场合：<br /> <code>sti;</code> <br /><code>ret;</code> <br />当 <code>sti</code> 指令最后是一条 <code>ret</code> 指令时（假设之前 <code>rflags.IF = 0</code>），<code>blocking by STI</code> 阻塞状态的存在避免了在返回前产生中断（阻塞期间不 delivery 可屏蔽的中断）。</td>
</tr>
<tr>
<td>1</td>
<td>blocking by MOV-SS</td>
<td>指示当前有 MOV-SS 阻塞状态。<br /><br />使用 <code>MOV</code> 或者 <code>POP</code> 指令更新 SS 寄存器时，下一条指令执行完毕前会产生了 <code>blocking by MOV-SS</code> 阻塞状态。这个阻塞状态将阻塞<strong>外部中断</strong>、<strong>NMI</strong> 及 <strong>#DB</strong> 异常。<br />在更新 SS 栈段时，需要保证栈指针（典型为内核中的栈）能够得到更新而不被中断打断（外部中断，NMI 或者 #DB 断点异常），避免在中断服务例程中使用了不适当的栈指针。如果软件使用 <code>LSS</code> 指令来更新 SS 寄存器和 RSP 栈指针，则不存在 <code>blocking by MOV-SS</code> 阻塞状态。因此，Intel 推荐使用 <code>LSS</code> 指令代替 <code>MOV</code> 或 <code>POP</code> 来更新 SS 寄存器。<br /><br />如：<code>MOV SS,AX; MOV RSP, KernelStack;</code> 或 <code>POP SS; MOV [RAX], RBX;</code> <br /><br /><strong>注意</strong>：在一个指令流里，不可能同时出现 <code>blocking by STI</code> 与 <code>blocking by MOV-SS</code>两种阻塞状态。因此，这两个位不能同时为 1 值。<br /><strong>注意</strong>：如果在 VM-entry 时存在 <code>blocking by MOV-SS</code> 阻塞状态，那么这个阻塞状态会因为注入事件的delivery 而被解除。</td>
</tr>
<tr>
<td></td>
<td>blocking by SMI</td>
<td>指示当前有 SMI 阻塞状态。<br /><br />处理器切换到 SMM 模式执行后，新的 SMI 请求会被阻塞，直到执行 <code>RSM</code> 指令退出 SMM 模式后 <code>blocking by SMT</code> 阻塞状态被解除。<br /><br />由于这个原因，VM-entry control 字段 <code>enter to SMM = 1</code> 时，表示 VM-entry 将进入 SMM 模式，此时 interruptibility state 字段的 <code>blocking by SMI</code> 位必须为 1。反 之，VM-entry 进入非 SMM 模式时，interruptibility state 字段的 <code>blocking by SMI</code> 位必须为 0 值。</td>
</tr>
<tr>
<td>3</td>
<td>blocking by NMI</td>
<td>指示当前有 NMI 阻塞状态。<br /><br />当处理器响应 NMI 请求时，NMI 服务例程得到 delivery 后将阻塞另一个 NMI 请求，直到执行 <code>iret</code> 指令后解除阻塞SMI 请求也是这样。因此，<code>blocking by NMI</code> 阻塞状态的存在依赖于 NMI 是否得到 delivery。（See Section 6.7.1, “Handling Multiple NMls” in the Inte&#x2F;® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A and Section 31.8, “NMI Handling While in SMM.”）<br /><br /><div class="note danger"><p>是否存在 <code>blocking by NMI</code> 阻塞状态的区分方法（主要看 NMI 是否得到 delivery）：<br />1、当 NMI 得到 delivery 执行时，即使<strong>在 delivery 期间</strong>发生某些错误而产生 VM-exit（在 NMI handler 过程，VM-exit 完成前），处理器就会存在 blocking by NMI 阻塞状态。<br />2、 当 NMI 由于 <code>NMI exiting = 1 </code> 而<strong>没有得到 delivery</strong> 直接 VM-exit 时，处理器在 VM-exit 完成前并不存在 blocking by NMI 阻塞状态。<br /></p>
</div><div class="note success"><p>关于 <code>iret</code> 指令对 <code>blocking by NMI</code> 阻塞状态的解除：<br />如果 NMI 或 virtual-NMI 已经被 delivery，此时再产生 NMI 或 virtual-NMI 时将会被阻塞。在执行 <code>iret</code> 指令后，<mark class="label danger">阻塞状态将会被解除</mark>。不管执行 <code>iret</code> 指令会不会产生异常，都不影响阻塞状态的解除（处理器虚拟化技术 P235）。<br /></p>
</div><div class="note primary"><p>关于 <em>VM-exit interruption information</em> 字段 <code>NMI unblocking</code>（bit 12）的说明：<br />只要 <code>iret</code> 指令执行，不管执行过程中是否会发生异常，<code>blocking by NMI</code> 或 <code>blocking by virtual-NMI</code> 阻塞状态都会被解除。但是并不是状态被解除就会将 <code>NMI unblocking</code> 位置 1。<br />只有在执行 <code>iret</code> 指令产生的异常<strong>直接导致 VM-exit</strong> 时，<em>VM-exit interruption information</em> 字段或 <em>VM-exit qualification field</em> 字段中的 <code>NMI unblocking due to IRET</code> 位才会置为 1 值，指示 NMI 或 virtual-NMI 阻塞状态已经被解除。间接导致的 VM-exit 不会将该位置 1。<br /><br />在以下的几种情形中，<code>NMI unblocking(bit 12)</code> 是未定义的值：<br />1、在 <code>Pin-Based VM-Execution Control（32 bits）</code> 字段的 <code>exiting NMI = 1</code> 且 <code>virtual NMIs = 0</code> 时，当产生一个 NMI 时将会直接 VM-exit，不会存在阻塞状态。所以 <code>iret</code> 指令并不会对 <code>blocking by NMI</code> 阻塞状态的解除产生任何影响。<br />2、当一个 NMI 在delivery 期间，执行一个 <code>iret</code> 指令，但是这个 <code>iret</code> 指令产生一个异常，并且这个异常并不会直接引发 VM-exit，而是在这个异常的 delivery 期间引发的另一个异常导致的 VM-exit。虽然此时的 <code>blocking by NMI</code> 阻塞状态已经被解除，但是 <code>NMI unblocking(bit 12)</code> 位并不会置 1。<br /></p>
</div><br />举例：<br />（1）当 <code>NMI exiting</code> 为 1 时，一个 NMI 请求直接产生 VM-exit，NMI 并没有得到 delivery。处理器在 VM-exit 过程中就不存在 <code>blocking by NMI</code> 阻塞状态。此时， interruptibility state 字段的 <code>blocking by NMI</code> 位为 0 值。<br />（2）当 VMM 注入一个 NMI 事件（或 virtual-NMI 事件）时，NMI 通过 guest-IDT 进行 deliver 执行。此时，处理器也存在 <code>blocking by NMI</code>（或 <code>blocking by virtual NMI</code>）阻塞状态。<br />（3）当 <em>pin-based VM-execution control</em> 字段的 <code>NMI exiting</code> 与 <code>virtual-NMIs</code> 位同时为 1 时，产生 virtual-NMI 概念，<code>blocking by NMI</code> 此时被视为 <code>blocking by virtual NMI</code> 位。当注入一个 virtual-NMI 事件 deliver 执行后，处理器就存在 <code>blocking by virtual-NMI</code> 阻塞状态。当注入的 virutal-NMl 事件由于 <code>NMIl-window exiting</code> 位为 1 而 产生VM-exit 时，并不存在 <code>blocking by virtual-NMI</code> 阻塞状态。<br />（4）在 NMI 或 virtual-NMI 服务例程中，执行 <code>iret</code> 指令后，这个 NMI 或 virtual-NMI 阻塞状态将解除。如果执行 <code>iret</code> 指令而发生某些错误，<strong>并不影响它解除 NMI 或 virtual NMI 的阻塞状态</strong>阻塞状态。执行 <code>iret</code> 指令发生一个异常而直接导致 VM-exit 时，在 <em>VM-exit interruption information</em> 字段中的 <code>NMI unblocking</code> 位（bit 12） 将为 1 值，指示 NMI 或 virtual-NMI 阻塞状态已经被解除（见 3.10.2.1节）。<br /><br />说明：<br /> 如果 NMI 直接引发 VM-exit，NMI 不被 deliver 执行，也就不会解除阻塞状态。<br /> 但是，如果 <code>iret</code> 指令产生了一个异常，但这个异常并不直接引发 VM-exit，而后来由于异常 delivery 期间导致 VM-exit （间接引发），此时 <code>blocking by NMI</code> 阻塞状态已经被解除。</td>
</tr>
<tr>
<td>4</td>
<td>Enclave interruption</td>
<td>逻辑处理器处于 enclave 模式时发生 VM exit，则设置为 1。<br />同时会设置 <em>VM-exit information fields—Basic VM-Exit Information</em>（基本信息类字段）的 Exit reason <code>bit 27 = 1</code>（表示与 enclave 模式相关的 VM-exit）。</td>
</tr>
<tr>
<td>31:5</td>
<td>Reserved</td>
<td>设置为 0。</td>
</tr>
</tbody></table>
</li>
<li><p>pending debug exception 字段。</p>
<p>x86 支持延迟发送一些调试异常，如某些情况下的单步调试。 pending debug exceptions 字段用来记录和设置 guest 存在未处理（阻塞）而 pending（悬挂）的 #DB异常。属于 natural-width 类型字段，在 64 位架构处理器上是 64 位，否则为 32 位。</p>
<div class="note primary"><p>pending debug exception 字段只支持记录 trap 类型 #DB 异常（由硬件断点或者 I&#x2F;O 断 点触发的 #DB 异常，以及由单步调试而触发的 #DB 异常），<strong>对于 fault 类型的 #DB 异常不能记录</strong>。</p>
</div>

<p>该字段的格式基本和 DR6 寄存器格式很相似：</p>
<p><img data-src="https://s2.loli.net/2024/01/20/plxd3sWmoAUZQcn.png" alt="83.png"></p>
<div class="note success"><p>当遇到一个硬件断点（指令执行、数据读写）或 single-step（单步调试）时，处理器将组织一个 #DB 异常，并提交处理器执行。</p>
<p>在 x86&#x2F;x64 体系上的 #DB（调试）异常使用 1 号中断向量，分为 fault 和 trap 两类，共有 6 个触发方式。</p>
<ul>
<li>fault 类型的 #DB 有 2 类触发方式：<ul>
<li>由执行断点触发。</li>
<li>由访问调试寄存器触发（DR7.GD &#x3D; 1 时）。当断点对应的 <code>DR7.R/Wx = 00</code> 时，使用执行断点，在断点寄存器 DR0-DR3 里设置断点的地址。当 <code>DR7.GD = 1</code> 时，使用 DR 寄存器访问触发方式。在后续的指令中访问任何一个 DR 寄存器将产生 #DB 异常。</li>
</ul>
</li>
<li>trap 类型 #DB 异常有 4 类触发方式：<ul>
<li>读写硬件断点（根据 DR7 的 <code>R/Wx</code> 位来区分）。</li>
<li>单步调试断点，设置 <code>Rflags.TF = 1</code> 时产生。单步调试分为指令单步调试及分支单步调试两种（单步调试在将 <code>eflags.TF</code> 置为 1 后，下一条指令执行完毕后触发，分支单步调试则在目标指令执行前触）</li>
<li>I&#x2F;O 断点，I&#x2F;O 断点是指令访问的 I&#x2F;O  端口地址。在 <code>CR4.DE = 1</code> 时，DR7 的 <code>R/Wx = 10</code>，产生的就是 I&#x2F;O 读写断点。（见 <em>卷 3A—Chapter 17 Debug, Branch Profile, TSC, and Intel® Resource Director Technology. (Intel® RDT) Features—17.2 Debug Registers</em>。）</li>
<li>在任务切换时，任务切换的 #DB 异常在执行完任务切换后，处理器检测到 TSS.T 为 1 时触发。（在 VMX 架构下，并不支持在 non-root operation 环境中使用任务切换机制。一旦发生任务切换，将产生 VM-exit 行为。因此，在 pending debug exception 字段中并不支持记录任务切换时产生的 #DB 异常。）</li>
</ul>
</li>
</ul>
<p>fault 和 trap 两类异常触发的位置不同，fault 类型如 DR 奇存器访问的 #DB 异常，在执行 <code>MOV-DR</code> 指令前触发，异常处理后还要继续执行该指令；trap 类型的异常，在执行完每一条指令后触发，异常处理后执行下一条指令。</p>
</div>

<div class="note danger"><p>上面提到的 <code>blocking by MOV-SS</code> 阻塞状态，会阻塞外部中断、NMI 及 #DB 异常。这里主要对阻塞的 #DB 异常进行说明。</p>
<ol>
<li>在 <code>pending debug exception</code> 字段中只能记录：（<strong>数据读写的硬件断点、 I&#x2F;0 断点、单步调试</strong>）产生的 #DB 异常。。<strong>不会记录指令指令而导致的硬件断点</strong>，这是因为 <code>blocking by MOV-SS</code> 阻塞状态不会阻塞因为指令执行硬件断点触发的 #DE 异常。</li>
<li><code>blocking by MOV-SS</code> 阻塞状态并不能阻塞由 DR 寄存器访问而产生的 #DB 异常。当 <code>DR7.GD = 1</code> 时，遇到 MOV-DR 指令将直接提交 #DB 异常执行（参考<a href="https://directoree.github.io/post/WinXP-Debug3/">硬件断点</a>），或者产生 VM-exit 行为。</li>
</ol>
<p>总结就是：对于指令执行的硬件断点的 #DB 异常和 DR 寄存器访问的 #DB 异常，它们不会被悬挂（pending）。</p>
</div>

<p>在 VM-exit 时存在 #DB 异常的 pending 状态，有如下 2 种可能。</p>
<ol>
<li>在 VM-exit 之前，一条指令产生 trap 类型异常。</li>
<li>在 VM-exit 前，已经存在由于 <code>blocking by Mov-SS</code> 阻塞状态而被 pending 的 #DB 异常。</li>
</ol>
<div class="note warning"><p><em>VM-exit information fields—exit qualification</em> 字段记录的 debug 异常信息与 pending debug exception 字段记录的 debug 异常信息是不同的。它们的用途也不同： </p>
<ul>
<li>exit qualification 字段记录的是由 #DB 异常引发 VM-exit 时的 debug 异常信息；</li>
<li>pending debug exception 字段记录的是由其他原因导致 VM-exit，而 #DB 异常未处理而被 pending（悬挂）的信息。</li>
</ul>
</div>




</li>
<li><p>其余字段。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>VMCS link pointer</strong></td>
<td>（1）如果 <em>VM-execution control</em> 的 <code>VMCS shadowing = 1</code>，此时该区域表示 VMCS region 的物理地址，可以通过该指针读写 VMCS 的字段。<br/>（2）如果 <em>VM-execution control</em> 的 <code>VMCS shadowing = 0</code>，此时该区域应该设置为 <code>0xFFFFFFFFFFFFFFFF</code>。</td>
</tr>
<tr>
<td>VMX-preemption timer value</td>
<td>保存定时器的计数值。<br/>（1）如果 <em>VM-execution control</em> 的 <code>active VMX-preemption timer = 1</code>，则该区域有效。表示一个定时器。<br/>（2）每 2^TSC 增加时，该值递减 1，递减为 0 时将会产生 VMX exit。<br/>填充该字段时，该字段的值来自于 <code>IA32_VMX_MISC[4:0]</code>。</td>
</tr>
<tr>
<td>PDPTEs</td>
<td>仅在启用 EPT 的 PAE 分页模式下可用。<br/>该区域包含 4 个 64 bits 的值：PDPTE0，PDPTE1，PDPTE2，PDPTE3。<br/>（1）只有在支持 EPT，即 <em>VM-execution control</em> 的 <code>enable EPT = 1</code> 时，且 Guest OS 在 <strong>PAE 分页</strong>模式下，需要填充这 4 个字段，以便在 VM-entry 时将这些字段的值加载到内部的 PDPTE 寄存器中、<strong>此时，CR3 寄存器将被忽略</strong>。<br/>（2）<em>VM-execution control</em> 的 <code>enable EPT = 0</code> 时，如果 Guest OS 使用 PAE 分页，CR3 寄存器指向的 4 个 PDPTEs 会被加载到内部的 PDPTE 寄存器，<strong>此时忽略 VMCS 中的 PDPTEs 字段</strong>。<br /><strong>注意</strong>：只有 Guest OS 在 32 位系统的 PAE 分页模式下，且启用 EPT 时才有用，IA-32e 模式不使用。</td>
</tr>
<tr>
<td>Guest interrupt status</td>
<td>只有在 <em>VM-execution control</em> 的 <code>virtual-interrupt delivery = 1</code> 时，该字段表示虚拟 local APIC，处理器使用该字段来维护虚拟中断的状态。</td>
</tr>
<tr>
<td>PML index</td>
<td>只有在 <em>VM-execution control</em> 的 <code>enable PML = 1</code> 时，该字段为一个 index 索引值，用在 EPT page-modification log。</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="2-3-字段填充"><a href="#2-3-字段填充" class="headerlink" title="2.3 字段填充"></a>2.3 字段填充</h3><h2 id="3-Host-state-area"><a href="#3-Host-state-area" class="headerlink" title="3 Host-state area"></a>3 Host-state area</h2><p>每一次 VM-exit 时，处理器的状态从 <em>Host-state area</em> 加载。</p>
<p><img data-src="https://s2.loli.net/2023/04/19/zI4JZR7qMFYjVgi.png" alt="21.png"></p>
<h3 id="3-1-寄存器类字段"><a href="#3-1-寄存器类字段" class="headerlink" title="3.1 寄存器类字段"></a>3.1 寄存器类字段</h3><p>Host-state area 区域中只有寄存器的的字段，没有其他字段：</p>
<ul>
<li>控制寄存器：CR0、CR3、CR4。</li>
<li>堆栈、指令寄存器：RSP、RIP。</li>
<li>段寄存器：CS、SS、DS、ES、FS、GS、TR。</li>
<li>描述符寄存器：GDTR、LDTR、IDTR。</li>
<li>MSR 寄存器。</li>
</ul>
<div class="note primary"><p><strong>说明</strong>：</p>
<ol>
<li>RIP 应该填充为 VMM 中的一个管理例程，使得每次 VM-exit 时都进入到该函数。</li>
<li>对于 MSR 寄存器，只有在 <em>VM-exit control</em> 区域中对应的寄存器字段设置为 <code>1</code> 时， <em>Host-state area</em> 区域中的寄存器字段才有效。</li>
</ol>
</div>



<h3 id="3-2-字段填充"><a href="#3-2-字段填充" class="headerlink" title="3.2 字段填充"></a>3.2 字段填充</h3><h2 id="4-VM-execution-control-fields"><a href="#4-VM-execution-control-fields" class="headerlink" title="4 VM-execution control fields"></a>4 VM-execution control fields</h2><p><em>VM-execution</em> 控制类字段主要控制处理器在 VMX non-root operation 模式下的行为能力：</p>
<ol>
<li>典型地可以控制某些条件引发 VM-exit 事件；</li>
<li>也控制着 VMX 的某些虚拟化功能的开启，例如 APIC 的虚拟化及 EPT 机制。</li>
</ol>
<div class="note danger"><p>将 VM-execution control fields 分为<strong>控制域</strong>和数据域，控制域决定着对应的数据域中是否有数值。</p>
<ul>
<li>控制域：<ul>
<li><strong>Pin-Based</strong> VM-Execution Control（32 bits），设置异步事件来导致 VM-exit 的条件。</li>
<li><strong>Processor-Based</strong> VM-Execution Control<ul>
<li><strong>primary processor-based</strong> VM-execution controls（32 bits），设置同步事件来导致 VM-exit 的条件。</li>
<li><strong>secondary processor-based</strong> VM-execution controls（32 bits），设置 <code>Enable</code> 的开关。</li>
<li><strong>tertiary</strong> VM-execution controls（64 bits），设置 HLAT 分页信息。</li>
</ul>
</li>
</ul>
</li>
<li>数据域：剩下的其余字段。</li>
</ul>
</div>



<p><img data-src="https://s2.loli.net/2023/04/20/a9zgWUMvuyibQZ6.png" alt="24.png"></p>
<h3 id="4-1-字段解释"><a href="#4-1-字段解释" class="headerlink" title="4.1 字段解释"></a>4.1 字段解释</h3><div class="note danger"><p>将 VM-execution control fields 分为<strong>控制域</strong>和数据域，控制域决定着对应的数据域中是否有数值。</p>
<ul>
<li>控制域：<ul>
<li><strong>Pin-Based</strong> VM-Execution Control（32 bits），设置异步事件来导致 VM-exit 的条件。</li>
<li><strong>Processor-Based</strong> VM-Execution Control<ul>
<li><strong>primary processor-based</strong> VM-execution controls（32 bits），设置同步事件来导致 VM-exit 的条件。</li>
<li><strong>secondary processor-based</strong> VM-execution controls（32 bits），设置 <code>Enable</code> 的开关。</li>
<li><strong>tertiary</strong> VM-execution controls（64 bits），设置 HLAT 分页信息。</li>
</ul>
</li>
</ul>
</li>
<li>数据域：剩下的其余字段。</li>
</ul>
</div>

<ol>
<li><p>Pin-Based VM-Execution Control（32 bits）</p>
<p><img data-src="https://s2.loli.net/2023/04/20/5AiHsl3fhDNxFdM.png" alt="25.png"></p>
</li>
<li><p><strong>Processor-Based</strong> VM-Execution Control</p>
<p>Processor-Based VM-Execution Control 包含以下三个字段：</p>
<ol>
<li><strong>primary processor-based</strong> VM-execution controls（32 bits），设置同步事件来导致 VM-exit 的条件。</li>
<li><strong>secondary processor-based</strong> VM-execution controls（32 bits），设置 <code>Enable</code> 的开关。</li>
<li><strong>tertiary</strong> VM-execution controls（64 bits），设置 HLAT 分页信息。</li>
</ol>
<p><img data-src="https://s2.loli.net/2023/04/25/o3rfOXAtRk4QTYg.png" alt="27.png"></p>
</li>
<li><p>以下数据域。</p>
<table>
<thead>
<tr>
<th>控制字段</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>Exception Bitmap</td>
<td>Exception Bitmap 是一个 32 bits 的字段，每一位对应一个中断号（例如 bit-14 对应 #PF 页面异常）。<br/>在 VMX non-root operation 中，如果发生异常，处理器会检查 Exception Bitmap 中 bit-INT Number 位是否为 1，如果为 1 则会产生 VM-exit，为 0 则会通过 Guest-IDT 执行对应的 ISR。<br/><strong>备注</strong>：如果需要进行 IDT Hook，则必须要注意对应的位。只有 32 bits，也就只能 Hook 前 32 个中断号对应的中断。</td>
</tr>
<tr>
<td>I&#x2F;O-Bitmap Addresses</td>
<td>包含两个 64KB 大小的物理地址（I&#x2F;O bitmaps A、I&#x2F;O bitmaps B。每个地位为 64bits）。<br/>当 primary processor-based VM-execution controls 中的 use I&#x2F;O bitmaps &#x3D; 1 时，使用该区域来存放 I&#x2F;O bitmaps 的地址，该地址指向相应的 64 KB（注意不是像 Exception Bitmap 直接存放数据）。<br/>I&#x2F;O bitmap 中的每个位对应一个 I&#x2F;O 地址，当位为 1 时，访问相应的位会产生 VM-exit。</td>
</tr>
<tr>
<td>Time-Stamp Counter offset and Multiplier</td>
<td>当 primary processor-based VM-execution controls 中的 use TSC offseting &#x3D; 1 时，当前字段提供一个 64 bits 的偏移值。<br/>启用后，使用 RDTSC、RDTSCP、RDMSR 等指令读取 TSC 时，返回的值为 TSC+TSC offset。<br/>该位启用的条件是：<br/>（1）use I&#x2F;O bitmaps &#x3D; 1<br/>（2）使用 RDTSC 指令时，RDTSC exiting &#x3D; 0<br/>（3）使用 RDTSCP 指令时，enable RDTSCP &#x3D; 1<br/>（4）使用 RDMSR 指令时，MSR read bitmap 相应的位为 0。</td>
</tr>
<tr>
<td>Guest&#x2F;Host Masks and Read Shadows for CR0 and CR4</td>
<td>用来保护 CR0、CR4 寄存器。共包含 4 个 natural-width 的字段。<br/>（1）CR0 奇存器的 guest&#x2F;host mask 与 read shadow 字段。<br/>（4）CR4 奇存器的 guest&#x2F;host mask 与 read shadow 字段。<br/>使用规则：<br/>guest&#x2F;host mask 中为 1 的位，表示属于 Host OS 所有，Guest OS 中不能将其修改。也就是说 Guest 从 read shadow 字段读出来的值，对应于 guest&#x2F;host mask 为 1 的位，不可以进行修改。否则将会导致 VM-exit。<img data-src="https://s2.loli.net/2023/05/09/aOG7n3AveCrzTLx.png" alt="39.png"><br />图片引自<a target="_blank" rel="noopener" href="https://revers.engineering/day-3-multiprocessor-initialization-error-handling-the-vmcs/">Day 3: The VMCS, Component Encoding, And Multiprocessor Initialization</a>。</td>
</tr>
<tr>
<td>CR3-Target Controls</td>
<td>包括 1 个 CR3-target count 字段（32 bits）与 4 个 CR3-target value 字段（natural-width，从 CR3 target value 0 到 CR3-target value 3 字段）。<br/>软件可以查询 <code>IA32_VMX_MISC[24:16]</code> 的值来获得支持 CR3-target value 的数量。<br/><strong>在 <code>CR3-load exiting = 1</code> 时</strong>，CR3-target count 与 CR3-target value 将决定写 CR3 寄存器是否会产生 VM-exit。以 CR3-target count 字段值作为 N（<code>N ≤ 4</code>）：<br/> （1）当向 CR3 写入的值<strong>等于</strong>这 N 个 CR3-target 值的其中一个时，<strong>不会</strong>产生 VM-exit。<br/> （2）当向 CR3 写入的值<strong>不等于</strong> N 个 CR3-target 值中的任何一个时，则<strong>会</strong>产生 VM-exit。</td>
</tr>
<tr>
<td>Controls for APIC Virtualization</td>
<td>当 <code>use TPR shadow = 1</code> 时，当前字段有效，需要提供一个物理地址作为 4K 的 virtual-APIC page 页面。<br/><strong>用来虚拟化 local APIC</strong>，包括以下字段：<br/>（1）APIC-access address (64 bits)<br/>（2）Virtual-APIC address (64 bits)<br/>（3）TPR threshold (32 bits)<br/>（4）EOI-exit bitmap (4 fields; 64 bits each)<br/>（5）Posted-interrupt notification vector (16 bits)<br/>（6）Posted-interrupt descriptor address (64 bits)</td>
</tr>
<tr>
<td><strong>MSR-Bitmap Address</strong></td>
<td>当 <strong>primary processor-based</strong> VM-execution controls（32 bits）中 <code>use MSR bitmaps = 1</code> 时，当 MSR bitmap 的某位为 1 时，<strong>访问该位所对应的 MSR 将产生 VM-exit</strong>。<br/>当前字段提供一个 64 bits 的物理地址，指向一个 4 个 1KB 大小的 MSR bitmap 区域。每一个位决定对应的 MSR 地址是否可读（RDMSR），或者是否可写（WRMSR）。<br/>（1）Read bitmap for low MSRs，表示可读的 MSR 地址范围为 <code>00000000H-00001FFFH</code>。<br>（2）Read bitmap for high MSRs，表示可读的 MSR 地址范围为 <code>C0000000H-C0001FFFH</code>。<br/>（3）Write bitmap for low MSRs，表示可写的 MSR 地址范围为 <code>00000000H-00001FFFH</code>。<br/>（4）Write bitmap for high MSRs，表示可写的 MSR 地址范围为 <code>C0000000H-C0001FFFH</code>。</td>
</tr>
<tr>
<td>Executive-VMCS Pointer</td>
<td>这个字段用于 SMM dual-monitor treatment（SMM 双重监控处理）机制下，当发生 SMM VM-exit 时，这个字段用来保存 executive-monitor 的 VMCS pointer。</td>
</tr>
<tr>
<td>Extended-Page-Table Pointer (EPTP)</td>
<td>在 <code>enable EPT = 1</code> 时，表示开启 EPT，指向 EPT PML4 table（类似于普通分页 CR3 指向 PLM4 页表）。<br /><img data-src="https://s2.loli.net/2023/04/20/wihJ6yTO4MGoScV.png" alt="28.png"></td>
</tr>
<tr>
<td>Virtual-Processor Identifier (VPID)</td>
<td>在 <code>enable VPID = 1</code> 时，该字段表示<strong>虚拟机标示符</strong>，16 bits。<br />（1）这个 VPID 用来标识虚拟处理器的 cache 域。<br />（2）处理器会在 cache 中维护 VPID 对应的一份 cache。<br />（3）如果每次 VM-entry 使用不同的 VPID 值，这样就为 VM 指定多个虚拟处理器 cache 域。<br />（4）另外，VMX 架构引入了 INVVPID 指令来刷新由 VPID 对应的 cache 信息。</td>
</tr>
<tr>
<td>Controls for PAUSE-Loop Exiting</td>
<td>功能的引进主要是解决在一个长时间的 spin lock（自旋锁）等待循环里浪费处理器的时间。在这个自旋锁等待循环里处理器可以产生 VM-exit， 从而去执行其他的任务。</td>
</tr>
<tr>
<td>VM-Function Controls</td>
<td>64 bits。用于管理 VMX non-operation 中 <code>VMFUNC</code> 指令的使用。在 <strong>secondary processor-based</strong> VM-execution controls 中 <code>Enable VM functions = 1</code> 时该字段才有效。<br/>VM-functions control 字段每个位对应一个 VM 功能号，最大功能号为 63。<code>VMFUNC</code> 指令执行时，VM 功能号提供在 EAX 奇存器中，当提供的功能号大于63 时，将产生 #UD 异常。<br/>在 VMX non-root operation 内执行 <code>VMFUNC</code> 指令时，如果使用的功能号在 VM functions control 字段相应位为 0，<strong>将产生 VM-exit</strong>。<br/>软件应该检查 <code>IA32_VMX_VMFUNC</code> 寄存器，确定支持哪个 VM 功能号。 <code>IA32_VMX_VMFUNC</code> 寄存器在  <code>enable VM functions = 1</code> 允许被置位下有效。<br/><img data-src="https://s2.loli.net/2023/04/20/k4qEh5ebQosKUpO.png" alt="29.png"></td>
</tr>
<tr>
<td>VMCS Shadowing Bitmap Addresses</td>
<td>在 VM-execution control 的 <code>VMCS shadowing = 1</code> 时当前字段才有效。该字段包含两个 64 bits 的物理地址：VMREAD bitmap address、VMWRITE bitmap address。每个 bitmap 都是 4KB 大小，</td>
</tr>
<tr>
<td>ENCLS-Exiting Bitmap</td>
<td>如果 <strong>secondary processor-based</strong> VM-execution controls 中 <code>Enable ENCLS exiting = 1</code> 时，如果 bitmap 为 1 的位对应的 EAX 中对应的位也为 1，则会产生 VM-exit。</td>
</tr>
<tr>
<td>ENCLV-Exiting Bitmap</td>
<td>如果 <strong>secondary processor-based</strong> VM-execution controls 中 <code>Enable ENCLV exiting = 1</code> 时，如果 bitmap 为 1 的位对应的 EAX 中对应的位也为 1，则会产生 VM-exit。</td>
</tr>
<tr>
<td>PCONFIG-Exiting Bitmap</td>
<td>如果 <strong>secondary processor-based</strong> VM-execution controls 中 <code>Enable PCONFIG = 1</code> 时，如果 bitmap 为 1 的位对应的 EAX 中对应的位也为 1，则会产生 VM-exit。</td>
</tr>
<tr>
<td>Control Field for Page-Modification Logging</td>
<td><strong>secondary processor-based</strong> VM-execution controls 中 <code>Enable PML = 1</code> 时，该字段才有效。它是页面修改日志的 4 KB 对齐地址。</td>
</tr>
<tr>
<td>Controls for Virtualization Exceptions</td>
<td><strong>secondary processor-based</strong> VM-execution controls 中 <code>Enable EPT-violation #VE = 1</code> 时，该字段才有效。包含以下两个信息：<br />（1）该字段表示虚拟化异常信息地址（64 bits）。当逻辑进程遇到虚拟化异常时，将虚拟化异常信息保存在虚拟化异常信息地址中（Virtualization-exception information address）。<br/>Virtualization-exception information address 是 Virtualization-exception information area 的地址。<br />（2）EPTP index。当  EPT violation 导致虚拟化异常时，处理器将此字段的值写入虚拟化异常信息区域。 EPTP-Switching VM 功能更新这个字段。</td>
</tr>
<tr>
<td>XSS-Exiting Bitmap</td>
<td><strong>secondary processor-based</strong> VM-execution controls 中 <code>Enable XSAVES/XRSTORS = 1</code> 时，该字段才有效。这两个指令的执行可能会参考该位图。</td>
</tr>
<tr>
<td>Sub-Page-Permission-Table Pointer (SPPTP)</td>
<td>如果启用了 EPT 的子页面写权限特性，则可以以 128 字节的粒度确定 EPT 写权限（参见第 28.3.4 节）。 这些权限是使用内存中的子页面权限结构的层次结构来确定的。</td>
</tr>
<tr>
<td>Fields Related to Hypervisor-Managed Linear-Address Translation</td>
<td><strong>tertiary</strong> VM-execution controls 中 <code>Enable HLAT = 1</code> 表示启用启用 HLAT 分页。当前字段表示分页转译相关信息。</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="4-2-字段填充"><a href="#4-2-字段填充" class="headerlink" title="4.2 字段填充"></a>4.2 字段填充</h3><h2 id="5-VM-entry-control-fields"><a href="#5-VM-entry-control-fields" class="headerlink" title="5 VM-entry control fields"></a>5 VM-entry control fields</h2><p>该区域中的字段控制着 VM-entry 时处理器对 Guest state area 区域操作的行为。在 VM-entry 时处理器会检查这些字段，如果检查不通过，则会产生 VMfailValid，在 VM-exit information fields 的 VM-instruction error field 中保存错误号。<br>包含三个区域：</p>
<ol>
<li>VM-entry Controls（32bits）</li>
<li>VM-entry Controls for MSRs（32bits）</li>
<li>VM-entry Controls for Event Injection<ul>
<li>VM-entry interruption-information field（32 bits）</li>
<li>VM-entry exception error code（32 bits）</li>
<li>VM-entry instruction length（32 bits）</li>
</ul>
</li>
</ol>
<p><img data-src="https://s2.loli.net/2023/04/21/pCcjZLun1gIseWP.png" alt="30.png"></p>
<div class="note success"><p>进行 VM-entry 操作时处理器会执行严格的检查，可以分为以下几个阶段。</p>
<ol>
<li>第一阶段：对 <code>VMLAUNCH</code> 或 <code>VMRESUME</code> 指令的执行进行基本检查。</li>
<li>第二阶段：对当前 VMCS 内的 VM-execution、VM-exit 以及 VM-entry 控制区域和 host-state 区域进行检查。</li>
<li>第三阶段：对当前 VMCS 内的 guest-state 区域进行检查，并加载 MSR。</li>
<li>在所有的检查都通过后，处理器从 guest-state 区域里加载处理器状态和执行环境信息。如果设置需要加载 MSR，则接着从 VM-entry MSR-load MSR 列表区域里加载 MSR。</li>
<li>VM-entry 操作附加动作会清由执行 <code>MONITOR</code> 指令而产生的地址监控，这个措施可以<strong>防止 guest 软件检测到自己处于虚拟机内</strong>。</li>
<li>在成功完成 VM-entry 后，如果注入了一个向量事件，则通过 guest-IDT 立即 deliver 这个向量事件执行。如果存在 pending debug exception 事件，则在注入事件完成后 deliver 一个 <code>#DB</code> 异常执行。</li>
</ol>
</div>

<div class="note info"><p>在整个 VM-entry 操作流程里，如果 VM-entry 失败可能产生以下三种结果：</p>
<ol>
<li><code>VMLAUNCH</code> 和 <code>VMRESUME</code> 指令<strong>产生异常</strong>（仅能产生 <code>#UD</code> 或 <code>#GP</code> 异常），从而执行相应的异常服务例程（如执行这两个指令的权限不够时会产生 <code>#GP</code> 异常）。《处理器虚拟化技术 P304》</li>
<li><code>VMLAUNCH</code> 和 <code>VMRESUME</code> 指令产生 <code>VMfailInvalid</code> 或 <code>VMfailValid</code> 类型失败，处理器接着执行下一条指令（Hypervisor 中）。</li>
<li><code>VMLAUNCH</code> 和 <code>VMRESUME</code> 指令的执行由于检查 guest-state 区域不通过，或者在加载 MSR 阶段失败而产生 VM-exit，从而转入 host-RIP 的入口点执行（进入VM-exit 处理函数）。</li>
</ol>
<p>更多具体的字段检查，详看《处理器虚拟化技术 P300》。</p>
</div>

<h3 id="5-1-字段解释"><a href="#5-1-字段解释" class="headerlink" title="5.1 字段解释"></a>5.1 字段解释</h3><p>类似于上面的 <em>VM-execution control fields</em> 字段一样，只要是 <em>Control Field</em> 都有<strong>控制域</strong>（前半部分）和<strong>数据域</strong>（后半部分）。</p>
<p><img data-src="https://s2.loli.net/2023/04/21/jAdhTQSmX2ZI5GN.png" alt="31.png"></p>
<div class="note success"><ul>
<li><code>bit 31</code> 是有效位，为 1 时指示 <code>VM-entry interuption information</code> 字段有效，为 0 时无无效。<code>bits 10:8</code> 设置事件类型，包括7 个事件类型，如表 3-10 所示。</li>
<li><code>bits 7:0</code> 设置中断或异常的向量号（IDT），当事件类型是NMI 时，向量号必须为2。事件类 型为 other 时，向量号必须为0值。</li>
<li><code>VM-entry interruption information</code> 字段 <code>bit 11 == 1</code> 时，指示有错误码需要提交。在注入事件 delivery 时，错误码会被压入栈中。<strong>这个位只有在注入硬件异常事件时才能被置 1</strong>，否则会产生 VMfailValid 失败。能产生错误码的硬件异常是：#DF，#TS，#NP，#SS，#GP，#PF 及 #AC 这 7 类。注入其余的硬件异常不能将此位置 1。</li>
</ul>
</div>

<div class="note danger"><p><strong>说明</strong>：事件注入机制目的是向 VM 中注入一个事件，使得每次 VM-entry 之后立即得到执行。而至于注入的事件会不会产生 VM-exit，需要根据注入事件（中断）类型查 <em>VM-execution Control</em> 等控制区域是否开启了对该类中断的监控，如果命中了就会产生 VM-exit（直接向量事件）。如果控制区域没有对注入的事件进行监控，那就不会马上产生 VM-exit，但是如果在中断&#x2F;异常分发的过程中产生了错误，那就会导致 VM-exit，这种 VM-exit 就叫做间接向量事件导致的 VM-exit。</p>
</div>

<p>中断和异常的区别：</p>
<table>
<thead>
<tr>
<th>中断&#x2F;异常类型</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>硬件中断</td>
<td>外部中断，使用 32~255 号中断。</td>
<td></td>
</tr>
<tr>
<td>硬件异常</td>
<td>（1）0~31 号中，<strong>除了 #BP 与 #OF 异常以外的所有异常</strong>。<br />（2）能产生 ErrorCode 的硬件异常：双重错误 (#DF)、无效 TSS (#TS)、段不存在 (#NP)、栈段错误 (#SS)、通用保护异常 (#GP)、页错误 (#PF)、对齐检查 (#AC)。</td>
<td>产生 ErrorCode 的硬件异常，要向堆栈压入错误码 ErrorCode</td>
</tr>
<tr>
<td>软件中断</td>
<td>软件中断指由 <code>INT</code> 指令执行的中断。</td>
<td>中断时需要进行段权限检查 CPL（在 delivery 期间）</td>
</tr>
<tr>
<td>软件异常</td>
<td>软件异常指由 <code>INT3</code> 与 <code>INTO</code> 指令产生的 #BP 与 #OF 异常。64 位模式下 <code>INTO</code> 指令是无效的。</td>
<td>中断时需要进行段权限检查 CPL（在 delivery 期间）</td>
</tr>
</tbody></table>
<h3 id="5-2-向量化事件"><a href="#5-2-向量化事件" class="headerlink" title="5.2 向量化事件"></a>5.2 向量化事件</h3><p>允许在 VM-entry 完成后，在执行任何 Guest 指令之前，处理器执行由 VMM 设置的注入的事件。这个事件可以是一个中断或异常，甚至 pending MTF VM-exit 事件，他们被称为<strong>向量化事件</strong>。而含有向量化事件的 VM-entry 被称为<strong>向量化的 VM-entry</strong>。</p>
<p>向量化事件通过 <code>VM-entry control fields</code> 区域的以下 3 个字段来进行设置。</p>
<ol>
<li><strong>VM-entry interruption-information field</strong>（32 bits）：设置中断或异常的中断向量号（IDT）、事件类型、事件有效位、错误码的 delivery 标志位。</li>
<li><strong>VM-entry exception error code</strong>（32 bits） ：当 <code>VM-entry interruption-information field bit 31 = 1</code> 时，注入的是硬件异常，且包含有 #DF、#TS、#NP、#SS、#GP、#PF、#AC 时才会产生错误码。因此只有注入这几个硬件异常时才需要提供错误码，对于其他异常或事件可以忽略该字段。</li>
<li><strong>VM-entry instruction length</strong>（32 bits）：当注入事件属于软件异常、软件中断以及特权级软件中断时，必须在这个字段提供注入的指令长度（指令长度一般在 <code>1~15</code> 之间，为 <code>0</code> 时会产生 VMfailValid 失败）。以便注入的事件引发 VM-exit 时能够在 VM-exit instruction length 找到这些指令的长度。</li>
</ol>
<h2 id="6-VM-exit-control-fields"><a href="#6-VM-exit-control-fields" class="headerlink" title="6 VM-exit control fields"></a>6 VM-exit control fields</h2><p>这些字段用来控制发生 VM-exit 时的处理器行为，决定如何进行 VM-exit 操作。</p>
<p>即在 VM-exit 时决定着如何保存和填充寄存器的值，以便在 VMM 中使用。</p>
<p>包含以下 3 个字段：</p>
<ol>
<li>VM-exit control 字段。</li>
<li>VM-exit MSR-store count 与 VM-exit MsR-store address 字段。</li>
<li>VM-exit MSR-load count 与 VM-exit MSR-load address 宇段。</li>
</ol>
<p><img data-src="https://s2.loli.net/2023/04/21/1bTCoXpl5Pa2ZSz.png" alt="33.png"></p>
<h3 id="6-1-字段解释"><a href="#6-1-字段解释" class="headerlink" title="6.1 字段解释"></a>6.1 字段解释</h3><table>
<thead>
<tr>
<th>字段</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>VM-exit control 字段</td>
<td>在 VM-exit 时决定着如何保存和填充寄存器的值。如下图。</td>
</tr>
<tr>
<td>VM-exit MSR-store count<br />VM-exit MSR-store address</td>
<td>VM-exit 时将相关 MSR 寄存器的值存储在 VM-exit MSR-store address 指向的对应区域中。</td>
</tr>
<tr>
<td>VM-exit MSR-load count<br />VM-exit MSR-load address</td>
<td>VM-exit 时从 VM-exit MSR-store address 指向的对应区域中加载值到 MSR 寄存器。<br />类似于 <em>VM-entry control fields</em>——<em>VM-entry Controls for MSRs</em>——<em>VM-entry MSR-load count（32 bits）</em> 和 <em>VM-entry MSR-load address（64 bits）</em>。</td>
</tr>
</tbody></table>
<p><img data-src="https://s2.loli.net/2023/04/21/b5pJln1uxq2AXIB.png" alt="32.png"></p>
<h3 id="6-2-字段填充"><a href="#6-2-字段填充" class="headerlink" title="6.2 字段填充"></a>6.2 字段填充</h3><h2 id="7-VM-exit-information-fields"><a href="#7-VM-exit-information-fields" class="headerlink" title="7  VM-exit information fields"></a>7  VM-exit information fields</h2><p>VMCS 的 VM-exit 信息类字段用来保存发生 VM-exit 事件的<strong>原因及明细信息</strong>，VMM 利用这些信息来决定如何管理和控制 VM。</p>
<p>VM-exit 信息类字段的 <em>VM-instruction error</em> 字段保存着 VMX 指令执行失败而发生 VMfailValid 的原因值。当VMX 指令发 VMfaillnvalid 失败时，不会产生错误原因值。</p>
<p><em>VM-exit information fields</em> 包含以下几类信息：</p>
<ol>
<li>Basic VM-Exit Information，基本信息类。</li>
<li>Information for VM Exits Due to Vectored Events，直接向量事件类。</li>
<li>Information for VM Exits That Occur During Event Delivery，间接向量事件类。</li>
<li>Information for VM Exits Due to Instruction Execution，指令信息类。</li>
<li>VM exits due to SMIS。</li>
<li>VM-Instruction Error Field，指令失败类。</li>
</ol>
<p><img data-src="https://s2.loli.net/2023/04/22/JjLCnwY84SMp9XW.png" alt="34.png"></p>
<p><strong>注意</strong>：一般 <em>VM-exit information fields</em> 是只读的，当 MSR <code>IA32_VMX_MISC[29](0x485) = 1</code> 表示可写。</p>
<p><img data-src="https://s2.loli.net/2024/01/21/H76mXoJYcPTKlIU.png" alt="37.png"></p>
<h3 id="7-1-基本信息类字段"><a href="#7-1-基本信息类字段" class="headerlink" title="7.1 基本信息类字段"></a>7.1 基本信息类字段</h3><p>基本信息类字段包括：</p>
<ul>
<li>Exit reason（32 bits）</li>
<li>Exit qualification（natural-width）</li>
<li>Guest-linear address（natural-width）</li>
<li>Guest-physical address（64 bits）</li>
</ul>
<div class="note danger"><p>如果我们需要输出 VM-exit 信息区域所有字段的信息，当根据 exit reason 字段值输出相应的 VM-exit 原因信息时，<strong>需要先检查 VM-exit instruction error 字段，确定 VMX 指令是成功的，然后再输出具体的 VM-exit 原因信息</strong>。</p>
</div>

<div class="note success"><p><strong>每类导致 VM-exit 的事件都对应一个原因编号</strong>，VMM 根据这个原因编号值来确定由什么事件导致 VM-exit 发生，再结合其余字段进一步提供的明细信息做出相应处理。</p>
<p>以下两个特殊值：</p>
<ul>
<li>VM-exit 原因码 0 值是有效的，它表示由异常或 NMI 导致的 VM exit。</li>
<li>VM-exit instruction error 字段的值为 0 时，表明 VMX 指令执行成功。</li>
</ul>
</div>

<ol>
<li><p><strong>Exit reason</strong>（32 bits）。32 位的 Exit reason 退出原因格式如下，<code>bit[15:0]</code> 具体指代原因见《Intel 卷3合集 24.9.1》 和《处理器虚拟化技术 3.10.1.2 VM-ext 原因》。</p>
<p><img data-src="https://s2.loli.net/2024/01/19/iCcaDZA4nSzMVEQ.png" alt="81.png"></p>
<div class="note primary"><p>由 VM-entry 失败而导致的 VM-exit 与在 guest 里产生的 VM-exit 的区分：</p>
<ul>
<li>exit reason 字段 <code>bits 31 = 1</code> 表示 VM-entry 失败而导致的 VM-exit。</li>
<li>exit reason 字段 <code>bits 31 = 0</code> 表示在 guest 里产生的 VM-exit。</li>
</ul>
<p><strong>备注</strong>：在每次 VM-exit 时，需要先检查 VM-exit instruction error 字段，确定 VMX 指令是成功的，然后再输出具体的 VM-exit 原因信息。</p>
</div>

<p>导致 VM-exit 发生的原因中，主要分无条件 VM-exit 与有条件 VM-exit 两大类。另外在 VMX non-root operation 模式中收到某些事件也会直接产生 VM-exit（例如 INIT， SMI，以及 SIPI 消息）。当 Guest 发生 triple fault 时，也会无条件地产生 VM-exit。</p>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>指令类</strong>导致 VM-exit</td>
<td>无条件指令类：<br />（1）所有 VMX 指令（除 VMFUNC 指令外）。<br />（2）CPUID，GETSEC，INVD，XSETBV 指令。<br /><br />有条件指令类：<br />取决于 <strong>primary processor-based</strong> VM-execution controls、<strong>secondary processor-based</strong> VM-execution controls 和 <strong>tertiary</strong> VM-execution controls 中设置的条件。例如当 <code>INVLPG exiting</code> 为 1 时，尝试执行 <code>INVLPG</code> 指令将导致 VM-exit。<br />HLT， INVLPG， INVPCID， RDPMC， RDTSC， RDTSCP，RSM，MOV from CR3，MOV to CR3，MOV from CR8，MOV to CR8，CLTS，LMSW，MOV to CRO，MOV to CR4，MOV-DR，IN&#x2F;OUT，INS&#x2F;OUTS，RDMSR，WRMSR，MWAIT，MONITOR，PAUSE，LGDT，LIDT，LLDT，LTR，SGDT，SIDT，SLDT，STR，RDRAND，WBINVD 指令。</td>
</tr>
<tr>
<td><strong>事件类</strong>导致 VM-exit</td>
<td>（1）<strong>primary processor-based</strong> VM-execution controls、<strong>secondary processor-based</strong> VM-execution controls 和 <strong>tertiary</strong> VM-execution controls 中设置的条件。如当发生异常时，异常向量号在 exception bitmap 对应的位为 1 时将引发 VM-exit。<br />比如：包括 <code>INT3</code> 和 <code>INTO</code> 指令引起的软件异常、<code>BOUND</code> 和 <code>UD2</code> 指令引起的硬件异常、对于 #PF 异常有些特殊，当 exception bitmap 的 bit 14 为 1，并且 <code>PFEC &amp; PFEC_MASK = PFEC_ MATCH</code>  时，#PF 异常会导致 VM-exit。<br />（2）注入机制中（<strong>VM-entry Controls</strong> for Event Injection）注入的事件导致的 VM-exit。<br />（3）三重错误（triple fault）。<br />（4）VM-entry 失败而导致的 VM-exit。不同于上面三种在 VMX non-root operation 模式下引发的，这种 VM-exit 是在 VMX root operation 模式下引发的，包括：<br />1、在检查 guest-state 区域的字段时，由于无效的 guest-state 字段而导致 VM-exit。<br />2、在加载 guest-state 区域的 MSR 时失败而导致 VM-exit。<br />3、在 VM-entry 期间可能由于遇到 machine-check 事件而失败导致 VM-exit。</td>
</tr>
</tbody></table>
</li>
<li><p>Exit qualification（natural-width 类型）。在 VM-exit 时，这个字段记录由于某些原因导致 VM-exit 的明细信息，具体内容见《处理器虚拟化技术 3.10.1.3》</p>
</li>
</ol>
<h3 id="7-2-直接与间接向量事件"><a href="#7-2-直接与间接向量事件" class="headerlink" title="7.2 直接与间接向量事件"></a>7.2 直接与间接向量事件</h3><p>这两个字段记录的是<strong>事件注入机制导致的 VM-exit</strong> 详细的信息。</p>
<ul>
<li>Information for VM Exits Due to Vectored Events，直接向量事件类。</li>
<li>Information for VM Exits That Occur During Event Delivery，间接向量事件类。</li>
</ul>
<h4 id="直接向量事件"><a href="#直接向量事件" class="headerlink" title="直接向量事件"></a>直接向量事件</h4><p>所谓的 <strong>直接向量事件</strong> 是指直接引发 VM-exit 的向量事件（<mark class="label danger">中断或异常没有机会得到 delivery 而直接 VM-exit</mark>）。主要包含以下 4 类：</p>
<ol>
<li>硬件异常。由于异常向量号（IDT 号）在 exception bitmap 对应的位为 <code>1</code> 而导致的 VM-exit。</li>
<li>软件异常（<code>#BP, #OF</code>）。由于异常向量号（IDT 号）在 exception bitmap 对应的位为 <code>1</code> 而导致的 VM-exit。</li>
<li>外部中断（硬件中断）。发生外部中断请求时，由于 <code>external-interrupt exiting = 1</code> 而直接导致的 VM-exit。</li>
<li>NMI。发生 NMI 请求时，由于 <code>NMI exiting = 1</code> 而直接导致的 VM-exit。</li>
</ol>
<p>注意：直接向量事件<strong>不包括软件中断和特权级软件中断</strong>（但是他们可以属于间接向量事件）。</p>
<ol>
<li><p>VM-exit interruption information（32 bits）。</p>
<p>32 bits 的 <code>VM-exit interruption information</code> 字段记录的是向量事件的 delivery 信息，格式如下图。注意：<code>VM-exit interruption information</code> 字段仅支持以上提到的硬件异常、软件异常（<code>#BP, #OF</code>）、外部中断（硬件中断）、NMI。<strong>这是因为 Guest 中不会因为软件中断和特权级软件中断而直接引发 VM-exit</strong>（只会在 delivery 的过程中引发）。</p>
<p>注意：bit 31 为 1 时，<em>VM-exit interruption information</em> 字段才有效。</p>
<p><img data-src="https://s2.loli.net/2024/01/21/r4ls2X9CB35vk6i.png" alt="84.png"></p>
<p>能产生错误码的硬件异常是：#DF，#TS，#NP，#SS，#GP，#PF 及 #AC 这 7 类。其他硬件异常、外部中断、NMI 及软件异常并不存在错误码。</p>
<p>注意：只有在<strong>异常直接导致 VM-exit 发生时</strong>，bit 12 才被置位，表示 IRET 指令执行</p>
<ul>
<li>如果 NMI 直接引发 VM-exit，NMI 不被 deliver 执行，也就不会解除阻塞状态。</li>
<li>但是，如果 <code>iret</code> 指令产生了一个异常，但这个异常并不直接引发 VM-exit，而后来由于异常 delivery 期间导致 VM-exit （间接引发），此时 <code>blocking by NMI</code> 阻塞状态已经被解除。</li>
</ul>
</li>
<li><p>VM-exit interruption error code（32 bits）。</p>
<p>如果 VM-exit 由硬件异常引发，当 <em>VM-exit interruption information</em> 字段的 bit 11 为 1 时，<em>VM-exit interruption error code</em> 字段记录异常的错误码。错误码仅存在于前面所述的 7 种硬件异常里，包括：#DF，#TS，#NP，#SS，#GP，#PF 及 #AC 异常。其他类型的事件 这个字段清为 0 值。</p>
</li>
</ol>
<h4 id="间接向量事件"><a href="#间接向量事件" class="headerlink" title="间接向量事件"></a>间接向量事件</h4><p>所谓的 <strong>间接向量事件</strong> 是指：当一个向量事件发生后它不直接产生 VM-exit，在通过 Guest-IDT delivery 期间由于遇到了某些错误而导致 VM-exit。</p>
<p>间接导致 VM-exit 的向量事件可以为：硬件异常、软件异常、软件中断、特权级软件中断、外部中断及 NMI、注入的向量化事件（因此，这个字段的中断类型也可以为软件中断或者特权级软件异常（由事件注入来实现））。</p>
<p>常见的间接向量事件：</p>
<ul>
<li>在向量事件 delivery 期间引发了一个异常，这个异常由于向量号在 exception bitmap 字段对应的位为 1 而导致 VM-exit（包括转变为 #DF 异常）。</li>
<li>在向量事件 delivery 期间引发连串异常，最终转变为 triple fault 而导致 VM-exit。</li>
<li>向量事件 delivery 期间由于向量号在 Guest-IDT 内对应的描述符为 task-gate 描述符，尝试进行任务切换而导致 VM-exit。</li>
<li>向量事件 delivery 期间访问了 APIC-access page 页面（包括线性访问和 guest-physical address 访问）而导致 VM-exit（在启用 <code>virtualize APIC-accesses</code> 功能时）。</li>
<li>向量事件在 delivery 期间发生了 EPT violation 或者 EPT misconfiguration 而导致 VM-exit（在启用 <code>enable EPT</code> 功能时）。</li>
</ul>
<ol>
<li><p><em>IDT-vectoring information</em> 字段（32 bits），只记录间接向量事件的信息，它与 <em>VM-exit interruption information</em> 字段极为相似。</p>
<p><img data-src="https://s2.loli.net/2024/01/21/qAu3OPCyv47DeEd.png" alt="85.png"></p>
<p>bit 11 为 1 时，表明间接向量事件存在错误码，只有 #DF，#TS，#NP，#SS，#GP，#PF， #AC 7 类硬件异常才会产生错误码。</p>
</li>
<li><p>IDT-vectoring error code 字段（32 bits）。它的作用和 <em>VM-exit interruption error code</em> 字段是一样的，所不同的是记录的向量事件对象不同。</p>
</li>
</ol>
<div class="note danger"><p><strong>说明</strong>：事件注入机制目的是向 VM 中注入一个事件，使得每次 VM-entry 之后立即得到执行。而至于注入的事件会不会产生 VM-exit，需要根据注入事件（中断）类型查 <em>VM-execution Control</em> 等控制区域是否开启了对该类中断的监控，如果命中了就会产生 VM-exit（<strong>直接</strong>向量事件）。如果控制区域没有对注入的事件进行监控，那就不会马上产生 VM-exit，但是如果在中断&#x2F;异常分发的过程中产生了错误，那就会导致 VM-exit，这种 VM-exit 就叫做<strong>间接</strong>向量事件导致的 VM-exit。</p>
</div>





<h3 id="7-3-指令信息类"><a href="#7-3-指令信息类" class="headerlink" title="7.3 指令信息类"></a>7.3 指令信息类</h3><p>Information for VM Exits Due to Instruction Execution 包含以下两个字段：</p>
<ul>
<li><p>VM-exit instruction length（32 bits），记录引起 VM-exit 指令的长度，指令长度在 1 到 15 之间。注意：如果软件异常，软件中断或者特权级软件中断是通过事件注入方式 deliver， 它们间接导致了 VM-exit 发生，那么，VM-exit instruction length 字段记录的指今长度等于 <em>VM-entry instruction length</em> 字段的值。</p>
<p>比如在 VM 中执行一个 <code>CPUID</code> 指令无条件导致 VM-exit，guest 中的 <code>CPUID</code> 的执行被 VMM 拦截，VMM 进行了虚拟化后（模拟执行该指令），然后返回一个虚拟化的结果给 guest。那么，VMM 重新进入VM 后，guest 应该从哪里开始执行呢？肯定不是指令本身。 guest 应该从引|起 VM-exit 的指令的下一条指令开始执行。这就是 <em>VM-exit instruction length</em> 字段的作用。所有指令类引起的 VM-exit 在 VM 中都是 fault 类型，也就是说：guest-state 区域的 guest-RIP 字段是指向引起 VM-exit 的指令的地址，<em>VM-exit instruction length</em> 字段保存这条指令的长度，VMM 在重新进入 VM 前，根据 <em>VM-exit instruction length</em> 字段的值来计算 guest 下一条指令的地址，然后设置 geust-RIP 字段的值。</p>
<p><code>新的 geust-RIP = geust-RIP + VM-exit instruction length</code>。</p>
</li>
<li><p>VM-exit instruction information（32 bits）。如果 VM-exit 是由下面的指令引起的：INS，OUTS，LGDT，LIDT，LLDT，LTR，SGDT，SIDT，SLDT，STR，RDRAND，INVPCID，INVEPT，INVVPID，VMCLEAR，VMPTRLD，VMPTRST，VMREAD，VMWRITE 以及 VMXON 指令，此时，<em>VM-exit qualification</em> 字段记录这些指令（除 INS&#x2F;OUTS 和 RDRAND 指令外）内存操作数的偏移量（参见 3.10.1.4 节），32 位宽的 <em>VM-exit instruction information</em> 字段进一步补充指令的明细信息。只有结合这两个字段才能够完整地分析指令信息，给 VMM 提供管理帮助。</p>
</li>
</ul>
<h3 id="7-4-指令错误类"><a href="#7-4-指令错误类" class="headerlink" title="7.4 指令错误类"></a>7.4 指令错误类</h3><p>当执行一条 VMX 指令时，如果发生 VMfailValid 失败，32 位的 <em>VM-instruetion error</em> 字段将记录指令的错误码。<strong>注意</strong>：如果 VMX 指令执行时产生异常，处理器会执行异常处理。此时，不会存在 VMfailValid 失败。</p>
<div class="note danger"><p>VMX 指令执行的结果（判断 rflags 的 CF 或 ZF）：</p>
<ol>
<li>执行成功：<strong>VMsuccess</strong>，指令会清所有的 rflags 寄存器标志位，例如 CF 与 ZF 标志。</li>
<li>执行失败：<ul>
<li><strong>VMfailInvalid</strong>，表示因 current-VMCS 指针无效或 VMCS 内的 ID 值是无效时而失败，失败原因不会被记录。</li>
<li><strong>VMfailValid</strong>，表示遇到某些原因而执行失败，失败原因记录在 <em>VM-exit instruction error</em> 字段。</li>
</ul>
</li>
</ol>
</div>

<div class="note info"><p>如果我们需要输出 VM-exit 信息区域所有字段的信息，当根据 exit reason 字段值输出相应的 VM-exit 原因信息时，<strong>需要先检查 VM-exit instruction error 字段，确定 VMX 指令是成功的，然后再输出具体的 VM-exit 原因信息</strong>。如果 VMX 指令执行失败则会产生 VMfailValid。</p>
</div>

<p>下表 2-5，列举了所有可能产生 VMfailValid 失败的原因，每个原因有唯一的指令错误码（<em>VM-instruetion error</em> 的值）。</p>
<p><img data-src="https://s2.loli.net/2023/04/22/er4vpafoyGRQMhP.png" alt="36.png"></p>
<p><strong>注意</strong>：上表是 如果 VMX 指令执行失败产生 VMfailValid 时对应的 <em>VM-instruetion error</em>。而 <strong>VMfaillnvalid</strong>：表示因 current-VMCS 指针无效而失败。当 current-VMCS 指针或 VMCS 内的 ID 值是无效时，VMX 指令会置 CF 标志位，指示执行失败。</p>
<h3 id="7-5-VM-exit-分类"><a href="#7-5-VM-exit-分类" class="headerlink" title="7.5 VM-exit 分类"></a>7.5 VM-exit 分类</h3><p>导致 VM-exit 发生的原因中，主要分<mark class="label success">无条件 VM-exit</mark>与<mark class="label warning">有条件 VM-exit</mark>两大类。另外在 VMX non-root operation 模式中收到某些事件也会直接产生 VM-exit（例如 INIT， SMI，以及 SIPI 消息）。当 guest 发生 triple fault 时，也会无条件地产生 VM-exit。</p>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>指令类</strong>导致 VM-exit</td>
<td>无条件指令类：<br />（1）所有 VMX 指令（除 VMFUNC 指令外）。<br />（2）CPUID，GETSEC，INVD，XSETBV 指令。<br /><br />有条件指令类：<br />取决于 <strong>primary processor-based</strong> VM-execution controls、<strong>secondary processor-based</strong> VM-execution controls 和 <strong>tertiary</strong> VM-execution controls 中设置的条件。例如当 <code>INVLPG exiting</code> 为 1 时，尝试执行 <code>INVLPG</code> 指令将导致 VM-exit。<br />HLT， INVLPG， INVPCID， RDPMC， RDTSC， RDTSCP，RSM，MOV from CR3，MOV to CR3，MOV from CR8，MOV to CR8，CLTS，LMSW，MOV to CRO，MOV to CR4，MOV-DR，IN&#x2F;OUT，INS&#x2F;OUTS，RDMSR，WRMSR，MWAIT，MONITOR，PAUSE，LGDT，LIDT，LLDT，LTR，SGDT，SIDT，SLDT，STR，RDRAND，WBINVD 指令。</td>
</tr>
<tr>
<td><strong>事件类</strong>导致 VM-exit</td>
<td>（1）<strong>primary processor-based</strong> VM-execution controls、<strong>secondary processor-based</strong> VM-execution controls 和 <strong>tertiary</strong> VM-execution controls 中设置的条件。如当发生异常时，异常向量号在 exception bitmap 对应的位为 1 时将引发 VM-exit。<br />比如：包括 <code>INT3</code> 和 <code>INTO</code> 指令引起的软件异常、<code>BOUND</code> 和 <code>UD2</code> 指令引起的硬件异常、对于 #PF 异常有些特殊，当 exception bitmap 的 bit 14 为 1，并且 <code>PFEC &amp; PFEC_MASK = PFEC_ MATCH</code>  时，#PF 异常会导致 VM-exit。<br />（2）注入机制中（<strong>VM-entry Controls</strong> for Event Injection）注入的事件导致的 VM-exit。<br />（3）三重错误（triple fault）。<br />（4）VM-entry 失败而导致的 VM-exit。不同于上面三种在 VMX non-root operation 模式下引发的，这种 VM-exit 是在 VMX root operation 模式下引发的，包括：<br />1、在检查 guest-state 区域的字段时，由于无效的 guest-state 字段而导致 VM-exit。<br />2、在加载 guest-state 区域的 MSR 时失败而导致 VM-exit。<br />3、在 VM-entry 期间可能由于遇到 machine-check 事件而失败导致 VM-exit。</td>
</tr>
</tbody></table>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>Buy me a coffee</div>
  <button onclick="document.querySelector('.post-reward').classList.toggle('active');">
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechat.jpg" alt="Catecat 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpg" alt="Catecat 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Catecat
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://directoree.github.io/post/Windows10-x64-hypervisor-2/" title="Hypervisor（二）：VMCS region">https://directoree.github.io/post/Windows10-x64-hypervisor-2/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/" rel="tag"><i class="fa fa-tag"></i> 虚拟化</a>
              <a href="/tags/VT-x/" rel="tag"><i class="fa fa-tag"></i> VT-x</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/Windows10-x64-hypervisor-1/" rel="prev" title="Hypervisor（一）：VMX 架构与 VMXON region">
                  <i class="fa fa-chevron-left"></i> Hypervisor（一）：VMX 架构与 VMXON region
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/Windows10-x64-hypervisor-3/" rel="next" title="Hypervisor（三）：虚拟化已运行的系统">
                  Hypervisor（三）：虚拟化已运行的系统 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Catecat</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">2.1m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">31:07</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1.15.0/dist/lozad.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  




  <script src="/js/local-search.js"></script>








<script data-pjax>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  const url = element.dataset.target;
  const pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  const pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  const fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script data-pjax>
if (document.querySelectorAll('.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8.7.0/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>





  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>








    <div class="pjax">
  

  
      <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//cdn.jsdelivr.net/npm/mathjax@3.1.0/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  
<script src="https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '70px',
  right: 'unset',
  left: '16px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#222',
  buttonColorLight: '#222',
  saveInCookies: false,
  label: '',
  autoMatchOsTheme: false
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
if (window.darkmode && !window.darkmode.isActivated()) {
  window.darkmode.toggle();
  var toggleButtons = document.getElementsByClassName("darkmode-toggle");
  if (toggleButtons && toggleButtons.length > 0) {
    for (i = 0; i < toggleButtons.length; i++) {
      toggleButtons[i].classList.add("darkmode-toggle--white");
    }
  }
}
</script>

<script>
NexT.utils.loadComments('#valine-comments', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    new Valine(Object.assign({"enable":true,"appId":"7zujCcS8pYH88CJXfdBlLyS8-gzGzoHsz","appKey":"lWGr7OPoNHo4v1YmVV5yr3E9","serverURLs":"https://7zujccs8.lc-cn-n1-shared.com","placeholder":"快来勾搭我呀🐶","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"lang":null,"visitor":true,"comment_count":true,"bg":"/images/comment_bg.png","recordIP":false,"enableQQ":false,"requiredFields":["nick"]}, {
      el: '#valine-comments',
      path: "/post/Windows10-x64-hypervisor-2/",
      serverURLs: "https://7zujccs8.lc-cn-n1-shared.com"
    }));
  }, window.Valine);
});
</script>

    </div>
</body>
</html>
