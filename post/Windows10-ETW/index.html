<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon1.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"directoree.github.io","root":"/","scheme":"Mist","version":"8.0.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="😄">
<meta property="og:type" content="article">
<meta property="og:title" content="Windows10 用户模式事件追踪（ETW）">
<meta property="og:url" content="https://directoree.github.io/post/Windows10-ETW/index.html">
<meta property="og:site_name" content="Catecat">
<meta property="og:description" content="😄">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/01/15/9JmV26HNTSaOfXd.png">
<meta property="og:image" content="https://s2.loli.net/2023/01/19/DzJw1RXy8ubgedN.png">
<meta property="og:image" content="https://s2.loli.net/2023/01/17/8xNFscRTb3oJCeD.png">
<meta property="og:image" content="https://s2.loli.net/2023/01/19/DzJw1RXy8ubgedN.png">
<meta property="article:published_time" content="2023-01-15T08:40:28.000Z">
<meta property="article:modified_time" content="2023-02-01T16:01:33.146Z">
<meta property="article:author" content="Catecat">
<meta property="article:tag" content="Windows内核">
<meta property="article:tag" content="ETW">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/01/15/9JmV26HNTSaOfXd.png">


<link rel="canonical" href="https://directoree.github.io/post/Windows10-ETW/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Windows10 用户模式事件追踪（ETW） | Catecat</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b832a9ae9a43377003fd975ca4e525ea";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Catecat</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">爱你所爱，行你所行，听从你心，无问西东。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/newcategories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-更新日志">

    <a href="/changelog" rel="section"><i class="fa fa-heartbeat fa-fw"></i>更新日志</a>

  </li>
        <li class="menu-item menu-item-空调房">

    <a href="/tips" rel="section"><i class="fa fa-wifi fa-fw"></i>空调房</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-ETW%E4%BB%8B%E7%BB%8D"><span class="nav-text">1 ETW介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-ETW-%E6%A1%86%E6%9E%B6"><span class="nav-text">2 ETW 框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Controllers"><span class="nav-text">Controllers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Providers"><span class="nav-text">Providers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Consumers"><span class="nav-text">Consumers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sessions"><span class="nav-text">Sessions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ETW-%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="nav-text">ETW 处理流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%BA%94%E7%94%A8%E5%B1%82-ETW"><span class="nav-text">3 应用层 ETW</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Providers-%E6%8F%90%E4%BE%9B%E4%BA%8B%E4%BB%B6"><span class="nav-text">4 Providers 提供事件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E6%B3%A8%E5%86%8C-x2F-%E6%B3%A8%E9%94%80-Providers"><span class="nav-text">4.1 注册&#x2F;注销 Providers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E6%8F%90%E4%BE%9B%E8%80%85%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="nav-text">4.2 提供者回调函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E5%86%99%E5%85%A5%E4%BA%8B%E4%BB%B6"><span class="nav-text">4.3 写入事件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Controllers-%E6%8E%A7%E5%88%B6%E4%BA%8B%E4%BB%B6%E8%B7%9F%E8%B8%AA%E4%BC%9A%E8%AF%9D"><span class="nav-text">5 Controllers 控制事件跟踪会话</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E9%85%8D%E7%BD%AE%E4%BC%9A%E8%AF%9D%E5%B1%9E%E6%80%A7"><span class="nav-text">5.1 配置会话属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E5%90%AF%E7%94%A8%E4%BC%9A%E8%AF%9D"><span class="nav-text">5.2 启用会话</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E5%90%AF%E7%94%A8-Providers"><span class="nav-text">5.3 启用 Providers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-%E5%81%9C%E6%AD%A2%E4%BC%9A%E8%AF%9D"><span class="nav-text">5.4 停止会话</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-%E7%B3%BB%E7%BB%9F%E8%AE%B0%E5%BD%95%E5%99%A8%EF%BC%88%E4%BC%9A%E8%AF%9D%EF%BC%89"><span class="nav-text">5.4 系统记录器（会话）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-%E9%85%8D%E7%BD%AE%E5%92%8C%E5%90%AF%E7%94%A8%E5%90%84%E7%B1%BB%E4%BC%9A%E8%AF%9D"><span class="nav-text">5.5 配置和启用各类会话</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Consumers-%E6%B6%88%E8%B4%B9%E4%BA%8B%E4%BB%B6"><span class="nav-text">6 Consumers 消费事件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-OpenTraceW-%E6%89%93%E5%BC%80%E4%BC%9A%E8%AF%9D"><span class="nav-text">6.1 OpenTraceW 打开会话</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-ProcessTrace-%E4%BC%A0%E9%80%92%E4%BA%8B%E4%BB%B6"><span class="nav-text">6.2  ProcessTrace 传递事件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E4%B8%A4%E4%B8%AA%E7%89%B9%E6%AE%8A%E4%BC%9A%E8%AF%9D"><span class="nav-text">7 两个特殊会话</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-ETW-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="nav-text">8 ETW 整体架构</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Catecat"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Catecat</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">143</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/newcategories/">
          
        <span class="site-state-item-count">63</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">81</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Directoree" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Directoree" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhao_yilong@aliyun.com" title="E-Mail → mailto:zhao_yilong@aliyun.com" rel="noopener" target="_blank"><i class="fas fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://sighttp.qq.com/msgrd?v=1&uin=1003432683" title="QQ → http:&#x2F;&#x2F;sighttp.qq.com&#x2F;msgrd?v&#x3D;1&amp;uin&#x3D;1003432683" rel="noopener" target="_blank"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://treecatee.github.io/" title="https:&#x2F;&#x2F;treecatee.github.io" rel="noopener" target="_blank">Treecatee</a>
        </li>
    </ul>
  </div>

      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://directoree.github.io/post/Windows10-ETW/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Catecat">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Catecat">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Windows10 用户模式事件追踪（ETW）
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-01-15 16:40:28" itemprop="dateCreated datePublished" datetime="2023-01-15T16:40:28+08:00">2023-01-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2023-02-02 00:01:33" itemprop="dateModified" datetime="2023-02-02T00:01:33+08:00">2023-02-02</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/x64%E5%86%85%E6%A0%B8/" itemprop="url" rel="index"><span itemprop="name">x64内核</span></a>
        </span>
    </span>

  
    <span id="/post/Windows10-ETW/" class="post-meta-item leancloud_visitors" data-flag-title="Windows10 用户模式事件追踪（ETW）" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/post/Windows10-ETW/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/post/Windows10-ETW/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>26k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>24 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>😄</p>
<span id="more"></span>

<h2 id="1-ETW介绍"><a href="#1-ETW介绍" class="headerlink" title="1 ETW介绍"></a>1 ETW介绍</h2><p>ETW（Event Tracing for Windows）利用<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/events/windows-events">事件机制（Event）</a>能够跟踪和记录由用户模式应用程序和内核模式驱动程序引发的事件。ETW 使用内核中实现的缓冲区和日志记录机制，提供对<strong>用户模式</strong>应用程序和<strong>内核模式</strong>设备驱动程序引发的事件的跟踪机制</p>
<p>通过 ETW 获取的信息非常丰富，通过 ETW 通常可以<a target="_blank" rel="noopener" href="https://renyili.org/post/etw_study/">获取到的信息</a>有：</p>
<ol>
<li>文件类信息，包括文件创建、删除、读写等信息。</li>
<li>注册表信息，包括注册表的创建、删除、读写等信息。</li>
<li>进程线程信息，包括进程创建退出、线程创建退出、模块加载等。</li>
<li>网络信息，TCP、UDP 协议的发送，接收 IP 地址以及数据长度等。</li>
<li>CPU 的使用情况、内存使用情况以及发生事件时的堆栈信息等。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/events/windows-events"><strong>关于事件 Event</strong></a>：</p>
<ul>
<li>Windows Vista 之前，可以使用事件跟踪（ETW）或事件日志来记录事件。</li>
<li>Windows Vista 及其之后，ETW 统一了以上两者，统一使用事件追踪 ETW。在 ETW 中，Windows 10 引入了 TraceLogging 的 ETW。</li>
</ul>
<p><strong>说明</strong>：ETW 事件追踪跟踪应用程序&#x2F;驱动程序，并不像是调试器附件进程那样，ETW 是<strong>非侵入式</strong>的进行监控。</p>
<h2 id="2-ETW-框架"><a href="#2-ETW-框架" class="headerlink" title="2 ETW 框架"></a>2 ETW 框架</h2><p>ETW 架构如下：</p>
<p><img data-src="https://s2.loli.net/2023/01/15/9JmV26HNTSaOfXd.png" alt="1.png"></p>
<p>ETW 包含三个组件：事件控制器（Controllers）、事件提供器（Providers）、事件消耗器（Consumers）。另外还包括会话（Sessions）。</p>
<ul>
<li>事件控制器（Controllers）：用于启动和停止事件跟踪会话并启用提供程序。</li>
<li>事件提供器（Providers）：用来产生事件。</li>
<li>事件消耗器（Consumers）：用来处理事件、消费事件。</li>
<li>会话（Sessions）：记录了一个或多个 Providers 输出的事件，其主要用来管理和刷新事件的缓存。</li>
</ul>
<h3 id="Controllers"><a href="#Controllers" class="headerlink" title="Controllers"></a>Controllers</h3><ul>
<li>定义日志文件的大小和位置。</li>
<li>设置日志是输出到文件还是实时解析。</li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/etw/controlling-event-tracing-sessions">启动和停止 Session</a>。</li>
<li>启用 Providers。</li>
</ul>
<h3 id="Providers"><a href="#Providers" class="headerlink" title="Providers"></a>Providers</h3><p>Providers 用来提供（产生）事件。当一个 Provider 注册后，可以通过 Controller 控制它是否输出事件。</p>
<p>Providers 程序共分为四类：</p>
<table>
<thead>
<tr>
<th>Providers 类型</th>
<th>系统</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td>MOF (经典) 提供程序</td>
<td>Windows 2000，Windows XP</td>
<td>1、使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntrace/nf-evntrace-registertraceguidsa">RegisterTraceGuids</a> 和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntrace/nf-evntrace-traceevent">TraceEvent</a> 函数注册和写入事件。 <br />2、使用 MOF 类定义事件，以便使用者知道如何使用这些事件。 <br />3、<strong>一次只能启用一个跟踪会话</strong>。</td>
</tr>
<tr>
<td>WPP 提供程序</td>
<td>Windows 2000，Windows XP</td>
<td>1、使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntrace/nf-evntrace-registertraceguidsa">RegisterTraceGuids</a> 和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntrace/nf-evntrace-traceevent">TraceEvent</a> 函数注册和写入事件。 <br />2、将关联的 TMF (编译为二进制文件的 .pdb) ，其中包含从预处理器扫描源代码中的 WPP 检测中推断出的解码信息。 <br />3、<strong>一次只能启用一个跟踪会话</strong>。</td>
</tr>
<tr>
<td>基于清单（manifest-based）的提供程序</td>
<td>Vista 新增</td>
<td>1、使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/Evntprov/nf-evntprov-eventregister">EventRegister</a> 和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/Evntprov/nf-evntprov-eventwrite">EventWrite</a> 注册和写入事件。 <br />2、 使用清单定义事件，以便使用者知道如何使用这些事件。  <br />3、<strong>最多可以同时启用 8 个跟踪会话</strong>。</td>
</tr>
<tr>
<td>TraceLogging 提供程序</td>
<td>Windows 10 新增</td>
<td>1、使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/traceloggingprovider/nf-traceloggingprovider-traceloggingregister">TraceLoggingRegister</a> 和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/traceloggingprovider/nf-traceloggingprovider-traceloggingwrite">TraceLoggingWrite</a> 注册和写入事件。 <br />2、使用自描述事件，使事件本身包含使用它们所需的所有信息。 <br />3、<strong>最多可以同时启用 8 个跟踪会话</strong>。</td>
</tr>
</tbody></table>
<h3 id="Consumers"><a href="#Consumers" class="headerlink" title="Consumers"></a>Consumers</h3><ul>
<li>可以同时接收多个 Session 的事件（系统按<strong>时间顺序</strong>传递事件）。</li>
<li>可以接收处理存储在日志文件中的事件，或是实时处理从 Session 获取的事件。</li>
</ul>
<h3 id="Sessions"><a href="#Sessions" class="headerlink" title="Sessions"></a>Sessions</h3><ul>
<li>由 Controllers 定义，Session 记录了一个或多个 Providers 输出的事件，其主要用来管理和刷新事件的缓存。</li>
<li>系统同时最多支持 64 个 Session（Windows 2000 仅支持 32 个事件跟踪会话），这些 Session 中<strong>有两个 Session 比较特殊</strong>，由操作系统直接定义，可直接使用，分别是：<ol>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/etw/configuring-and-starting-the-global-logger-session"><strong>全局记录器会话</strong></a>（<code>Global Logger Session</code>），它用来记录操作系统早期启动过程中的事件，例如设备驱动相关的事件。</li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/etw/configuring-and-starting-the-nt-kernel-logger-session"><strong>NT 内核记录器会话</strong></a>（<code>NT Kernel Logger Session</code>），它用来记录操作系统生成的预定义系统事件，例如磁盘 IO 或页面错误事件。</li>
</ol>
</li>
</ul>
<h3 id="ETW-处理流程"><a href="#ETW-处理流程" class="headerlink" title="ETW 处理流程"></a>ETW 处理流程</h3><p><img data-src="https://s2.loli.net/2023/01/19/DzJw1RXy8ubgedN.png" alt="3.png"></p>
<h2 id="3-应用层-ETW"><a href="#3-应用层-ETW" class="headerlink" title="3 应用层 ETW"></a>3 应用层 ETW</h2><p>本文介绍<mark class="label warning">应用层</mark>的 ETW，下一篇文章再介绍内核层的 ETW。</p>
<p>下面参考 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/etw/using-event-tracing">使用事件跟踪—MSDN</a>，以下主题介绍如何使用 ETW API 进行事件跟踪。</p>
<table>
<thead>
<tr>
<th align="left">主题</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/etw/controlling-event-tracing-sessions">控制事件跟踪会话</a></td>
<td align="left">介绍如何管理事件跟踪会话。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/etw/providing-events">提供事件</a></td>
<td align="left">介绍如何注册和检测事件跟踪提供程序。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/etw/consuming-events">使用事件</a></td>
<td align="left">介绍如何实现用于从跟踪日志文件或实时使用和处理事件的回调函数。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/etw/windows-software-trace-preprocessor">Windows软件跟踪预处理器</a></td>
<td align="left">提供一种有效的机制，用于记录和使用在应用程序或驱动程序执行过程中发生的事件。</td>
</tr>
</tbody></table>
<h2 id="4-Providers-提供事件"><a href="#4-Providers-提供事件" class="headerlink" title="4 Providers 提供事件"></a>4 Providers 提供事件</h2><p>Providers 程序共分为四类：</p>
<table>
<thead>
<tr>
<th>Providers 类型</th>
<th>系统</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td>MOF (经典) 提供程序</td>
<td>Windows 2000，Windows XP</td>
<td>1、使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntrace/nf-evntrace-registertraceguidsa">RegisterTraceGuids</a> 和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntrace/nf-evntrace-traceevent">TraceEvent</a> 函数注册和写入事件。 <br />2、使用 MOF 类定义事件，以便使用者知道如何使用这些事件。 <br />3、<strong>一次只能启用一个跟踪会话</strong>。</td>
</tr>
<tr>
<td>WPP 提供程序</td>
<td>Windows 2000，Windows XP</td>
<td>1、使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntrace/nf-evntrace-registertraceguidsa">RegisterTraceGuids</a> 和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntrace/nf-evntrace-traceevent">TraceEvent</a> 函数注册和写入事件。 <br />2、将关联的 TMF (编译为二进制文件的 .pdb) ，其中包含从预处理器扫描源代码中的 WPP 检测中推断出的解码信息。 <br />3、<strong>一次只能启用一个跟踪会话</strong>。</td>
</tr>
<tr>
<td>基于清单（manifest-based）的提供程序</td>
<td>Vista 新增</td>
<td>1、使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/Evntprov/nf-evntprov-eventregister">EventRegister</a> 和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/Evntprov/nf-evntprov-eventwrite">EventWrite</a> 注册和写入事件。 <br />2、 使用清单定义事件，以便使用者知道如何使用这些事件。  <br />3、<strong>最多可以同时启用 8 个跟踪会话</strong>。</td>
</tr>
<tr>
<td>TraceLogging 提供程序</td>
<td>Windows 10 新增</td>
<td>1、使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/traceloggingprovider/nf-traceloggingprovider-traceloggingregister">TraceLoggingRegister</a> 和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/traceloggingprovider/nf-traceloggingprovider-traceloggingwrite">TraceLoggingWrite</a> 注册和写入事件。 <br />2、使用自描述事件，使事件本身包含使用它们所需的所有信息。 <br />3、<strong>最多可以同时启用 8 个跟踪会话</strong>。</td>
</tr>
</tbody></table>
<p>如何将事件写入跟踪会话取决于提供程序的类型。</p>
<ul>
<li>有关 MOF 提供程序，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/etw/tracing-events">编写 MOF (经典) 事件</a>。</li>
<li>有关 WPP 提供程序，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/etw/windows-software-trace-preprocessor">编写 WPP 事件</a>。</li>
<li>有关 基于清单的 提供程序，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/etw/writing-manifest-based-events">编写基于清单的事件</a>。</li>
<li>有关 TraceLogging 提供程序，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/tracelogging/tracelogging-using-tracelogging">使用 TraceLogging</a>。</li>
</ul>
<p>本节以基于清单的事件进行介绍 Providers。</p>
<h3 id="4-1-注册-x2F-注销-Providers"><a href="#4-1-注册-x2F-注销-Providers" class="headerlink" title="4.1 注册&#x2F;注销 Providers"></a>4.1 注册&#x2F;注销 Providers</h3><p>每个进程理论上最多可以注册 1024 个提供程序 GUID；但是，<strong>应将每个进程注册的提供程序数限制为一两个</strong>。</p>
<p>ETW <mark class="label primary">通过 GUID 来标识系统中的 ETW 提供器</mark>。</p>
<p>提供器的使用顺序：注册提供器——将事件写入会话——卸载提供器。</p>
<blockquote>
<p> 本节以<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/etw/writing-manifest-based-events">基于清单的事件</a>进行介绍 Providers。</p>
</blockquote>
<p>若要注册基于清单的提供程序，请调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/Evntprov/nf-evntprov-eventregister">EventRegister</a> 函数。 该函数注册提供程序的 GUID，并在控制器启用或禁用提供程序时标识 ETW 调用的可选回调。</p>
<p><code>EventRegister</code> 函数：注册 ETW 事件提供程序，创建可用于写入 ETW 事件的句柄。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ULONG EVNTAPI <span class="title">EventRegister</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           LPCGUID         ProviderId,	</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] PENABLECALLBACK EnableCallback,	</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] PVOID           CallbackContext,	</span></span></span><br><span class="line"><span class="function"><span class="params">  [out]          PREGHANDLE      RegHandle		</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>ProviderId：标识提供程序的 GUID，唯一值。</li>
<li>EnableCallback：当跟踪会话启用或禁用此提供程序时，ETW 将调用的可选 EnableCallback 。 如果需要任何回调，请使用 NULL 。</li>
<li>CallbackContext：回调函数的参数。</li>
<li>RegHandle：输出值，提供程序的句柄，方便 EventWrite、 EventProviderEnabled 和 EventRegister 函数使用。</li>
</ul>
<p>返回值：如果成功 <strong>，</strong> 则返回 <code>ERROR_SUCCESS</code>。</p>
<p><code>EventUnregister</code> 函数：取消注册（即注销） ETW 事件提供程序。如果 DLL 注册事件提供程序，然后卸载而不注销事件提供程序，则进程可能会崩溃。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ULONG EVNTAPI <span class="title">EventUnregister</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] REGHANDLE RegHandle	<span class="comment">// EventRegister 返回的事件提供程序注册句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>返回值：如果成功 <strong>，</strong> 则返回 <code>ERROR_SUCCESS</code>。</p>
<h3 id="4-2-提供者回调函数"><a href="#4-2-提供者回调函数" class="headerlink" title="4.2 提供者回调函数"></a>4.2 提供者回调函数</h3><p>ETW 事件提供程序定义 <strong>EnableCallback</strong> 函数（可选）以接收配置更改通知。 回调函数调用时机：当跟踪会话<strong>启用或禁用此提供程序时</strong>，ETW 将调用的可选 EnableCallback 。</p>
<p><strong>PENABLECALLBACK</strong> 类型定义指向此回调函数的指针。 <strong>EnableCallback</strong> 是应用程序定义函数名称的占位符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PENABLECALLBACK Penablecallback;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Penablecallback</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           LPCGUID SourceId,	<span class="comment">// 提供者 GUID</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           ULONG IsEnabled,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           UCHAR Level,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           ULONGLONG MatchAnyKeyword,</span></span></span><br><span class="line"><span class="function"><span class="params">                 ULONGLONG MatchAllKeyword,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] PEVENT_FILTER_DESCRIPTOR FilterData,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] PVOID CallbackContext</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>IsEnabled：指示与此通知对应的 ControlCode。<ul>
<li>EVENT_CONTROL_CODE_DISABLE_PROVIDER(0)，禁用提供者。</li>
<li>EVENT_CONTROL_CODE_ENABLE_PROVIDER(1)，启用提供者。</li>
<li>EVENT_CONTROL_CODE_CAPTURE_STATE(2)，会话请求提供程序记录其状态信息。 提供程序通常通过编写包含提供程序状态的事件来响应。</li>
</ul>
</li>
<li>Level：该值指定提供程序应写入的事件的详细程度。</li>
<li>FilterData：指向具有事件提供程序筛选器数据的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntprov/ns-evntprov-event_filter_descriptor">EVENT_FILTER_DESCRIPTOR</a> 的指针。每个会话只能指定一个筛选器。 筛选器数据仅在回调中有效。</li>
</ul>
<h3 id="4-3-写入事件"><a href="#4-3-写入事件" class="headerlink" title="4.3 写入事件"></a>4.3 写入事件</h3><p>基于清单的提供程序调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/Evntprov/nf-evntprov-eventwrite">EventWrite</a> 或 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/Evntprov/nf-evntprov-eventwritestring">EventWriteString</a> 函数以将事件写入会话。</p>
<ul>
<li>如果事件数据是字符串，或者未为提供程序定义清单，并且事件数据是单个字符串，请调用 <code>EventWriteString</code> 函数以写入事件。</li>
<li>对于包含数值或复杂数据类型的事件数据，请调用 <code>EventWrite</code> 函数来记录事件。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ULONG EVNTAPI <span class="title">EventWrite</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           REGHANDLE              RegHandle,		<span class="comment">// 提供程序的注册句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           PEVENT_DESCRIPTOR      EventDescriptor,	<span class="comment">// 用来描述事件的属性（元数据）</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in]           ULONG                  UserDataCount,		<span class="comment">// 参数 4 的个数</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in, optional] PEVENT_DATA_DESCRIPTOR UserData		<span class="comment">// 该结构用来描述事件内容</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<ul>
<li>成功，ERROR_SUCCESS。</li>
<li>失败，返回<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntprov/nf-evntprov-eventwrite">错误码</a>。</li>
</ul>
<p>下面介绍非常重要的 <code>EVENT_DESCRIPTOR</code>、<code>EVENT_DATA_DESCRIPTOR</code> 结构。</p>
<ul>
<li><code>EVENT_DESCRIPTOR</code>：主要用来描述事件相关的属性（元数据）。</li>
<li><code>EVENT_DATA_DESCRIPTOR</code>：主要用来描述事件包含的内容。</li>
</ul>
<p><code>EVENT_DESCRIPTOR</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EVENT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">  USHORT    Id;		<span class="comment">// 标志基于清单的事件（使用16个数字）</span></span><br><span class="line">  UCHAR     Version;	<span class="comment">// 指定基于清单的事件的版本（8个数字）</span></span><br><span class="line">  UCHAR     Channel;	<span class="comment">// 启用特殊事件处理的 8 位数字</span></span><br><span class="line">  UCHAR     Level;	<span class="comment">// 描述事件的严重性或重要性的 8 位数字</span></span><br><span class="line">  UCHAR     Opcode;	<span class="comment">// 用于标记具有特殊语义的事件的 8 位数字</span></span><br><span class="line">  USHORT    Task;	<span class="comment">// 用于批注事件或相关事件组的 16 位数字</span></span><br><span class="line">  ULONGLONG Keyword;	<span class="comment">// 一个 64 位掩码，用于指示一组事件类别中的事件成员身份</span></span><br><span class="line">&#125; EVENT_DESCRIPTOR, *PEVENT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<p><code>EVENT_DATA_DESCRIPTOR</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EVENT_DATA_DESCRIPTOR</span> &#123;</span></span><br><span class="line">  ULONGLONG Ptr;	<span class="comment">// 指向数据的指针</span></span><br><span class="line">  ULONG     Size;	<span class="comment">// 数据的大小（以字节为单位）</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    ULONG Reserved;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      UCHAR  Type;	<span class="comment">// 在事件中使用此数据，表示时间类型</span></span><br><span class="line">      UCHAR  Reserved1;	<span class="comment">// 未使用, 设置为 0</span></span><br><span class="line">      USHORT Reserved2;	<span class="comment">// 未使用, 设置为 0</span></span><br><span class="line">    &#125; DUMMYSTRUCTNAME;</span><br><span class="line">  &#125; DUMMYUNIONNAME;</span><br><span class="line">&#125; EVENT_DATA_DESCRIPTOR, *PEVENT_DATA_DESCRIPTOR;</span><br></pre></td></tr></table></figure>



<div class="note default"><p><code>EVENT_DATA_DESCRIPTOR</code> 的用法：</p>
<p>一般会在程序中定义一个 <code>EVENT_DATA_DESCRIPTOR[MAXLENTH]</code> 数组，<code>EVENT_DATA_DESCRIPTOR[i].Ptr</code> 指针指向与该结构相关的数据。一般可以直接手动给 <code>EVENT_DATA_DESCRIPTOR</code> 结构赋值，但是通常使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntprov/nf-evntprov-eventdatadesccreate">EventDataDescCreate</a> 函数来对该结构进行初始化。</p>
</div>

<p>用法参考<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/etw/writing-manifest-based-events">编写基于清单的事件</a>。</p>
<h2 id="5-Controllers-控制事件跟踪会话"><a href="#5-Controllers-控制事件跟踪会话" class="headerlink" title="5 Controllers 控制事件跟踪会话"></a>5 Controllers 控制事件跟踪会话</h2><p>控制事件跟踪会话由 Controllers 来完成，主要分为会话<mark class="label danger">配置</mark>和<mark class="label success">启动</mark>。</p>
<ul>
<li>配置：<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntrace/ns-evntrace-event_trace_properties">EVENT_TRACE_PROPERTIES</a> 结构指定会话的属性，填充该结构。</li>
<li>启动：<ul>
<li>启动会话，调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntrace/nf-evntrace-starttracea">StartTrace</a> 函数。</li>
<li>启动 Providers，调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntrace/nf-evntrace-enabletrace">EnableTrace</a> 或 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntrace/nf-evntrace-enabletraceex">EnableTraceEx</a> 函数。</li>
</ul>
</li>
</ul>
<h3 id="5-1-配置会话属性"><a href="#5-1-配置会话属性" class="headerlink" title="5.1 配置会话属性"></a>5.1 配置会话属性</h3><p><img data-src="https://s2.loli.net/2023/01/17/8xNFscRTb3oJCeD.png" alt="2.png"></p>
<p>会话属性 <code>EVENT_TRACE_PROPERTIES</code> 配置时，要注意：</p>
<ul>
<li>WNODE_HEADER 指定：<ul>
<li><code>BufferSize = sizeof(EVENT_TRACE_PROPERTIES) + sizeof(LOGFILE_PATH) + sizeof(KERNEL_LOGGER_NAME)</code>。</li>
<li>Guid：<ul>
<li>SystemTraceControlGuid，<strong>NT 内核记录器会话</strong>。</li>
<li>SystemTraceControlGuid 或 GlobalLoggerGuid，<mark class="label danger">系统记录器</mark>。</li>
</ul>
</li>
<li>ClientContext：<ul>
<li>1，查询性能计数器 (QPC) 。</li>
<li>2，系统时间。</li>
<li>3，CPU 周期计数器。</li>
</ul>
</li>
<li>Flags：WNODE_FLAG_TRACED_GUID。</li>
</ul>
</li>
<li>LogFileMode（指定日志输出的模式，输出到日志文件、缓冲区、实时输出）：请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/etw/logging-mode-constants">日志记录模式常量</a>。</li>
<li>EnableFlags：指示跟踪<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntrace/ns-evntrace-event_trace_properties">哪种类型的事件</a>。EnableFlags <strong>仅适用于系统记录器</strong>（以下属性都必须设置）：<ul>
<li><strong>LogFileMode 包含 EVENT_TRACE_SYSTEM_LOGGER_MODE</strong>。</li>
<li>会话名称 &#x3D; KERNEL_LOGGER_NAME（已弃用 - 不应用于新代码，因为它与其他还尝试使用这些 GUID 的组件冲突）</li>
<li><strong>WNODE_HEADER.Guid &#x3D; SystemTraceControlGuid</strong></li>
<li>WNODE_HEADER.Guid &#x3D; GlobalLoggerGuid（已弃用 - 不应用于新代码，因为它与其他还尝试使用这些 GUID 的组件冲突）。</li>
</ul>
</li>
<li>LoggerNameOffset：偏移量，<strong>会话名称</strong>的字符存储的位置的偏移（相对于 EVENT_TRACE_PROPERTIES 结构）。<ul>
<li>通常取值：<code>sizeof(EVENT_TRACE_PROPERTIES)</code></li>
</ul>
</li>
<li>LogFileNameOffset：偏移量，<strong>日志文件名称</strong>的字符存储的位置的偏移（相对于EVENT_TRACE_PROPERTIES结构）。<ul>
<li>日志文件名限制为 1024 个字符，LogFileMode &#x3D; EVENT_TRACE_REAL_TIME_MODE 时，LogFileNameOffset &#x3D; 0</li>
<li>通常取值：<code>sizeof(EVENT_TRACE_PROPERTIES) + sizeof(KERNEL_LOGGER_NAME)</code></li>
</ul>
</li>
</ul>
<h3 id="5-2-启用会话"><a href="#5-2-启用会话" class="headerlink" title="5.2 启用会话"></a>5.2 启用会话</h3><p><strong>StartTrace</strong> 函数注册并启动事件跟踪会话。</p>
<p>指定会话的属性后，调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntrace/nf-evntrace-starttracea">StartTrace</a> 函数以启动会话。 如果函数成功， <em>SessionHandle</em> 参数将包含会话句柄， 而 <strong>LoggerNameOffset</strong> 属性将包含会话名称的偏移量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ULONG WMIAPI <span class="title">StartTraceW</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [out]     PTRACEHANDLE            TraceHandle,	</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]      LPCWSTR                 InstanceName,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, out] PEVENT_TRACE_PROPERTIES Properties</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><p>TraceHandle：接收会话的句柄，以便随后与 <code>ControlTrace</code> 等 API 一起使用。</p>
</li>
<li><p>InstanceName：包含事件跟踪会话名称的以 Null 结尾的字符串。 会话名称限制为 1024 个字符，不区分大小写，并且必须是唯一的。</p>
<p>此函数将 <code>InstanceName</code> 指定的会话名称复制到 <code>EVENT_TRACE_PROPERTIES.LoggerNameOffset</code> 成员指向的偏移量的内存中。</p>
</li>
<li><p>Properties：指向指定会话行为的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntrace/ns-evntrace-event_trace_properties">EVENT_TRACE_PROPERTIES</a> 结构的指针。 以下是要设置的结构的关键成员：</p>
<ul>
<li><strong>Wnode.BufferSize</strong></li>
<li><strong>Wnode.Guid</strong></li>
<li><strong>Wnode.ClientContext</strong></li>
<li><strong>Wnode.Flags</strong></li>
<li>LogFileMode</li>
<li>LogFileNameOffset</li>
<li>LoggerNameOffset</li>
</ul>
</li>
</ul>
<p>返回值：</p>
<ul>
<li>成功，返回值为 ERROR_SUCCESS。</li>
<li>失败，参见<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntrace/nf-evntrace-starttracew">一些常见错误及其原因</a>。</li>
</ul>
<div class="note danger"><p>当函数 <code>StartTraceW</code> 开启会话之后，<code>EVENT_TRACE_PROPERTIES</code> 中的 <code>OUT</code> 成员就被赋值了。</p>
</div>

<div class="note success"><p><strong>不使用此函数启动全局记录器会话</strong> (已弃用) 。 有关启动全局记录器会话的详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/etw/configuring-and-starting-the-global-logger-session">配置和启动全局记录器会话</a>。</p>
</div>

<p>若要在收集事件后停止跟踪会话，请调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntrace/nf-evntrace-controltracew">ControlTrace</a> 函数，并将 <code>EVENT_TRACE_CONTROL_STOP</code> 作为控制代码传递。 </p>
<p>若要指定要停止的会话，可以将从之前调用 StartTrace 函数获取的事件跟踪会话句柄或之前启动的会话的名称传递。 <strong>在停止会话之前，请务必禁用所有提供程序</strong>。 如果在首次禁用提供程序之前停止会话，ETW 将禁用提供程序，并尝试调用提供程序的控制回调函数。 如果启动会话的应用程序在未禁用提供程序或调用 ControlTrace 函数的情况下结束，<strong>则提供程序将保持启用状态</strong>。</p>
<h3 id="5-3-启用-Providers"><a href="#5-3-启用-Providers" class="headerlink" title="5.3 启用 Providers"></a>5.3 启用 Providers</h3><ul>
<li>MOF经典的Providers：使用函数  EnableTrace 。 </li>
<li>基于清单的 Providers：使用函数  EnableTraceEx 。 </li>
<li>会话筛选的Providers：调用函数 EnableTraceEx2。</li>
</ul>
<p>实例： </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/etw/example-that-creates-a-session-and-enables-a-manifest-based-provider">创建会话并启用基于清单的提供程序的示例</a></li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/etw/configuring-and-starting-the-nt-kernel-logger-session">配置和启动 NT 内核记录器会话</a></li>
</ul>
<h3 id="5-4-停止会话"><a href="#5-4-停止会话" class="headerlink" title="5.4 停止会话"></a>5.4 停止会话</h3><p><strong>ControlTrace</strong> 函数刷新、查询、更新或停止指定的事件跟踪会话。</p>
<p>若要停止事件跟踪会话，请调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntrace/nf-evntrace-controltracew">ControlTrace</a> 函数并将 <em>ControlCode</em> 参数设置为 <code>EVENT_TRACE_CONTROL_STOP</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ULONG WMIAPI <span class="title">ControlTraceW</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]      TRACEHANDLE             TraceHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]      LPCWSTR                 InstanceName,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, out] PEVENT_TRACE_PROPERTIES Properties,</span></span></span><br><span class="line"><span class="function"><span class="params">  [in]      ULONG                   ControlCode</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><p>TraceHandle：事件跟踪会话的句柄，或 0。如果 <em>InstanceName</em> 为 <strong>NULL</strong>，则必须指定非零 <em>TraceHandle</em>。 如果 <em>InstanceName</em> 不为 <strong>NULL</strong>，ETW 将忽略句柄。</p>
</li>
<li><p>InstanceName：事件跟踪会话的名称，或 <strong>NULL</strong>。 如果 <em>TraceHandle</em> 为 0，则必须指定 <em>InstanceName</em>。</p>
<p>若要指定 NT 内核记录器会话，请将 <em>InstanceName</em> 设置为 <strong>KERNEL_LOGGER_NAME</strong>。</p>
</li>
<li><p>Properties：指向初始化 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntrace/ns-evntrace-event_trace_properties">EVENT_TRACE_PROPERTIES</a> 结构的指针。在设置任何字段之前，此结构应为零。</p>
<p>该参数中传递给 <code>ControlTraceW</code> 函数前成员的设置，取决于参数 <code>ControlCode</code>。</p>
<ol>
<li>如果 <em>ControlCode</em> 指定EVENT_TRACE_CONTROL_STOP、EVENT_TRACE_CONTROL_QUERY或EVENT_TRACE_CONTROL_FLUSH，则只需设置<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntrace/ns-evntrace-event_trace_properties">EVENT_TRACE_PROPERTIES</a>结构的 Wnode.BufferSize、Wnode.Guid、LoggerNameOffset 和 LogFileNameOffset 成员。</li>
<li>如果 ControlCode 在输入中指定 EVENT_TRACE_CONTROL_UPDATE，则成员必须为要更新的属性指定新值。 在输出中， 属性 包含事件跟踪会话的属性和统计信息。 可以更新以下属性：EnableFlags、FlushTimer、LogFileNameOffset、LogFileMode、MaximumBuffers。</li>
</ol>
</li>
<li><p>ControlCode：请求的控制函数。 可以指定以下值之一：</p>
<ul>
<li><p>EVENT_TRACE_CONTROL_FLUSH：刷新会话的活动缓冲区。</p>
<p>这可与内存中会话一起使用， (从 <strong>EVENT_TRACE_BUFFERING_MODE</strong> 标志开始的会话) ，以便将数据从跟踪写入文件。</p>
<p>通常不需要刷新基于文件的会话或实时会话，因为 ETW 会在缓冲区满 (时自动刷新缓冲区，即当它没有下一个事件空间) 、跟踪会话的 FlushTimer 过期或跟踪会话关闭时。</p>
<p><strong>Windows 2000：</strong> 不支持此值。</p>
</li>
<li><p>EVENT_TRACE_CONTROL_QUERY：检索会话属性和统计信息。</p>
</li>
<li><p>EVENT_TRACE_CONTROL_STOP：停止会话。 会话句柄不再有效。</p>
</li>
<li><p>EVENT_TRACE_CONTROL_UPDATE：汇报会话属性。</p>
</li>
<li><p>EVENT_TRACE_CONTROL_INCREMENT_FILE：如果会话具有 <code>EVENT_TRACE_FILE_MODE_NEWFILE</code>，请更新会话以立即切换到下一个文件，而不是等待前一个文件填充。 从Windows 10 2018 年 10 月更新开始支持。</p>
</li>
<li><p>EVENT_TRACE_CONTROL_CONVERT_TO_REALTIME：将文件模式会话更改为实时会话 (启用实时传送，并禁用将事件写入 ETL 文件) 。 从 2020 年 10 月更新Windows 10开始支持。</p>
</li>
</ul>
</li>
</ul>
<p><strong>注意</strong>：DllMain 中刷新缓冲区或停止  (跟踪会话可能会导致死锁) 是不安全的。</p>
<p>返回值：</p>
<ul>
<li>成功，返回值为 ERROR_SUCCESS。</li>
<li>失败，参见<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntrace/nf-evntrace-starttracew">一些常见错误及其原因</a>。</li>
</ul>
<h3 id="5-4-系统记录器（会话）"><a href="#5-4-系统记录器（会话）" class="headerlink" title="5.4 系统记录器（会话）"></a>5.4 系统记录器（会话）</h3><p>参考 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntrace/nf-evntrace-starttracew">StartTraceW</a> 函数。下面所说的<strong>记录器（Logger）实际上就是会话</strong>。</p>
<p>要使记录器成为系统记录器并从 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/ETW/configuring-and-starting-a-systemtraceprovider-session">SystemTraceProvider</a> 或其他 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/etw/system-providers">系统提供程序</a>接收事件，以下任一项都必须为 true：</p>
<ul>
<li><code>Properties.LogFileMode = EVENT_TRACE_SYSTEM_LOGGER_MODE</code>。</li>
<li><em>属性</em>成员 <strong>Wnode.Guid</strong> 设置为 <strong>SystemTraceControlGuid</strong> 或 <strong>GlobalLoggerGuid</strong> (已弃用 - 不应用于新代码，因为它与其他还尝试使用这些 GUID 的组件冲突) 。</li>
<li><em>InstanceName</em> 设置为 <strong>KERNEL_LOGGER_NAME</strong> (弃用 - 不应用于新代码，因为它与其他组件冲突，这些组件也会尝试使用此名称) 。</li>
</ul>
<p>系统记录器必须设置<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntrace/ns-evntrace-event_trace_properties">EVENT_TRACE_PROPERTIES</a>结构的 <strong>EnableFlags</strong> 成员，以指示跟踪中应包含哪些 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/etw/configuring-and-starting-a-systemtraceprovider-session">SystemTraceProvider</a> 事件。</p>
<p>由于<mark class="label warning">系统记录器接收特殊内核事件</mark>，因此它们受到其他限制：</p>
<ul>
<li>同一系统上的系统记录器不能超过 8 个。</li>
<li>无法在 Windows Server 容器中创建系统记录器。</li>
<li>系统记录器不能使用 <strong>EVENT_TRACE_USE_PAGED_MEMORY</strong> 标志。</li>
<li>在 Windows 10 版本 1703 之前，任何系统记录器都可以同时使用 2 个不同的时钟类型。 例如，如果一个活动系统记录器使用“CPU 周期计数器”时钟类型，而另一个活动系统记录器使用的是“查询性能计数器”时钟类型，则任何使用“系统时间”时钟类型启动系统记录器的尝试都将失败，因为它需要激活第三个时钟类型。 由于此限制，Microsoft 强烈建议系统记录器不使用“系统时间”时钟类型。</li>
<li>从 Windows 10 版本 1703 开始，已删除时钟类型限制。 所有三种时钟类型现在都可以由系统记录器同时使用。</li>
</ul>
<p>若要指定 NT 内核记录器会话 (已弃用) ，请将 <em>InstanceName</em> 设置为 <strong>KERNEL_LOGGER_NAME</strong>，并将<em>属性</em>的 <strong>Wnode.Guid</strong>成员设置为 <strong>SystemTraceControlGuid</strong>。 如果未将 GUID 指定为 <strong>SystemTraceControlGuid</strong>，ETW 将重写 GUID 值并将其设置为 <strong>SystemTraceControlGuid</strong>。</p>
<p><strong>Windows 2000：</strong> 若要启动内核会话，会话名称必须 <strong>KERNEL_LOGGER_NAME</strong> ，GUID 必须是 <strong>SystemTraceControlGuid</strong>。</p>
<h3 id="5-5-配置和启用各类会话"><a href="#5-5-配置和启用各类会话" class="headerlink" title="5.5 配置和启用各类会话"></a>5.5 配置和启用各类会话</h3><ul>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/etw/configuring-and-starting-a-systemtraceprovider-session">配置和启动 SystemTraceProvider 会话</a></li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/etw/configuring-and-starting-an-autologger-session">配置和启动 AutoLogger 会话</a></li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/etw/configuring-and-starting-a-private-logger-session">配置和启动专用记录器会话</a></li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/etw/updating-an-event-tracing-session">更新事件跟踪会话</a></li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/etw/retrieving-additional-event-tracing-data">检索其他事件跟踪数据</a></li>
</ul>
<h2 id="6-Consumers-消费事件"><a href="#6-Consumers-消费事件" class="headerlink" title="6 Consumers 消费事件"></a>6 Consumers 消费事件</h2><p>ETW 消耗器在接收 ETW 消息前，必须使用 <code>OpenTrace</code> 打开一个 <code>etl</code> 文件（文件模式） 或实时的 ETW 会话（实时模式），同时注册自己用于接收消息的回调函数。</p>
<p>Consumers 可以从日志文件或实时处理事件，处理模式由 <code>EVENT_TRACE_LOGFILEA.LogFileName/LoggerName</code> 来指定。</p>
<p>Consumers 消费事件大致过程：</p>
<ol>
<li><code>OpenTrace</code> 打开会话，获得会话句柄 <code>TRACEHANDLE</code>；</li>
<li><code>ProcessTrace</code> 从会话将事件传递给消费者；</li>
<li>使用<code>CloseTrace</code> 函数关闭使用 <code>OpenTrace</code> 打开的跟踪处理会话。</li>
<li><code>EventRecordCallback/EventCallback/BufferCallback</code> 接收事件。</li>
</ol>
<p><img data-src="https://s2.loli.net/2023/01/19/DzJw1RXy8ubgedN.png" alt="3.png"></p>
<div class="note danger"><p><strong>注意</strong>：ProcessTrace 函数会让线程线程阻塞，直到它传递所有事件、<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntrace/nc-evntrace-pevent_trace_buffer_callbacka">BufferCallback</a> 函数返回 <strong>FALSE</strong> 或调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntrace/nf-evntrace-closetrace">CloseTrace</a>。 此外，如果使用者实时消耗事件， 则 ProcessTrace 函数会在控制器停止跟踪会话后返回。 (请注意，函数返回前几秒可能会有延迟。)</p>
</div>



<h3 id="6-1-OpenTraceW-打开会话"><a href="#6-1-OpenTraceW-打开会话" class="headerlink" title="6.1 OpenTraceW 打开会话"></a>6.1 OpenTraceW 打开会话</h3><p><code>OpenTrace</code> 函数打开指定 ETW 跟踪会话，调用成功则会返回该会话句柄。<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntrace/nf-evntrace-opentracea">OpenTrace</a> 函数可以处理一个或多个日志文件中的事件，<mark class="label primary">但只能处理一个实时会话中的事件</mark>。 </p>
<p><code>PEVENT_TRACE_LOGFILEW</code> 指定要打开的会话，以及<strong>指定 Consumers 处理事件的回调函数</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ETW_APP_DECLSPEC_DEPRECATED TRACEHANDLE WMIAPI <span class="title">OpenTraceW</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in, out] PEVENT_TRACE_LOGFILEW Logfile	<span class="comment">// IN、OUT 说明该结构有输入成员也有输出成员</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>EVENT_TRACE_LOGFILE</code> 结构存储有关跟踪数据源的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EVENT_TRACE_LOGFILEW</span> &#123;</span></span><br><span class="line">  LPWSTR                        LogFileName;	<span class="comment">// 如果使用文件模式，则指向 ETL 文件完整路径名称（包括后缀）；实时会话为 NULL</span></span><br><span class="line">  						<span class="comment">// 调用 OpenTrace 时，使用事件的用户必须具有读取文件的权限</span></span><br><span class="line">  LPWSTR                        LoggerName;	<span class="comment">// 如果使用实时模式，则指向 ETW 控制器定义的会话名称</span></span><br><span class="line">  						<span class="comment">// LogFileName、LoggerName 只能二选一</span></span><br><span class="line">  LONGLONG                      CurrentTime;	<span class="comment">//【OUT 输出值】，当前时间</span></span><br><span class="line">  ULONG                         BuffersRead;	<span class="comment">//【OUT 输出值】，已读缓冲区个数</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    ULONG LogFileMode;		<span class="comment">// 保留，请勿使用</span></span><br><span class="line">    ULONG ProcessTraceMode;	<span class="comment">// 用于处理事件的模式。PROCESS_TRACE_MODE_EVENT_RECORD、PROCESS_TRACE_MODE_REAL_TIME</span></span><br><span class="line">  &#125; DUMMYUNIONNAME;</span><br><span class="line">  EVENT_TRACE                   CurrentEvent;	<span class="comment">//【OUT 输出值】，最后一个已处理事件的 EVENT_TRACE 结构</span></span><br><span class="line">  TRACE_LOGFILE_HEADER          LogfileHeader;	<span class="comment">//【OUT 输出值】，ETL 文件信息</span></span><br><span class="line">  PEVENT_TRACE_BUFFER_CALLBACKW BufferCallback;	<span class="comment">// 回调函数用来接收 ETW递送缓冲区中事件的统计信息</span></span><br><span class="line">  						<span class="comment">// ETW 在传递每个缓冲区的事件后调用此函数</span></span><br><span class="line">  ULONG                         BufferSize;	<span class="comment">//【OUT 输出值】，每个缓冲区的大小（以字节为单位）</span></span><br><span class="line">  ULONG                         Filled;		<span class="comment">//【OUT 输出值】，缓冲区中包含的有效信息字节数</span></span><br><span class="line">  ULONG                         EventsLost;	<span class="comment">// 未使用</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    PEVENT_CALLBACK        EventCallback;	<span class="comment">// ProcessTraceMode != PROCESS_TRACE_MODE_EVENT_RECORD 时才使用该回调函数</span></span><br><span class="line">    						<span class="comment">// 不应在新代码中使用此回调，应使用 EventRecordCallback</span></span><br><span class="line">    PEVENT_RECORD_CALLBACK EventRecordCallback;	<span class="comment">// 仅当 ProcessTraceMode == PROCESS_TRACE_MODE_EVENT_RECORD 时才使用该回调函数</span></span><br><span class="line">  &#125; DUMMYUNIONNAME2;</span><br><span class="line">  ULONG                         IsKernelTrace;	<span class="comment">//【OUT 输出值】，如果为 TRUE 则为 NT 内核记录器（NT Kernel Logger）</span></span><br><span class="line">  PVOID                         Context;	<span class="comment">// 如果使用者使用 EventRecordCallback 来使用事件，</span></span><br><span class="line">  						<span class="comment">// ETW 会将 EVENT_RECORD 结构的 UserContext 成员设置为此值（将该值传给回调函数）</span></span><br><span class="line">&#125; EVENT_TRACE_LOGFILEW, *PEVENT_TRACE_LOGFILEW;</span><br></pre></td></tr></table></figure>

<div class="note success"><p>  <strong>注意</strong>：</p>
<ol>
<li>如果 <code>LoggerName != NULL</code>，则必须 <code>LogFileName == NULL</code>，且需要指定 <code>ProcessTraceMode = PROCESS_TRACE_MODE_REAL_TIME</code>。</li>
<li>如果使用建议的 <code>EventRecordCallback</code> 回调函数，则 <code>EVENT_TRACE_LOGFILEW.Context</code> 指向传递给该回调函数的参数，且 <code>ProcessTraceMode</code> 必须要包含 <code>PROCESS_TRACE_MODE_EVENT_RECORD</code>。</li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntrace/nf-evntrace-processtrace">ProcessTrace</a> <strong>将为每个事件，调用事件回调函数</strong>。</li>
</ol>
</div>



<h3 id="6-2-ProcessTrace-传递事件"><a href="#6-2-ProcessTrace-传递事件" class="headerlink" title="6.2  ProcessTrace 传递事件"></a>6.2  ProcessTrace 传递事件</h3><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntrace/nf-evntrace-processtrace">ProcessTrace</a> 函数将事件从一个或多个 ETW 会话传递给 Consumer。</p>
<p>在成功调用 <code>ProcessTrace</code> 后，如果在指定的 ETW 会话中有输出事件，那么系统便会调用消耗器注册的回调函数来处理事件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ETW_APP_DECLSPEC_DEPRECATED ULONG WMIAPI <span class="title">ProcessTrace</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  [in] PTRACEHANDLE HandleArray,<span class="comment">// 要处理事件的会话句柄数组。数组最多可以包含 64 个文件处理会话句柄，也可以包含一个实时处理会话的句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  				<span class="comment">// 数组不能同时包含文件处理会话句柄和实时处理会话句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] ULONG        HandleCount,<span class="comment">// HandleArray 数组元素的个数</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] LPFILETIME   StartTime,	<span class="comment">// 指向可选 FILETIME 结构的指针，该结构指定要接收事件的开始时间段</span></span></span></span><br><span class="line"><span class="function"><span class="params">  [in] LPFILETIME   EndTime	<span class="comment">// 可选，该结构指定要接收事件的结束时间段</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>返回值：如果函数成功，则返回值为 <code>ERROR_SUCCESS</code>。</p>
<div class="note danger"><p><strong>注意</strong>：ProcessTrace 函数会让线程线程阻塞，直到它传递所有事件、<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntrace/nc-evntrace-pevent_trace_buffer_callbacka">BufferCallback</a> 函数返回 <strong>FALSE</strong> 或调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntrace/nf-evntrace-closetrace">CloseTrace</a>。 此外，如果使用者实时消耗事件， 则 ProcessTrace 函数会在控制器停止跟踪会话后返回。 (请注意，函数返回前几秒可能会有延迟。)</p>
</div>

<p>所以可以在调用该函数之后直接使用 <code>CloseTrace</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...   </span><br><span class="line">    <span class="comment">// 开始处理事件，该函数为阻塞函数，在这里不断调用事件处理函数处理事件，直到session关闭</span></span><br><span class="line">    ProcessTrace(&amp;handle, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    CloseTrace(handle);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<div class="note default"><p><strong>注意</strong>：</p>
<ol>
<li>ProcessTrace 函数通过调用 Consumer 的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntrace/nc-evntrace-pevent_trace_buffer_callbacka">BufferCallback、EventCallback</a> 和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/evntrace/nc-evntrace-pevent_record_callback">EventRecordCallback</a> 回调函数从会话传递事件。</li>
<li>ProcessTrace 函数尝试根据事件的时间戳的顺序传递事件。 在某些情况下， ProcessTrace 可能会按顺序传递事件。</li>
</ol>
</div>









<h2 id="7-两个特殊会话"><a href="#7-两个特殊会话" class="headerlink" title="7 两个特殊会话"></a>7 两个特殊会话</h2><ol>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/etw/configuring-and-starting-the-global-logger-session"><strong>全局记录器会话</strong></a>（<code>Global Logger Session</code>），它用来记录操作系统早期启动过程中的事件，例如设备驱动相关的事件。</li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/etw/configuring-and-starting-the-nt-kernel-logger-session"><strong>NT 内核记录器会话</strong></a>（<code>NT Kernel Logger Session</code>），它用来记录操作系统生成的预定义系统事件，例如磁盘 IO 或页面错误事件。</li>
</ol>
<p>ETW 应用：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-253450.htm">剖析 InfinityHook 原理 掀起一场更激烈的攻与防恶战</a></li>
<li><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-266207.htm">InfinityHook 事件逆向</a></li>
<li><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/206288">Windows 10 19041版本的Infinity hook 原理</a></li>
<li><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-259760.htm">在WIN10 19041下继续欢快的infinityhook</a></li>
<li><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/202797">两种最新Bypass ETW的方法</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cyberpointllc.com/blog-posts/cp-logging-keystrokes-with-event-tracing-for-windows-etw.php">Logging Keystrokes with Event Tracing for Windows (ETW)</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.redbluepurple.io/windows-security-research/kernel-tracing-injection-detection">Detecting Process Injection with ETW</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.palantir.com/tampering-with-windows-event-tracing-background-offense-and-defense-4be7ac62ac63">Tampering with Windows Event Tracing: Background, Offense, and Defense</a></li>
</ul>
<h2 id="8-ETW-整体架构"><a href="#8-ETW-整体架构" class="headerlink" title="8 ETW 整体架构"></a>8 ETW 整体架构</h2><p>这部分应该重启一篇文章，包括分析内核 ETW。</p>
<p>参考《Windows Internals 7th, Part 2,Chapter 10》。</p>
<p><a target="_blank" rel="noopener" href="https://binarly.io/posts/Design_issues_of_modern_EDRs_bypassing_ETW-based_solutions">https://binarly.io/posts/Design_issues_of_modern_EDRs_bypassing_ETW-based_solutions</a></p>
<p><strong>Session</strong>：</p>
<p>ETW 最重要的实体之一是会话（内部称为记录器实例），它是提供者和消费者之间的粘合剂。 事件跟踪会话记录来自控制器已启用的一个或多个提供程序的事件。 会话通常包含描述哪些事件应由哪些提供者记录以及应如何处理这些事件的所有信息。 例如，一个会话可能被配置为接受来自 Microsoft Windows-Hyper-V-Hypervisor 提供程序（使用 (52fc89f8-995e-434c-a9le-199986449890) GUID 进行内部标识）的所有事件。 用户还可以配置过滤器。 提供者（或提供者组）生成的每个事件都可以根据事件级别（信息、警告、错误或严重）、事件关键字、事件 ID 和其他特征进行过滤。 会话配置还可以为会话定义各种其他细节，例如什么时间源应该用于事件时间戳（例如，QPC、TSC 或系统时间），哪些事件应该捕获堆栈跟踪，等等。 会话具有托管 ETW 记录器线程的重要规则，它是将事件刷新到日志文件或将它们传递给实时使用者的主要实体。</p>
<p>会话使用 StartTrace APl 创建并使用 ControlTrace 和 EnableTraceEx2 配置。 xperf、logman、tracelog 和 wevtutil 等命令行工具使用这些 API 来启动或控制跟踪会话。 会话也可以配置为对创建它的进程私有。 在这种情况下，ETW 用于使用仅由同时充当提供者的同一应用程序创建的事件。 因此，该应用程序消除了与内核模式转换相关的开销。 私有 ETW 会话只能记录其正在执行的进程线程的事件，不能用于实时交付。 私有ETW的内部架构本书不做描述。</p>
<p>创建全局会话时，StartTrace API 验证参数并将它们复制到数据结构中，NtTraceControl APl 使用该数据结构调用内核中的内部函数 EtwpStartLogger。 ETW 会话在内部通过 ETW_LOGGER_CONTEXT 数据结构表示，该数据结构包含指向会话内存缓冲区的重要指针，事件被写入其中。 如“ETW 初始化”部分所述，系统可以支持有限数量的 ETW 会话，这些会话存储在位于全局 per-SILO 数据结构中的数组中。EtwpStartLogger 检查全局会话数组，确定是否有空闲 空间或者如果同名会话已经存在。如果是这种情况，它会退出并发出错误信号。否则，它会生成一个会话 GUID（如果调用者尚未指定），分配并初始化一个 ETW_LOGGER_CONTEXT 数据 表示会话的结构，为其分配一个索引，并将其插入到每个筒仓数组中。</p>
<p>ETW 查询位于 HKLM\SystemlCurrentControlSet\ControlWmil 安全注册表项中的会话安全描述符。 如图 10-33 所示，注册表项中的每个注册表值都被命名为会话 GUID（但是，注册表项也包含提供者的 GUID）并包含自相关安全描述符的二进制表示如果安全描述符用于 会话不存在，则返回会话的默认会话（有关详细信息，请参阅本章后面的“见证 ETw 会话的默认安全描述符”实验）。</p>
<p>EtwpStartLogger 函数对会话的安全描述符执行访问检查，使用当前进程的访问令牌请求 TRACELOG_GUID_ENABLE 访问权限（以及 TRACELOG_CREATE_REALTIME 或 TRACELOG_CREATE_OND&#x2F;SK，具体取决于日志文件模式）。 如果检查成功，则例程计算事件缓冲区的默认大小和数量，这些大小是根据系统物理内存的大小计算的（默认缓冲区大小为 8、16 或 64KB）。 缓冲区的数量取决于系统处理器的数量和 EVENT_TRACE_NO PER PROCESSOR_BUFFERING 记录器模式标志的存在，它可以防止事件（可以从不同的处理器生成）被写入每个处理器的缓冲区。</p>
<p>ETW 获取会话的初始参考时间戳。 目前支持三种时钟分辨率 Query performance counter（QPC，一种不受系统时钟影响的高分辨率时间戳）、System time 和 CPU cycle counter。 EtwpAllocate TraceBuffer 函数用于分配与记录器会话关联的每个缓冲区（缓冲区的数量在之前计算或指定为用户的输入）。 可以从分页池、非分页池或直接从物理大页面分配缓冲区，具体取决于日志记录模式。 每个缓冲区都存储在多个内部每会话列表中，这些列表能够为 ETW 主记录器线程和 ETW 提供程序提供快速查找。 最后，如果日志模式未设置为循环缓冲区，则 Etwp StartLogger 函数启动主 ETW 记录器线程，其目的是将与会话关联的提供程序写入的事件刷新到日志文件或实时 消费者。 主线程启动后，ETW 向已注册的会话通知提供程序 (GUID 2a6e185b-90de-4fc5-826c-9f44e608a427) 发送会话通知，这是一个特殊的提供程序，允许其消费者在某些 ETW 事件发生时得到通知（如 创建或销毁新会话、创建新日志文件或引发日志错误）。</p>
<p><strong>ETW providers</strong>：</p>
<p>如前几节所述，提供者是产生事件的组件（而包含提供者的应用程序包含事件跟踪工具）。 ETW 支持不同类型的提供程序，它们都共享相似的编程模型。 （它们的主要区别在于它们对事件进行编码的方式）提供者必须首先向 ETW 注册，然后才能生成事件。 以类似的方式，控制器应用程序应启用提供者并将其与 ETw 会话相关联，以便能够从提供者接收事件。 如果没有会话启用提供者，则提供者将不会生成任何事件。 提供者定义其对启用或禁用的解释。 通常，启用的提供程序会生成事件，而禁用的提供程序则不会。</p>
<p><strong>Providers registration：</strong></p>
<p>每个提供者的类型都有自己的 API，需要由提供者应用程序（或驱动程序）调用以注册提供者。 例如，基于清单的提供程序依赖 EventRegister APl 进行用户模式注册，并依赖 EtwRegister 进行内核模式注册。 所有提供者类型最终都会调用内部的 EtwpRegisterProvider 函数，该函数执行实际的注册过程（并在 NT 内核和 NTDLL 中实现）。 后者分配并初始化一个 ETW_GUID_ENTRY 数据结构，它表示提供者（相同的数据结构用于通知和特征）。 该数据结构包含重要信息，如提供者 GUID、安全描述符、引用计数器、启用信息（针对启用提供者的每个 ETW 会话）和提供者注册列表。</p>
<p>对于用户模式提供程序注册，NT 内核对调用进程的令牌执行访问检查，请求 TRACELOG.<em>REGISTER_GUIDS 访问权限。 如果检查成功，或者如果注册请求源自内核代码，则 ET W 插入新的 ETV</em> GUID。 ENTRY 数据结构位于全局 ETW 每筒仓数据结构中的哈希表中，使用提供者 GUID 的哈希作为表的键（这允许快速查找系统中注册的所有提供者）。 哈希表中已存在相同的 GUID，ETW 使用现有条目而不是新条目。 GUID 可能已经存在于哈希表中，主要有两个原因：</p>
<ul>
<li>另一个驱动程序或应用程序在实际注册之前启用了提供程序（有关更多详细信息，请参阅本章后面的“提供程序启用”部分）。</li>
<li>该提供者已经注册过一次。 支持同一提供者 GUID 的多次注册。</li>
</ul>
<p>提供者成功添加到全局列表后，ETW 创建并初始化一个 ETW 注册对象，该对象表示一次注册。 该对象封装了一个 ETW_REG_ENTRY 数据结构，它将提供者与请求其注册的进程和会话联系起来。 （ETW 还支持从不同的会话注册。）对象被插入到位于 ETW.<em>GUID_ENTRY 的列表中（EtwRegistration 对象类型先前已在 ETW 初始化时创建并注册到 NT 对象管理器）。 图 10-34 显示了这两个数据结构及其关系。 图中有两个提供者的进程（进程A，生活在session 4，进程B，生活在session 16）已经注册了provider 这样两个ETW REG</em> ENTRY数据结构就被创建并链接到代表provider的ETW_ GUID_ ENTRY 1.</p>
<p>在此阶段，提供程序已注册并准备好在请求它的会话中启用（通过 EnableTrace API）。 如果提供者在其注册之前已经在至少一个会话中启用，ETW 将启用它（有关详细信息，请参阅下一节）并调用启用回调，这可以由 EventRegister（或 EtwRegister）API 的调用者指定 开始了注册过程。</p>
<p><strong>Provider Enablement</strong>：</p>
<p>如上一节所述，提供者应与 ETW 会话相关联才能生成事件。 这种关联称为提供者启用，它可以通过两种方式发生：在提供者注册之前或之后。 控制器应用程序可以通过 EnableTraceEx APl 在会话中启用提供程序。 APl 允许您指定关键字的位掩码，以确定会话要接收的事件类别。 同样，API 支持对其他类型数据的高级过滤器，例如生成事件的进程 ID、程序包 ID、可执行文件名称等。 （您可以在 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/evntprov/ns-evntprov-event_filter_descriptor">https://docs.microsoft.com/en-us/windows/win32/api/evntprov/ns-evntprov-event_filter_descriptor</a> 找到更多信息）</p>
<p>Provider Enablement 由 ETW 在内核模式下通过内部 EtwpEnableGuid 函数进行管理。 对于用户模式请求，该函数对会话和提供者安全描述符执行访问检查，代表调用进程的令牌请求 TRACELOG_ GUID_ ENABLE 访问权限。 如果记录器会话包含 SECURITY TRACE 标志，则 EtwpEnableGuid 要求调用进程是 PPL（有关更多详细信息，请参阅本章后面的“ETW 安全”部分）。如果检查成功，该函数将执行与 之前讨论过提供者注册：</p>
<ul>
<li>它分配并初始化一个 ETW_ GUID_ ENTRY 数据结构来表示提供者，或者在提供者已经注册的情况下使用已经链接到全局 ETW per-silo 数据结构中的那个。</li>
<li>通过在 ETW GUID_ENTRY 中添加相关会话启用信息，将提供程序链接到记录器会话。</li>
</ul>
<p>如果提供程序之前未注册过，则不存在链接到 ETW_GUID_ENTRY 数据结构中的 ETW 注册对象，因此过程终止。 （提供者将在首次注册后启用。）否则，提供者将被启用。</p>
<p>虽然传统 MOF 提供程序和 WPP 提供程序一次只能启用一个会话，但基于清单和跟踪日志记录的提供程序最多可以启用八个会话。 如前面的图 10-32 所示，ETV_GUID_ENTRY 数据结构包含启用提供程序的每个可能的 ETW 会话的启用信息（最多八个）。 基于启用的会话，EtwpEnableGuid 函数计算出一个新的会话启用掩码，并将其存储在 ETW REG_ENTRY 数据结构（代表提供者注册）中。 掩码非常重要，因为它是事件生成的关键。 当应用程序或驱动程序将事件写入提供者时，会进行检查：如果启用掩码中的某个位等于 1，则意味着应将事件写入由特定 ETW 会话维护的缓冲区； 否则，会话将被跳过并且事件不会写入其缓冲区。</p>
<p>请注意，对于安全会话，在更新提供者注册中的会话启用掩码之前执行补充访问检查。 ETW 会话的安全描述符应允许 TRACELOG_LOG_EVENT 访问调用进程的访问令牌。 否则，启用掩码中的相对位不会设置为 1。（目标 ET W 会话将不会从提供者注册中接收任何事件。）有关安全会话的更多信息，请参阅后面的“安全记录器和 ETw 安全”部分 在这一章当中。</p>
<p><strong>Providing events</strong>:</p>
<p>注册一个或多个 ETW 提供程序后，提供程序应用程序可以开始生成事件。 请注意，即使控制器应用程序没有机会在 ETW 会话中启用提供程序，也可以生成事件。 应用程序或驱动程序生成事件的方式取决于提供者的类型。 例如，将事件写入基于清单的提供程序的应用程序通常会直接创建一个事件描述符（遵循 XML 清单）并使用 EventWrite API 将事件写入启用了提供程序的 ETW 会话。 管理 MOF 和 WPP 提供程序的应用程序依赖于 TraceEvent APl。</p>
<p>正如前面“ETW 会话”部分所讨论的，基于清单的提供程序生成的事件可以通过多种方式进行过滤。ETW 从提供程序注册对象中定位 ETV_GUID_ENTRY 数据结构，该对象由应用程序通过句柄提供 . 内部 Etwp EventWriteFul&#x2F;l 函数使用提供者的注册会话启用掩码在与提供者关联的所有启用的 ETW 会话之间循环（由 ETV LOGGER_CONTEXT 表示）。对于每个会话，它检查事件是否满足所有过滤器。如果 因此，它会计算 vent 有效负载的完整大小，并检查会话的当前缓冲区中是否有足够的可用空间。</p>
<p>如果没有可用空间，ETW 会检查会话中是否还有另一个空闲缓冲区：空闲缓冲区存储在 FIFO（先进先出）队列中。 如果有空闲缓冲区，ETW 会将旧缓冲区标记为“脏”并切换到新的空闲缓冲区。 通过这种方式，Logger 线程可以唤醒并将整个缓冲区刷新到日志文件或将其交付给实时消费者。 <strong>如果会话的日志模式是循环记录器，则永远不会创建记录器线程</strong>：ETW 只是将旧的完整缓冲区链接到空闲缓冲区队列的末尾（因此队列永远不会为空）。 否则，如果队列中没有空闲缓冲区，ETW 会在向调用者返回错误之前尝试分配一个额外的缓冲区。</p>
<p>在缓冲区中找到足够的空间后，EtwpEventWriteFull 自动将整个事件负载写入缓冲区并退出。 请注意，如果会话启用掩码为 O，则意味着没有会话与提供者相关联。 因此，该事件是 ost 并且没有记录在任何地方。</p>
<p>MOF 和 WPP 事件经过类似的过程，但仅支持单个 ETW 会话并且通常支持较少的筛选器。 对于这些类型的提供者，将对关联的会话执行补充检查：如果控制器应用程序已将会话标记为安全，则没有人可以写入任何事件。 在这种情况下，将向调用方返回一个错误（安全会话将在稍后的“安全记录器和 ETW 安全性”部分中讨论）。</p>
<p><strong>ETW Logger thread</strong>:</p>
<p>Logger 线程是 ETW 中最重要的实体之一。 它的主要目的是将事件刷新到日志文件或将它们传递给实时消费者，跟踪传递和丢失事件的数量。 每次最初创建 ETW 会话时都会启动记录器线程，但前提是会话不使用循环日志模式。 它的执行逻辑很简单。 启动后，它会将自己链接到表示关联 ETW 会话的 ETW_LOGGER_CONTEXT 数据结构，并等待两个主要的同步对象。 每次属于会话的缓冲区变满时，ETW 都会发出 Flush 事件信号（这可能发生在提供者生成新事件之后——例如，如前一节“提供事件”中所讨论的），当一个新的 实时消费者已请求连接，或者当记录器会话将要停止时。只有在会话是实时会话或用户 在调用 StartTrace APl 以创建新会话时已明确要求它。</p>
<p>当两个同步对象之一收到信号时，记录器线程重新装备它们并检查文件系统是否准备就绪。 如果不是，则主记录器线程再次返回睡眠状态（在早期引导阶段不应刷新任何会话）。 否则，它开始将属于会话的每个缓冲区刷新到日志文件或实时消费者。</p>
<p>对于实时会话，记录器线程首先在％SystemRoot%\System32\LogFileslWMl\RtBackup文件夹中创建一个临时的per-session ETL文件（如图10-35所示）。日志文件名是通过添加EtwRT生成的 实时会话名称的前缀。 该文件用于在将临时事件传递给实时消费者之前保存它们（日志文件还可以存储在适当的时间范围内未传递给消费者的丢失事件）。 启动时，实时自动记录器会从日志文件中恢复丢失的事件，目的是将它们传递给消费者。</p>
<p><strong>记录器线程是唯一能够在实时消费者和会话之间建立连接的实体</strong>。 消费者第一次调用 ProcessTrace APl 以从实时会话接收事件时，ETW 会设置一个新的实时消费者对象并使用它来创建消费者与实时会话之间的链接。 解析为 ETW_REALTIME 的对象。 NT 内核中的 CONSUMER 数据结构允许将事件“注入”到消费者的进程地址空间（另一个用户模式缓冲区由消费者应用程序提供）。</p>
<p>对于非实时会话，记录器线程打开（或创建，以防文件不存在）创建会话的实体指定的初始 ETL 日志文件。 如果会话的日志模式指定了 EVENT_TRACE_FILE，Iogger 线程还可以创建全新的日志文件。 模式。 NEWFILE 标志，当前日志文件达到最大大小。</p>
<p>在此阶段，ETW 记录器线程启动将与会话关联的所有缓冲区刷新到当前日志文件（如前所述，对于实时会话，该文件可以是临时文件）。 刷新是通过向缓冲区中的每个事件添加事件头并使用 NtWriteFile API 将二进制内容写入 ETL 日志文件来执行的。 对于实时会话，下次记录器线程唤醒时，它能够将存储在临时日志文件中的所有事件注入目标用户模式实时消费者应用程序。 因此，对于实时会话，ETW 事件永远不会同步传递。</p>
<p><strong>Consuming events</strong>:</p>
<p>由于 Sechost.dll 提供的服务，ETW 中的事件消费几乎完全由消费者应用程序在用户模式下执行。 消费者应用程序使用 OpenTrace API 打开由主记录器线程生成的 ETL 日志文件或建立与实时记录器的连接。 应用程序指定一个事件回调函数，每次 ETW 使用单个事件时都会调用该函数。 此外，对于实时会话，应用程序可以提供一个可选的缓冲区回调函数，该函数接收 ETW 刷新的每个缓冲区的统计信息，并在每次单个缓冲区已满并已交付给消费者时调用。</p>
<p>实际的事件消费是由 ProcessTrace APl 启动的。 APl 适用于标准和实时会话，具体取决于先前传递给 OpenTrace 的日志文件模式标志。</p>
<p>对于实时会话，API 使用内核模式服务（通过 NtTraceControl 系统调用访问）来验证 ETW 会话是否真的是实时会话。 NT 内核验证 ETW 会话的安全描述符是否授予 TRACELOG。 ACCESS_ REALTIME 对调用进程令牌的访问权限。 如果它没有访问权，API 就会失败并向控制器应用程序返回一个错误。 否则，它会分配一个临时用户模式缓冲区和一个用于接收事件的位图，并连接到主记录器线程（创建关联的 EtwConsumer 对象；有关详细信息，请参阅本章前面的“ETW 记录器线程”部分）。 建立连接后，API 会等待来自会话记录器线程的新数据。 当数据到来时，API 枚举每个事件并调用事件回调。</p>
<p>对于非实时 ETW 会话，ProcessTrace API 执行类似的处理，但它不是连接到记录器线程，而是打开并解析 ETL 日志文件，逐个读取每个缓冲区并调用事件回调 每个找到的事件（事件按时间顺序排序）。 与每次可以消耗一个的实时记录器不同，在这种情况下，API 甚至可以使用 OpenTrace APl 创建的多个跟踪句柄，这意味着它可以解析来自不同 ETL 日志文件的事件。</p>
<p>属于使用循环缓冲区的 ETW 会话的事件不会使用所描述的方法进行处理。 （确实没有转储 : 事件的记录器线程。）通常，当控制器应用程序想要将属于配置为使用循环缓冲区的 ETW 会话的当前缓冲区的快照转储到日志文件中时，它会使用 FlushTrace API。 APl 通过 NtTraceControl 系统调用调用 NT 内核，该系统调用定位 ET W 会话并验证其安全描述符授予 TRACELOG_CREATE_OND&#x2F;SK 对调用进程的访问令牌的访问权。 如果是这样，并且如果控制器应用程序指定了一个有效的日志文件名，NT 内核调用内部 EtwpBufferingModeFlush 例程，创建新的 ETL 文件，添加适当的标题，并写入与会话相关的所有缓冲区。 然后，消费者应用程序可以使用 OpenTrace 和 ProcessTrace APl 解析写入新日志文件的事件，如前所述。</p>
<p><strong>System loggers:</strong></p>
<p>到目前为止，我们所描述的是正常的 ETW 会话和提供程序是如何工作的。 从 Windows XP 开始，ETW 就支持系统记录器的概念，它允许 NT 内核全局发出不依赖于任何提供程序并且通常用于性能测量的日志事件。 在撰写本文时，有两个主要的系统记录器可用，分别是 NT 内核记录器和循环内核上下文记录器（而全局记录器是 NT 内核记录器的子集）。 NT 内核最多支持八个系统记录器会话。 从系统记录器接收事件的每个会话都被视为系统会话。</p>
<p>为了启动系统会话，应用程序使用 StartTrace APl，但它指定 EVENT TRACE_SYSTEM_LOGGER_MODE 标志或系统记录器会话的 GUID 作为输入参数。 表 10-16 列出了系统记录器及其 GUID。 NT 内核中的 EtwpStartLogger 函数识别标志或特殊 GUID，并对 NT kernellogger 安全描述符执行额外检查，代表调用者进程访问令牌请求 TRACELOG_GUID_ENABLE 访问权限。 如果检查通过，ETW 将计算系统记录器索引并更新记录器组掩码和系统全局性能组掩码。</p>
<p>最后一步是驱动系统记录器的关键。 可以在高 IRQL（Context Swapper 是一个很好的例子）的多个低级系统函数分析性能组掩码并决定是否将事件写入系统记录器。 控制器应用程序可以通过修改 StartTrace APl 和 Contro&#x2F;Trace API 使用的 EnableFlags 位掩码来启用或禁用系统记录器记录的不同事件。 系统记录器记录的事件以明确定义的顺序内部存储在全局性能组掩码中。 掩码由八个 32 位值的数组组成。 数组中的每个索引代表一组事件。 可以使用 Xperf 工具枚举系统事件集（也称为组）。 表 10-17 列出了系统记录器事件及其分组的分类。 大多数系统记录器事件都记录在 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/evntrace/ns-evntrace-event_trace_properties">https://docs.microsoft.com/en-us/windows/win32/api/evntrace/ns-evntrace-event_trace_properties</a> 中。</p>
<p>当系统会话启动时，会立即记录事件。 没有需要启用的提供程序。 这意味着消费者应用程序无法对事件进行通用解码。 系统记录器事件使用精确的事件编码格式（称为 NTPERF），这取决于事件类型。 然而，大多数表示不同 NT 内核记录器事件的数据结构通常记录在 Windows 平台 SDK 中。</p>
<p><strong>The Global logger and Autologgers</strong>：</p>
<p>某些记录器会话会在系统启动时自动启动。 全局记录器会话记录操作系统启动过程早期发生的事件，包括 NT 内核记录器生成的事件。 （全局记录器实际上是一个系统记录器，如表 10-16 所示。）应用程序和设备驱动程序可以使用全局记录器会话在用户登录之前捕获跟踪（某些设备驱动程序，例如磁盘设备驱动程序，不是 在全局记录器会话开始时加载）虽然全局记录器主要用于捕获由 NT 内核提供程序生成的跟踪（请参阅表 10-17），但自动记录器（Autologgers）旨在捕获来自经典 ETW 提供程序的跟踪（而不是来自 NT 内核记录器）。</p>
<p>如本章前面的“ETW 初始化”部分所述，ETW 在 NT 内核初始化的早期阶段几乎同时启动 Global logger 和 Autologgers。Etw&#x2F;StartAutologger 内部函数查询所有记录器配置数据 从注册表中验证它，并使用 EtwpStartLogger 例程创建记录器会话，该例程已在“ETW 会话”部分中进行了广泛讨论。全局记录器是系统记录器，因此在创建会话后，不再提供其他提供程序 已启用。与 Globallogger 不同，Autologgers 需要启用提供程序。它们通过从 Autologger 注册表项中枚举每个会话的名称来启动。创建会话后，ETW 枚举应在会话中启用的提供程序，这些提供程序列为 Autologger 项的子项（提供程序由 GUID 标识）。图 10-36 显示了在 EventLog-System 会话中启用的多个提供程序。这 se ssion 是 Windows 事件查看器显示的主要 Windows 日志之一（由事件记录器服务捕获）。</p>
<p>验证提供者的配置数据后，与经典 ETW 会话一样，通过内部 EtwpEnableTrace 函数在会话中启用提供者。</p>
<p><strong>ETW security</strong>：</p>
<p>启动和停止 ETW 会话被视为高权限操作，因为事件可以包括可用于利用系统完整性的系统数据（这对于系统日志记录器尤其如此）。 Windows 安全模型已扩展为支持 ETW 安全。 如前几节所述，ETW 执行的每个操作都需要定义明确的访问权限，该访问权限必须由保护会话、提供程序或提供程序组（取决于操作）的安全描述符授予。 表 10-18 列出了为 ETW 引入的所有新访问权限及其用法。</p>
<p>大多数 ETW 访问权限会自动授予 SYSTEM 帐户以及 Administrators、Local Service 和 Network Service 组的成员。 这意味着不允许普通用户与 ETW 交互（除非显式会话和提供程序安全描述符允许这样做）。 为了解决这个问题，Windows 包含了 Performance Log Users 组，该组旨在允许普通用户与 ETW 交互（特别是用于控制跟踪会话）。 尽管所有 ETW 访问权限都由默认安全描述符授予 Performance Log Users 组，但 Windows 支持另一个名为 Performance Monitor Users 的组，该组被设计为仅接收或向会话通知提供程序发送通知。 这是因为该组旨在访问系统性能计数器，由性能监视器和资源监视器等工具枚举，而不是访问完整的 ETW 事件。 这两个工具已经在第 1 部分第 1 章的“性能监视器和资源监视器”部分进行了描述。</p>
<p>正如前面在本章“ETW 会话”部分介绍的那样，所有 ETW 安全描述符都以二进制格式存储在 HKLM\Systeml\CurrentControlSet\ControlWmil\Security 注册表项中。 在 ETW 中，GUID 表示的所有内容都可以通过自定义的安全描述符进行保护。 为了管理 ETW 安全，应用程序通常不直接与存储在注册表中的安全描述符交互，而是使用在 Sechost.all 中实现的 EventAccessControl 和 EventAccessQuery API。</p>
<p><strong>Security Audit logger:</strong></p>
<p>安全审计记录器是 Windows 事件记录器服务 (wevtsvc.dll) 用来侦听安全 Lsass 提供程序生成的事件的 ETW 会话。 Security Lsass 提供程序（由 (54849625-5478-4994-a5ba-3e3b0328c30d GUID 标识）只能在 ET W 初始化时由 NT 内核注册，并且永远不会插入到全局提供程序的哈希表中。只有 Security 将 Enab&#x2F;eSecurityProvider 注册表值设置为 1 的审计记录器和自动记录器可以接收来自安全 Lsass 提供程序的事件。当 EtwStartAutoLogger 内部函数遇到设置为 1 的值时，它会在关联的 ETW 会话上启用 SECURITY_TRACE 标志， 将会话添加到可以接收安全审计事件的记录器列表中。</p>
<p>该标志还具有用户模式应用程序不能再查询、停止、刷新或控制会话的重要影响，除非它们作为受保护的进程轻运行（在反恶意软件、Windows 或 WinTcb 级别；有关受保护的更多详细信息 第 1 部分第 3 章中提供了流程）。</p>
<p><strong>Secure loggers</strong></p>
<p>经典 (MOF) 和 WPP 提供程序并未设计为支持为基于清单和跟踪记录提供程序实现的所有安全功能。因此，可以使用 EVENT_TRACE_SECURE_MODE 标志创建自动记录器或通用 ETW 会话，该标志将会话标记为 安全的。 安全会话的目标是确保它仅从受信任的身份接收事件。 该标志有两个主要作用：</p>
<ul>
<li>防止经典 (MOF) 和 WPP 提供程序将任何事件写入安全会话。 如果在安全部分启用了经典提供程序，则该提供程序将无法生成任何事件。</li>
<li>需要补充的 TRACELOG._LOG_EVENT 访问权限，该权限应由会话的安全描述符授予控制器应用程序的访问令牌，同时启用安全会话的提供程序。</li>
</ul>
<p>TRACELOG_EVENT 访问权限允许在会话的安全描述符中指定更细粒度的安全性。 如果安全描述符仅将 TRACELOG_ GUID_ ENABLE 授予不受信任的用户，并且 ETW 会话由另一个实体（内核驱动程序或更高特权的应用程序）创建为安全的，则不受信任的用户无法在安全部分启用任何提供程序。 如果该部分创建为非安全部分，则不受信任的用户可以在其上启用任何提供程序。</p>
<p><strong>Dynamic tracing (DTrace)</strong></p>
<p>如前一节所述，Windows 事件跟踪是一种集成到操作系统中的强大跟踪技术，但它是静态的，这意味着最终用户只能跟踪和记录由属于操作系统的定义明确的组件生成的事件 或第三方框架&#x2F;应用程序（例如 .NET CLR）为了克服限制，Windows 10 的 2019 年 5 月更新 (19H1) 引入了 DTrace，这是 Windows 中内置的动态跟踪工具。 实时系统上的管理员可以使用 DTrace 检查用户程序和操作系统本身的行为。 DTrace 是一种开源技术，专为 Solaris 操作系统（及其后代 illumos，两者均基于 Unix）而开发，并已移植到 Windows 以外的多个操作系统。</p>
<p>DTrace 可以在某些感兴趣的位置（称为探测器）动态跟踪操作系统和用户应用程序的各个部分。 探测是一个二进制代码位置或活动，DTrace 可以将请求绑定到该位置以执行一组操作，例如记录消息、记录堆栈跟踪、时间戳等。 当探测器触发时，DTrace 从探测器收集数据并执行与探测器关联的操作。 使用 D 编程语言在脚本文件中（或通过命令行直接在 DTrace 应用程序中）指定探测器和操作。 对探测的支持由称为提供者的内核模块提供。 最初的 illumos DTrace 支持大约 20 个提供程序，这些提供程序与基于 Unix 的操作系统紧密相关。 在撰写本文时，Windows 支持以下提供程序：</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>Buy me a coffee</div>
  <button onclick="document.querySelector('.post-reward').classList.toggle('active');">
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechat.jpg" alt="Catecat 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpg" alt="Catecat 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Catecat
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://directoree.github.io/post/Windows10-ETW/" title="Windows10 用户模式事件追踪（ETW）">https://directoree.github.io/post/Windows10-ETW/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Windows%E5%86%85%E6%A0%B8/" rel="tag"><i class="fa fa-tag"></i> Windows内核</a>
              <a href="/tags/ETW/" rel="tag"><i class="fa fa-tag"></i> ETW</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/Driver-Signing-Policy/" rel="prev" title="驱动强制签名（一）">
                  <i class="fa fa-chevron-left"></i> 驱动强制签名（一）
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/WinXP-Struct/" rel="next" title="WinXP 结构/指令查询">
                  WinXP 结构/指令查询 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Catecat</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">2.2m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">33:02</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1.15.0/dist/lozad.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/local-search.js"></script>








<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  const url = element.dataset.target;
  const pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  const pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  const fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script>
if (document.querySelectorAll('.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8.7.0/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>








  

  
      <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//cdn.jsdelivr.net/npm/mathjax@3.1.0/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
NexT.utils.loadComments('#valine-comments', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    new Valine(Object.assign({"enable":true,"appId":"7zujCcS8pYH88CJXfdBlLyS8-gzGzoHsz","appKey":"lWGr7OPoNHo4v1YmVV5yr3E9","serverURLs":"https://7zujccs8.lc-cn-n1-shared.com","placeholder":"快来勾搭我呀🐶","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"lang":null,"visitor":true,"comment_count":true,"bg":"/images/comment_bg.png","recordIP":false,"enableQQ":false,"requiredFields":["nick"]}, {
      el: '#valine-comments',
      path: "/post/Windows10-ETW/",
      serverURLs: "https://7zujccs8.lc-cn-n1-shared.com"
    }));
  }, window.Valine);
});
</script>

</body>
</html>
