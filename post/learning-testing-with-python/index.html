<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon1.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"directoree.github.io","root":"/","scheme":"Mist","version":"8.0.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="ʕ •ᴥ•ʔ (๑˃̵ᴗ˂̵) ପ( ˘ᵕ˘ ) ੭">
<meta property="og:type" content="article">
<meta property="og:title" content="Python 测试之道">
<meta property="og:url" content="https://directoree.github.io/post/learning-testing-with-python/index.html">
<meta property="og:site_name" content="Catecat">
<meta property="og:description" content="ʕ •ᴥ•ʔ (๑˃̵ᴗ˂̵) ପ( ˘ᵕ˘ ) ੭">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/10/30/i47ltq5M2PzpbSf.png">
<meta property="og:image" content="https://i.loli.net/2020/10/30/uGiFWU8mND9taqn.jpg">
<meta property="og:image" content="https://i.loli.net/2020/11/03/MGPEQZzJ8YvUO9K.png">
<meta property="og:image" content="https://i.loli.net/2020/11/04/m1GFIQfnhrzsACE.png">
<meta property="og:image" content="https://i.loli.net/2020/11/04/PjdGCvabwDmqFxn.png">
<meta property="og:image" content="https://i.loli.net/2020/11/04/TA2LqSRjkVfgxBe.png">
<meta property="og:image" content="https://i.loli.net/2020/11/06/3eD81tGJxwgSfIV.png">
<meta property="og:image" content="https://i.loli.net/2020/11/06/21ah8vLkg9Np37m.png">
<meta property="og:image" content="https://i.loli.net/2020/11/06/a8rIAkjD7qdzFT4.png">
<meta property="article:published_time" content="2020-10-30T06:06:08.000Z">
<meta property="article:modified_time" content="2021-09-02T12:42:12.837Z">
<meta property="article:author" content="Catecat">
<meta property="article:tag" content="知识笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/10/30/i47ltq5M2PzpbSf.png">


<link rel="canonical" href="https://directoree.github.io/post/learning-testing-with-python/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Python 测试之道 | Catecat</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b832a9ae9a43377003fd975ca4e525ea";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Catecat</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">爱你所爱，行你所行，听从你心，无问西东。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-更新日志">

    <a href="/changelog" rel="section"><i class="fa fa-heartbeat fa-fw"></i>更新日志</a>

  </li>
        <li class="menu-item menu-item-空调房">

    <a href="/tips" rel="section"><i class="fa fa-wifi fa-fw"></i>空调房</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80"><span class="nav-text">接口测试基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E7%9F%A5%E8%AF%86"><span class="nav-text">1 网络传输知识</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-Cache"><span class="nav-text">1.1 Cache</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-1-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98"><span class="nav-text">1.1.1 浏览器缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-2-%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98"><span class="nav-text">1.1.2 代理缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-3-%E7%BD%91%E5%85%B3%E7%BC%93%E5%AD%98"><span class="nav-text">1.1.3 网关缓存</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-Cookie"><span class="nav-text">1.2 Cookie</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-1-%E8%8E%B7%E5%8F%96Cookie%E7%9A%84%E9%80%94%E5%BE%84"><span class="nav-text">1.2.1 获取Cookie的途径</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-2-Cookie%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">1.2.2 Cookie的生命周期</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-Session"><span class="nav-text">1.3 Session</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-1-Session%E7%9A%84%E4%BC%A0%E8%BE%93"><span class="nav-text">1.3.1 Session的传输</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-2-Session%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">1.3.2 Session的生命周期</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-3-Cookie%E5%92%8CSession%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">1.3.3 Cookie和Session的区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-Token"><span class="nav-text">1.4 Token</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-JOSN-Web-Token%EF%BC%88JWT%EF%BC%89"><span class="nav-text">1.5 JOSN Web Token（JWT）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-1-%E5%A4%B4%E9%83%A8-Header"><span class="nav-text">1.5.1 头部( Header )</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-2-%E8%BD%BD%E8%8D%B7-Payload"><span class="nav-text">1.5.2 载荷( Payload )</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-3-%E7%AD%BE%E5%90%8D-Signature"><span class="nav-text">1.5.3 签名( Signature )</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-HTTP-%E5%8D%8F%E8%AE%AE"><span class="nav-text">2 HTTP 协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-HTTP-%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D"><span class="nav-text">2.1 HTTP 协议介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-Uniform-Resource-Locator%EF%BC%88URL%EF%BC%89"><span class="nav-text">2.2 Uniform Resource Locator（URL）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%EF%BC%88request%EF%BC%89"><span class="nav-text">2.3 请求报文（request）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-1-%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="nav-text">2.3.1 报文格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-2-%E8%AF%B7%E6%B1%82%E8%A1%8C"><span class="nav-text">2.3.2 请求行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-3-%E8%AF%B7%E6%B1%82%E5%A4%B4"><span class="nav-text">2.3.3 请求头</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%EF%BC%88response%EF%BC%89"><span class="nav-text">2.4 响应报文（response）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-1-%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="nav-text">2.4.1 报文格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-2-%E7%8A%B6%E6%80%81%E8%A1%8C"><span class="nav-text">2.4.2 状态行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-3-%E5%93%8D%E5%BA%94%E5%A4%B4"><span class="nav-text">2.4.3 响应头</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Catecat"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Catecat</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">109</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">43</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">58</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Directoree" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Directoree" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhao_yilong@aliyun.com" title="E-Mail → mailto:zhao_yilong@aliyun.com" rel="noopener" target="_blank"><i class="fas fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://sighttp.qq.com/msgrd?v=1&uin=1003432683" title="QQ → http:&#x2F;&#x2F;sighttp.qq.com&#x2F;msgrd?v&#x3D;1&amp;uin&#x3D;1003432683" rel="noopener" target="_blank"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://treecatee.github.io/" title="https:&#x2F;&#x2F;treecatee.github.io" rel="noopener" target="_blank">Treecatee</a>
        </li>
    </ul>
  </div>

      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://directoree.github.io/post/learning-testing-with-python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Catecat">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Catecat">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Python 测试之道
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-30 14:06:08" itemprop="dateCreated datePublished" datetime="2020-10-30T14:06:08+08:00">2020-10-30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-09-02 20:42:12" itemprop="dateModified" datetime="2021-09-02T20:42:12+08:00">2021-09-02</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">软件测试</span></a>
        </span>
    </span>

  
    <span id="/post/learning-testing-with-python/" class="post-meta-item leancloud_visitors" data-flag-title="Python 测试之道" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/post/learning-testing-with-python/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/post/learning-testing-with-python/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>21k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>19 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>ʕ •ᴥ•ʔ (๑˃̵ᴗ˂̵) ପ( ˘ᵕ˘ ) ੭ </p>
<a id="more"></a>

<h2 id="接口测试基础"><a href="#接口测试基础" class="headerlink" title="接口测试基础"></a>接口测试基础</h2><p>从技术的角度来说，把用户发起请求之后的<strong>等待时间</strong>称为<mark class="label info">响应时间</mark>。</p>
<h3 id="1-网络传输知识"><a href="#1-网络传输知识" class="headerlink" title="1 网络传输知识"></a>1 网络传输知识</h3><h4 id="1-1-Cache"><a href="#1-1-Cache" class="headerlink" title="1.1 Cache"></a>1.1 Cache</h4><p>提高反应速度的方法常见的有使用缓存、CDN、优化网页内容加载等。最常用的是使用缓存Cache保存到本地。根据类型来分缓存分为：</p>
<ul>
<li>浏览器缓存</li>
<li>代理缓存</li>
<li>网关缓存</li>
</ul>
<p>根据缓存策略来分：</p>
<ul>
<li>强缓存：直接从本地缓存中取资源，不会和服务器通信。</li>
<li>协商缓存：通过服务器告知是否能用本地缓存。<ul>
<li>先和服务器通信，若返回可以使用本地缓存的指示，再从本地缓存取；</li>
<li>如不可以使用本地缓存，就会返回最新的资源。</li>
</ul>
</li>
</ul>
<p>参考【<a target="_blank" rel="noopener" href="https://github.com/frontend9/fe9-interview/issues/29#:~:text=%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E5%88%86%E4%B8%BA%E5%BC%BA%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%EF%BC%8C%E4%B8%A4%E8%80%85%E6%9C%89%E4%B8%A4%E4%B8%AA%E6%AF%94%E8%BE%83%E6%98%8E%E6%98%BE%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A.%20%E5%A6%82%E6%9E%9C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%91%BD%E4%B8%AD%E5%BC%BA%E7%BC%93%E5%AD%98%EF%BC%8C%E5%88%99%E4%B8%8D%E9%9C%80%E8%A6%81%E7%BB%99%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E8%AF%B7%E6%B1%82%EF%BC%9B%E8%80%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E6%9C%80%E7%BB%88%E7%94%B1%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9D%A5%E5%86%B3%E5%AE%9A%E6%98%AF%E5%90%A6%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%EF%BC%8C%E5%8D%B3%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E5%AD%98%E5%9C%A8%E4%B8%80%E6%AC%A1%E9%80%9A%E4%BF%A1%E3%80%82.%20%E5%9C%A8%20chrome%20%E4%B8%AD%E5%BC%BA%E7%BC%93%E5%AD%98%EF%BC%88%E8%99%BD%E7%84%B6%E6%B2%A1%E6%9C%89%E5%8F%91%E5%87%BA%E7%9C%9F%E5%AE%9E%E7%9A%84%20http%20%E8%AF%B7%E6%B1%82%EF%BC%89%E7%9A%84%E8%AF%B7%E6%B1%82%E7%8A%B6%E6%80%81%E7%A0%81%E8%BF%94%E5%9B%9E%E6%98%AF%20200,%E4%BC%9A%E5%88%86%E4%B8%BA%20from%20disk%20cache%20%E5%92%8C%20from%20memory%20cache.">阿里巴巴：浏览器的强缓存和协商缓存（一面）</a>】</p>
<p><img data-src="https://i.loli.net/2020/10/30/i47ltq5M2PzpbSf.png" alt="缓存策略"></p>
<p><img data-src="https://i.loli.net/2020/10/30/uGiFWU8mND9taqn.jpg" alt="IMG_9365.JPG"></p>
<h5 id="1-1-1-浏览器缓存"><a href="#1-1-1-浏览器缓存" class="headerlink" title="1.1.1 浏览器缓存"></a>1.1.1 浏览器缓存</h5><p>使用缓存 Cache 的站点会监听客户端向服务端发出的请求，并根据相应缓存设置保存服务器反馈的数据到本地主机，比如 HTML页面、图片等文件。当下次用户使用相同的 URL 发送请求，请求不会直接发向服务器，而是通过缓存策略先行判断是否使用之前已经保存下来的反馈文件，从而降低服务器的负载及提高数据的响应时间。这样可以节省上网流量。</p>
<h5 id="1-1-2-代理缓存"><a href="#1-1-2-代理缓存" class="headerlink" title="1.1.2 代理缓存"></a>1.1.2 代理缓存</h5><p>由于客户端内存的限制，浏览器缓存不能存放过多的数据，否则会降低本机的性能。在实际应用中，开发者需要缓存大规模的数据及面向更广泛的用户群时，可以使用代理缓存（代理服务器），它使用相同的原理，但可以用相同的方法为几百甚至几千的使用者服务。<strong>总结来说代理缓存比浏览器缓存面向多用户及大规模数据</strong>。</p>
<p>代理缓存是共享缓存的一种，不是只有一个人正在使用它们，而是同时存在大量的用户使用。</p>
<p>代理缓存既不属于客户端，也不属于服务器端，而是利用网络路由请求信息。有以下几种场景：</p>
<ul>
<li>用户手动设置浏览器的代理</li>
<li>使用网页代理，网页代理将你的 URL 请求通过它潜在的网络定向到代理，所以用户甚至无需手动配置它们</li>
</ul>
<h5 id="1-1-3-网关缓存"><a href="#1-1-3-网关缓存" class="headerlink" title="1.1.3 网关缓存"></a>1.1.3 网关缓存</h5><p>网关缓存同样是充当代理的角色，同样起到代理缓存的作用，但是他和代理缓存是有区别的。网关可以为通信线路上的服务器提供不同的协议服务。加入上网线路为：</p>
<ul>
<li><p>代理缓存：$用户\dashrightarrow代理服务器\dashrightarrow服务器$ ，代理服务器与用户和服务器之间使用<strong>相同</strong>的通信协议</p>
</li>
<li><p>网关缓存：$用户\dashrightarrow网关\dashrightarrow服务器$ ，网关与用户和服务器之间可以使用<strong>不相同</strong>的通信协议</p>
</li>
</ul>
<p>网关缓存也是中间人，但不是由系统网络管理员处于节省带宽而部署，它们通常是网站站长部署的，使网站可扩展性、可靠性和性能更好，它可以将请求路由到网关高速缓存，类似于负载均衡器。</p>
<h4 id="1-2-Cookie"><a href="#1-2-Cookie" class="headerlink" title="1.2 Cookie"></a>1.2 Cookie</h4><p>可以用来解决 <mark class="label danger">无状态协议反复认证和身份认证</mark>的的特性。关于无状态协议和有状态协议：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000017357883">cookie与session详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_14989227/article/details/78961876?utm_medium=distribute.pc_relevant_bbs_down.none-task-blog-baidujs-1.nonecase&depth_1-utm_source=distribute.pc_relevant_bbs_down.none-task-blog-baidujs-1.nonecase">哪些协议是无状态协议哪些是有状态的，怎么区别？</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/300560131">如何理解有状态协议和无状态协议？</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangvalue/article/details/100635666">http协议是无状态协议</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/bellkosmos/p/5237146.html">http协议无状态中的 “状态” 到底指的是什么？！</a></li>
</ul>
<p>此外还应该关注<mark class="label info">无连接</mark>协议，同时对应 HTTP 报文中的中的<mark class="label success">connect</mark>字段为<mark class="label danger">alive</mark> 或 <mark class="label danger">close</mark></p>
<p>用户浏览器访问一个支持 Cookie 的网站，会经过以下过程（1 2是首次请求访问时选择“保存用户名”，3 4是再次访问）：</p>
<p>（1）客户端  --&gt; 服务器</p>
<p>（2）客户端 （保存Cookie） &lt;-- 服务器（Set-Cookie）</p>
<p>（3）客户端（Cookie）  --&gt; 服务器</p>
<p>（4）客户端   &lt;--  服务器</p>
<h5 id="1-2-1-获取Cookie的途径"><a href="#1-2-1-获取Cookie的途径" class="headerlink" title="1.2.1 获取Cookie的途径"></a>1.2.1 获取Cookie的途径</h5><ol>
<li><p>使用抓包工具，如 BurpSuite 等</p>
</li>
<li><p>浏览器检查网页请求能够获取Cookie</p>
</li>
<li><p>从本地文件中获取</p>
<ul>
<li><p><strong>IE 浏览器</strong>：<code>%APPDATA%\Microsoft\Windows\Cookies\ </code>目录中的<code>xxx.txt</code>文件（里面可能有很多个<code>.txt Cookie</code>文件）</p>
</li>
<li><p><strong>Firefox</strong>：<code>%APPDATA%\Mozilla\Firefox\Profiles\</code> 目录中的<code>xxx.default</code>目录，名为<code>cookies.sqlite</code>的文件。在 Firefox 中查看 cookie，可以选择<code>工具 &gt; 选项 &gt; 隐私 &gt; 显示cookie</code>。</p>
</li>
<li><p><strong>Chrome</strong>：<code>%LOCALAPPDATA%\Google\Chrome\User Data\Default\</code> 目录中，名为<code>Cookies</code>的文件。在 Chrome 中查看 cookie，可以选择<code>设置 &gt; 隐私设置和安全性 &gt; Cookie 及其他网站数据 &gt; 查看所有 Cookie 和网站数据</code>。</p>
<p>在 IE 浏览器中，IE将各个站点的<code>Cookie</code>分别保存为一个<code>XXX.txt</code>这样的纯文本文件（文件个数可能很多，但文件大小都较小）；而 Firefox 和 Chrome 是将所有的<code>Cookie</code>都保存在一个文件中（文件大小较大），该文件的格式为<code>SQLite3</code>数据库格式的文件。</p>
</li>
</ul>
</li>
<li><p>通过前端技术获取</p>
<ul>
<li>可以在浏览器地址栏输入：<code>javascript:alert(document.cookie)</code></li>
</ul>
</li>
</ol>
<h5 id="1-2-2-Cookie的生命周期"><a href="#1-2-2-Cookie的生命周期" class="headerlink" title="1.2.2 Cookie的生命周期"></a>1.2.2 Cookie的生命周期</h5><ol>
<li><strong>默认情况下</strong>：Cookie 数据保存到内存里，当浏览器关闭后，Cookie数据被销毁</li>
<li><strong>持久化存储</strong>： 根据<code>setMaxAge(int seconds)</code>函数的参数来设置：</li>
</ol>
<ul>
<li>正数：将Cookie数据写到硬盘的文件中，持久化存储。并指定Cookie存活时间，时间到后，Cookie文件自动失效。 </li>
<li>负数：默认值，即关闭浏览器后，Cookie即失效 </li>
<li>零：删除Cookie信息，会马上在浏览器上删除指定的cookie</li>
</ul>
<p><code>setMaxAge</code>参数为正数时的情况如下：</p>
<table>
<thead>
<tr>
<th align="center">cookie时间是否到期</th>
<th align="center">重启浏览器</th>
<th align="center">不关闭浏览器</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>cookie时间未到</strong></td>
<td align="center">能访问cookie</td>
<td align="center">能访问cookie</td>
</tr>
<tr>
<td align="center"><strong>cookie时间到</strong></td>
<td align="center">不能访问cookie</td>
<td align="center">能访问cookie</td>
</tr>
</tbody></table>
<p>修改 Cookie 的生命周期的方法：</p>
<ul>
<li>通过浏览器修改</li>
<li>在服务器端的代码层面修改</li>
</ul>
<div class="note info"><p>Cookie 的常用属性：</p>
<ol>
<li><p><strong>Name</strong>：Cookie 的名称。Cookie 一旦创建，名称便不可以修改。</p>
</li>
<li><p><strong>Value</strong>：Cookie 的值。如果值为<code>Unicode</code>字符，需要为字符编码，如果值为二进制数据，则需要使用<code>base64</code>编码</p>
<ul>
<li><p><strong>Unicode编码</strong>：<mark class="label info">保存中文</mark></p>
<p>中文与英文字符不同，中文属于<code>Unicode</code>字符，在内存中占<code>4</code>个字符，而英文属于<code>ASCII</code>字 符，内存中只占<code>2</code>个字节。Cookie 中使用<code>Unicode</code>字符时需要对<code>Unicode</code>字符进行编码，否则会乱码。</p>
</li>
<li><p><strong>Base64编码</strong>：<mark class="label warning">保存二进制图片</mark></p>
<p>Cookie 不仅可以使用<code>ASCII</code>字符与<code>Unicode</code>字符，还可以使用二进制数据。例如，在Cookie中使用数字证书，提供安全度。使用二进制数据时需要进行Base64编码。</p>
</li>
</ul>
</li>
<li><p><strong>Expires&#x2F;Max-Age</strong>：Cookie 失效时间，单位为秒。</p>
<ul>
<li>如果为正数，该 Cookie 会在 MaxAge 秒之后自动失效。</li>
<li>为0时表示立即删除Cookie。</li>
<li>为负数，表示该 Cookie 为临时 Cookie，关闭浏览器即失效，默认值为<code>-1</code>。</li>
</ul>
</li>
<li><p><strong>Secure</strong>：该 Cookie 是否仅被使用安全传输协议传输。安全协议由 HTTPS、SSL等，在网络上传输数据之前先将数据加密，默认是<code>false</code>。</p>
</li>
<li><p><strong>Path</strong>：该 Cookie 的使用路径。</p>
</li>
<li><p><strong>Domain</strong>：可以访问该 Cookie 的域名。如果设置为<code>.google.com</code>，则所有以<code>google.com</code>结尾的域名都可以访问该 Cookie（即它的子域名）。若当前网站是非顶级域名，如二级域名或者三级域名，设置的 Cookie 的<code>domain</code>只能为顶级域名或者二级域名或者三级域名本身，不能设置其他二级域名的 Cookie，否则 Cookie 无法生成。</p>
</li>
<li><p><strong>HttpOnly</strong>：Cookie 的<code>HttpOnly</code> 属性是 Cookie 的扩展功能，它使<code>JavaScript</code> 脚本无法获得 Cookie。其主要目的为防止跨站脚本攻击（<code>Cross-sitescripting</code>，<code>XSS</code>）对 Cookie 的信息窃取。</p>
</li>
</ol>
</div>

<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/27669892">认识HTTP—-Cookie和Session篇</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/dd73c27ab8d6">Cookie中的SameSite设置</a></li>
</ul>
<h4 id="1-3-Session"><a href="#1-3-Session" class="headerlink" title="1.3 Session"></a>1.3 Session</h4><p>Session 和 Cookie 一样是用来解决无状态协议的，不同的是 Cookie 保存在<mark class="label primary">客户端浏览器</mark>中，而 Session 保存在<mark class="label default">服务器</mark>上。</p>
<p>客户端访问网站带有 Session 的过程：</p>
<p>（1）客户端  --&gt; 服务器</p>
<p>（2）客户端  &lt;-- 服务器（Set-Session 并保存）</p>
<p>（3）客户端（Session）  --&gt; 服务器</p>
<p>（4）客户端   &lt;--  服务器</p>
<p>HTTP协议本身是”无状态”的，在一次请求和下一次请求之间没有任何状态保持，服务器无法识别来自同一用户的连续请求。有了cookie和session，服务器就可以利用它们记录客户端的访问状态了，这样用户就不用在每次访问不同页面都需要登录了。</p>
<p><strong>什么是cookie，cookie的应用场景及缺点</strong></p>
<p>cookie是一种数据存储技术, 它是将一段文本保存在客户端(浏览器或本地电脑)的一种技术，并且可以长时间的保存。当用户首次通过客户端访问服务器时，web服务器会发送给客户端的一小段信息。客户端浏览器会将这段信息以cookie形式保存在本地某个目录下的文件内。当客户端下次再发送请求时会自动将cookie也发送到服务器端，这样服务器端通过查验cookie内容就知道该客户端早访问过了。</p>
<div class="note primary"><p>Cookie 的常见应用场景包括：</p>
<ul>
<li>判断用户是否已经登录</li>
<li>记录用户登录信息(比如用户名，上次登录时间）</li>
<li>记录用户搜索关键词</li>
</ul>
<p>Session 的常见应用场景包括：验证登录信息</p>
</div>

<p>Cookie的缺点在于其并<strong>不可靠</strong>和<strong>不安全</strong>，主要原因如下:</p>
<ul>
<li>浏览器不一定会保存服务器发来的cookie，用户可以通过设置选择是否保存cookie。</li>
<li>cookie是有生命周期的（通过Expire设置），如果超过周期，cookie就会被清除。</li>
<li>HTTP数据通过明文发送，容易受到攻击，因此不能在cookie中存放敏感信息（比如信用卡号，密码等）。</li>
<li>cookie以文件形式存储在客户端，用户可以随意修改的。</li>
</ul>
<p><strong>什么是session及session的工作原理</strong></p>
<p>session又名会话，其功能与应用场景与cookie类似，用来存储少量的数据或信息。但由于数据存储在服务器上，而不是客户端上，所以比cookie更安全。</p>
<p>Session工作的流程如下：</p>
<ul>
<li>客户端向服务器发送请求时，看本地是否有cookie文件。如果有，就在HTTP的请求头（Request Headers）中，包含一行cookie信息。</li>
<li>服务器接收到请求后，根据cookie信息，得到sessionId，根据sessionId找到对应的session，用这个session就能判断出用户是否登录等等。</li>
</ul>
<p>使用Session的好处在于，即使用户关闭了浏览器，session仍将保持到会话过期。</p>
<h5 id="1-3-1-Session的传输"><a href="#1-3-1-Session的传输" class="headerlink" title="1.3.1 Session的传输"></a>1.3.1 Session的传输</h5><ul>
<li>通过 Cookie 传输</li>
<li>URL地址重写</li>
</ul>
<p>Session 可以借助 Cookie 来传输，在 Cookie 中会有一个<code>sessionID</code>的键值对，他就是用来传输 Session 的。</p>
<p>一次打开浏览器时，session是可以多窗口共享的，子窗口可以使用符窗口的 Cookie，因此会共享一个 Session，但是重新打开浏览器（重新启动）会生成新的 Session。但是如果浏览器将 Cookie 功能禁用或者网站不支持 Cookie 时，这时候就不能够通过 Cookie 来传输 Session，所以就使用 URL 地址重写来进行 Session 的传输。</p>
<p>URL地址重写是对客户端不支持 Cookie 的解决方案。它的原理是将用户的 Session 的 ID 信息重写到 URL 地址中。服务器能够解析重写后的 URL，获取 Session 的 ID。 服务器会先自动判断客户端是否支持 Cookie。如果客户端支持，会将 URL 原封不动地输出，如果不支持，则会将 Session 的 ID 重写到 URL 中，重写后的 URL 可能是这样的：<code>https://mp.weixin.qq.com/s?jsessionid=BYjhghj89HBbuhygG-145</code></p>
<h5 id="1-3-2-Session的生命周期"><a href="#1-3-2-Session的生命周期" class="headerlink" title="1.3.2 Session的生命周期"></a>1.3.2 Session的生命周期</h5><p>需要区分开 Session 和 Session ID，Session 由服务器来进行存储，而且是<mark class="label warning">存储在内存中</mark>，不过 Session 可以通过特殊的方式做持久化管理（memcache，redis）。Session ID 存放在服务器以及客户端的 Cookie 中，客户端中的 Session ID 用来和服务器进行会话认证。</p>
<p>服务器内存中有许多的 Session，可以用使用 Session ID 来找到 Session 对象，这就是使用 Session ID 来标志 Session 的作用。</p>
<ul>
<li>在创建了 Session 的同时，服务器会为该 Session 生成唯一的Session ID，而这个Session ID 在随后的请求中会被用来重新获得已经创建的Session；</li>
<li>在 Session 被创建之后，就可以调用Session相关的方法往 Session 中增加内容了，而这些内容只会保存在服务器中，发到客户端的只有SessionID；</li>
<li>当客户端再次发送请求的时候，会将这个Session ID 带上，服务器接受到请求之后就会依据 Session ID 找到相应的 Session，从而再次使用之。</li>
</ul>
<div class="note danger"><p>Session 和 Session ID 的删除：</p>
<ol>
<li>当浏览器关闭时 Session ID 会删除而 Session 不会删除。</li>
<li>Session 删除的几种方式：超时、程序调用<code>HttpSession.invalidate()</code>、服务器关机或重启（内存数据丢失）。</li>
</ol>
</div>

<p>参考【<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43625577/article/details/92393581">Cookie和Session、SessionID的那些事儿</a>】</p>
<h5 id="1-3-3-Cookie和Session的区别"><a href="#1-3-3-Cookie和Session的区别" class="headerlink" title="1.3.3 Cookie和Session的区别"></a>1.3.3 Cookie和Session的区别</h5><ol>
<li><strong>存储位置不同</strong></li>
</ol>
<p>通常情况</p>
<ul>
<li>Cookie 的数据信息存放在客户端浏览器上。</li>
<li>Session 的数据信息存放在服务器内存中。</li>
</ul>
<ol start="2">
<li><strong>存储容量不同</strong></li>
</ol>
<p>通常情况</p>
<ul>
<li>单个 Cookie 保存的数据<code>≤ 4KB</code>，一个站点最多保存<code>20</code>个 Cookie。</li>
<li>对于 Session 并没有上限，但出于对服务器端的性能考虑，Session 内不要存放过多的东西，并且设置 Session 删除机制。</li>
</ul>
<ol start="3">
<li><strong>存取方式的不同</strong></li>
</ol>
<ul>
<li>Cookie 中只能保管<code>ASCII</code>字符串，需要通过编码的方式存取<code>Unicode</code>字符或者二进制数据。运用 Cookie 难以实现存储略微复杂的信息。</li>
<li>Session中能够存取任何类型的数据，包括且不限于Sting、Integer、List、Map等。</li>
</ul>
<ol start="4">
<li><strong>隐私策略的不同</strong></li>
</ol>
<ul>
<li>Cookie 对客户端是可见的，别有用心的人可以分析存放在本地的 Cookie 并进行Cookie欺骗，所以它是不安全的。</li>
<li>Session 存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。</li>
</ul>
<p>假如选用 Cookie，比较好的方法是：敏感的的信息，如账号密码等，尽量不要写到 Cookie中。可以将 Cookie 信息加密，提交到服多务器后再进行解密。存储在本地的 Cookie 就需要自行加密。</p>
<ol start="5">
<li><strong>有效期上的不同</strong></li>
</ol>
<ul>
<li>开发可以通过设置 Cookie的属性，达到使Cookie长期有效的效果。</li>
<li>由于Session依赖于名为<code>JSESSIONID</code>的 Cookie，而<code>Cookie JSESSIONID</code>的过期时间默认为<code>-1</code>，只需关闭窗口该 Session 就会失效。因而 Session 不能达到长期有效的效果，就算不依顿于 Cookie，运用 URL 地址重写也不能完成，因为假如设置 Session 的超时时间过长，服务器累计的 Session 就会越多，越容易导致内存溢出。</li>
</ul>
<ol start="6">
<li><strong>服务器压力的不同</strong></li>
</ol>
<ul>
<li>Session 是保管在服务器端内存中的，每个用户都会产生一个 Session。假如并发访问的用户很多，会产生很多的 Session，耗费大量的内存。</li>
<li>Cookie 保管在客户端，不占用服务器资源。对于并发用户很多的网站，Cookie 是很好的选择。</li>
</ul>
<ol start="7">
<li><strong>浏览器支持的不同</strong></li>
</ol>
<p>假如客户端浏览器不支持 Cookie。</p>
<ul>
<li>Cookie 是需要客户端浏览器支持的。假如客户端禁用了 Cookie， 或者不支持 Cookie，则会话跟踪会失效。关于 WAP 上的应用，常规的 Cookie 就派不上用场了。</li>
<li>运用 Session 需要使用URL地址重写的方式。一切用到 Session 程序的 URL 都要进行 URL 地址重写，否则Session 会话跟踪还会失效。关于 WAP 应用来说，Session+URL 地址重写或许是它唯一的选择。</li>
</ul>
<p>假如客户端支持Cookie。</p>
<ul>
<li>Cookie既能够设为本浏览器窗口以及子窗口内有效（把过期时间设为<code>-1</code>），也能够设为一切窗口内有效（把过期时间设为某个大于0的整数）。</li>
<li>Session 只能在本窗口以及其子窗口内有效。假如两个浏览器窗口互不相干，它们将运用两个不同的 Session（IE8 下不同窗口 Session 相干。）</li>
</ul>
<ol start="8">
<li><strong>跨域支持上的不同</strong></li>
</ol>
<ul>
<li>Cookie支持跨城名访问，例如，将<code>domain</code>属性设置为<code>.biaodianfu.com</code>，则以 <code>.biaodianfu.com</code>为后缀的一切域名均能够访问该 Cookie。跨域名 Cookie 如今被普遍用在网络中，例如，Google、Baidu、Sina 等。</li>
<li>Session 则不会支持跨坡名访问。Session 仅在它所在的城名内有效。</li>
</ul>
<h4 id="1-4-Token"><a href="#1-4-Token" class="headerlink" title="1.4 Token"></a>1.4 Token</h4><ul>
<li>Session 是用来解决 Cookie 的安全性的问题的，那么 Token 就是用来解决 Session 消耗内存问题而提升性能的。</li>
<li>Token 是使用时间换取空间的方法，即 CPU 计算验证的时间换取内存存储 Session 的空间。</li>
<li>Token 受同源策略限制，而 Cookie 和 Session 不受同源策略限制，故 Token 能够防范 CSRF 攻击。</li>
</ul>
<p><img data-src="https://i.loli.net/2020/11/03/MGPEQZzJ8YvUO9K.png" alt="未命名文件.png"></p>
<div class="note warning"><p>Token 的原理图如上图，可以概述为以下几点：</p>
<p>（1）客户端第一次请求时，发送用户信息到服务器。服务器收到用户信息并进行身份认证无误后，使用加密算法和密钥对用户信息进行签名，然后将被签名和数据作为 Token，返回给客户端。</p>
<p>（2）<strong>服务器端不保存 Token，客户端保存 Token</strong>。</p>
<p>（3）客户端再次发送请求时，在请求的信息中将 Token 一起发送给服务器。</p>
<p>（4）服务器使用同样的加密算法和密钥对数据再进行一次签名，然后对比计算得到的签名和 Token 的签名做比较进行认证。</p>
</div>

<p>运用 Token 服务器就不再需要保存 Session 了，只需要生成 Token 然后认证 Token，这就是服务器利用 CPU 计算时间换取 Session存储空间的方式。Token 可以放在 Cookie 中，若客户端不支持 Cookie，Token 也可以放置在请求头中。</p>
<p>Token 通常用于一种轻巧的规范下，这种规范叫做 JOSN Web Token（<mark class="label success">JWT</mark>）。</p>
<div class="note success"><p><strong>Token可以抵抗CSRF，Cookie + Session不行？</strong></p>
<p>假如用户正在登陆银行网页，同时登陆了攻击者的网页，并且银行网页未对csrf攻击进行防护。攻击者就可以在网页放一个表单，该表单提交src为<code>http://www.bank.com/api/transfer</code>，body为<code>count=1000&amp;to=Tom</code>。倘若是session+cookie，用户打开网页的时候就已经转给Tom1000元了.因为form 发起的 POST 请求并不受到浏览器同源策略的限制，因此可以任意地使用其他域的 Cookie 向其他域发送 POST 请求，形成 CSRF 攻击。在post请求的瞬间，cookie会被浏览器自动添加到请求头中。但token不同，token是开发者为了防范csrf而特别设计的令牌，浏览器不会自动添加到headers里，攻击者也无法访问用户的token，所以提交的表单无法通过服务器过滤，也就无法形成攻击。</p>
</div>

<p>参考文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/63061864">彻底理解cookie，session，token</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xuxinstyle/p/9675541.html">深入理解token</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lufeiludaima/p/pz20190203.html">什么是token及怎样生成token</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000017831088">彻底弄懂session，cookie，token</a></li>
</ul>
<h4 id="1-5-JOSN-Web-Token（JWT）"><a href="#1-5-JOSN-Web-Token（JWT）" class="headerlink" title="1.5 JOSN Web Token（JWT）"></a>1.5 JOSN Web Token（JWT）</h4><p>JOSN Web Token（JWT）是一种开放标准（ RFC 7519），它定义了一种紧凑且安全的标准，用于将各方之间的信息传输为 JSON 对象。该信息通过数字简明进行校验。使用 HMAC 算法或者使用 RSA 的公钥&#x2F;私钥对 JWT 进行检签名，但是在通信中为了提高通信的速度，所以一般使用对称密码算法进行数字签名。</p>
<p>JWT 由三部分组成：<mark class="label info">头部</mark>、<mark class="label warning">荷载</mark> 与 <mark class="label success">签名</mark>。</p>
<h5 id="1-5-1-头部-Header"><a href="#1-5-1-头部-Header" class="headerlink" title="1.5.1 头部( Header )"></a>1.5.1 头部( Header )</h5><p>头部用于描述关于 JWT 的最基本的信息，例如，其类型以及签名所用的算法等。它被表示成一个 JSON 对象。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span>,</span><br><span class="line"><span class="attr">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，我们说明了这是一个<code>JWT</code>，并且我们所用的签名算法是<code>HS256</code>算法。</p>
<p>对它进行<mark class="label danger">Base64编码后</mark>形成的字符串就成了<code>JWT</code>的<code>header</code> (头部)。</p>
<h5 id="1-5-2-载荷-Payload"><a href="#1-5-2-载荷-Payload" class="headerlink" title="1.5.2 载荷( Payload )"></a>1.5.2 载荷( Payload )</h5><p>将添加好友的操作描述成一个<code>JSON</code>对象。其中添加了一些其他的信息，帮助今后收到这个<code>JWT</code>的服务器理解这个<code>JWT</code>。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;iss&quot;</span>: <span class="string">&quot;Kathy Yang JWT&quot;</span>, </span><br><span class="line"><span class="attr">&quot;iat&quot;</span>: <span class="number">1455624102</span>,</span><br><span class="line"><span class="attr">&quot;exp&quot;</span>: <span class="number">1475632522</span>,</span><br><span class="line"><span class="attr">&quot;aud&quot;</span>: <span class="string">&quot;www.example.com&quot;</span>,</span><br><span class="line"><span class="attr">&quot;sub&quot;</span>: <span class="string">&quot;jrocket@example.com&quot;</span>,</span><br><span class="line"><span class="attr">&quot;Givename&quot;</span>: <span class="string">&quot;Smark&quot;</span>,</span><br><span class="line"><span class="attr">&quot;Surname&quot;</span>: <span class="string">&quot;Kathy&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面的前五个字段都是由<code>JWT</code>的标准所定义的。</p>
<ul>
<li><code>iss</code>：该<code>JWT</code>的签发者。</li>
<li><code>sub</code>：该<code>JWT</code>所面向的用户。</li>
<li><code>aud</code>：接收该<code>JWT</code>的一方。</li>
<li><code>exp</code>(<code>expires</code>)：什么时候过期，这里是一个<code>UNIX</code>时间戳。</li>
<li><code>iat</code>(<code>issued at</code>)：在什么时候签发的。</li>
</ul>
<p>将上面的<code>JSON</code>对象进行<mark class="label danger">Base64编码后</mark>可以得到一串字符串。这个字符串我们将它称作<code>JWT</code>的<code>Payload</code> (载荷)。</p>
<h5 id="1-5-3-签名-Signature"><a href="#1-5-3-签名-Signature" class="headerlink" title="1.5.3 签名( Signature )"></a>1.5.3 签名( Signature )</h5><p>将上面的两个编码后的字符串都用符号 <code>.</code> 连接在一起 （头部在前），就形成了一串新的字符串。最后，我们将上面拼接完的字符串用<code>HS256</code>算法进行加密。在加密的时候，我们还需要提供一个密钥（<code>secret</code>）。通过密钥和加密算法加密后的部分就叫作签名。</p>
<p>总结 <code>JWT</code> 生成过程为：</p>
<div class="note primary"><ol>
<li>头部<code>JSON</code>对象 --&gt; <code>Base64</code>  --&gt; <code>JWT</code>的头部<code>Head</code></li>
<li>荷载<code>JSON</code>对象 --&gt; <code>Base64</code>  --&gt; <code>JWT</code>的荷载<code>Payload</code></li>
<li><code>JWTHead.JWTPayload</code>  --&gt;  <code>HS256</code>加密   --&gt; <code>JWT</code>的签名<code>Signature</code></li>
<li><code>JWT</code>的完整格式：<mark class="label success">Head</mark><mark class="label danger">.</mark><mark class="label success">Payload</mark><mark class="label danger">.</mark><mark class="label success">Signature</mark></li>
</ol>
</div>



<p>下面通过一个实例了解<code>JWT</code>机制实现认证的过程。当用户第一次登录系统时，如图4.17所示。</p>
<p>创建<code>JWT</code>的步骤如下。</p>
<p>(1)第一次登录，用户从客户端输人用户名&#x2F;密码，提交后到服务器的登录处理<code>Action</code>层 （ <code>Login Action</code>）。</p>
<p><img data-src="https://i.loli.net/2020/11/04/m1GFIQfnhrzsACE.png" alt="Login Action.png"></p>
<p><img data-src="https://i.loli.net/2020/11/04/PjdGCvabwDmqFxn.png" alt="第4章 接口测试的基础 2.png"></p>
<p><img data-src="https://i.loli.net/2020/11/04/TA2LqSRjkVfgxBe.png" alt="1598504-20190202220449263-1608141775.png"></p>
<h3 id="2-HTTP-协议"><a href="#2-HTTP-协议" class="headerlink" title="2 HTTP 协议"></a>2 HTTP 协议</h3><p>网络协议就是为计算机网络中进行数据交换而建立的规则、标准或约定的集合。</p>
<p>为了使不同计算机厂家 生产的计算机能够相互通信，以便在更大的范围内建立计算机网络，国际标准化组织（ISO）在1978 年提出了“开放系统互联参考模型”，即著名的 OSIRM 模型（Open System Itereonnection&#x2F;RefrerceModel）。它将计算机网络体系结构的通信协议划分为七层，自下而上依次为：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p>
<p>每一层都有其不同的含义及网络协议。</p>
<table>
<thead>
<tr>
<th align="center">网络结构层</th>
<th>协议</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>物理层</strong></td>
<td>以太网、调制解调器、电力线通信(PLC)、SONET&#x2F;SDH、光导纤维、同轴电缆、双绞线等。</td>
</tr>
<tr>
<td align="center"><strong>数据链路层</strong></td>
<td>Wi-Fi(EEE 82.11)、WiMAX(IEEE 802.16)、ATM、令牌环、PPP、L2TP、PPTP等。</td>
</tr>
<tr>
<td align="center"><strong>网络层协议</strong></td>
<td>IP(IPv4、IPv6)、ICMP、ICMPv6、IGMP、IS-IS、IPsec、 ARP、RARP等。</td>
</tr>
<tr>
<td align="center"><strong>传输层协议</strong></td>
<td>TCP、UDP、TLS、 DCCP、SCTP、 RSVP、 OSPF 等。</td>
</tr>
<tr>
<td align="center"><strong>应用层协议</strong></td>
<td>DNS、FTP、Gopher、HTTP、IMAP4、POP3、SIP、SSH、TELNET、RPC、SDP、SOAP、GTP等。</td>
</tr>
</tbody></table>
<p>本节主要讲的就是应用层中被应用最多的协议：HTTP 协议。</p>
<h4 id="2-1-HTTP-协议介绍"><a href="#2-1-HTTP-协议介绍" class="headerlink" title="2.1 HTTP 协议介绍"></a>2.1 HTTP 协议介绍</h4><p>HTTP&#x2F;1.0 没有充分考虑分层代理、缓存以及持久连接和虚拟主机的需求的影响。并且随着不完善的 HTTP&#x2F;1.0 应用程序的激增，迫切需要一个新的版本，以便使两个通信程序能够确定彼此真实的能力。此规范协议叫做<mark class="label primary">HTTP/1.1</mark>，这个协议与<mark class="label success">HTTP/1.0</mark>相比，更为严格，以确保各个协议的特征得到可靠实现。</p>
<p>把HTTP协议的官方定义进行归纳，得出HTTP协议的4个关键点。</p>
<p>（1）HTTP 是建立在 TCP&#x2F;IP 协议之上，面向应用层的超文本传输协议。</p>
<p>（2）它由请求和响应组成，完全符合标准的客户端服务器的请求响应模型。</p>
<p>（3）协议很轻便简单，并且请求与请求间没有关联，是无状态性的协议。</p>
<p>（4）为了弥补这种无状态性就需要使用 HTTP 协议的扩展 Cookie 等方式建立关联。</p>
<p>（5）HTTP 协议工作于客户端-服务器的架构上，采用请求&#x2F;响应模型。</p>
<h4 id="2-2-Uniform-Resource-Locator（URL）"><a href="#2-2-Uniform-Resource-Locator（URL）" class="headerlink" title="2.2 Uniform Resource Locator（URL）"></a>2.2 Uniform Resource Locator（URL）</h4><ul>
<li>URL：统一资源定位器&#x2F;统一资源定位系统。HTTP&#x2F;1.0支持：GET、POST、HEAD三种HTTP请求方法。</li>
<li>URI：统一资源定位标识符（Uniform Resource Identifiers），URL 是一种特殊类型的 URI，包含了用于查找某个资源的足够的信息。HTTP&#x2F;1.1是当前正在使用的版本。该版本默认采用持久连接，并能很好地配合代理服务器工作。还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。HTTP&#x2F;1.1 新增了：OPTIONS、PUT、DELETE、TRACE、CONNECT 五种 HTTP 请求方法。</li>
</ul>
<p>URL 的基本格式如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">schema://host[:port#]/path/.../[;url-params][?query-string][#anchor]</span><br><span class="line">&lt;方案&gt;://&lt;用户名&gt;:&lt;密码&gt;@主机:端口/路径;参数?查询#片段</span><br></pre></td></tr></table></figure>

<p>URL主要有三个作用。</p>
<p>（1）HTTP 是 URL 的方案，方案告诉客户端使用什么样的协议去访问服务器。</p>
<p>（2）<code>Host: www.example.com</code>， 指服务器的位置。</p>
<p>（3）<code>/index.html</code>是资源路径，说明了请求的是服务器上哪个特定的本地资源。</p>
<p>我们以链接<code>http://www.kath2.com/news/index.asp?ID=210&amp;page=1#name</code> 为例，对 URL 进行详解。</p>
<p>URL 一般分为以下几个部分。</p>
<ol>
<li><strong>协议部分</strong>：该 URL 的协议部分为<code>HTTP:</code>，这代表网页使用的是 HTTP 协议。在 Internet 中可以使用多种协议，如HTTPS、Ftp 等。在<code>HTTP</code>后面的<code>//</code>为分隔符。</li>
<li><strong>域名部分</strong>：该 URL 的域名部分为<code>www.kath2.com</code> 。一个 URL 中，也可以使用 IP 地址作为域名使用。</li>
<li><strong>端口部分</strong>：跟在域名后面的是端口，域名和端口之间使用 <code>.</code> 作为分隔符。端口不是一 个 URL 必需的部分，如果省略端口部分，将采用默认端口。例如，HTTP 的默认端口为<code>80</code>, HTTPS 的默认端口为<code>443</code>。</li>
<li><strong>虚拟目录部分</strong>：从域名后的第一个<code>/</code>开始到最后一个<code>/</code>为止，是虛拟目录部分。 虚拟目录也不是一个 URL必需的部分。本例中的虚拟目录是<code>/news/</code>。</li>
<li><strong>文件名部分</strong>：从域名后的最后一个<code>/</code>开始到<code>?</code>为止，是文件名部分。<ol>
<li>如果没有<code>?</code>，则是从域名后的最后一个<code>/</code>开始到<code>#</code>为止，是文件名部分。 </li>
<li>如果没有<code>?</code>和<code>#</code>，那么从域名后的最后一个<code>/</code>开始到结束，都是文件名部分。 本例中的文件名是<code>index.asp</code> 。文件名部分也不是一个 URL 必需的部分，如果省略该部分，则使用默认的文件名。</li>
</ol>
</li>
<li><strong>锚部分</strong>：从<code>#</code>开始到最后，都是锚部分。本例中的锚部分是<code>name</code> 。锚部分也不是一个 URL 必需的部分。</li>
<li><strong>参数部分</strong>：从<code>?</code>开始到<code>#</code> 为止之间的部分为参数部分，又称搜索部分、查询部分。 本例中的参数部分为<code>ID= -210&amp;page=1</code>。可以允许有多个参数，参数与参数之间用<code>&amp;</code>作为分隔符。</li>
</ol>
<h4 id="2-3-请求报文（request）"><a href="#2-3-请求报文（request）" class="headerlink" title="2.3 请求报文（request）"></a>2.3 请求报文（request）</h4><h5 id="2-3-1-报文格式"><a href="#2-3-1-报文格式" class="headerlink" title="2.3.1 报文格式"></a>2.3.1 报文格式</h5><p><img data-src="https://i.loli.net/2020/11/06/3eD81tGJxwgSfIV.png" alt="屏幕快照 2020-11-06 下午2.37.26.png"></p>
<p>request 报文的结构分为 4 部分：</p>
<ul>
<li>请求行（request line）</li>
<li>请求头部（header）</li>
<li>空行</li>
<li>主体（body）</li>
</ul>
<p>header 和 body 之间有个<mark class="label warning">空行</mark>。</p>
<p><img data-src="https://i.loli.net/2020/11/06/21ah8vLkg9Np37m.png" alt="1820506-20190928150409842-1112819644 (1).png"></p>
<h5 id="2-3-2-请求行"><a href="#2-3-2-请求行" class="headerlink" title="2.3.2 请求行"></a>2.3.2 请求行</h5><p><strong>一、请求方法</strong></p>
<p>请求行中包括请求方法（<strong>GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT</strong>），其中最常用的为<strong>GET、POST</strong>。</p>
<p>请求的起始行以方法作为开始，方法用来告诉服务器要如何做。</p>
<p>在开发中通常有两种请求方式。</p>
<table>
<thead>
<tr>
<th align="center">请求方式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>GET</strong></td>
<td align="left">是以实体的方式得到由请求URI所指定资源的信息，如果请求 URI 只是一个数据产生过程，那么最终要在响应实体中返回的是处理过程的结果所指向的资源，而不是处理过程的描述。</td>
</tr>
<tr>
<td align="center"><strong>POST</strong></td>
<td align="left">用来向目的服务器发出请求，要求它接收被附在请求后的实体，并把它当作请求队列中请求 URI 所指定资源的附加新子项，所以 post 请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。</td>
</tr>
<tr>
<td align="center"><strong>HEAD</strong></td>
<td align="left">类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头。</td>
</tr>
<tr>
<td align="center"><strong>DELETE</strong></td>
<td align="left">请求服务器删除指定的页面。</td>
</tr>
<tr>
<td align="center"><strong>CONNECT</strong></td>
<td align="left">HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td>
</tr>
<tr>
<td align="center"><strong>OPTIONS</strong></td>
<td align="left">允许客户端查看服务器的性能。</td>
</tr>
<tr>
<td align="center"><strong>TRACE</strong></td>
<td align="left">回显服务器收到的请求，主要用于测试或调试。</td>
</tr>
</tbody></table>
<p><strong>二、HTTP版本</strong></p>
<table>
<thead>
<tr>
<th align="center">协议版本</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>HTTP&#x2F;1.0</strong></td>
<td>HTTP&#x2F;1.0支持：GET、POST、HEAD三种HTTP请求方法。</td>
</tr>
<tr>
<td align="center"><strong>HTTP&#x2F;1.1</strong></td>
<td>HTTP&#x2F;1.1是当前正在使用的版本。该版本默认采用持久连接，并能很好地配合代理服务器工作。还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。HTTP&#x2F;1.1新增了：OPTIONS、PUT、DELETE、TRACE、CONNECT 五种 HTTP 请求方法。</td>
</tr>
</tbody></table>
<p>　</p>
<h5 id="2-3-3-请求头"><a href="#2-3-3-请求头" class="headerlink" title="2.3.3 请求头"></a>2.3.3 请求头</h5><p>请求报头域主要用于指定被请求资源的 Internet 主机和端口号，它通常从 HTTP URL 中提取出来。</p>
<p>请求报文的 header 属性为以下六个部分：</p>
<ul>
<li>Cache</li>
<li>Client</li>
<li>Cookies</li>
<li>Miscellaneou</li>
<li>Security</li>
<li>Transport</li>
</ul>
<p><strong>一、Cache</strong> 头域</p>
<table>
<thead>
<tr>
<th align="center">Cache 字段名称</th>
<th>字段值说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>Cache-Control</strong></td>
<td>用来指定Response-Request遵循的缓存机制。各个指令含义如下。<br/><strong>Cache-Control:Public</strong>：可以被任何缓存所缓存。<br/><strong>Cache-Control:Private</strong>：指示响应信息的全部或部分用于单个用户，而不能用一个共享缓存来缓存。这可以让源服务器指示，响应的特定部分只用于一个用户，而对其他用户的请求则是一个不可靠的响应。<br/><strong>Cache-Control:no-cache</strong>：所有内容都不会被缓存，请求头里的<code>no-cache</code>表示浏览器不想读 缓存，并不是说没有缓存。一般在浏览器按<code>Ctrl+F5</code>键强制刷新时，请求头里也会有这个<code>no-cache</code>，也就是跳过强缓存和协商缓存阶段，直接请求服务器。<br/><strong>Cache-Control:max-age&#x3D;0</strong>：指示客户端愿意接收其绝对时间不大于指定的时间，以秒计。 如果直接按<code>F5</code>键的话，请求头是<code>max-age =0</code>，只跳过强缓存，但进行协商缓存。</td>
</tr>
<tr>
<td align="center"><strong>if-Modified-Since</strong></td>
<td>把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回<mark class="label primary">304</mark>，客户端就直接使用本地缓存文件。如果时间不一致，就会返回<mark class="label success">200</mark>和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中。<br/><strong>本地文件的修改时间和服务器上的文件修改时间一致， 说明文件没有被更新。HTTP服务器返回304，告诉客户端使用本地缓存文件。</strong></td>
</tr>
<tr>
<td align="center"><strong>If-None-Match</strong></td>
<td><mark class="label warning">If-None-Match</mark>和<mark class="label info">ETag</mark>一起工作，工作原理是在<code>HTTP response</code> 中添加 ETag 信息。当用户再 次请求该资源时，将在 <code>HTTP request</code> 中加入<code>If-None-Match</code>信息( <code>ETag</code>的值)。如果服务器验证资源的<code>ETag</code>没有改变(该资源没有更新)，将返回一个<code>304</code>状态告诉客户端使用本地缓存文件，否则将返回<code>200</code>状态和新的资源和<code>Etag</code>。 使用这样的机制将提高网站的性能。<br/><code>If-None-Mach</code>和<code>ETag</code>的值一致， 说明文件没有被更新。服务器将返回<code>304</code>，告诉客户端使用本地缓存文件。<br/></td>
</tr>
<tr>
<td align="center">Pragma</td>
<td>防止页面被缓存，<code>HTTP/L.1</code>版本中， 它和<code>Cache-Coltrol:no-cache</code>的作用一模一样。 <code>Pargma</code>只有一个用法，例如，<code>Pragma: no-cache</code>。</td>
</tr>
</tbody></table>
<p><strong>二、Client头域</strong></p>
<table>
<thead>
<tr>
<th>Client字段名称</th>
<th>字段值说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Accept</strong></td>
<td>浏览器端可以接收的媒体类型。<br/><mark class="label success">Accept: text/html</mark> 代表浏览器可以接收服务器发回的类型为<code>text/html</code>也就是我们常说的<code>HTML</code>文档，如果服务器无法返回<code>text/html</code>类型的数据，服务器应该返回一个<mark class="label info">406</mark>错误（non acceptable）<br/><mark class="label success">Accept:*/*</mark> 通配符<code>*</code>代表任意类型。代表浏览器可以处理所有类型。<br/><mark class="label success">Accept -Encoding</mark>  浏览器声明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法 ( <code>gzip</code>，<code>deflate</code>) 。例如，<code>Accept-Encoding: gzip, deflate</code><br/><mark class="label success">Accept - Language</mark>   浏览器声明自己接收的语言。语言跟字符集的区别是：中文是语言，中文有多种字符集，比 如<code>bigs</code>、<code>gb2312</code>、<code>gbk</code>等。</td>
</tr>
<tr>
<td><strong>User-Agent</strong></td>
<td>告诉 HTTP 服务器客户端使用的操作系统和浏览器的名称和版本。我们上网登录论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本、你所使用的浏览器的名称和版本，实际上，服务器应用程序就是从<code>User-Agent</code>这个请求报头域中获取到这些信息的。</td>
</tr>
<tr>
<td><strong>Accept-Charset</strong></td>
<td>浏览器声明自己接收的字符集，如<code>gb2312</code>、<code>utf-8</code>等。</td>
</tr>
</tbody></table>
<p><strong>三、Cookie</strong></p>
<table>
<thead>
<tr>
<th>Cookie字段名称</th>
<th>字段值说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Cookie</strong></td>
<td>最重要的 header，将Cookie 的值发送给 HTTP 服务器。</td>
</tr>
</tbody></table>
<p><strong>四、Miscellaneous 头域</strong></p>
<table>
<thead>
<tr>
<th>Miscellaneous字段名称</th>
<th>字段值说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Referer</strong></td>
<td>提供了 request 的上下文信息的服务器，告诉服务器我是从哪个链接过来的。有些统计数据需要用到此头域。比如从我的主页上链接到统计服务器那里，该服务器就能够从<code>HTTP Referer</code>中统计出每天有多少用户点击我主页上的链接访问他的网站。</td>
</tr>
</tbody></table>
<p><strong>五、Entity 头域</strong></p>
<table>
<thead>
<tr>
<th>Entity字段名称</th>
<th>字段值描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Content-Length</strong></td>
<td>发送给 HTTP 服务器数据的长度。</td>
</tr>
<tr>
<td><strong>Content-Type</strong></td>
<td>①表示具体请求中的媒体类型信息。常见的媒体格式类型如下。<br/><strong>text&#x2F;html</strong>：HTML格式<br/><strong>text&#x2F;plain</strong>：纯文本格式<br/><strong>text&#x2F;xml</strong>：XML格式<br/><strong>imag&#x2F;gif</strong>：gif图片格式<br/><strong>image&#x2F;jpeg</strong>：jpg图片格式<br/><strong>image&#x2F;png</strong>：png图片格式<br/>②以application开头的媒体格式类型如下：<br/><strong>application&#x2F;xhtml+xml</strong>：XHTML格式<br/><strong>application&#x2F;xml</strong>：XML数据格式<br/><strong>application&#x2F;atom+xml</strong>：Atom XML聚合格式<br/><strong>application&#x2F;json</strong>：JSON数据格式<br/><strong>application&#x2F;pdf</strong>：pdf格式<br/><strong>application&#x2F;msword</strong>：Word文档格式<br/><strong>application&#x2F;octet-stream</strong>：二进制流数据<br/><strong>application&#x2F;x-www-form-urlencoded</strong>： <code>&lt;form encType=&quot;&quot;&gt;</code>中默认的<code>encType</code>，<code>form</code>表单数据被编码为<code>key/value</code><br/>格式发送到服务器（表单默认的提交数据的格式）。<br/>③另外一种常见的媒体格式是上传文件之时使用的。<br/><strong>multipart&#x2F;form-data</strong>：需要在表单中进行文件上传时，就需要使用该格式。</td>
</tr>
</tbody></table>
<p><strong>六、Transport 头域</strong></p>
<table>
<thead>
<tr>
<th>Transport字段名称</th>
<th>字段值描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Connection</strong></td>
<td><strong>Connection: keep-alive</strong>：当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建 立的连接。<br/><strong>Connection: close</strong>：代表一个 request 完成后，客户端和服务器之间用于传输 HTTP 数据的TCP 连接会关闭，当客户端再次发送 request 时，需要重新建立 TCP 连接。</td>
</tr>
<tr>
<td><strong>Host</strong></td>
<td>发送请求时，该报头域是必需的</td>
</tr>
</tbody></table>
<p>参考文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Mr-mubai/p/11603520.html">HTTP报文格式</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kageome/p/10859996.html">http报文详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012375924/article/details/82806617">浅谈http中的Cache-Control</a></li>
<li><a target="_blank" rel="noopener" href="https://wenku.baidu.com/view/80397dda71fe910ef12df8af.html">http协议请求响应报文格式及状态码详解</a></li>
</ul>
<h4 id="2-4-响应报文（response）"><a href="#2-4-响应报文（response）" class="headerlink" title="2.4 响应报文（response）"></a>2.4 响应报文（response）</h4><h5 id="2-4-1-报文格式"><a href="#2-4-1-报文格式" class="headerlink" title="2.4.1 报文格式"></a>2.4.1 报文格式</h5><p>Response 报文的结构也分为 4 部分：</p>
<ul>
<li>响应状态（response code）</li>
<li>响应头（response header）</li>
<li>空行</li>
<li>响应主体（response body）</li>
</ul>
<p>header 和 body 之间也有一个空行。</p>
<p><img data-src="https://i.loli.net/2020/11/06/a8rIAkjD7qdzFT4.png" alt="屏幕快照 2020-11-06 下午2.40.03.png"></p>
<h5 id="2-4-2-状态行"><a href="#2-4-2-状态行" class="headerlink" title="2.4.2 状态行"></a>2.4.2 状态行</h5><p>状态行最重要的一部分就是响应报文的<mark class="label success">状态码</mark>。</p>
<p>当客户端发起一次 HTTP请求后，服务器会返回一个包含 HTTP 状态码的信息头（server header ）用以响应客户端的请求。response 消息中的第一行叫作<strong>状态行</strong>，由 HTTP 协议<strong>版本号</strong>、<strong>状态码</strong>、<strong>状态消息</strong>三部分组成。</p>
<p>状态码用来告诉 HTTP 客户端 HTTP 服务器是否产生了预期的 response。</p>
<div class="note warning"><p>状态码<mark class="label danger">总共只有三位</mark>，<mark class="label danger">第一位</mark>表示状态类别，共分为<mark class="label success">五种</mark>。</p>
<ul>
<li><mark class="label primary">1xx</mark>：是进度通知类状态，意思就是说“请求我已经收到了，或你的请求我正在处理”。</li>
<li><mark class="label primary">2xx</mark>：表示“你的请求我已经成功处理了”。</li>
<li><mark class="label primary">3xx</mark>：即重定向，也就是服务器告诉客户端“你要的资源搬家了，你到某某地方再去找它吧”。</li>
<li><mark class="label primary">4xx</mark>：客户端发来的响应报文里有些<strong>错误</strong>，比如语法错误或请求的资源不存在等。</li>
<li><mark class="label primary">5xx</mark>：服务器端有些问题，已经无法处理完成你的请求了。</li>
</ul>
</div>

<p>常用的一些状态码如下：</p>
<ul>
<li><strong>200 OK</strong>：客户端，你的请求处理成功，你要的东西就在响应报文里了。</li>
<li><strong>301 Moved Permanently</strong>：客户端，你要请求的资源已经永久地搬家了，我把它的新地址放到了<code>Location</code>头部域中了。</li>
<li><strong>302 Moved Temporarily</strong>：客户端，你要请求的源临时有事去别的地方了，我把它的位置放到<code>Location</code>头部域中了，你可以先去那里找它.不过它应该会回到它原来的家的。</li>
<li><strong>304 Not Modified</strong>：客户端，你要请求的资源自从上次你请求之后，就再也没有改动过。我想你应该早就有这个资源了。所以在响应报文的数据部分我就没有再放这个资源。</li>
<li><strong>400 Bad Request</strong>客户端，你发来的请求报文里有语法情误，服务器端实在看不懂。 </li>
<li><strong>401 Unauthorized</strong>：客户端，你发来的请求不是合法来源的请求，你是没有被授权的客户端吧。 </li>
<li><strong>403 Forbidden</strong>：服务器端顺利收到了客户端的请求，但因为某些理由，服务器端拒绝为你提供服务。</li>
<li><strong>404 Not Found</strong>：客户端，你请求的资源不存在，八成是资源地址写错了。</li>
<li><strong>500 Internal Server Error</strong>：很遗憾，服务器不能给你提供服务了，服务器内部出现了不可预知的问题。</li>
<li><strong>502 Bad Gateway</strong>：客户端你好，我是请求报文的代理服务器，持有资源的那个服务器在给我发送资源时出问题了。</li>
<li><strong>503 Server Unavailable</strong>：服务器现在可能是太忙了，暂时不能给你这个客户端提供服务，或许稍后会恢复的。</li>
</ul>
<p>除了以上几个常用的状态码，还有许多其他含义的状态码。完整状态码含义表如下。</p>
<p>（1）<mark class="label warning">请求收到，继续处理</mark></p>
<table>
<thead>
<tr>
<th align="center">状态码</th>
<th>状态描述</th>
<th>状态说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">100</td>
<td>Continue</td>
<td>客户端必须继续发出请求</td>
</tr>
<tr>
<td align="center">101</td>
<td>Switching Protocols</td>
<td>客户端要求服务器根据请求转换 HTTP 协议版本</td>
</tr>
</tbody></table>
<p>（2）<mark class="label warning">成功响应，操作成功收到，分析、接受</mark></p>
<table>
<thead>
<tr>
<th align="center">状态码</th>
<th>状态描述</th>
<th>状态说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">200</td>
<td>OK</td>
<td>请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td align="center">201</td>
<td>Created</td>
<td>已创建。成功请求并创建了新的资源。提示知道新文件的URL</td>
</tr>
<tr>
<td align="center">202</td>
<td>Accepted</td>
<td>已接受和处理，但处理未完成</td>
</tr>
<tr>
<td align="center">203</td>
<td>Non-Authoritative Information</td>
<td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本<br/>返回信息不确定或不完整</td>
</tr>
<tr>
<td align="center">204</td>
<td>No Content</td>
<td>无内容。服务器成功处理，但未返回内容。但返回信息为空<br/>在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td align="center">205</td>
<td>Reset Content</td>
<td>重置内容。服务器处理成功，用户终端（例如：浏览器）必须复位当前已经测览过的文件</td>
</tr>
<tr>
<td align="center">206</td>
<td>Partial Content</td>
<td>部分内容。服务器成功处理了部分 GET 请求</td>
</tr>
</tbody></table>
<p>（3）<mark class="label warning">重定向，完成此请求必须进一步处理</mark></p>
<table>
<thead>
<tr>
<th align="center">状态码</th>
<th>状态描述</th>
<th>状态说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">300</td>
<td>Multiple Choices</td>
<td>多种选择。请求的资源可在多处得到</td>
</tr>
<tr>
<td align="center">301</td>
<td>Moved Permanently</td>
<td>永久移动。请求的资源已被永久的移动到新 URI ，返回信息会包括新的 URI ，浏览器会自动定向到新 URI。<br/>今后任何新的请求都应使用新的 URI 代替</td>
</tr>
<tr>
<td align="center">302</td>
<td>Found</td>
<td>临时移动。与 301 类似。但资源只是临时被移动。客户端应继续使用原有 URI<br/>只有在<code>Cache-Control</code>或<code>Expires</code>中进行了指定的情况下，这个响应才是可缓存的</td>
</tr>
<tr>
<td align="center">303</td>
<td>See Other</td>
<td>查看其它地址。对应当前请求的响应可以在另一个 URI 上被找到，使用 GET 和 POST 请求查看<br/>这个方法的存在主要是为了允许由脚本激活的 POST 请求输出重定向到一个新的资源</td>
</tr>
<tr>
<td align="center">304</td>
<td>Not Modified</td>
<td>未修改。GET 所请求的资源未修改，服务器返回此状态码时，不会返回任何资源<br/>304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾</td>
</tr>
<tr>
<td align="center">305</td>
<td>Use Proxy</td>
<td>使用代理。所请求的资源必须通过服务器指定的代理访问</td>
</tr>
<tr>
<td align="center">306</td>
<td>Unused</td>
<td>已经被废弃的HTTP状态码，前一版本 HTTP 中使用用的代码，现行版本中 HTTP 不再使用</td>
</tr>
<tr>
<td align="center">307</td>
<td>Temporary Redirect</td>
<td>临时重定向。与302类似。使用GET请求重定向。</td>
</tr>
</tbody></table>
<p>（4）<mark class="label warning">请求错误，请求包含一个错误语法或不能完成</mark></p>
<table>
<thead>
<tr>
<th align="center">状态码</th>
<th>状态描述</th>
<th>状态说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">400</td>
<td>Bad Request</td>
<td>错误请求，如语法错误</td>
</tr>
<tr>
<td align="center">401</td>
<td>Unauthorized</td>
<td>未授权，请求要求用户的身份认证</td>
</tr>
<tr>
<td align="center">401.1</td>
<td></td>
<td>未授权：登录失败</td>
</tr>
<tr>
<td align="center">401.2</td>
<td></td>
<td>未授权：服务器配置问题导致登录失败</td>
</tr>
<tr>
<td align="center">401.3</td>
<td></td>
<td>未授权：禁止访问资源，由于 ACL 对资源的限制而未获得授权。</td>
</tr>
<tr>
<td align="center">401.4</td>
<td></td>
<td>授权被筛选器拒绝</td>
</tr>
<tr>
<td align="center">401.5</td>
<td></td>
<td>未授权：ISAPI 或 CGl 授权失败</td>
</tr>
<tr>
<td align="center">401.7</td>
<td></td>
<td>访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。</td>
</tr>
<tr>
<td align="center">402</td>
<td>Payment Required</td>
<td>保留，将来使用</td>
</tr>
<tr>
<td align="center">403</td>
<td>Forbidden</td>
<td>服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td align="center">403.1</td>
<td></td>
<td>禁止可执行访问</td>
</tr>
<tr>
<td align="center">403.2</td>
<td></td>
<td>禁止读访问</td>
</tr>
<tr>
<td align="center">403.3</td>
<td></td>
<td>禁止写访问</td>
</tr>
<tr>
<td align="center">403.4</td>
<td></td>
<td>禁止访问：要求SSL</td>
</tr>
<tr>
<td align="center">403.5</td>
<td></td>
<td>禁止访问：要求SSL128</td>
</tr>
<tr>
<td align="center">403.6</td>
<td></td>
<td>禁止访问：IP地址被拒绝</td>
</tr>
<tr>
<td align="center">403.7</td>
<td></td>
<td>禁止访问：要求客户证书</td>
</tr>
<tr>
<td align="center">403.8</td>
<td></td>
<td>禁止访问：禁止站点访问</td>
</tr>
<tr>
<td align="center">403.9</td>
<td></td>
<td>禁止访问：连接的用户过多</td>
</tr>
<tr>
<td align="center">403.10</td>
<td></td>
<td>禁止访问：配置无效</td>
</tr>
<tr>
<td align="center">403.11</td>
<td></td>
<td>禁止访问：密码更改</td>
</tr>
<tr>
<td align="center">403.12</td>
<td></td>
<td>禁止访问：映射器拒绝访问</td>
</tr>
<tr>
<td align="center">403.13</td>
<td></td>
<td>禁止访问：客户证书已被吊销</td>
</tr>
<tr>
<td align="center">403.14</td>
<td></td>
<td>禁止访问：Web 服务器被配置不列出此目录的内容</td>
</tr>
<tr>
<td align="center">403.15</td>
<td></td>
<td>禁止访问：客户访问许可过多</td>
</tr>
<tr>
<td align="center">403.16</td>
<td></td>
<td>禁止访问：客户证书不可信或者无效</td>
</tr>
<tr>
<td align="center">403.17</td>
<td></td>
<td>禁止访问：客户证书已经到期或者尚未生效</td>
</tr>
<tr>
<td align="center">403.18</td>
<td></td>
<td>客户端证书已过期或尚未生效。</td>
</tr>
<tr>
<td align="center">403.19</td>
<td></td>
<td>不能为这个应用程序池中的客户端执行 CGI。这个错误代码为 IIS 6.0 所专用。</td>
</tr>
<tr>
<td align="center">403.20</td>
<td></td>
<td>Passport 登录失败。这个错误代码为 IIS 6.0 所专用。</td>
</tr>
<tr>
<td align="center">404</td>
<td>Not Found</td>
<td>服务器无法根据客户端的请求找到资源（网页）。没有发现文件、 查询或URI</td>
</tr>
<tr>
<td align="center">405</td>
<td>Method Not Allowed</td>
<td>客户端请求中的方法被禁止。用户在<code>Request-Line</code>字段定义的方法不允许</td>
</tr>
<tr>
<td align="center">406</td>
<td>Not Acceptable</td>
<td>无法接受用户发送的请求，请求资源不可被访问</td>
</tr>
<tr>
<td align="center">407</td>
<td>Proxy Authentication Required</td>
<td>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>
</tr>
<tr>
<td align="center">408</td>
<td>Request Time-out</td>
<td>客户端没有在用户指定的时间内完成请求，超时</td>
</tr>
<tr>
<td align="center">409</td>
<td>Conflict</td>
<td>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。</td>
</tr>
<tr>
<td align="center">410</td>
<td>Gone</td>
<td>客户端请求的资源已经不存在。<br/>410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>
</tr>
<tr>
<td align="center">411</td>
<td>Length Required</td>
<td>服务器无法处理客户端发送的不带Content-Length的请求信息</td>
</tr>
<tr>
<td align="center">412</td>
<td>Precondition Failed</td>
<td>一个或多个请求头字段在当前请求中错误</td>
</tr>
<tr>
<td align="center">413</td>
<td>Request Entity Too Large</td>
<td>请求的资源大于服务器允许的大小，服务器无法处理，因此拒绝请求。</td>
</tr>
<tr>
<td align="center">414</td>
<td>Request-URI Too Large</td>
<td>请求的 URI 过长（ URI 通常为网址），服务器无法处理</td>
</tr>
<tr>
<td align="center">415</td>
<td>Unsupported Media Type</td>
<td>服务器无法处理请求附带的媒体格式，请求资源不支持请求项目格式</td>
</tr>
<tr>
<td align="center">416</td>
<td>Requested range not satisfiable</td>
<td>客户端请求的范围无效</td>
</tr>
<tr>
<td align="center">417</td>
<td>Expectation Failed</td>
<td>服务器无法满足 Expect 的请求头信息</td>
</tr>
</tbody></table>
<p>（5）<mark class="label warning">服务端响应</mark></p>
<table>
<thead>
<tr>
<th align="center">状态码</th>
<th>状态描述</th>
<th>状态说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">500</td>
<td>Internal Server Error</td>
<td>服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td align="center">500.11</td>
<td></td>
<td>服务器关闭</td>
</tr>
<tr>
<td align="center">500.12</td>
<td></td>
<td>应用程序重新启动</td>
</tr>
<tr>
<td align="center">500.13</td>
<td></td>
<td>服务器太忙</td>
</tr>
<tr>
<td align="center">500.14</td>
<td></td>
<td>应用程序无效</td>
</tr>
<tr>
<td align="center">500.15</td>
<td></td>
<td>不允许请求</td>
</tr>
<tr>
<td align="center">501</td>
<td>Not Implemented</td>
<td>服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td align="center">502</td>
<td>Bad Gateway</td>
<td>网关错误。<br/>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>
</tr>
<tr>
<td align="center">503</td>
<td>Service Unavailable</td>
<td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。<br/>延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td align="center">504</td>
<td>Gateway Time-out</td>
<td>充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td align="center">505</td>
<td>HTTP Version not supported</td>
<td>服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody></table>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">HTTP 响应代码</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/http/http-status-codes.html">HTTP状态码</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/dufufd/article/details/53112184">常见的HTTP状态码(HTTP Status Code)说明</a></li>
<li><a target="_blank" rel="noopener" href="https://tool.oschina.net/commons?type=5">HTTP状态码详解</a></li>
</ul>
<h5 id="2-4-3-响应头"><a href="#2-4-3-响应头" class="headerlink" title="2.4.3 响应头"></a>2.4.3 响应头</h5><p><strong>一、Cache 头域</strong></p>
<table>
<thead>
<tr>
<th>Cache字段名称</th>
<th>字段值说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Cache-Concrol</strong></td>
<td>缓存内容，上一节已说明。</td>
</tr>
<tr>
<td><strong>Date</strong></td>
<td>生成消息的具体时间和日期。</td>
</tr>
<tr>
<td><strong>Expires</strong></td>
<td>浏览器会制定过期时间内使用本地缓存。格林尼治时间 GMT。</td>
</tr>
<tr>
<td><strong>Pragma</strong></td>
<td>浏览内容不会被缓存</td>
</tr>
</tbody></table>
<p><strong>二、Cookie&#x2F;Login 头域</strong></p>
<table>
<thead>
<tr>
<th>Cookie字段名称</th>
<th>字段值说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>P3P</strong></td>
<td>用于跨域设置 Cookie，这样可以解决<code>iframe</code>跨域访问 Cookie 的问题。</td>
</tr>
<tr>
<td><strong>Set-Cookie</strong></td>
<td>用于把 Cookie 发送到客户端浏览器，每一个写入 Cookie 都会生成个<code>Set-Cookie</code></td>
</tr>
</tbody></table>
<p><strong>三、Entity 头域</strong></p>
<table>
<thead>
<tr>
<th>Entity字段名称</th>
<th>字段值说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ETag</strong></td>
<td>和<code>If-None-Match</code>配合使用。</td>
</tr>
<tr>
<td><strong>Last-Modified</strong></td>
<td>用于指示资源的最后修改日期和时间。</td>
</tr>
<tr>
<td><strong>Content-Type</strong></td>
<td>Web服务器告诉浏览器自己响应的对象的类型和字符集。</td>
</tr>
<tr>
<td><strong>Content-Length</strong></td>
<td>指明实体正文的长度，以字节方式存储的十进制数字来表示。</td>
</tr>
<tr>
<td><strong>Content-Encoding</strong></td>
<td>Web服务器表明自己使用了什么压缩方法( gzip, deflate )压缩响应中的对象。</td>
</tr>
<tr>
<td><strong>Content-Language</strong></td>
<td>Web服务器告诉浏览器自己响应的对象的语言。</td>
</tr>
</tbody></table>
<p><strong>四、Miscellaneous 头域</strong></p>
<table>
<thead>
<tr>
<th>Miscellaneous字段名称</th>
<th>字段值说明</th>
</tr>
</thead>
<tbody><tr>
<td>Server</td>
<td>指明 HTTP 服务器的软件信息。</td>
</tr>
<tr>
<td>X-AspNet-Version</td>
<td>如果网站是用<code>ASP.NET</code>开发的，这个<code>header</code>用来表示<code>ASP.NET</code>的版本。</td>
</tr>
<tr>
<td>X-Powered-By</td>
<td>表示网站是用什么技术开发的。</td>
</tr>
</tbody></table>
<p><strong>五、Transport 头域</strong></p>
<table>
<thead>
<tr>
<th>Transport字段名称</th>
<th>字段值说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Connection: keep-alive</strong></td>
<td>当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭<br/>如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</td>
</tr>
<tr>
<td><strong>Connection: close</strong></td>
<td>代表一个 request 完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接会关闭<br/>当客户端再次发送 Request 时，需要重新建立 TCP 连接。</td>
</tr>
</tbody></table>
<p>一个传输层的实际环流，它是建立在两个相互通信的应用程序之间。</p>
<p>在 HTTP1.1,中，<code>request</code>和<code>response</code>头中都有可能出现个<code>Connection</code>的头，此<code>header</code>的含义是当 Client 和 Server 通信时对于长连接如何进行处理。</p>
<div class="note primary"><ul>
<li>HTTP&#x2F;1.0，Connection: close</li>
<li>HTTP&#x2F;1.1，Connection: keep-alive</li>
<li>HTTP TCP，无状态，面向连接。</li>
<li>HTTP UDP，无状态，无连接</li>
</ul>
<p>HTTP 的无状态和<code>Connection: keep-alive</code>是两个不同的概念。无状态是指协议对于事务处理没有记忆，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和之前打开这个服务器上的网页之间没有任何联系，所以出现了 <strong>Cookie、Session等来解决无状态</strong>的问题。</p>
<p>keep-alive 不会永久保持，它有一个保持时间。</p>
</div>

<p><strong>六、Location 头域</strong></p>
<p>用于重定向一个新的位置，包含新的 URL 地址。</p>
<p><strong>七、Security 头域</strong></p>
<p>Strict-Transport-Security: max-age-31536000</p>
<p>网站通过 HTTP Strict Transport Security (HSTS ) 通知浏览器，这个网站禁止使用 HTTP 方式加载，浏览器应该自动把所有尝试使用 HTTP 的请求自动替换为 HTTPS 请求。</p>
<p>当你的网站第一次发送 HTTPS 请求，服务器响应<code>Strict-Transport-Security</code>头，浏览器记录下这些信息。然后后面尝试访问这个网站的请求都会自动把 HTTP 替换为 HTTPS 。当 HTTPS 头设置的过期时间到了，后面通过HTTP 的访问恢复到正常模式，不会再自动跳转到 HTTPS。每次浏览器接收到<code>Strict-Transport-Security</code>头，它都会更新这个网站的过期时间，所以网站可以刷新这些信息，防止过期发生。</p>
<p>会话保持、长连接、短链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/document/product/214/6154">文档中心 &gt; 负载均衡 &gt; 负载均衡监听器 &gt; 会话保持</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/32943807">负载均衡之TCP会话保持（一）</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/dshf_1/article/details/89336750">负载均衡的会话保持和长短连接简介</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_31812703/article/details/79082542">会话的长连接与短连接详解</a></li>
</ul>
<p>关于同源策略：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/laixiangran/p/9064769.html">浏览器同源策略及跨域的解决方法</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xhz-dalalala/p/5259965.html">同源策略和跨域-总结</a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>Buy me a coffee</div>
  <button onclick="document.querySelector('.post-reward').classList.toggle('active');">
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechat.jpg" alt="Catecat 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpg" alt="Catecat 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Catecat
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://directoree.github.io/post/learning-testing-with-python/" title="Python 测试之道">https://directoree.github.io/post/learning-testing-with-python/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/" rel="tag"># 知识笔记</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/csapp_datalab/" rel="prev" title="CS:APP Data Lab">
                  <i class="fa fa-chevron-left"></i> CS:APP Data Lab
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/web-basic-safety-guide-uploadfile/" rel="next" title="Web 安全防护指南基础篇-文件上传">
                  Web 安全防护指南基础篇-文件上传 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Catecat</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">928k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">14:04</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1.15.0/dist/lozad.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/local-search.js"></script>








<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  const url = element.dataset.target;
  const pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  const pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  const fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script>
if (document.querySelectorAll('.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8.7.0/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>








  

  
      <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//cdn.jsdelivr.net/npm/mathjax@3.1.0/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
NexT.utils.loadComments('#valine-comments', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    new Valine(Object.assign({"enable":true,"appId":"7zujCcS8pYH88CJXfdBlLyS8-gzGzoHsz","appKey":"lWGr7OPoNHo4v1YmVV5yr3E9","serverURLs":"https://7zujccs8.lc-cn-n1-shared.com","placeholder":"快来勾搭我呀🐶","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"lang":null,"visitor":true,"comment_count":true,"bg":"/images/comment_bg.png","recordIP":false,"enableQQ":false,"requiredFields":["nick"]}, {
      el: '#valine-comments',
      path: "/post/learning-testing-with-python/",
      serverURLs: "https://7zujccs8.lc-cn-n1-shared.com"
    }));
  }, window.Valine);
});
</script>

</body>
</html>
