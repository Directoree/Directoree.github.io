{"title":"C/C++ 语言内存管理","date":"2019-06-17T09:25:05.000Z","thumbnail":"https://i.loli.net/2019/06/17/5d07368a6119054318.png","link":"post/memory-management","comments":true,"tags":["C-Memory","内存管理"],"categories":["C&C++"],"updated":"2019-06-17T09:31:14.000Z","content":"<h2 id=\"0x01-内存存储结构\"><font color=\"#03a9f4\" face=\"Comic sans MS\">0x01 内存存储结构</font><a href=\"post/memory-management#0x01-内存存储结构\"></a></h2><blockquote>\n<p>为什么要这么分配内存？<br>（1）一个进程在运行过程中，代码是根据流程依次执行的，只需要访问一次，当然跳转和递归有可能使代码执行多次，而数据一般都需要访问多次，因此单独开辟空间以方便访问和节约空间。<br>（2）临时数据及需要再次使用的代码在运行时放入栈区中，生命周期短。<br>（3）全局数据和静态数据有可能在整个程序执行过程中都需要访问，因此单独存储管理。<br>（4）堆区由用户自由分配，以便管理。</p>\n</blockquote>\n<p>存储结构分为：<strong>可执行代码存储时结构</strong>和<strong>运行时存储结构</strong>。结构图如下，左边为可执行代码存储时结构，右边为运行时存储结构。</p>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/06/17/5d0735f3ea5bb52011.png\" alt=\"806053-20170722131756261-1095755633.png\" data-zoomable></p></div>\n<h3 id=\"0x001-可执行代码存储时结构\"><font color=\"#3CB371\" face=\"Comic sans MS\">0x001 可执行代码存储时结构</font><a href=\"post/memory-management#0x001-可执行代码存储时结构\"></a></h3><p>当一个<strong><code>.c</code></strong>或<strong><code>.cpp</code></strong>文件编译后生    成可执行文件时，可执行文件在存储（也就是还没有载入到内存中）的时候，分为：<font color=\"#FF7F00\"><strong>代码区</strong></font>、<font color=\"#FF7F00\"><strong>数据区</strong></font>和<font color=\"#FF7F00\"><strong>未初始化数据区</strong></font>3个部分。</p>\n<blockquote>\n<p>注意：</p>\n</blockquote>\n<ul>\n<li>代码区：text segment</li>\n<li>数据区：局初始化数据区/静态数据区（initialized data segment/data segment）</li>\n<li>未初始化区：亦称BSS区（uninitialized data segment）</li>\n</ul>\n<ol>\n<li><p><strong>代码区</strong>（text segment）。存放CPU执行的机器指令（machine instructions）。通常，代码区是<font color=\"#FF7F00\"><strong>可共享</strong></font>的（即另外的执行程序可以调用它），因为对于频繁被执行的程序，只需要在内存中有一份代码即可。代码区通常是<font color=\"#FF7F00\"><strong>只读</strong></font>的，使其只读的原因是防止程序意外地修改了它的指令。另外，代码区还规划了局部变量的相关信息。</p>\n</li>\n<li><p><strong>全局初始化数据区/静态数据区</strong>（initialized data segment/data segment）。该区包含了在程序中明确<font color=\"#FF7F00\"><strong>已被初始化的全局变量、静态变量</strong></font>（包括全局静态变量和局部静态变量）和常量数据（如字符串常量）。</p>\n</li>\n<li><p><strong>未初始化数据区</strong>。亦称BSS区（uninitialized data segment），存入的是<font color=\"#FF7F00\"><strong>全局未初始化变量</strong></font>。BSS这个叫法是根据一个早期的汇编运算符而来，这个汇编运算符标志着一个块的开始。BSS区的数据在程序开始执行之前被内核初始化为0或者空指针（NULL）</p>\n</li>\n</ol>\n<h3 id=\"0x002-运行时存储结构\"><font color=\"#3CB371\" face=\"Comic sans MS\">0x002 运行时存储结构</font><a href=\"post/memory-management#0x002-运行时存储结构\"></a></h3><p>一个正在运行着的C编译程序占用的内存分为<strong>代码区</strong>、<strong>初始化数据区</strong>、<strong>未初始化数据区</strong>、<strong>堆区</strong>和<strong>栈区</strong>5个部分。</p>\n<ol>\n<li><p>代码区（text segment/code segment）。代码区指令根据程序设计流程依次执行，对于顺序指令，则只会执行一次（每个进程），如果反复，则需要使用跳转指令，如果进行递归，则需要借助栈来实现。</p>\n<ul>\n<li><strong>代码段（区）</strong>：定义： 代码段（code segment/text segment ）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。代码区的指令中包括操作码和要操作的对象（或对象地址引用）。如果是立即数（即具体的数值，如5），将直接包含在代码中；如果是局部数据，将在栈区分配空间，然后引用该数据地址；如果是BSS区和数据区，在代码中同样将引用该数据地址。另外，代码段还规划了局部数据所申请的内存空间信息。</li>\n</ul>\n</li>\n<li><p>全局初始化数据区/静态数据区（Data Segment）。只初始化一次。</p>\n<ul>\n<li><strong>数据段（区）</strong>： 数据段（data segment ）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。data段中的静态数据区存放的是程序中已初始化的全局变量、静态变量和常量。</li>\n</ul>\n</li>\n<li><p>未初始化数据区（BSS）。在运行时改变其值。</p>\n<ul>\n<li><strong>BSS 段（区）</strong>： BSS 段（bss segment ）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS 是英文Block Started by Symbol 的简称。BSS 段属于静态内存分配，即程序一开始就将其清零了。一般在初始化时BSS段部分将会清零。</li>\n</ul>\n</li>\n<li><p>栈区（stack）。由编译器自动分配释放，存放函数的参数值、局部变量的值等。存放函数的参数值、局部变量的值，以及在进行任务切换时存放当前任务的上下文内容。其操作方式类似于数据结构中的栈。每当一个函数被调用，该函数返回地址和一些关于调用的信息，比如某些寄存器的内容，被存储到栈区。然后这个被调用的函数再为它的自动变量和临时变量在栈区上分配空间，这就是C实现函数递归调用的方法。每执行一次递归函数调用，一个新的栈框架就会被使用，这样这个新实例栈里的变量就不会和该函数的另一个实例栈里面的变量混淆。</p>\n<ul>\n<li><strong>栈(stack)</strong> ：栈又称<font color=\"#FF7F00\"><strong>堆栈</strong></font>， 是用户存放程序临时创建的局部变量，也就是说我们函数括弧”{}”中定义的变量（但不包括static 声明的变量，static 意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/ 恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</li>\n</ul>\n</li>\n<li><p>堆区（heap）。用于动态内存分配。堆在内存中位于bss区和栈区之间。一般由程序员分配和释放，若程序员不释放，程序结束时有可能由OS回收。</p>\n<ul>\n<li><strong>堆(heap)</strong>： 堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc 等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free 等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。在将应用程序加载到内存空间执行时，操作系统负责代码段、数据段和BSS段的加载，并将在内存中为这些段分配空间。栈段亦由操作系统分配和管理，而不需要程序员显示地管理；堆段由程序员自己管理，即显式地申请和释放空间。</li>\n</ul>\n</li>\n</ol>\n<p>C语言程序编译完成之后，已初始化的全局变量保存在DATA段中，未初始化的全局变量保存在BSS段中。TEXT和DATA段都在可执行文件中，由系统从可执行文件中加载；而BSS段不在可执行文件中，由系统初始化。BSS段只保存没有值的变量，所以事实上它并不需要保存这些变量的映像。运行时所需要的BSS段大小记录在目标文件中，但是BSS段并不占据目标文件的任何空间。</p>\n<p>以下两图来自于《C语言专家编程》</p>\n<div class=\"article-img\"><p><img src=\"https://s2.ax1x.com/2019/06/17/VHfXtO.png\" alt=\"VHfXtO.png\" data-zoomable></p></div>\n<div class=\"article-img\"><p><img src=\"https://s2.ax1x.com/2019/06/17/VHfjhD.png\" alt=\"VHfjhD.png\" data-zoomable></p></div>\n<br>\n\n<h3 id=\"0x003-几个基本概念\"><font color=\"#3CB371\" face=\"Comic sans MS\">0x003 几个基本概念</font><a href=\"post/memory-management#0x003-几个基本概念\"></a></h3><p>在C语言中，关于内存管理的知识点比较多，如函数、变量、作用域、指针等，在探究C语言内存管理机制时，先简单复习下这几个基本概念：</p>\n<ol>\n<li><p>变量：需要搞清楚这几种变量类型：</p>\n<ul>\n<li>全局变量（外部变量）：出现在代码块<strong><code>{}</code></strong>之外的变量就是全局变量。</li>\n<li>局部变量（自动变量）：一般情况下，代码块<strong><code>{}</code></strong>内部定义的变量就是自动变量，也可使用auto显示定义。</li>\n<li>静态变量：是指内存位置在程序执行期间一直不改变的变量，用关键字static修饰。代码块内部的静态变量只能被这个代码块内部访问，代码块外部的静态变量只能被定义这个变量的文件访问。</li>\n</ul>\n</li>\n</ol>\n<p>注意：extern修饰变量时，根据具体情况，既可以看作是定义也可以看作是声明；但extern修饰函数时只能是定义，没有二义性。</p>\n<ol start=\"2\">\n<li><p>作用域：通常指的是变量的作用域，广义上讲，也有函数作用域及文件作用域等。我理解的作用域就是指某个事物能够存在的区域或范围，比如一滴水只有在0-100摄氏度之间才能存在，超出这个范围，广义上讲的“水”就不存在了，它就变成了冰或气体。</p>\n</li>\n<li><p>函数：不解释。</p>\n</li>\n</ol>\n<p>注意：C语言中函数默认都是全局的，可以使用static关键字将函数声明为静态函数（只能被定义这个函数的文件访问的函数）。</p>\n<h2 id=\"0x02-栈与堆\"><font color=\"#03a9f4\" face=\"Comic sans MS\">0x02 栈与堆</font><a href=\"post/memory-management#0x02-栈与堆\"></a></h2><p>栈与堆是两个概念，特别要注意<font color=\"#FF7F00\"><strong>数据结构</strong></font>中的栈与堆和<font color=\"#FF7F00\"><strong>内存管理中</strong></font>的栈与堆是<strong>两个不相关</strong>的概念。</p>\n<h3 id=\"0x001-数据结构中的栈与堆\"><font color=\"#3CB371\" face=\"Comic sans MS\">0x001 数据结构中的栈与堆</font><a href=\"post/memory-management#0x001-数据结构中的栈与堆\"></a></h3><p><strong>栈</strong>：是一种连续储存的数据结构，具有先进后出的性质。通常的操作有入栈（圧栈）、出栈和栈顶元素。想要读取栈中的某个元素，就要将其之前的所有元素出栈才能完成。类比现实中的箱子一样。</p>\n<blockquote>\n<p>栈是一种运算受限的线性表，其限制是指只仅允许在表的一端进行插入和删除操作，这一端被称为栈顶（Top），相对地，把另一端称为栈底（Bottom）。把新元素放到栈顶元素的上面，使之成为新的栈顶元素称作进栈、入栈或压栈（Push）；把栈顶元素删除，使其相邻的元素成为新的栈顶元素称作出栈或退栈（Pop）。这种受限的运算使栈拥有“先进后出”的特性（First In Last Out），简称FILO。<br>栈分顺序栈和链式栈两种。栈是一种线性结构，所以可以使用数组或链表（单向链表、双向链表或循环链表）作为底层数据结构。使用数组实现的栈叫做顺序栈，使用链表实现的栈叫做链式栈，二者的区别是顺序栈中的元素地址连续，链式栈中的元素地址不连续。</p>\n</blockquote>\n<p><strong>堆</strong>：是一种非连续的树形储存数据结构，每个节点有一个值，整棵树是经过排序的。特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。常用来实现优先队列，存取随意。</p>\n<blockquote>\n<p>像是一颗倒立的大树：堆是一种经过排序的树形数据结构，每个节点都有一个值。通常我们所说的堆的数据结构是指二叉树。堆的特点是根节点的值最小（或最大），且根节点的两个树也是一个堆。由于堆的这个特性，常用来实现优先队列，堆的存取是随意的，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，书架这种机制不同于箱子，我们可以直接取出我们想要的书。</p>\n</blockquote>\n<h3 id=\"0x002-内存分配中的堆和栈\"><font color=\"#3CB371\" face=\"Comic sans MS\">0x002 内存分配中的堆和栈</font><a href=\"post/memory-management#0x002-内存分配中的堆和栈\"></a></h3><p><strong>栈</strong>：是由编译器在需要时自动分配的，不需要时自动清除的变量存储区。里面的变量通常是局部变量、函数参数等。<br><strong>堆</strong>：是由malloc()等函数或new分配的内存块，内存释放由程序员手动控制，在C语言为free函数完成。</p>\n<p><font size=\"4\"><strong>栈和堆的主要区别有以下几点：</strong></font></p>\n<ol>\n<li><p><font color=\"#FF7F00\"><strong>申请方式和回收方式不同(管理方式不同)。</strong></font>栈编译器自动管理，无需程序员手工控制；而堆空间的申请释放工作由程序员控制，容易产生内存泄漏。</p>\n</li>\n<li><p><font color=\"#FF7F00\"><strong>内存增长方向不同。</strong></font>堆的增长方向是向上的，即向着内存地址增加的方向；栈的增长方向是向下的，即向着内存地址减小的方向。这和栈申请大小是相关的，因为栈顶的地址和栈的最大容量是系统预先规定好的，所以再次申请地址时只能从高地址向低地址存放局部变量或者形式参数。</p>\n</li>\n<li><p><font color=\"#FF7F00\"><strong>申请大小的限制。</strong></font></p>\n</li>\n</ol>\n<p><strong>栈</strong>是向低地址扩展的数据结构，是一块连续的内存区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，当申请的空间超过栈的剩余空间时，将提示溢出。因此，用户能从栈获得的<strong>空间较小</strong>。栈不会很大，一般都是以K为单位。如果在程序中直接将较大的数组保存在函数内的栈变量中，很可能会内存溢出，严格来说应该叫栈溢出（当栈空间以满，但还往栈内存压变量，这个就叫栈溢出）。<br><strong>堆</strong>是向高地址扩展的数据结构，是不连续的内存区域。因为系统是用链表来存储空闲内存地址的，且链表的遍历方向是由低地址向高地址。由此可见，堆获得的空间较灵活，也较大。栈中元素都是一一对应的，不会存在一个内存块从栈中间弹出的情况。</p>\n<ol start=\"4\">\n<li><font color=\"#FF7F00\"><strong>申请后系统的响应不同。</strong></font></li>\n</ol>\n<p><strong>栈：</strong>只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。<br><strong>堆：</strong>首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。也就是说堆会在申请后还要做一些后续的工作这就会引出申请效率的问题。</p>\n<ol start=\"5\">\n<li><font color=\"#FF7F00\"><strong>分配效率不同。</strong></font></li>\n</ol>\n<p><strong>栈：</strong>由系统自动分配，速度较快。但程序员是无法控制的。<br><strong>堆：</strong>是由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便。</p>\n<blockquote>\n<p>栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行。堆则是C函数库提供的，它的机制很复杂，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大的空间，如果没有足够大的空间（可能是由于内存碎片太多），就有需要操作系统来重新整理内存空间，这样就有机会分到足够大小的内存，然后返回。显然，堆的效率比栈要低得多。</p>\n</blockquote>\n<ol start=\"6\">\n<li><font color=\"#FF7F00\"><strong>是否产生碎片。</strong></font></li>\n</ol>\n<p><strong>堆：</strong>对于堆来讲，频繁的malloc/free（new/delete）势必会造成内存空间的不连续，从而<strong>造成大量的碎片</strong>，使程序效率降低（虽然程序在退出后操作系统会对内存进行回收管理）。<br><strong>栈：</strong>对于栈来讲，则不会产生碎片。</p>\n<ol start=\"7\">\n<li><font color=\"#FF7F00\"><strong>栈和堆中的存储内容不同。</strong></font></li>\n</ol>\n<p><strong>栈：</strong>在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。栈中的内存是在程序编译完成以后就可以确定的，不论占用空间大小，还是每个变量的类型。<br><strong>堆：</strong>一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。</p>\n<p>下面附上一张栈和堆地址增长方向的对比图：<br><img src=\"https://i.loli.net/2019/06/17/5d0759163057393552.png\" alt=\"806053-20170723012539965-796179889.png\"></p>\n<h2 id=\"0x03-操作系统中的内存分配\"><font color=\"#03a9f4\" face=\"Comic sans MS\">0x03 操作系统中的内存分配</font><a href=\"post/memory-management#0x03-操作系统中的内存分配\"></a></h2><p>操作系统在管理内存时，最小单位不是字节，而是内存页（32位操作系统的内存页一般是4K）。比如，初次申请1K内存，操作系统会分配1个内存页，也就是4K内存。4K是一个折中的选择，因为：内存页越大，内存浪费越多，但操作系统内存调度效率高，不用频繁分配和释放内存；内存页越小，内存浪费越少，但操作系统内存调度效率低，需要频繁分配和释放内存。嵌入式系统的内存内存资源很稀缺，其内存页会更小，因此在嵌入式开发当中需要特别注意。</p>\n<br>\n\n\n\n<p>参考资料：</p>\n<ul>\n<li><font color=\"#00B2EE\"><a href=\"https://www.cnblogs.com/tuhooo/p/7221136.html\" target=\"_blank\" rel=\"noopener\">《深入理解C语言内存管理》\n</a></font></li>\n<li><font color=\"#00B2EE\"><a href=\"https://www.cnblogs.com/yif1991/p/5049638.html\" target=\"_blank\" rel=\"noopener\">《C语言知识整理（3）：内存管理（详细版）》\n</a></font></li>\n<li><font color=\"#00B2EE\"><a href=\"https://www.cnblogs.com/kimiway/p/3224607.html\" target=\"_blank\" rel=\"noopener\">《C语言内存管理详解》\n</a></font></li>\n<li><font color=\"#00B2EE\"><a href=\"https://blog.csdn.net/K346K346/article/details/80849966\" target=\"_blank\" rel=\"noopener\">《堆与栈的区别》\n</a></font></li>\n<li><font color=\"#00B2EE\"><a href=\"https://blog.csdn.net/qq_41035588/article/details/81953424\" target=\"_blank\" rel=\"noopener\">《【C语言】数据结构和内存中的堆和栈》\n</a></font></li>\n</ul>\n","prev":{"title":"CTF-SSH私钥泄漏","link":"post/CTF-SSH-private-key-leak"},"next":{"title":"C/C++ Memory Application","link":"post/memory"},"plink":"https://Directoree.github.io/post/memory-management/","toc":[{"title":"<font color=\"#03a9f4\" face=\"Comic sans MS\">0x01 内存存储结构</font>","id":"0x01-内存存储结构","index":"1","children":[{"title":"<font color=\"#3CB371\" face=\"Comic sans MS\">0x001 可执行代码存储时结构</font>","id":"0x001-可执行代码存储时结构","index":"1.1"},{"title":"<font color=\"#3CB371\" face=\"Comic sans MS\">0x002 运行时存储结构</font>","id":"0x002-运行时存储结构","index":"1.2"},{"title":"<font color=\"#3CB371\" face=\"Comic sans MS\">0x003 几个基本概念</font>","id":"0x003-几个基本概念","index":"1.3"}]},{"title":"<font color=\"#03a9f4\" face=\"Comic sans MS\">0x02 栈与堆</font>","id":"0x02-栈与堆","index":"2","children":[{"title":"<font color=\"#3CB371\" face=\"Comic sans MS\">0x001 数据结构中的栈与堆</font>","id":"0x001-数据结构中的栈与堆","index":"2.1"},{"title":"<font color=\"#3CB371\" face=\"Comic sans MS\">0x002 内存分配中的堆和栈</font>","id":"0x002-内存分配中的堆和栈","index":"2.2"}]},{"title":"<font color=\"#03a9f4\" face=\"Comic sans MS\">0x03 操作系统中的内存分配</font>","id":"0x03-操作系统中的内存分配","index":"3"}],"reward":true,"copyright":{"author":"Directoree","link":"<a href=\"https://Directoree.github.io/post/memory-management/\" title=\"C/C++ 语言内存管理\">https://Directoree.github.io/post/memory-management/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}