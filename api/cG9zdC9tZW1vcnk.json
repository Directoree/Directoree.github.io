{"title":"C/C++ Memory Application","date":"2019-06-06T15:06:55.000Z","thumbnail":"https://i.loli.net/2019/06/06/5cf8bc144d93293008.png","link":"post/memory","comments":true,"tags":["C","C-Memory"],"categories":["C&C++"],"updated":"2019-06-17T09:27:06.058Z","content":"<h2 id=\"0x01-malloc-amp-calloc\"><font color=\"#03a9f4\" face=\"Comic sans MS\">0x01 malloc() &amp; calloc()</font><a href=\"post/memory#0x01-malloc-amp-calloc\"></a></h2><ul>\n<li><p><strong>void *malloc ( size );</strong></p>\n<ul>\n<li>malloc的作用是在内存的动态存储区中分配一个长度为size的<font color=\"#FF7F00\"><strong>连续空间</strong></font>。如果由malloc()函数分配的内存空间原来没有被使用过，则其中的每一位可能都是0；反之,如果这部分内存曾经被分配过,则其中可能遗留有各种各样的数据。所以一般mallc()要配合memset()函数使用。</li>\n</ul>\n</li>\n<li><p><strong>void *calloc ( n, size );</strong></p>\n<ul>\n<li>calloc() 在内存中动态地分配 n 个长度为 size 的<font color=\"#FF7F00\"><strong>连续空间</strong></font>，并将每一个字节都初始化为 0。所以它的结果是分配了 num x size 个字节长度的内存空间，并且每个字节的值都是0。</li>\n</ul>\n<br>\n\n</li>\n</ul>\n<p><font color=\"#FF7F00\"><strong>1. 相似点：</strong></font></p>\n<ol>\n<li>动态内存申请都需要用到头文件<strong><code>#include &lt;stdlib.h&gt;</code></strong>。</li>\n<li>malloc()、calloc()申请的内存类型都是 <strong><code>void*</code></strong> 类型的，需要强制转化为指定类型；</li>\n</ol>\n<p> <strong>注意：</strong>函数的返回值类型是<strong><code>void*</code></strong>，void 并不是说没有返回值或者返回空指针，而是返回的指针类型未知。所以在使用 calloc() 时通常需要进行强制类型转换，将 void 指针转换成我们希望的类型，例如：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>ptr <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 分配100个字节的内存空间</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<ol start=\"3\">\n<li><p><strong>返回值：</strong></p>\n<ul>\n<li>如果调用成功,函数malloc()和函数calloc()都将返回所分配的内存空间的<font color=\"#FF7F00\"><strong>首地址</strong></font>。</li>\n<li>如果调用失败，则返回 NULL。</li>\n</ul>\n</li>\n<li><p><strong>申请了内存空间后，必须检查是否分配成功</strong>。</p>\n<ul>\n<li>函数同样要注意这点：如果所申请的内存块大于目前堆上剩余内存块（整块），则内存分配会失败，函数返回NULL。注意这里说的“堆上剩余内存块”不是所有剩余内存块之和，是指堆上剩余内存块中与上次申请的内存地址连续的那部分，因为malloc函数申请的是<strong>连续的一块内存</strong>。既然malloc函数申请内存有不成功的可能，那我们在使用指向这块内存的指针时，必须用<strong><code>if（p!=NULL）</code></strong>语句来验证内存确实分配成功了。</li>\n</ul>\n</li>\n<li><p>二者返回的地址是连续的：下面两种方式申请<strong>地址大小</strong>是相等的</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>str1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">calloc</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>str2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n</ol>\n<br>\n\n<p><font color=\"#FF7F00\"><strong>2. 不相同点：</strong></font></p>\n<ol>\n<li>函数malloc()和函数calloc()的主要区别是<strong>前者不能初始化所分配的内存空间,而后者能</strong>。如果由malloc()函数分配的内存空间原来没有被使用过，则其中的每一位可能都是0；反之，如果这部分内存曾经被分配过，则其中可能遗留有各种各样的数据。</li>\n<li>函数calloc()会将所分配的内存空间中的每一位都初始化为零，也就是说,如果你是为字符类型或整数类型的元素分配内存，那么这些元素将保证会被初始化为0；如果你是为指针类型的元素分配内存,那么这些元素通常会被初始化为空指针；如果你为实型数据分配内存，则这些元素会被初始化为浮点型的零。</li>\n<li>calloc 可以代替 malloc + memset，但是 malloc + memset 代替不了 calloc。 calloc 大块内存时，如果是从系统分配，就可以免了 memset 的操作，快很多。memset可以设任意数，calloc只能设0 。calloc表示申请 n x size大小的内存，malloc只有一个参数。</li>\n</ol>\n<br>\n\n<p><font color=\"#FF7F00\"><strong>3. 以下两种方式完全等价：</strong></font></p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">// calloc() 分配内存空间并初始化</span>\n<span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>str1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">calloc</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// malloc() 分配内存空间并用 memset() 初始化</span>\n<span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>str2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">memset</span><span class=\"token punctuation\">(</span>str2<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"0x02-realloc\"><font color=\"#03a9f4\" face=\"Comic sans MS\">0x02 realloc()</font><a href=\"post/memory#0x02-realloc\"></a></h2><p>函数原型：<strong><code>realloc(void *p, addsize)</code></strong></p>\n<p><strong>一、基本特性</strong></p>\n<ol>\n<li><p>realloc()函数可以重用或扩展以前用malloc()、calloc()及realloc()函数自身分配的内存。</p>\n</li>\n<li><p>realloc()函数需两个参数：一个是包含地址的指针（该地址由之前的malloc()、calloc()或realloc()函数返回），另一个是要新分配的内存字节数。</p>\n</li>\n<li><p>realloc()函数分配第二个参数指定的内存量，并把第一个参数指针指向的之前分配的内容复制到新配的内存中，且复制的内容长度等于新旧内存区域中较小的那一个。即新内存大于原内存，则原内存所有内容复制到新内存，如果新内存小于原内存，只复制长度等于新内存空间的内容。</p>\n</li>\n<li><p>realloc()函数的第一个参数若为空指针，相当于分配第二个参数指定的新内存空间，此时等价于malloc()、calloc()或realloc()函数。</p>\n</li>\n<li><p>如果是将分配的内存扩大，则有以下3种情况：</p>\n<blockquote>\n<ul>\n<li>如果当前内存段后面有需要的内存空间，则直接扩展这段内存空间，realloc()将返回<strong>原指针</strong>。  </li>\n<li>如果当前内存段后面的空闲字节不够，那么就使用堆中的第一个能够满足这一要求的内存块，将目前的数据复制到新的位置，并<font color=\"red\" size=\"5\"><strong>自动</strong></font>将原来的数据块释放掉，不需要使用free()再释放一次，返回新的内存块首地址（不同于之前malloc申请的首地址）。</li>\n<li>如果申请失败，将返回NULL，此时，原来的指针仍然有效。</li>\n</ul>\n</blockquote>\n<br>\n\n</li>\n</ol>\n<p><strong>二、注意事项</strong></p>\n<ol>\n<li><p><strong>第一个参数要么是空指针，要么是指向以前分配的内存。如果不指向以前分配的内存或指向已释放的内存，结果就是不确定的。</strong></p>\n</li>\n<li><p><font color=\"#FF7F00\"><strong>如果调用成功，不管当前内存段后面的空闲空间是否满足要求，都会释放掉原来的指针，重新返回一个指针，虽然返回的指针有可能和原来的指针一样，即不能再次释放掉原来的指针。</strong></font></p>\n</li>\n</ol>\n<p>举例（不需要手动free释放原来的首地址指针，realloc若新申请成功会自动释放原来的首地址。），实现在一个按升序排序的数组中查找x应插入的位置，将x插入数组中，使数组元素仍按升序排列。<br><strong>注意：</strong>注意代码45行 <strong><code>free(pNumber);</code></strong>，如果注释掉，则结果正确。如果不注释掉则错误。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;stdio.h></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;stdlib.h></span></span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> index <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> insert_data <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>pNumber <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>pNewArray <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Input array size:\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    pNumber <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">calloc</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>pNumber <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Not enough memory\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//输入插入前已按升序排序的数组元素提示信息</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Input array:\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\"</span><span class=\"token punctuation\">,</span> pNumber<span class=\"token operator\">+</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//输入待插入的元素x提示信息：</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Input x:\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>insert_data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//确定待插入位置的索引值</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>insert_data <span class=\"token operator\">&lt;</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>pNumber<span class=\"token operator\">+</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            index <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//用realloc()新分配一块内存，用于存储原数组和新插入的值</span>\n    pNewArray <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">realloc</span><span class=\"token punctuation\">(</span>pNumber<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">*</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>pNewArray <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Not enough memory\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//free(pNumber); </span>\n    <span class=\"token comment\" spellcheck=\"true\">//输出新分配的内存空间的值，查看是否实现了复制</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%4d\"</span><span class=\"token punctuation\">,</span> pNewArray<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//待插入位置及后面的所有数据依次向后移1位</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> n<span class=\"token punctuation\">;</span> i  <span class=\"token operator\">></span> index<span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>pNewArray<span class=\"token operator\">+</span>i<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> pNewArray<span class=\"token punctuation\">[</span>i<span class=\"token number\">-1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>pNewArray <span class=\"token operator\">+</span> index<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> insert_data<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"After insert %d:\\n\"</span><span class=\"token punctuation\">,</span> insert_data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%4d\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>pNewArray<span class=\"token operator\">+</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">free</span><span class=\"token punctuation\">(</span>pNewArray<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<br>\n\n<h2 id=\"0x03-free-amp-memset\"><font color=\"#03a9f4\" face=\"Comic sans MS\">0x03 free() &amp; memset()</font><a href=\"post/memory#0x03-free-amp-memset\"></a></h2><h3 id=\"0x001-free\"><font color=\"#00C5CD\" face=\"Comic sans MS\">0x001 free()</font><a href=\"post/memory#0x001-free\"></a></h3><p>free()函数声明：<strong><code>void free(void *ptr);</code></strong></p>\n<blockquote>\n<p><strong>说明：</strong>释放ptr指向的内存空间，ptr必须是之前调用过malloc,calloc,realloc这三个函数返回的，否则，如果free(ptr)已经执行过了，而又没有重新赋值给ptr的话，又执行一次free(ptr)会导致意外发生（undefined behavior occurs.），如果ptr指向的是NULL，则不会做任何操作。</p>\n</blockquote>\n<p>示例：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;stdio.h></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;stdlib.h></span></span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>p <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    p <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">==</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"You are failed to applicate the memory.\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">free</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    p<span class=\"token operator\">=</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//一定要给p赋个值NULL，否则再次free(p)会报错</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<br>\n\n<p>其实它就做了一件事：<font color=\"#FF7F00\"><strong>斩断指针变量与这块内存的关系</strong></font>。</p>\n<blockquote>\n<p>free函数就是把这块内存和p之间的所有关系斩断。从此p和那块内存之间再无瓜葛。<strong>至于指针变量p本身保存的地址并没有改变（即指针p的值仍然是刚才的地址，只是再也不能通过p来使用刚才的地址了。），但是它对这个地址处的那块内存却已经没有所有权了。那块被释放的内存里面保存的值也没有改变，只是再也没有办法使用了</strong>。</p>\n<ol>\n<li>这就是free函数的功能。按照上面的分析，如果对p连续两次以上使用free函数，肯定会发生错误。因为第一使用free函数时，p所属的内存已经被释放，第二次使用时已经无内存可释放了。</li>\n<li>malloc两次只free一次会内存泄漏；malloc一次free两次肯定会出错。也就是说，在程序中malloc的使用次数一定要和free相等，否则必有错误。这种错误主要发生在循环使用malloc函数时，不要把malloc和free对数弄错了。</li>\n<li>内存释放之后，既然使用free函数之后指针变量p本身保存的地址并没有改变，那我们就需要重新把p的值变为NULL。</li>\n<li>释放完块内存之后，没有把指针置NULL，这个指针就成为了“<strong>野指针</strong>”，也有书叫“<strong>悬垂指针</strong>”。这是很危险的，而且也是经常出错的地方。所以一定要记住一条：<font color=\"red\"><strong>free完之后，一定要给指针置NULL</strong></font>。</li>\n</ol>\n</blockquote>\n<p><strong>注意：</strong>内存已经被释放了，但是继续通过指针来使用！</p>\n<blockquote>\n<p><strong>这里一般有三种情况：</strong><br>第一种：就是上面所说的，free（p）之后，继续通过p指针来访问内存。解决的办法就是给p置NULL。<br>第二种：函数返回栈内存。这是初学者最容易犯的错误。比如在函数内部定义了一个数组，却用return语句返回指向该数组的指针。解决的办法就是弄明白栈上变量的生命周期。<br>第三种：内存使用太复杂，弄不清到底哪块内存被释放，哪块没有被释放。解决的办法是重新设计程序，改善对象之间的调用关系。</p>\n</blockquote>\n<h3 id=\"0x002-memset\"><font color=\"#00C5CD\" face=\"Comic sans MS\">0x002 memset()</font><a href=\"post/memory#0x002-memset\"></a></h3><p>函数声明：<strong><code>void *memset(void *s, int c, unsigned long n);</code></strong></p>\n<p>定义变量时一定要进行初始化，尤其是数组和结构体这种占用内存大的数据结构。在使用数组的时候经常因为没有初始化而产生“烫烫烫烫烫烫”这样的野值，俗称“乱码”。</p>\n<p>每种类型的变量都有各自的初始化方法，memset() 函数可以说是初始化内存的“万能函数”，通常为新申请的内存进行初始化工作。它是直接操作内存空间，mem即“内存”（memory）的意思。该函数的原型为：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\"># <span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string.h></span></span>\n<span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">memset</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>s<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> c<span class=\"token punctuation\">,</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>函数的功能是：</strong>将指针变量 s 所指向的前 n 字节的内存单元用一个“整数” c 替换，注意 c 是 int 型。s 是 void* 型的指针变量，所以它可以为任何类型的数据进行初始化。</p>\n<p>memset() 的作用是在一段内存块中填充某个给定的值。因为它只能填充一个值，所以该函数的初始化为原始初始化，无法将变量初始化为程序中需要的数据。用memset初始化完后，后面程序中再向该内存空间中存放需要的数据。</p>\n<p>memset 一般使用“0”初始化内存单元，而且通常是给数组或结构体进行初始化。一般的变量如 char、int、float、double 等类型的变量直接初始化即可，没有必要用 memset。如果用 memset 的话反而显得麻烦。</p>\n<p>当然，数组也可以直接进行初始化，但 memset 是对较大的数组或结构体进行清零初始化的最快方法，因为它是直接对内存进行操作的。</p>\n<p>这时有人会问：“字符串数组不是最好用’\\0’进行初始化吗？那么可以用 memset 给字符串数组进行初始化吗？也就是说参数 c 可以赋值为’\\0’吗？”</p>\n<p>可以的。虽然参数 c 要求是一个整数，但是整型和字符型是互通的。但是赋值为 ‘\\0’ 和 0 是等价的，因为字符 ‘\\0’ 在内存中就是 0。所以在 memset 中初始化为 0 也具有结束标志符 ‘\\0’ 的作用，所以通常我们就写“0”。</p>\n<p>memset 函数的第三个参数 n 的值一般用 sizeof()  获取，这样比较专业。注意，如果是对指针变量所指向的内存单元进行清零初始化，那么一定要先对这个指针变量进行初始化，即一定要先让它指向某个有效的地址。而且用memset给指针变量如p所指向的内存单元进行初始化时，n 千万别写成 sizeof(p)，这是新手经常会犯的错误。因为 p 是指针变量，不管 p 指向什么类型的变量，sizeof(p) 的值都是 4。</p>\n<p>下面写一个程序：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\"># <span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n<span class=\"token macro property\"># <span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string.h></span></span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">//循环变量</span>\n    <span class=\"token keyword\">char</span> str<span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>p <span class=\"token operator\">=</span> str<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">memset</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">//只能写sizeof(str), 不能写sizeof(p)</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\x20\"</span><span class=\"token punctuation\">,</span> str<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n根据memset函数的不同，输出结果也不同，分为以下几种情况：\n<span class=\"token function\">memset</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">//地址的大小都是4字节</span>\n<span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token operator\">-</span><span class=\"token number\">52</span> <span class=\"token operator\">-</span><span class=\"token number\">52</span> <span class=\"token operator\">-</span><span class=\"token number\">52</span> <span class=\"token operator\">-</span><span class=\"token number\">52</span> <span class=\"token operator\">-</span><span class=\"token number\">52</span> <span class=\"token operator\">-</span><span class=\"token number\">52</span>\n\n<span class=\"token function\">memset</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">//*p表示的是一个字符变量, 只有一字节</span>\n<span class=\"token number\">0</span> <span class=\"token operator\">-</span><span class=\"token number\">52</span> <span class=\"token operator\">-</span><span class=\"token number\">52</span> <span class=\"token operator\">-</span><span class=\"token number\">52</span> <span class=\"token operator\">-</span><span class=\"token number\">52</span> <span class=\"token operator\">-</span><span class=\"token number\">52</span> <span class=\"token operator\">-</span><span class=\"token number\">52</span> <span class=\"token operator\">-</span><span class=\"token number\">52</span> <span class=\"token operator\">-</span><span class=\"token number\">52</span> <span class=\"token operator\">-</span><span class=\"token number\">52</span>\n\n<span class=\"token function\">memset</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span>\n\n<span class=\"token function\">memset</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span>\n\n<span class=\"token function\">memset</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">//直接写10也行, 但不专业</span>\n<span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"0x04-Summary\"><font color=\"#03a9f4\" face=\"Comic sans MS\">0x04 Summary</font><a href=\"post/memory#0x04-Summary\"></a></h2><h3 id=\"0x001-C-C-程序内存分配\"><font color=\"#00C5CD\" face=\"Comic sans MS\">0x001 C/C++程序内存分配</font><a href=\"post/memory#0x001-C-C-程序内存分配\"></a></h3><div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/06/06/5cf8befa94fbc58191.png\" alt=\"20180818211016694.png\" data-zoomable></p></div>\n<blockquote>\n<p><font color=\"#FF7F00\"><strong>注意：</strong></font></p>\n<ol>\n<li>内存泄漏(仅存在程序运行时，程序退出，OS将回收所有资源)是指那些本应该回收（不再使用）的内存对象无法被系统回收的现象。在c/c++中需要程序猿手动释放内存对象，所以在C/C++中更容易存在内存泄漏。java引入了自动回收机制，使得在C/C++中令人头疼的内存问题得到了有效的改善，但这并不意味着java程序员不关注内存，因为垃圾回收机制不能完全保证内存对象在该释放的地方释放.</li>\n<li>内存溢出指的是系统在为某段执行指令（程序）分配内存的时候，发现内存不足，抛出错误。</li>\n</ol>\n</blockquote>\n<br>\n\n<h3 id=\"0x002-C-C-内存分配方式\"><font color=\"#00C5CD\" face=\"Comic sans MS\">0x002 C/C++内存分配方式</font><a href=\"post/memory#0x002-C-C-内存分配方式\"></a></h3><blockquote>\n<ol>\n<li><font color=\"#FF7F00\"><strong>在栈上创建</strong></font><br>在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放.栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限.</li>\n<li><font color=\"#FF7F00\"><strong>从堆上分配，亦称动态内存分配</strong></font><br>程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存.动态内存的生存期由用户决定，使用非常灵活，但问题也最多.</li>\n<li><font color=\"#FF7F00\"><strong>从静态存储区域分配</strong></font><br>内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在.例如全局变量、static变量.</li>\n</ol>\n</blockquote>\n<br>\n\n<h3 id=\"0x003-C语言内存申请相关的函数\"><font color=\"#00C5CD\" face=\"Comic sans MS\">0x003 C语言内存申请相关的函数</font><a href=\"post/memory#0x003-C语言内存申请相关的函数\"></a></h3><blockquote>\n<ol>\n<li><strong>alloca</strong> 是向栈申请内存,因此无需释放.</li>\n<li><strong>malloc</strong> 分配的内存是位于堆中的，并且没有初始化内存的内容，malloc() 不初始化，里边数据是未知的垃圾数据，因此基本上malloc之后,调用函数memset来初始化这部分的内存空间.</li>\n<li><strong>calloc</strong> 则将初始化这部分的内存，设置为0。</li>\n<li><strong>realloc</strong> 则对malloc申请的内存进行大小的调整。</li>\n<li>申请的内存最终需要通过函数free来释放。<br><font color=\"#FF7F00\"><strong>注意：</strong></font><br>当程序运行过程中malloc了,但是没有free的话,会造成内存泄漏.一部分的内存没有被使用,但是由于没有free,因此系统认为这部分内存还在使用,造成不断的向系统申请内存,使得系统可用内存不断减少.但是内存泄漏仅仅指程序在运行时,程序退出时,OS将回收所有的资源.因此,适当的重起一下程序,有时候还是有点作用.</li>\n</ol>\n</blockquote>\n<br>\n\n<h3 id=\"0x004-malloc，realloc，calloc函数声明\"><font color=\"#00C5CD\" face=\"Comic sans MS\">0x004 malloc，realloc，calloc函数声明</font><a href=\"post/memory#0x004-malloc，realloc，calloc函数声明\"></a></h3><blockquote>\n<ul>\n<li><strong>void* malloc(unsigned size)</strong>;</li>\n<li><strong>void* realloc(void* ptr, unsigned newsize)</strong>;</li>\n<li><strong>void* calloc(size_t numElements, size_t sizeOfElement)</strong>; </li>\n</ul>\n</blockquote>\n<blockquote>\n<p><font color=\"#FF7F00\"><strong>注意：</strong></font>都在stdlib.h函数库内，它们的返回值都是请求系统分配的地址,如果请求失败就返回NULL.<br>(1)函数malloc()<br>在内存的动态存储区中分配一块长度为size字节的连续区域，参数size为需要内存空间的长度，返回该区域的首地址.<br>(2)函数calloc()<br>与malloc相似,参数sizeOfElement为申请地址的单位元素长度,numElements为元素个数，即在内存中申请numElements*sizeOfElement字节大小的连续地址空间.<br>(3)函数realloc()<br>给一个已经分配了地址的指针重新分配空间,参数ptr为原有的空间地址,newsize是重新申请的地址长度.</p>\n</blockquote>\n<br>\n\n<ol>\n<li><font color=\"#FF7F00\"><strong>函数malloc不能初始化所分配的内存空间，而函数calloc能</strong></font>。如果由malloc()函数分配的内存空间原来没有被使用过，则其中的每一位可能都是0；反之, 如果这部分内存曾经被分配过，则其中可能遗留有各种各样的垃圾数据。也就是说，使用malloc()函数的程序开始时(内存空间还没有被重新分配)能正常进行,但经过一段时间(内存空间还已经被重新分配)可能会出现问题。</li>\n<li>函数calloc() 会将所分配的内存空间中的每一位都初始化为零，也就是说，如果你是为字符类型或整数类型的元素分配内存，那么这些元素将保证会被初始化为0；如果你是为指针类型的元素分配内存,那么这些元素通常会被初始化为空指针；如果你为实型数据分配内存，则这些元素会被初始化为浮点型的零。</li>\n<li>函数malloc向系统申请分配指定size个字节的内存空间.返回类型是 void*类型。void*表示未确定类型的指针。<font color=\"#FF7F00\"><strong>C,C++规定，void* 类型可以强制转换为任何其它类型的指针</strong></font>。 </li>\n<li>realloc可以对给定的指针所指的空间进行扩大或者缩小，无论是扩张或是缩小，原有内存的中内容将保持不变.当然，对于缩小，则被缩小的那一部分的内容会丢失。realloc并不保证调整后的内存空间和原来的内存空间保持同一内存地址。相反，realloc返回的指针很可能指向一个新的地址。</li>\n<li>realloc是从堆上分配内存的。当扩大一块内存空间时，realloc()试图直接从堆上现存的数据后面的那些字节中获得附加的字节，如果能够满足，自然天下太平；如果数据后面的字节不够，问题就出来了，那么就使用堆上第一个有足够大小的自由块，现存的数据然后就被拷贝至新的位置，而老块则放回到堆上。这句话传递的一个重要的信息就是数据可能被移动。</li>\n</ol>\n<br>\n\n<p>参考资料：<br>参考资料：</p>\n<ul>\n<li><p><font color=\"#00B2EE\"><a href=\"https://www.runoob.com/cprogramming/c-memory-management.html\" target=\"_blank\" rel=\"noopener\">《C 内存管理》\n</a></font></p>\n</li>\n<li><p><font color=\"#00B2EE\"><a href=\"http://c.biancheng.net/c/\" target=\"_blank\" rel=\"noopener\">《C语言中文网-C语言教程》\n</a></font></p>\n</li>\n<li><p><font color=\"#00B2EE\"><a href=\"http://c.biancheng.net/cpp/u/cjinjie/list_48_2.html\" target=\"_blank\" rel=\"noopener\">《C语言深度剖析【进阶篇】》\n</a></font></p>\n</li>\n<li><p><font color=\"#00B2EE\"><a href=\"https://www.cnblogs.com/chunzhulovefeiyue/p/6821317.html\" target=\"_blank\" rel=\"noopener\">《如何使用 malloc 函数》</a>]</font></p>\n</li>\n<li><p><font color=\"#00B2EE\"><a href=\"https://blog.csdn.net/qq_41035588/article/details/81813480\" target=\"_blank\" rel=\"noopener\">《【C语言】malloc、calloc、realloc的区别》</a></font></p>\n</li>\n<li><p><font color=\"#00B2EE\"><a href=\"https://blog.csdn.net/qq_41119046/article/details/80057135\" target=\"_blank\" rel=\"noopener\">《C语言—动态内存分配之malloc与realloc的区别》</a></font></p>\n</li>\n<li><p><font color=\"#00B2EE\"><a href=\"https://www.cnblogs.com/stevenwuzheng/p/5484986.html\" target=\"_blank\" rel=\"noopener\">《C语言中malloc()和calloc()c函数用法》</a></font></p>\n</li>\n<li><p><font color=\"#00B2EE\"><a href=\"https://blog.csdn.net/sinat_35297665/article/details/78925121\" target=\"_blank\" rel=\"noopener\">《C语言calloc()函数：分配内存空间并初始化》</a></font></p>\n</li>\n<li><p><font color=\"#00B2EE\"><a href=\"https://blog.csdn.net/21aspnet/article/details/1540020\" target=\"_blank\" rel=\"noopener\">《关于C语言中的malloc和free函数的用法》</a></font> </p>\n</li>\n<li><p><font color=\"#00B2EE\"><a href=\"https://wenku.baidu.com/view/d48102f0d1d233d4b14e852458fb770bf78a3bdf.html\" target=\"_blank\" rel=\"noopener\">《c语言深度剖析》----陈正冲\n</a></font></p>\n</li>\n<li><p><font color=\"#00B2EE\"><a href=\"https://www.cnblogs.com/xkfz007/archive/2012/02/27/2369562.html\" target=\"_blank\" rel=\"noopener\">《读书笔记之：C语言深度剖析》\n</a></font></p>\n</li>\n<li><p><font color=\"#00B2EE\"><a href=\"http://c.biancheng.net/view/231.html\" target=\"_blank\" rel=\"noopener\">《memset函数及其用法，C语言memset函数详解》\n</a></font></p>\n</li>\n</ul>\n","prev":{"title":"C/C++ 语言内存管理","link":"post/memory-management"},"next":{"title":"Network attack and defense","link":"post/Network-attack-and-defense"},"plink":"https://Directoree.github.io/post/memory/","toc":[{"title":"<font color=\"#03a9f4\" face=\"Comic sans MS\">0x01 malloc() &amp; calloc()</font>","id":"0x01-malloc-amp-calloc","index":"1"},{"title":"<font color=\"#03a9f4\" face=\"Comic sans MS\">0x02 realloc()</font>","id":"0x02-realloc","index":"2"},{"title":"<font color=\"#03a9f4\" face=\"Comic sans MS\">0x03 free() &amp; memset()</font>","id":"0x03-free-amp-memset","index":"3","children":[{"title":"<font color=\"#00C5CD\" face=\"Comic sans MS\">0x001 free()</font>","id":"0x001-free","index":"3.1"},{"title":"<font color=\"#00C5CD\" face=\"Comic sans MS\">0x002 memset()</font>","id":"0x002-memset","index":"3.2"}]},{"title":"<font color=\"#03a9f4\" face=\"Comic sans MS\">0x04 Summary</font>","id":"0x04-Summary","index":"4","children":[{"title":"<font color=\"#00C5CD\" face=\"Comic sans MS\">0x001 C/C++程序内存分配</font>","id":"0x001-C-C-程序内存分配","index":"4.1"},{"title":"<font color=\"#00C5CD\" face=\"Comic sans MS\">0x002 C/C++内存分配方式</font>","id":"0x002-C-C-内存分配方式","index":"4.2"},{"title":"<font color=\"#00C5CD\" face=\"Comic sans MS\">0x003 C语言内存申请相关的函数</font>","id":"0x003-C语言内存申请相关的函数","index":"4.3"},{"title":"<font color=\"#00C5CD\" face=\"Comic sans MS\">0x004 malloc，realloc，calloc函数声明</font>","id":"0x004-malloc，realloc，calloc函数声明","index":"4.4"}]}],"reward":true,"copyright":{"author":"Directoree","link":"<a href=\"https://Directoree.github.io/post/memory/\" title=\"C/C++ Memory Application\">https://Directoree.github.io/post/memory/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}