{"title":"C/C++ Memory","date":"2019-06-06T06:50:55.000Z","thumbnail":"https://i.loli.net/2019/06/06/5cf8bc144d93293008.png","link":"post/memory","comments":true,"tags":["C","C-Memory"],"categories":["C&C++"],"updated":"2019-06-06T09:00:36.094Z","content":"<h2 id=\"0x01-malloc-amp-calloc\"><font color=\"#03a9f4\" face=\"Comic sans MS\">0x01 malloc() &amp; calloc()</font><a href=\"post/memory#0x01-malloc-amp-calloc\"></a></h2><ul>\n<li><p><strong>void *malloc ( size );</strong></p>\n<ul>\n<li>malloc的作用是在内存的动态存储区中分配一个长度为size的<font color=\"#FF7F00\"><strong>连续空间</strong></font>。如果由malloc()函数分配的内存空间原来没有被使用过，则其中的每一位可能都是0；反之,如果这部分内存曾经被分配过,则其中可能遗留有各种各样的数据。所以一般mallc()要配合memset()函数使用。</li>\n</ul>\n</li>\n<li><p><strong>void *calloc ( n, size );</strong></p>\n<ul>\n<li>calloc() 在内存中动态地分配 n 个长度为 size 的<font color=\"#FF7F00\"><strong>连续空间</strong></font>，并将每一个字节都初始化为 0。所以它的结果是分配了 num x size 个字节长度的内存空间，并且每个字节的值都是0。</li>\n</ul>\n<p><br></p>\n</li>\n</ul>\n<font color=\"#FF7F00\"><strong>1. 相似点：</strong></font>\n\n<ol>\n<li>动态内存申请都需要用到头文件<strong><code>#include &lt;stdlib.h&gt;</code></strong>。</li>\n<li><p>malloc()、calloc()申请的内存类型都是 <strong><code>void*</code></strong> 类型的，需要强制转化为指定类型；<br><strong>注意：</strong>函数的返回值类型是<strong><code>void*</code></strong>，void 并不是说没有返回值或者返回空指针，而是返回的指针类型未知。所以在使用 calloc() 时通常需要进行强制类型转换，将 void 指针转换成我们希望的类型，例如：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>ptr <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 分配100个字节的内存空间</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p><strong>返回值：</strong></p>\n<ul>\n<li>如果调用成功,函数malloc()和函数calloc()都将返回所分配的内存空间的<font color=\"#FF7F00\"><strong>首地址</strong></font>。</li>\n<li>如果调用失败，则返回 NULL。</li>\n</ul>\n</li>\n<li><p>二者返回的地址是连续的：下面两种方式申请<strong>地址大小</strong>是相等的</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>str1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">calloc</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>str2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n</ol>\n<p><br></p>\n<font color=\"#FF7F00\"><strong>2. 不相同点：</strong></font>\n\n<ol>\n<li>函数malloc()和函数calloc()的主要区别是<strong>前者不能初始化所分配的内存空间,而后者能</strong>。如果由malloc()函数分配的内存空间原来没有被使用过，则其中的每一位可能都是0；反之，如果这部分内存曾经被分配过，则其中可能遗留有各种各样的数据。</li>\n<li>函数calloc()会将所分配的内存空间中的每一位都初始化为零，也就是说,如果你是为字符类型或整数类型的元素分配内存，那么这些元素将保证会被初始化为0；如果你是为指针类型的元素分配内存,那么这些元素通常会被初始化为空指针；如果你为实型数据分配内存，则这些元素会被初始化为浮点型的零。</li>\n<li>calloc 可以代替 malloc + memset，但是 malloc + memset 代替不了 calloc。 calloc 大块内存时，如果是从系统分配，就可以免了 memset 的操作，快很多。memset可以设任意数，calloc只能设0 。calloc表示申请 n x size大小的内存，malloc只有一个参数。</li>\n</ol>\n<p><br></p>\n<font color=\"#FF7F00\"><strong>3. 以下两种方式完全等价：</strong></font>\n\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">// calloc() 分配内存空间并初始化</span>\n<span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>str1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">calloc</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// malloc() 分配内存空间并用 memset() 初始化</span>\n<span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>str2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">memset</span><span class=\"token punctuation\">(</span>str2<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"0x02-realloc\"><font color=\"#03a9f4\" face=\"Comic sans MS\">0x02 realloc()</font><a href=\"post/memory#0x02-realloc\"></a></h2><p>函数原型：<strong><code>realloc(void *p, addsize)</code></strong></p>\n<p><strong>一、基本特性</strong></p>\n<ol>\n<li><p>realloc()函数可以重用或扩展以前用malloc()、calloc()及realloc()函数自身分配的内存。</p>\n</li>\n<li><p>realloc()函数需两个参数：一个是包含地址的指针（该地址由之前的malloc()、calloc()或realloc()函数返回），另一个是要新分配的内存字节数。</p>\n</li>\n<li><p>realloc()函数分配第二个参数指定的内存量，并把第一个参数指针指向的之前分配的内容复制到新配的内存中，且复制的内容长度等于新旧内存区域中较小的那一个。即新内存大于原内存，则原内存所有内容复制到新内存，如果新内存小于原内存，只复制长度等于新内存空间的内容。</p>\n</li>\n<li><p>realloc()函数的第一个参数若为空指针，相当于分配第二个参数指定的新内存空间，此时等价于malloc()、calloc()或realloc()函数。</p>\n</li>\n<li><p>如果是将分配的内存扩大，则有以下3种情况：</p>\n<blockquote>\n<ul>\n<li>如果当前内存段后面有需要的内存空间，则直接扩展这段内存空间，realloc()将返回<strong>原指针</strong>。  </li>\n<li>如果当前内存段后面的空闲字节不够，那么就使用堆中的第一个能够满足这一要求的内存块，将目前的数据复制到新的位置，并<font color=\"red\" size=\"5\"><strong>自动</strong></font>将原来的数据块释放掉，不需要使用free()再释放一次，返回新的内存块首地址（不同于之前malloc申请的首地址）。</li>\n<li>如果申请失败，将返回NULL，此时，原来的指针仍然有效。</li>\n</ul>\n</blockquote>\n<p><br></p>\n</li>\n</ol>\n<p><strong>二、注意事项</strong></p>\n<ol>\n<li><p><strong>第一个参数要么是空指针，要么是指向以前分配的内存。如果不指向以前分配的内存或指向已释放的内存，结果就是不确定的。</strong></p>\n</li>\n<li><font color=\"#FF7F00\"><strong>如果调用成功，不管当前内存段后面的空闲空间是否满足要求，都会释放掉原来的指针，重新返回一个指针，虽然返回的指针有可能和原来的指针一样，即不能再次释放掉原来的指针。</strong></font>\n\n</li>\n</ol>\n<p>举例（不需要手动free释放原来的首地址指针，realloc若新申请成功会自动释放原来的首地址。），实现在一个按升序排序的数组中查找x应插入的位置，将x插入数组中，使数组元素仍按升序排列。<br><strong>注意：</strong>注意代码45行 <strong><code>free(pNumber);</code></strong>，如果注释掉，则结果正确。如果不注释掉则错误。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;stdio.h></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;stdlib.h></span></span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> index <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> insert_data <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>pNumber <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>pNewArray <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Input array size:\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    pNumber <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">calloc</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>pNumber <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Not enough memory\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//输入插入前已按升序排序的数组元素提示信息</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Input array:\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\"</span><span class=\"token punctuation\">,</span> pNumber<span class=\"token operator\">+</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//输入待插入的元素x提示信息：</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Input x:\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>insert_data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//确定待插入位置的索引值</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>insert_data <span class=\"token operator\">&lt;</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>pNumber<span class=\"token operator\">+</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            index <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//用realloc()新分配一块内存，用于存储原数组和新插入的值</span>\n    pNewArray <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">realloc</span><span class=\"token punctuation\">(</span>pNumber<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">*</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>pNewArray <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Not enough memory\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//free(pNumber); </span>\n    <span class=\"token comment\" spellcheck=\"true\">//输出新分配的内存空间的值，查看是否实现了复制</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%4d\"</span><span class=\"token punctuation\">,</span> pNewArray<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//待插入位置及后面的所有数据依次向后移1位</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> n<span class=\"token punctuation\">;</span> i  <span class=\"token operator\">></span> index<span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>pNewArray<span class=\"token operator\">+</span>i<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> pNewArray<span class=\"token punctuation\">[</span>i<span class=\"token number\">-1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>pNewArray <span class=\"token operator\">+</span> index<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> insert_data<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"After insert %d:\\n\"</span><span class=\"token punctuation\">,</span> insert_data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%4d\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>pNewArray<span class=\"token operator\">+</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">free</span><span class=\"token punctuation\">(</span>pNewArray<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><br></p>\n<h2 id=\"0x03-free-amp-memset\"><font color=\"#03a9f4\" face=\"Comic sans MS\">0x03 free() &amp; memset()</font><a href=\"post/memory#0x03-free-amp-memset\"></a></h2><p>1</p>\n<h2 id=\"0x04-Summary\"><font color=\"#03a9f4\" face=\"Comic sans MS\">0x04 Summary</font><a href=\"post/memory#0x04-Summary\"></a></h2><h3 id=\"0x001-C-C-程序内存分配\"><font color=\"#00C5CD\" face=\"Comic sans MS\">0x001 C/C++程序内存分配</font><a href=\"post/memory#0x001-C-C-程序内存分配\"></a></h3><div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/06/06/5cf8befa94fbc58191.png\" alt=\"20180818211016694.png\" data-zoomable></p></div>\n<blockquote>\n<p><font color=\"#FF7F00\"><strong>注意：</strong></font></p>\n<ol>\n<li>内存泄漏(仅存在程序运行时，程序退出，OS将回收所有资源)是指那些本应该回收（不再使用）的内存对象无法被系统回收的现象。在c/c++中需要程序猿手动释放内存对象，所以在C/C++中更容易存在内存泄漏。java引入了自动回收机制，使得在C/C++中令人头疼的内存问题得到了有效的改善，但这并不意味着java程序员不关注内存，因为垃圾回收机制不能完全保证内存对象在该释放的地方释放.</li>\n<li>内存溢出指的是系统在为某段执行指令（程序）分配内存的时候，发现内存不足，抛出错误。</li>\n</ol>\n</blockquote>\n<p><br></p>\n<h3 id=\"0x002-C-C-内存分配方式\"><font color=\"#00C5CD\" face=\"Comic sans MS\">0x002 C/C++内存分配方式</font><a href=\"post/memory#0x002-C-C-内存分配方式\"></a></h3><blockquote>\n<ol>\n<li><font color=\"#FF7F00\"><strong>在栈上创建</strong></font><br>在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放.栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限.</li>\n<li><font color=\"#FF7F00\"><strong>从堆上分配，亦称动态内存分配</strong></font><br>程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存.动态内存的生存期由用户决定，使用非常灵活，但问题也最多.</li>\n<li><font color=\"#FF7F00\"><strong>从静态存储区域分配</strong></font><br>内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在.例如全局变量、static变量.</li>\n</ol>\n</blockquote>\n<p><br></p>\n<h3 id=\"0x003-C语言内存申请相关的函数\"><font color=\"#00C5CD\" face=\"Comic sans MS\">0x003 C语言内存申请相关的函数</font><a href=\"post/memory#0x003-C语言内存申请相关的函数\"></a></h3><blockquote>\n<ol>\n<li><strong>alloca</strong> 是向栈申请内存,因此无需释放.</li>\n<li><strong>malloc</strong> 分配的内存是位于堆中的，并且没有初始化内存的内容，malloc() 不初始化，里边数据是未知的垃圾数据，因此基本上malloc之后,调用函数memset来初始化这部分的内存空间.</li>\n<li><strong>calloc</strong> 则将初始化这部分的内存，设置为0。</li>\n<li><strong>realloc</strong> 则对malloc申请的内存进行大小的调整。</li>\n<li>申请的内存最终需要通过函数free来释放。<br><font color=\"#FF7F00\"><strong>注意：</strong></font><br>当程序运行过程中malloc了,但是没有free的话,会造成内存泄漏.一部分的内存没有被使用,但是由于没有free,因此系统认为这部分内存还在使用,造成不断的向系统申请内存,使得系统可用内存不断减少.但是内存泄漏仅仅指程序在运行时,程序退出时,OS将回收所有的资源.因此,适当的重起一下程序,有时候还是有点作用.</li>\n</ol>\n</blockquote>\n<p><br></p>\n<h3 id=\"0x004-malloc，realloc，calloc函数声明\"><font color=\"#00C5CD\" face=\"Comic sans MS\">0x004 malloc，realloc，calloc函数声明</font><a href=\"post/memory#0x004-malloc，realloc，calloc函数声明\"></a></h3><blockquote>\n<ul>\n<li><strong>void* malloc(unsigned size)</strong>;</li>\n<li><strong>void<em> realloc(void</em> ptr, unsigned newsize)</strong>;</li>\n<li><strong>void* calloc(size_t numElements, size_t sizeOfElement)</strong>; </li>\n</ul>\n</blockquote>\n<blockquote>\n<p><font color=\"#FF7F00\"><strong>注意：</strong></font>都在stdlib.h函数库内，它们的返回值都是请求系统分配的地址,如果请求失败就返回NULL.<br>(1)函数malloc()<br>在内存的动态存储区中分配一块长度为size字节的连续区域，参数size为需要内存空间的长度，返回该区域的首地址.<br>(2)函数calloc()<br>与malloc相似,参数sizeOfElement为申请地址的单位元素长度,numElements为元素个数，即在内存中申请numElements*sizeOfElement字节大小的连续地址空间.<br>(3)函数realloc()<br>给一个已经分配了地址的指针重新分配空间,参数ptr为原有的空间地址,newsize是重新申请的地址长度.</p>\n</blockquote>\n<p><br></p>\n<ol>\n<li><font color=\"#FF7F00\"><strong>函数malloc不能初始化所分配的内存空间，而函数calloc能</strong></font>。如果由malloc()函数分配的内存空间原来没有被使用过，则其中的每一位可能都是0；反之, 如果这部分内存曾经被分配过，则其中可能遗留有各种各样的垃圾数据。也就是说，使用malloc()函数的程序开始时(内存空间还没有被重新分配)能正常进行,但经过一段时间(内存空间还已经被重新分配)可能会出现问题。</li>\n<li>函数calloc() 会将所分配的内存空间中的每一位都初始化为零，也就是说，如果你是为字符类型或整数类型的元素分配内存，那么这些元素将保证会被初始化为0；如果你是为指针类型的元素分配内存,那么这些元素通常会被初始化为空指针；如果你为实型数据分配内存，则这些元素会被初始化为浮点型的零。</li>\n<li>函数malloc向系统申请分配指定size个字节的内存空间.返回类型是 void*类型。void*表示未确定类型的指针。<font color=\"#FF7F00\"><strong>C,C++规定，void* 类型可以强制转换为任何其它类型的指针</strong></font>。 </li>\n<li>realloc可以对给定的指针所指的空间进行扩大或者缩小，无论是扩张或是缩小，原有内存的中内容将保持不变.当然，对于缩小，则被缩小的那一部分的内容会丢失。realloc并不保证调整后的内存空间和原来的内存空间保持同一内存地址。相反，realloc返回的指针很可能指向一个新的地址。</li>\n<li>realloc是从堆上分配内存的。当扩大一块内存空间时，realloc()试图直接从堆上现存的数据后面的那些字节中获得附加的字节，如果能够满足，自然天下太平；如果数据后面的字节不够，问题就出来了，那么就使用堆上第一个有足够大小的自由块，现存的数据然后就被拷贝至新的位置，而老块则放回到堆上。这句话传递的一个重要的信息就是数据可能被移动。</li>\n</ol>\n","next":{"title":"Network attack and defense","link":"post/Network-attack-and-defense"},"plink":"https://Directoree.github.io/post/memory/","toc":[{"title":"<font color=\"#03a9f4\" face=\"Comic sans MS\">0x01 malloc() &amp; calloc()</font>","id":"0x01-malloc-amp-calloc","index":"1"},{"title":"<font color=\"#03a9f4\" face=\"Comic sans MS\">0x02 realloc()</font>","id":"0x02-realloc","index":"2"},{"title":"<font color=\"#03a9f4\" face=\"Comic sans MS\">0x03 free() &amp; memset()</font>","id":"0x03-free-amp-memset","index":"3"},{"title":"<font color=\"#03a9f4\" face=\"Comic sans MS\">0x04 Summary</font>","id":"0x04-Summary","index":"4","children":[{"title":"<font color=\"#00C5CD\" face=\"Comic sans MS\">0x001 C/C++程序内存分配</font>","id":"0x001-C-C-程序内存分配","index":"4.1"},{"title":"<font color=\"#00C5CD\" face=\"Comic sans MS\">0x002 C/C++内存分配方式</font>","id":"0x002-C-C-内存分配方式","index":"4.2"},{"title":"<font color=\"#00C5CD\" face=\"Comic sans MS\">0x003 C语言内存申请相关的函数</font>","id":"0x003-C语言内存申请相关的函数","index":"4.3"},{"title":"<font color=\"#00C5CD\" face=\"Comic sans MS\">0x004 malloc，realloc，calloc函数声明</font>","id":"0x004-malloc，realloc，calloc函数声明","index":"4.4"}]}],"reward":true,"copyright":{"author":"Directoree","link":"<a href=\"https://Directoree.github.io/post/memory/\" title=\"C/C++ Memory\">https://Directoree.github.io/post/memory/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}